<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM 核心知识点总结 | ZengCP's BLOGS</title><meta name="author" content="ZengCP"><meta name="copyright" content="ZengCP"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="题目一、内存模型与结构 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？ 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？ 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？ 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？ 字符串常量池在JDK 1.7及之后版本的位置变化及原因？ 什么是">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 核心知识点总结">
<meta property="og:url" content="http://example.com/2023/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="ZengCP&#39;s BLOGS">
<meta property="og:description" content="题目一、内存模型与结构 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？ 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？ 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？ 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？ 字符串常量池在JDK 1.7及之后版本的位置变化及原因？ 什么是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png">
<meta property="article:published_time" content="2023-05-22T13:08:39.000Z">
<meta property="article:modified_time" content="2025-03-10T17:52:18.422Z">
<meta property="article:author" content="ZengCP">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png"><link rel="shortcut icon" href="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/longmao.png"><link rel="canonical" href="http://example.com/2023/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 核心知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-11 01:52:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ZengCP's BLOGS"><span class="site-name">ZengCP's BLOGS</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM 核心知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-22T13:08:39.000Z" title="发表于 2023-05-22 21:08:39">2023-05-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-10T17:52:18.422Z" title="更新于 2025-03-11 01:52:18">2025-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM 核心知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h3 id="一、内存模型与结构"><a href="#一、内存模型与结构" class="headerlink" title="一、内存模型与结构"></a><strong>一、内存模型与结构</strong></h3><ol>
<li>详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？</li>
<li>堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？</li>
<li>什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？</li>
<li>元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？</li>
<li>字符串常量池在JDK 1.7及之后版本的位置变化及原因？</li>
<li>什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？</li>
<li>对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？</li>
<li>内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？</li>
</ol>
<hr>
<h3 id="二、垃圾回收（GC）"><a href="#二、垃圾回收（GC）" class="headerlink" title="二、垃圾回收（GC）"></a><strong>二、垃圾回收（GC）</strong></h3><ol>
<li>列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？</li>
<li>如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？</li>
<li>强引用、软引用、弱引用、虚引用的区别及使用场景？</li>
<li>CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？</li>
<li>G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？</li>
<li>ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？</li>
<li>什么情况下会触发Full GC？如何避免频繁Full GC？</li>
<li>Minor GC时出现“晋升失败”（Promotion Failed）的原因及解决方案？</li>
<li>什么是卡表（Card Table）？如何解决跨代引用问题？</li>
<li>动态年龄判定（-XX:MaxTenuringThreshold）和空间分配担保机制？</li>
</ol>
<hr>
<h3 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a><strong>三、类加载机制</strong></h3><ol>
<li>类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？</li>
<li>双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？</li>
<li>如何自定义类加载器？应用场景（热部署、模块化隔离）？</li>
<li>为什么说Java的类加载是“懒加载”（Lazy Loading）？</li>
<li>类初始化触发条件（new、反射、主类、子类初始化等）？</li>
<li>接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？</li>
</ol>
<hr>
<h3 id="四、JVM性能调优"><a href="#四、JVM性能调优" class="headerlink" title="四、JVM性能调优"></a><strong>四、JVM性能调优</strong></h3><ol>
<li>常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？</li>
<li>如何通过GC日志分析频繁GC或内存泄漏问题？</li>
<li>什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？</li>
<li>解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？</li>
<li>如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？</li>
<li>逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？</li>
<li>方法内联（Inlining）的条件及对性能的影响？</li>
</ol>
<hr>
<h3 id="五、JMM（Java内存模型）与并发"><a href="#五、JMM（Java内存模型）与并发" class="headerlink" title="五、JMM（Java内存模型）与并发"></a><strong>五、JMM（Java内存模型）与并发</strong></h3><ol>
<li>JMM如何定义主内存与工作内存的交互（8种原子操作）？</li>
<li>volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？</li>
<li>happens-before原则的具体规则及应用场景？</li>
<li>什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？</li>
<li>什么是伪共享（False Sharing）？如何通过@Contended或填充解决？</li>
<li>CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？</li>
</ol>
<hr>
<h3 id="六、监控与故障排查"><a href="#六、监控与故障排查" class="headerlink" title="六、监控与故障排查"></a><strong>六、监控与故障排查</strong></h3><ol>
<li>如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？</li>
<li>MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？</li>
<li>如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？</li>
<li>解释JVM的SafePoint（安全点）机制及其对GC的影响？</li>
<li>什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？</li>
<li>如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？</li>
</ol>
<hr>
<h3 id="七、高级与扩展"><a href="#七、高级与扩展" class="headerlink" title="七、高级与扩展"></a><strong>七、高级与扩展</strong></h3><ol>
<li>JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？</li>
<li>解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？</li>
<li>如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？</li>
<li>什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？</li>
<li>JVM对协程（Loom项目）的支持及与线程的对比？</li>
<li>容器化（Docker）环境下JVM内存参数设置的注意事项？</li>
</ol>
<hr>
<h3 id="八、实战场景"><a href="#八、实战场景" class="headerlink" title="八、实战场景"></a><strong>八、实战场景</strong></h3><ol>
<li>如果线上服务出现频繁Full GC，你会如何逐步排查？</li>
<li>如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？</li>
<li>高并发场景下，如何通过JVM参数优化减少GC停顿时间？</li>
<li>如何模拟并分析Metaspace的OOM问题？</li>
<li>在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？</li>
</ol>
<hr>
<h1 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h1><hr>
<h3 id="一、内存模型与结构-1"><a href="#一、内存模型与结构-1" class="headerlink" title="一、内存模型与结构"></a><strong>一、内存模型与结构</strong></h3><h4 id="1-详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？"><a href="#1-详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？" class="headerlink" title="1. 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？"></a>1. 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>堆（Heap）</strong>：存储所有对象实例和数组，线程共享，是GC主战场，分新生代（Eden、Survivor区）和老年代。  </li>
<li><strong>虚拟机栈（JVM Stack）</strong>：线程私有，存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口），栈深度过大导致<code>StackOverflowError</code>，无法扩展时<code>OutOfMemoryError</code>。  </li>
<li><strong>方法区（Method Area）</strong>：JDK 8后称“元空间”，存储类信息、常量、静态变量等，线程共享，OOM触发条件为元空间不足。  </li>
<li><strong>本地方法栈（Native Method Stack）</strong>：为Native方法（如C&#x2F;C++代码）服务，可能抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。  </li>
<li><strong>程序计数器（Program Counter Register）</strong>：记录当前线程执行指令的位置，唯一无OOM的区域，线程私有。</li>
</ul>
<hr>
<h4 id="2-堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？"><a href="#2-堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？" class="headerlink" title="2. 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？"></a>2. 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>设计目的</strong>：根据对象存活时间差异优化GC效率。新生代（对象存活率低）使用复制算法快速回收，老年代（对象存活率高）使用标记-整理&#x2F;清除算法。  </li>
<li><strong>比例</strong>：默认 <code>-XX:NewRatio=2</code>（老年代:新生代&#x3D;2:1），新生代占堆1&#x2F;3。可通过 <code>-Xmn</code> 指定新生代固定大小（如 <code>-Xmn512m</code>），动态调整由JVM根据GC频率和对象晋升速率自适应优化。</li>
</ul>
<hr>
<h4 id="3-什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？"><a href="#3-什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？" class="headerlink" title="3. 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？"></a>3. 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>定义</strong>：通过<code>ByteBuffer.allocateDirect()</code>分配的本地内存，不受JVM堆限制，由操作系统管理。  </li>
<li><strong>使用场景</strong>：  <ul>
<li>NIO网络传输、大文件读写（避免堆内外拷贝）。  </li>
<li>高频临时数据缓存（如Netty的零拷贝）。</li>
</ul>
</li>
<li><strong>优点</strong>：  <ul>
<li>减少GC压力，提升I&#x2F;O性能。  </li>
<li>突破堆内存限制，支持更大数据量。</li>
</ul>
</li>
<li><strong>缺点</strong>：  <ul>
<li>需手动释放（依赖<code>Cleaner</code>机制，可能因未调用<code>DirectByteBuffer</code>的<code>clean()</code>方法导致内存泄漏）。  </li>
<li>分配速度慢于堆内存，过量使用可能触发Native OOM。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-元空间（Metaspace）与永久代（PermGen）的区别？为什么Java-8要移除永久代？"><a href="#4-元空间（Metaspace）与永久代（PermGen）的区别？为什么Java-8要移除永久代？" class="headerlink" title="4. 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？"></a>4. 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>区别</strong>：  <table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>永久代（PermGen）</strong></th>
<th><strong>元空间（Metaspace）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储位置</strong></td>
<td>JVM堆内</td>
<td>本地内存（Native Memory）</td>
</tr>
<tr>
<td><strong>大小限制</strong></td>
<td>固定（<code>-XX:MaxPermSize</code>）</td>
<td>动态扩展（默认无上限）</td>
</tr>
<tr>
<td><strong>GC机制</strong></td>
<td>Full GC时回收</td>
<td>由Metaspace的垃圾回收器管理</td>
</tr>
<tr>
<td><strong>OOM风险</strong></td>
<td>易因类加载过多触发OOM</td>
<td>内存不足时触发Native OOM</td>
</tr>
</tbody></table>
</li>
<li><strong>移除PermGen的原因</strong>：  <ul>
<li>简化JVM内存模型，避免字符串常量池和类元数据共存导致PermGen OOM。  </li>
<li>本地内存管理更灵活，支持动态扩展。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-字符串常量池在JDK-1-7及之后版本的位置变化及原因？"><a href="#5-字符串常量池在JDK-1-7及之后版本的位置变化及原因？" class="headerlink" title="5. 字符串常量池在JDK 1.7及之后版本的位置变化及原因？"></a>5. 字符串常量池在JDK 1.7及之后版本的位置变化及原因？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>JDK 1.6及之前</strong>：位于PermGen中，易因字符串过多触发PermGen OOM。  </li>
<li><strong>JDK 1.7及之后</strong>：字符串常量池移至堆内存，原因：  <ul>
<li>堆的GC机制更灵活，减少OOM风险。  </li>
<li>字符串可被GC回收，避免内存泄漏。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-什么是TLAB（Thread-Local-Allocation-Buffer）？如何避免多线程内存分配竞争？"><a href="#6-什么是TLAB（Thread-Local-Allocation-Buffer）？如何避免多线程内存分配竞争？" class="headerlink" title="6. 什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？"></a>6. 什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>TLAB</strong>：为每个线程预先分配一小块Eden区内存（默认约Eden的1%），线程优先在TLAB中分配对象，避免全局锁竞争。  </li>
<li><strong>参数控制</strong>：  <ul>
<li><code>-XX:+UseTLAB</code>：启用TLAB（默认开启）。  </li>
<li><code>-XX:TLABSize</code>：指定TLAB初始大小。  </li>
<li><code>-XX:ResizeTLAB</code>：允许JVM动态调整TLAB大小。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？"><a href="#7-对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？" class="headerlink" title="7. 对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？"></a>7. 对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>对象头（Header）</strong>：  <ul>
<li><strong>Mark Word</strong>：存储哈希码、锁状态、GC分代年龄等（64位系统占8字节）。  </li>
<li><strong>类指针（Class Pointer）</strong>：指向类元数据（开启压缩指针占4字节，否则8字节）。  </li>
<li><strong>数组长度</strong>（仅数组对象）：4字节。</li>
</ul>
</li>
<li><strong>实例数据（Instance Data）</strong>：对象的字段值，按类型对齐（如int占4字节）。  </li>
<li><strong>对齐填充（Padding）</strong>：保证对象大小为8字节的整数倍。  </li>
<li><strong>计算工具</strong>：  <ul>
<li><code>jol-core</code>库：<code>ClassLayout.parseClass(Class.class).toPrintable()</code>。  </li>
<li><code>Instrumentation.getObjectSize()</code>方法。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？"><a href="#8-内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？" class="headerlink" title="8. 内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？"></a>8. 内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>堆OOM（OutOfMemoryError: Java heap space）</strong>：  <ul>
<li>场景：对象过多（如缓存未清理）、内存泄漏（如静态集合持有对象）。  </li>
<li>解决：调大堆（<code>-Xmx</code>），分析内存泄漏（MAT工具）。</li>
</ul>
</li>
<li><strong>栈OOM（OutOfMemoryError: Unable to create new native thread &#x2F; StackOverflowError）</strong>：  <ul>
<li>场景：递归调用过深、线程数过多（<code>-Xss</code>调整栈大小）。</li>
</ul>
</li>
<li><strong>元空间OOM（OutOfMemoryError: Metaspace）</strong>：  <ul>
<li>场景：动态生成大量类（如CGLib代理）、未卸载类加载器。  </li>
<li>解决：调大元空间（<code>-XX:MaxMetaspaceSize</code>），检查类加载逻辑。</li>
</ul>
</li>
<li><strong>直接内存OOM（OutOfMemoryError: Direct buffer memory）</strong>：  <ul>
<li>场景：过量分配<code>DirectByteBuffer</code>未释放。  </li>
<li>解决：限制直接内存（<code>-XX:MaxDirectMemorySize</code>），显式调用<code>cleaner.clean()</code>。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="二、垃圾回收（GC）-1"><a href="#二、垃圾回收（GC）-1" class="headerlink" title="二、垃圾回收（GC）"></a><strong>二、垃圾回收（GC）</strong></h3><h4 id="1-列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？"><a href="#1-列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？" class="headerlink" title="1. 列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？"></a>1. 列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>标记-清除（Mark-Sweep）</strong>：  <ul>
<li><strong>流程</strong>：标记存活对象→清除未标记对象。  </li>
<li><strong>优点</strong>：实现简单。  </li>
<li><strong>缺点</strong>：内存碎片化，大对象分配困难。</li>
</ul>
</li>
<li><strong>复制算法（Copying）</strong>：  <ul>
<li><strong>流程</strong>：将存活对象从Eden和From Survivor复制到To Survivor。  </li>
<li><strong>优点</strong>：无碎片，适合新生代（对象存活率低）。  </li>
<li><strong>缺点</strong>：内存利用率低（需预留Survivor区）。</li>
</ul>
</li>
<li><strong>标记-整理（Mark-Compact）</strong>：  <ul>
<li><strong>流程</strong>：标记存活对象→向一端移动→清理边界外内存。  </li>
<li><strong>优点</strong>：无碎片，适合老年代。  </li>
<li><strong>缺点</strong>：移动对象成本高，STW时间长。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-如何判断对象是否可回收（引用计数法、可达性分析）？GC-Roots包括哪些对象？"><a href="#2-如何判断对象是否可回收（引用计数法、可达性分析）？GC-Roots包括哪些对象？" class="headerlink" title="2. 如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？"></a>2. 如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>引用计数法</strong>：记录对象被引用次数，为0时回收。缺点：无法解决循环引用（如A→B→A）。  </li>
<li><strong>可达性分析</strong>：从GC Roots出发，不可达的对象判定为可回收（JVM实际采用）。  </li>
<li><strong>GC Roots对象</strong>：  <ul>
<li>虚拟机栈中局部变量引用的对象。  </li>
<li>方法区中类静态变量引用的对象。  </li>
<li>方法区中常量引用的对象（如字符串常量池）。  </li>
<li>本地方法栈中JNI引用的Native对象。  </li>
<li>活跃线程对象（如Thread）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-强引用、软引用、弱引用、虚引用的区别及使用场景？"><a href="#3-强引用、软引用、弱引用、虚引用的区别及使用场景？" class="headerlink" title="3. 强引用、软引用、弱引用、虚引用的区别及使用场景？"></a>3. 强引用、软引用、弱引用、虚引用的区别及使用场景？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>强引用（Strong Reference）</strong>：  <ul>
<li>定义：<code>Object obj = new Object()</code>。  </li>
<li>回收条件：永不回收（除非无强引用）。  </li>
<li>场景：普遍对象引用。</li>
</ul>
</li>
<li><strong>软引用（SoftReference）</strong>：  <ul>
<li>回收条件：内存不足时回收。  </li>
<li>场景：缓存（如图片缓存）。</li>
</ul>
</li>
<li><strong>弱引用（WeakReference）</strong>：  <ul>
<li>回收条件：GC时立即回收。  </li>
<li>场景：<code>WeakHashMap</code>（缓存键值对，键无强引用时自动删除）。</li>
</ul>
</li>
<li><strong>虚引用（PhantomReference）</strong>：  <ul>
<li>回收条件：无法通过虚引用访问对象，仅用于跟踪对象回收状态。  </li>
<li>场景：管理堆外内存（如<code>DirectByteBuffer</code>回收通知）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？"><a href="#4-CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？" class="headerlink" title="4. CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？"></a>4. CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>工作流程</strong>：  <ol>
<li><strong>初始标记（Initial Mark，STW）</strong>：标记GC Roots直接关联的对象。  </li>
<li><strong>并发标记（Concurrent Mark）</strong>：遍历对象图，标记存活对象。  </li>
<li><strong>重新标记（Remark，STW）</strong>：修正并发标记期间变动的对象（使用增量更新或原始快照）。  </li>
<li><strong>并发清除（Concurrent Sweep）</strong>：清除未标记对象。</li>
</ol>
</li>
<li><strong>浮动垃圾（Floating Garbage）</strong>：  <ul>
<li>成因：并发标记阶段用户线程产生的新垃圾。  </li>
<li>解决：预留空间（通过<code>-XX:CMSInitiatingOccupancyFraction</code>设置触发CMS的阈值，默认92%）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-G1收集器的核心设计（Region分区、SATB、Mixed-GC）？与CMS的对比？"><a href="#5-G1收集器的核心设计（Region分区、SATB、Mixed-GC）？与CMS的对比？" class="headerlink" title="5. G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？"></a>5. G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>核心设计</strong>：  <ul>
<li><strong>Region分区</strong>：将堆划分为多个等大小Region（1MB~32MB），可属于新生代或老年代。  </li>
<li><strong>SATB（Snapshot-At-The-Beginning）</strong>：标记开始时存活对象的快照，解决并发标记期间对象状态变化问题。  </li>
<li><strong>Mixed GC</strong>：同时回收新生代和部分老年代Region（根据回收价值排序）。</li>
</ul>
</li>
<li><strong>对比CMS</strong>：  <table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>CMS</strong></th>
<th><strong>G1</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存结构</strong></td>
<td>分代（连续内存）</td>
<td>Region分区（离散内存）</td>
</tr>
<tr>
<td><strong>碎片处理</strong></td>
<td>不整理（碎片问题）</td>
<td>整体整理（无碎片）</td>
</tr>
<tr>
<td><strong>停顿目标</strong></td>
<td>低延迟但不可控</td>
<td>可控停顿（<code>-XX:MaxGCPauseMillis</code>）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>中小堆（&lt;4GB）</td>
<td>大堆（&gt;4GB）</td>
</tr>
</tbody></table>
</li>
</ul>
<hr>
<h4 id="6-ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？"><a href="#6-ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？" class="headerlink" title="6. ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？"></a>6. ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>ZGC</strong>：  <ul>
<li><strong>颜色指针（Colored Pointers）</strong>：利用指针元数据标记对象状态（可达、重定位等）。  </li>
<li><strong>读屏障（Load Barrier）</strong>：在访问对象时触发屏障，处理并发阶段的对象状态。  </li>
<li><strong>目标</strong>：亚毫秒级停顿（&lt;10ms），支持TB级堆内存。</li>
</ul>
</li>
<li><strong>Shenandoah</strong>：  <ul>
<li><strong>并发压缩</strong>：在用户线程运行时移动对象，减少STW时间。  </li>
<li><strong>Brooks指针</strong>：每个对象附加转发指针，处理并发访问。  </li>
<li><strong>目标</strong>：低停顿（&lt;10ms），适合大堆和实时系统。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-什么情况下会触发Full-GC？如何避免频繁Full-GC？"><a href="#7-什么情况下会触发Full-GC？如何避免频繁Full-GC？" class="headerlink" title="7. 什么情况下会触发Full GC？如何避免频繁Full GC？"></a>7. 什么情况下会触发Full GC？如何避免频繁Full GC？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>触发条件</strong>：  <ol>
<li><strong>老年代空间不足</strong>：对象晋升失败或大对象直接分配老年代失败。  </li>
<li><strong>元空间不足</strong>：加载过多类或未卸载类加载器。  </li>
<li><strong>显式调用</strong>：<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>。  </li>
<li><strong>空间分配担保失败</strong>：Minor GC前检查老年代剩余空间是否足够（需开启<code>-XX:-HandlePromotionFailure</code>）。  </li>
<li><strong>CMS并发模式失败</strong>：CMS回收速度跟不上对象分配速度。</li>
</ol>
</li>
<li><strong>避免方法</strong>：  <ul>
<li>调大堆内存（<code>-Xmx</code>）和元空间（<code>-XX:MaxMetaspaceSize</code>）。  </li>
<li>优化对象生命周期（减少大对象、缓存失效策略）。  </li>
<li>选择低延迟收集器（G1、ZGC）。  </li>
<li>关闭显式GC（<code>-XX:+DisableExplicitGC</code>）。</li>
</ul>
</li>
</ul>
<p>以下是剩余部分的完整答案：</p>
<hr>
<h3 id="三、类加载机制-1"><a href="#三、类加载机制-1" class="headerlink" title="三、类加载机制"></a><strong>三、类加载机制</strong></h3><h4 id="1-类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？"><a href="#1-类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？" class="headerlink" title="1. 类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？"></a>1. 类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>加载（Loading）</strong>：  <ul>
<li>通过类全限定名获取二进制字节流。  </li>
<li>将字节流转换为方法区的运行时数据结构。  </li>
<li>在堆中生成<code>Class</code>对象作为访问入口。</li>
</ul>
</li>
<li><strong>验证（Verification）</strong>：  <ul>
<li>检查字节码是否符合JVM规范（文件格式、元数据、字节码、符号引用验证）。</li>
</ul>
</li>
<li><strong>准备（Preparation）</strong>：  <ul>
<li>为类变量（static变量）分配内存并设置初始值（零值，如<code>0</code>、<code>null</code>）。  </li>
<li>常量（final static）直接赋实际值。</li>
</ul>
</li>
<li><strong>解析（Resolution）</strong>：  <ul>
<li>将符号引用（类、方法、字段名）转换为直接引用（内存地址）。</li>
</ul>
</li>
<li><strong>初始化（Initialization）</strong>：  <ul>
<li>执行类构造器<code>&lt;clinit&gt;()</code>（静态变量赋值和静态代码块）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？"><a href="#2-双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？" class="headerlink" title="2. 双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？"></a>2. 双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>原理</strong>：  <ul>
<li>类加载请求先委派父加载器处理，只有父加载器无法加载时，子加载器才尝试加载。  </li>
<li>层级结构：<strong>Bootstrap → Extension → Application → 自定义加载器</strong>。</li>
</ul>
</li>
<li><strong>打破双亲委派</strong>：  <ul>
<li><strong>场景1</strong>：JDBC通过<code>ServiceLoader</code>（SPI机制）使用线程上下文类加载器（<code>Thread.currentThread().getContextClassLoader()</code>）。  </li>
<li><strong>场景2</strong>：Tomcat为每个Web应用配置独立的<code>WebAppClassLoader</code>，优先加载自身类，避免应用间类冲突。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-如何自定义类加载器？应用场景（热部署、模块化隔离）？"><a href="#3-如何自定义类加载器？应用场景（热部署、模块化隔离）？" class="headerlink" title="3. 如何自定义类加载器？应用场景（热部署、模块化隔离）？"></a>3. 如何自定义类加载器？应用场景（热部署、模块化隔离）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>实现步骤</strong>：  <ol>
<li>继承<code>ClassLoader</code>类。  </li>
<li>重写<code>findClass()</code>方法（从自定义路径读取字节码，调用<code>defineClass()</code>生成Class对象）。</li>
</ol>
</li>
<li><strong>应用场景</strong>：  <ul>
<li>热部署：动态加载修改后的类（如Spring DevTools）。  </li>
<li>模块化隔离：不同模块使用独立类加载器（如OSGi、Tomcat多应用隔离）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-为什么说Java的类加载是“懒加载”（Lazy-Loading）？"><a href="#4-为什么说Java的类加载是“懒加载”（Lazy-Loading）？" class="headerlink" title="4. 为什么说Java的类加载是“懒加载”（Lazy Loading）？"></a>4. 为什么说Java的类加载是“懒加载”（Lazy Loading）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>定义</strong>：类在首次使用时（如<code>new</code>、调用静态方法）才被加载，而非JVM启动时加载所有类。  </li>
<li><strong>优点</strong>：减少启动时间和内存占用。</li>
</ul>
<hr>
<h4 id="5-类初始化触发条件（new、反射、主类、子类初始化等）？"><a href="#5-类初始化触发条件（new、反射、主类、子类初始化等）？" class="headerlink" title="5. 类初始化触发条件（new、反射、主类、子类初始化等）？"></a>5. 类初始化触发条件（new、反射、主类、子类初始化等）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>触发条件</strong>：  <ol>
<li><code>new</code>实例化对象。  </li>
<li>访问或修改类的静态变量（final常量除外）。  </li>
<li>调用类的静态方法。  </li>
<li>反射调用（<code>Class.forName()</code>）。  </li>
<li>初始化子类时，父类需先初始化。  </li>
<li>JVM启动时的主类（包含<code>main()</code>方法的类）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="6-接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？"><a href="#6-接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？" class="headerlink" title="6. 接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？"></a>6. 接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>接口加载</strong>：  <ul>
<li>接口初始化时，不要求父接口全部初始化（除非使用父接口的常量）。</li>
</ul>
</li>
<li><strong>类加载顺序</strong>：  <ol>
<li>父类静态代码 → 子类静态代码 → 父类构造代码 → 父类构造器 → 子类构造代码 → 子类构造器。</li>
</ol>
</li>
<li><strong>执行顺序</strong>：  <ul>
<li><strong>静态代码块</strong>：类初始化时执行一次。  </li>
<li><strong>构造代码块</strong>：每次实例化对象时执行（在构造器之前）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、JVM性能调优-1"><a href="#四、JVM性能调优-1" class="headerlink" title="四、JVM性能调优"></a><strong>四、JVM性能调优</strong></h3><h4 id="1-常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？"><a href="#1-常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？" class="headerlink" title="1. 常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？"></a>1. 常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>堆内存</strong>：  <ul>
<li><code>-Xms</code>：初始堆大小（如<code>-Xms512m</code>）。  </li>
<li><code>-Xmx</code>：最大堆大小（通常设与<code>-Xms</code>相同，避免动态扩容）。</li>
</ul>
</li>
<li><strong>新生代</strong>：  <ul>
<li><code>-Xmn</code>：新生代大小（如<code>-Xmn256m</code>）。  </li>
<li><code>-XX:NewRatio</code>：老年代与新生代比例（默认2）。  </li>
<li><code>-XX:SurvivorRatio</code>：Eden与Survivor区的比例（默认8，即Eden:Survivor&#x3D;8:1:1）。</li>
</ul>
</li>
<li><strong>GC日志</strong>：  <ul>
<li><code>-Xloggc:/path/gc.log</code>：输出GC日志。  </li>
<li><code>-XX:+PrintGCDetails</code>：打印GC详细信息。  </li>
<li><code>-XX:+UseGCLogFileRotation</code>：启用日志轮转。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-如何通过GC日志分析频繁GC或内存泄漏问题？"><a href="#2-如何通过GC日志分析频繁GC或内存泄漏问题？" class="headerlink" title="2. 如何通过GC日志分析频繁GC或内存泄漏问题？"></a>2. 如何通过GC日志分析频繁GC或内存泄漏问题？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>分析步骤</strong>：  <ol>
<li>观察Full GC频率：频繁Full GC可能内存泄漏。  </li>
<li>查看堆内存占用：老年代使用率持续上升且不下降。  </li>
<li>检查对象晋升：Minor GC后对象频繁晋升到老年代。</li>
</ol>
</li>
<li><strong>工具</strong>：  <ul>
<li><strong>GCEasy</strong>：在线GC日志分析工具。  </li>
<li><strong>MAT</strong>：分析堆转储文件，定位大对象或GC Roots路径。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-什么情况下需要调整新生代与老年代的比例（-XX-NewRatio）？"><a href="#3-什么情况下需要调整新生代与老年代的比例（-XX-NewRatio）？" class="headerlink" title="3. 什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？"></a>3. 什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>场景</strong>：  <ol>
<li>短期对象过多：增大新生代（减少对象晋升）。  </li>
<li>长期存活对象过多：增大老年代（减少Full GC频率）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="4-解释-XX-UseCompressedOops和-XX-UseCompressedClassPointers的作用？"><a href="#4-解释-XX-UseCompressedOops和-XX-UseCompressedClassPointers的作用？" class="headerlink" title="4. 解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？"></a>4. 解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>UseCompressedOops</strong>：启用压缩普通对象指针（32位表示，堆内存&lt;32GB时默认开启）。  </li>
<li><strong>UseCompressedClassPointers</strong>：启用压缩类指针（依赖UseCompressedOops）。  </li>
<li><strong>效果</strong>：减少内存占用（64位JVM中对象引用从8字节压缩为4字节）。</li>
</ul>
<hr>
<h4 id="5-如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？"><a href="#5-如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？" class="headerlink" title="5. 如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？"></a>5. 如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>设置原则</strong>：  <ul>
<li>初始堆（<code>-Xms</code>）与最大堆（<code>-Xmx</code>）相同，避免动态调整。  </li>
<li>根据系统物理内存的1&#x2F;4<del>1&#x2F;2分配堆（如64GB内存，堆设16GB</del>32GB）。</li>
</ul>
</li>
<li><strong>估算方法</strong>：  <ol>
<li>监控运行峰值：使用<code>jstat -gcutil</code>观察老年代使用率。  </li>
<li>预留30%缓冲：避免堆满触发Full GC。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="6-逃逸分析的作用及如何通过-XX-DoEscapeAnalysis优化代码？"><a href="#6-逃逸分析的作用及如何通过-XX-DoEscapeAnalysis优化代码？" class="headerlink" title="6. 逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？"></a>6. 逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>逃逸分析</strong>：判断对象是否在方法外部被引用（未逃逸的对象可优化）。  </li>
<li><strong>优化手段</strong>：  <ul>
<li><strong>栈上分配</strong>：未逃逸对象直接在栈上分配（随栈帧销毁回收）。  </li>
<li><strong>标量替换</strong>：将对象拆分为基本类型（如<code>Point</code>的x、y字段直接分配）。  </li>
<li><strong>锁消除</strong>：对线程私有对象移除同步锁。</li>
</ul>
</li>
<li><strong>参数</strong>：<code>-XX:+DoEscapeAnalysis</code>（默认开启）。</li>
</ul>
<hr>
<h4 id="7-方法内联（Inlining）的条件及对性能的影响？"><a href="#7-方法内联（Inlining）的条件及对性能的影响？" class="headerlink" title="7. 方法内联（Inlining）的条件及对性能的影响？"></a>7. 方法内联（Inlining）的条件及对性能的影响？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>条件</strong>：  <ul>
<li>方法体小（如getter&#x2F;setter）。  </li>
<li>频繁调用（热点方法）。  </li>
<li>无虚方法（未被重写）。</li>
</ul>
</li>
<li><strong>影响</strong>：  <ul>
<li>减少方法调用开销，提升执行速度。  </li>
<li>可能增加代码体积（需权衡）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五、JMM（Java内存模型）与并发-1"><a href="#五、JMM（Java内存模型）与并发-1" class="headerlink" title="五、JMM（Java内存模型）与并发"></a><strong>五、JMM（Java内存模型）与并发</strong></h3><h4 id="1-JMM如何定义主内存与工作内存的交互（8种原子操作）？"><a href="#1-JMM如何定义主内存与工作内存的交互（8种原子操作）？" class="headerlink" title="1. JMM如何定义主内存与工作内存的交互（8种原子操作）？"></a>1. JMM如何定义主内存与工作内存的交互（8种原子操作）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>8种操作</strong>：  <ul>
<li><code>lock</code>（锁定主内存变量） → <code>read</code>（读取） → <code>load</code>（载入工作内存） →  </li>
<li><code>use</code>（使用） → <code>assign</code>（赋值） → <code>store</code>（存储） → <code>write</code>（写入主内存） → <code>unlock</code>（解锁）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？"><a href="#2-volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？" class="headerlink" title="2. volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？"></a>2. volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>语义</strong>：  <ul>
<li><strong>可见性</strong>：写操作立即刷新到主内存，读操作从主内存读取。  </li>
<li><strong>禁止重排序</strong>：通过内存屏障实现。</li>
</ul>
</li>
<li><strong>与synchronized区别</strong>：  <ul>
<li><code>volatile</code>仅保证可见性和有序性，不保证原子性。  </li>
<li><code>synchronized</code>保证原子性、可见性和有序性。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-happens-before原则的具体规则及应用场景？"><a href="#3-happens-before原则的具体规则及应用场景？" class="headerlink" title="3. happens-before原则的具体规则及应用场景？"></a>3. happens-before原则的具体规则及应用场景？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>规则</strong>：  <ol>
<li>程序顺序规则：同一线程内顺序执行。  </li>
<li>锁规则：解锁操作先于后续加锁。  </li>
<li><code>volatile</code>规则：写操作先于后续读操作。  </li>
<li>传递性：A先于B，B先于C → A先于C。</li>
</ol>
</li>
<li><strong>应用</strong>：多线程环境下保证操作顺序性（如单例模式的双重检查锁）。</li>
</ul>
<hr>
<h4 id="4-什么是内存屏障（Memory-Barrier）？JVM如何实现volatile的语义？"><a href="#4-什么是内存屏障（Memory-Barrier）？JVM如何实现volatile的语义？" class="headerlink" title="4. 什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？"></a>4. 什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>内存屏障</strong>：CPU指令，禁止指令重排序，强制刷新缓存。  </li>
<li><strong>volatile实现</strong>：  <ul>
<li>写操作后插入<code>StoreStore</code>屏障和<code>StoreLoad</code>屏障。  </li>
<li>读操作前插入<code>LoadLoad</code>屏障和<code>LoadStore</code>屏障。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-什么是伪共享（False-Sharing）？如何通过-Contended或填充解决？"><a href="#5-什么是伪共享（False-Sharing）？如何通过-Contended或填充解决？" class="headerlink" title="5. 什么是伪共享（False Sharing）？如何通过@Contended或填充解决？"></a>5. 什么是伪共享（False Sharing）？如何通过@Contended或填充解决？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>伪共享</strong>：不同线程修改同一缓存行中的不同变量，导致缓存行无效，性能下降。  </li>
<li><strong>解决</strong>：  <ul>
<li><strong>填充</strong>：在变量间添加无用字段（如<code>long p1, p2, p3;</code>）。  </li>
<li><strong>@Contended</strong>：JVM自动填充（需<code>-XX:-RestrictContended</code>）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？"><a href="#6-CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？" class="headerlink" title="6. CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？"></a>6. CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>实现</strong>：  <ul>
<li><code>Unsafe</code>类的<code>compareAndSwapInt()</code>方法。  </li>
<li>底层调用CPU的<code>cmpxchg</code>指令。</li>
</ul>
</li>
<li><strong>ABA问题</strong>：变量值从A→B→A，CAS误认为未变化。  </li>
<li><strong>解决</strong>：使用版本号（如<code>AtomicStampedReference</code>）。</li>
</ul>
<hr>
<h3 id="六、监控与故障排查-1"><a href="#六、监控与故障排查-1" class="headerlink" title="六、监控与故障排查"></a><strong>六、监控与故障排查</strong></h3><h4 id="1-如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？"><a href="#1-如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？" class="headerlink" title="1. 如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？"></a>1. 如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>jstat</strong>：  <ul>
<li><code>jstat -gcutil &lt;pid&gt;</code>：查看各分区内存使用率和GC次数。</li>
</ul>
</li>
<li><strong>jmap</strong>：  <ul>
<li><code>jmap -heap &lt;pid&gt;</code>：查看堆配置。  </li>
<li><code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code>：生成堆转储文件。</li>
</ul>
</li>
<li><strong>jstack</strong>：  <ul>
<li><code>jstack &lt;pid&gt;</code>：抓取线程快照，分析死锁（查找<code>BLOCKED</code>状态和锁持有链）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-MAT（Memory-Analyzer-Tool）分析堆转储文件的常用技巧？"><a href="#2-MAT（Memory-Analyzer-Tool）分析堆转储文件的常用技巧？" class="headerlink" title="2. MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？"></a>2. MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>步骤</strong>：  <ol>
<li>查找大对象：<code>Dominator Tree</code>视图。  </li>
<li>分析GC Roots：<code>Path to GC Roots</code>排除弱&#x2F;软引用。  </li>
<li>检查重复类：<code>Duplicate Classes</code>视图（类加载器泄漏）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-如何快速定位CPU飙高或线程阻塞问题（结合top-Hp、jstack）？"><a href="#3-如何快速定位CPU飙高或线程阻塞问题（结合top-Hp、jstack）？" class="headerlink" title="3. 如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？"></a>3. 如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>步骤</strong>：  <ol>
<li><code>top -Hp &lt;pid&gt;</code>：找到高CPU占用的线程ID（十进制）。  </li>
<li>将线程ID转为十六进制（如<code>printf &quot;%x\n&quot; 12345</code> → <code>3039</code>）。  </li>
<li><code>jstack &lt;pid&gt;</code>：查找对应线程的堆栈信息（如<code>nid=0x3039</code>）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="4-解释JVM的SafePoint（安全点）机制及其对GC的影响？"><a href="#4-解释JVM的SafePoint（安全点）机制及其对GC的影响？" class="headerlink" title="4. 解释JVM的SafePoint（安全点）机制及其对GC的影响？"></a>4. 解释JVM的SafePoint（安全点）机制及其对GC的影响？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>安全点</strong>：线程执行到特定位置（如方法调用、循环跳转）时可暂停，用于GC、代码优化等。  </li>
<li><strong>影响</strong>：  <ul>
<li>所有线程需到达安全点才能执行STW操作（如GC）。  </li>
<li>长时间未进入安全点的线程可能导致GC停顿时间延长。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-什么是OOM-Killer？Linux系统下如何避免JVM进程被误杀？"><a href="#5-什么是OOM-Killer？Linux系统下如何避免JVM进程被误杀？" class="headerlink" title="5. 什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？"></a>5. 什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>OOM Killer</strong>：Linux内核在系统内存不足时强制终止进程。  </li>
<li><strong>避免方法</strong>：  <ol>
<li>限制JVM堆大小（<code>-Xmx</code>），留出系统内存。  </li>
<li>调整进程OOM优先级（<code>-XX:+UseLargePages</code>或<code>echo -17 &gt; /proc/&lt;pid&gt;/oom_adj</code>）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="6-如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？"><a href="#6-如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？" class="headerlink" title="6. 如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？"></a>6. 如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>常用命令</strong>：  <ul>
<li><code>watch com.example.Service methodName &quot;&#123;params, returnObj&#125;&quot;</code>：监控方法入参和返回值。  </li>
<li><code>trace *.ClassName methodName</code>：统计方法调用耗时。  </li>
<li><code>logger --name ROOT --level debug</code>：动态调整日志级别。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="七、高级与扩展-1"><a href="#七、高级与扩展-1" class="headerlink" title="七、高级与扩展"></a><strong>七、高级与扩展</strong></h3><h4 id="1-JIT编译器的工作机制（解释执行-vs-编译执行）？分层编译（C1-C2）？"><a href="#1-JIT编译器的工作机制（解释执行-vs-编译执行）？分层编译（C1-C2）？" class="headerlink" title="1. JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？"></a>1. JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>解释执行</strong>：逐行解释字节码，启动快但执行慢。  </li>
<li><strong>编译执行</strong>：将热点代码编译为本地机器码（JIT）。  </li>
<li><strong>分层编译</strong>：  <ul>
<li><strong>C1（Client Compiler）</strong>：快速编译，优化较少（如方法内联）。  </li>
<li><strong>C2（Server Compiler）</strong>：深度优化，耗时较长（如逃逸分析）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-解释JVM的逃逸分析及栈上分配（Stack-Allocation）优化？"><a href="#2-解释JVM的逃逸分析及栈上分配（Stack-Allocation）优化？" class="headerlink" title="2. 解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？"></a>2. 解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>逃逸分析</strong>：判断对象是否在方法外部被引用。  </li>
<li><strong>栈上分配</strong>：未逃逸的对象直接在栈上分配，随栈帧销毁自动回收，减少GC压力。</li>
</ul>
<hr>
<h4 id="3-如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？"><a href="#3-如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？" class="headerlink" title="3. 如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？"></a>3. 如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>回收条件</strong>：  <ol>
<li>类的所有实例已被回收。  </li>
<li>类对应的<code>Class</code>对象无引用。  </li>
<li>类加载器已被回收（如Tomcat热部署时卸载旧类加载器）。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="4-什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？"><a href="#4-什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？" class="headerlink" title="4. 什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？"></a>4. 什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>偏向锁</strong>：标记线程ID，无竞争时直接访问。  </li>
<li><strong>轻量级锁</strong>：CAS竞争，失败后膨胀为重量级锁。  </li>
<li><strong>重量级锁</strong>：基于操作系统互斥量（Mutex），线程阻塞。  </li>
<li><strong>升级过程</strong>：无锁 → 偏向锁 → 轻量级锁 → 重量级锁。</li>
</ul>
<hr>
<h4 id="5-JVM对协程（Loom项目）的支持及与线程的对比？"><a href="#5-JVM对协程（Loom项目）的支持及与线程的对比？" class="headerlink" title="5. JVM对协程（Loom项目）的支持及与线程的对比？"></a>5. JVM对协程（Loom项目）的支持及与线程的对比？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>协程（虚拟线程）</strong>：  <ul>
<li>轻量级（由JVM调度，非操作系统线程），支持百万级并发。  </li>
<li>适用I&#x2F;O密集型任务（如网络请求）。</li>
</ul>
</li>
<li><strong>对比线程</strong>：  <ul>
<li>线程：上下文切换成本高，受操作系统限制。  </li>
<li>协程：切换由JVM管理，资源消耗低。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-容器化（Docker）环境下JVM内存参数设置的注意事项？"><a href="#6-容器化（Docker）环境下JVM内存参数设置的注意事项？" class="headerlink" title="6. 容器化（Docker）环境下JVM内存参数设置的注意事项？"></a>6. 容器化（Docker）环境下JVM内存参数设置的注意事项？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>问题</strong>：JVM默认读取物理机内存，而非容器限制。  </li>
<li><strong>解决</strong>：  <ul>
<li>使用<code>-XX:+UseContainerSupport</code>（JDK 8u191+默认开启）。  </li>
<li>显式设置堆大小（<code>-Xmx</code>不超过容器内存的50%~70%）。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="八、实战场景-1"><a href="#八、实战场景-1" class="headerlink" title="八、实战场景"></a><strong>八、实战场景</strong></h3><h4 id="1-如果线上服务出现频繁Full-GC，你会如何逐步排查？"><a href="#1-如果线上服务出现频繁Full-GC，你会如何逐步排查？" class="headerlink" title="1. 如果线上服务出现频繁Full GC，你会如何逐步排查？"></a>1. 如果线上服务出现频繁Full GC，你会如何逐步排查？</h4><p><strong>答案</strong>：  </p>
<ol>
<li><strong>查看GC日志</strong>：确认Full GC触发原因（老年代不足、元空间不足等）。  </li>
<li><strong>分析堆转储</strong>：使用MAT找出大对象或内存泄漏。  </li>
<li><strong>检查代码</strong>：排查静态集合、未关闭资源、大对象分配。  </li>
<li><strong>调整参数</strong>：增加堆大小、优化新生代比例、切换收集器（如G1）。</li>
</ol>
<hr>
<h4 id="2-如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？"><a href="#2-如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？" class="headerlink" title="2. 如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？"></a>2. 如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>方案</strong>：  <ol>
<li><strong>软引用缓存</strong>：<code>SoftReference</code>在内存不足时自动回收。  </li>
<li><strong>LRU策略</strong>：<code>LinkedHashMap</code>重写<code>removeEldestEntry()</code>。  </li>
<li><strong>WeakHashMap</strong>：键为弱引用，自动清理无引用键值对。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-高并发场景下，如何通过JVM参数优化减少GC停顿时间？"><a href="#3-高并发场景下，如何通过JVM参数优化减少GC停顿时间？" class="headerlink" title="3. 高并发场景下，如何通过JVM参数优化减少GC停顿时间？"></a>3. 高并发场景下，如何通过JVM参数优化减少GC停顿时间？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>参数调整</strong>：  <ul>
<li>使用低延迟收集器（G1、ZGC）。  </li>
<li>增大堆内存和元空间。  </li>
<li>设置<code>-XX:MaxGCPauseMillis</code>（G1目标停顿时间）。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-如何模拟并分析Metaspace的OOM问题？"><a href="#4-如何模拟并分析Metaspace的OOM问题？" class="headerlink" title="4. 如何模拟并分析Metaspace的OOM问题？"></a>4. 如何模拟并分析Metaspace的OOM问题？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>模拟方法</strong>：  <ol>
<li>动态生成大量类（如CGLib代理）。  </li>
<li>限制元空间：<code>-XX:MaxMetaspaceSize=50m</code>。</li>
</ol>
</li>
<li><strong>分析</strong>：通过<code>jstat -gcmetacapacity</code>监控元空间使用率。</li>
</ul>
<hr>
<h4 id="5-在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？"><a href="#5-在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？" class="headerlink" title="5. 在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？"></a>5. 在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？</h4><p><strong>答案</strong>：  </p>
<ul>
<li><strong>volatile</strong>：保证可见性（如状态标志位）。  </li>
<li><strong>final</strong>：不可变对象（如初始化后字段不可修改）。  </li>
<li><strong>synchronized</strong>：原子性操作（如计数器递增）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ZengCP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2023/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ZengCP's BLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/" title="TCP 状态详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">TCP 状态详解</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/" title="JVM 调优总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM 调优总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" title="JVM 核心知识点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="title">JVM 核心知识点总结</div></div></a></div><div><a href="/2023/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/" title="JVM 调优总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-21</div><div class="title">JVM 调优总结</div></div></a></div><div><a href="/2023/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/" title="AQS 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-08</div><div class="title">AQS 详解</div></div></a></div><div><a href="/2023/05/18/Java%20%E5%9F%BA%E7%A1%80/Java%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="Java 代理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-18</div><div class="title">Java 代理模式</div></div></a></div><div><a href="/2023/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/" title="Java 基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-04</div><div class="title">Java 基础</div></div></a></div><div><a href="/2023/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java 并发编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-05-11</div><div class="title">Java 并发编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZengCP</div><div class="author-info__description">记录心得，见证成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">86</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.1.</span> <span class="toc-text">一、内存模型与结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89"><span class="toc-number">1.0.2.</span> <span class="toc-text">二、垃圾回收（GC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">1.0.3.</span> <span class="toc-text">三、类加载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">1.0.4.</span> <span class="toc-text">四、JVM性能调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.0.5.</span> <span class="toc-text">五、JMM（Java内存模型）与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5"><span class="toc-number">1.0.6.</span> <span class="toc-text">六、监控与故障排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%AB%98%E7%BA%A7%E4%B8%8E%E6%89%A9%E5%B1%95"><span class="toc-number">1.0.7.</span> <span class="toc-text">七、高级与扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.8.</span> <span class="toc-text">八、实战场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">答案：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BB%93%E6%9E%84-1"><span class="toc-number">2.0.1.</span> <span class="toc-text">一、内存模型与结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%88%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E3%80%81%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%E3%80%81%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">1. 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E6%9C%BA%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%96%B0%E7%94%9F%E4%BB%A3%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E4%BE%8B%E5%8F%8A%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">2.0.1.2.</span> <span class="toc-text">2. 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%88%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%EF%BC%89%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E5%8A%A3%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">2.0.1.3.</span> <span class="toc-text">3. 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89%E4%B8%8E%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88PermGen%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88Java-8%E8%A6%81%E7%A7%BB%E9%99%A4%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%9F"><span class="toc-number">2.0.1.4.</span> <span class="toc-text">4. 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%9C%A8JDK-1-7%E5%8F%8A%E4%B9%8B%E5%90%8E%E7%89%88%E6%9C%AC%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%98%E5%8C%96%E5%8F%8A%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">2.0.1.5.</span> <span class="toc-text">5. 字符串常量池在JDK 1.7及之后版本的位置变化及原因？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFTLAB%EF%BC%88Thread-Local-Allocation-Buffer%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AB%9E%E4%BA%89%EF%BC%9F"><span class="toc-number">2.0.1.6.</span> <span class="toc-text">6. 什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%EF%BC%88%E5%AF%B9%E8%B1%A1%E5%A4%B4%E3%80%81%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE%E3%80%81%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85%EF%BC%89%E5%8F%8A%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%EF%BC%9F"><span class="toc-number">2.0.1.7.</span> <span class="toc-text">7. 对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%88OOM%EF%BC%89%E7%9A%84%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%A0%86%E3%80%81%E6%A0%88%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA%E3%80%81%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%89%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.0.1.8.</span> <span class="toc-text">8. 内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88GC%EF%BC%89-1"><span class="toc-number">2.0.2.</span> <span class="toc-text">二、垃圾回收（GC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%88%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E3%80%81%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">1. 列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E3%80%81%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%EF%BC%89%EF%BC%9FGC-Roots%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.0.2.2.</span> <span class="toc-text">2. 如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.0.2.3.</span> <span class="toc-text">3. 强引用、软引用、弱引用、虚引用的区别及使用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-CMS%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%88%E5%88%9D%E5%A7%8B%E6%A0%87%E8%AE%B0%E3%80%81%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E3%80%81%E9%87%8D%E6%96%B0%E6%A0%87%E8%AE%B0%E3%80%81%E5%B9%B6%E5%8F%91%E6%B8%85%E9%99%A4%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E2%80%9C%E6%B5%AE%E5%8A%A8%E5%9E%83%E5%9C%BE%E2%80%9D%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.0.2.4.</span> <span class="toc-text">4. CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%EF%BC%88Region%E5%88%86%E5%8C%BA%E3%80%81SATB%E3%80%81Mixed-GC%EF%BC%89%EF%BC%9F%E4%B8%8ECMS%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">2.0.2.5.</span> <span class="toc-text">5. G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-ZGC%E5%92%8CShenandoah%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%88%E9%A2%9C%E8%89%B2%E6%8C%87%E9%92%88%E3%80%81%E8%AF%BB%E5%B1%8F%E9%9A%9C%E3%80%81%E4%BD%8E%E5%BB%B6%E8%BF%9F%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.2.6.</span> <span class="toc-text">6. ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%A7%A6%E5%8F%91Full-GC%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81Full-GC%EF%BC%9F"><span class="toc-number">2.0.2.7.</span> <span class="toc-text">7. 什么情况下会触发Full GC？如何避免频繁Full GC？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6-1"><span class="toc-number">2.0.3.</span> <span class="toc-text">三、类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E5%8A%A0%E8%BD%BD%E3%80%81%E9%AA%8C%E8%AF%81%E3%80%81%E5%87%86%E5%A4%87%E3%80%81%E8%A7%A3%E6%9E%90%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%E5%90%84%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">2.0.3.1.</span> <span class="toc-text">1. 类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%88%E5%A6%82JDBC%E3%80%81Tomcat%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AE%BE%E8%AE%A1%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.3.2.</span> <span class="toc-text">2. 双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E7%83%AD%E9%83%A8%E7%BD%B2%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E9%9A%94%E7%A6%BB%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.3.3.</span> <span class="toc-text">3. 如何自定义类加载器？应用场景（热部署、模块化隔离）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%98%AF%E2%80%9C%E6%87%92%E5%8A%A0%E8%BD%BD%E2%80%9D%EF%BC%88Lazy-Loading%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.3.4.</span> <span class="toc-text">4. 为什么说Java的类加载是“懒加载”（Lazy Loading）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%EF%BC%88new%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E4%B8%BB%E7%B1%BB%E3%80%81%E5%AD%90%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%AD%89%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.3.5.</span> <span class="toc-text">5. 类初始化触发条件（new、反射、主类、子类初始化等）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-number">2.0.3.6.</span> <span class="toc-text">6. 接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81JVM%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-1"><span class="toc-number">2.0.4.</span> <span class="toc-text">四、JVM性能调优</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B8%B8%E8%A7%81%E7%9A%84JVM%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0%EF%BC%88%E5%A0%86%E5%A4%A7%E5%B0%8F%E3%80%81%E5%B9%B4%E8%BD%BB%E4%BB%A3%E6%AF%94%E4%BE%8B%E3%80%81SurvivorRatio%E3%80%81GC%E6%97%A5%E5%BF%97%E7%AD%89%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.4.1.</span> <span class="toc-text">1. 常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87GC%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A2%91%E7%B9%81GC%E6%88%96%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.0.4.2.</span> <span class="toc-text">2. 如何通过GC日志分析频繁GC或内存泄漏问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E8%B0%83%E6%95%B4%E6%96%B0%E7%94%9F%E4%BB%A3%E4%B8%8E%E8%80%81%E5%B9%B4%E4%BB%A3%E7%9A%84%E6%AF%94%E4%BE%8B%EF%BC%88-XX-NewRatio%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.4.3.</span> <span class="toc-text">3. 什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8A-XX-UseCompressedOops%E5%92%8C-XX-UseCompressedClassPointers%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.0.4.4.</span> <span class="toc-text">4. 解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%90%88%E7%90%86%E7%9A%84%E5%A0%86%E5%A4%A7%E5%B0%8F%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81GC%EF%BC%9F%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E8%B4%9F%E8%BD%BD%E4%BC%B0%E7%AE%97%E5%86%85%E5%AD%98%E9%9C%80%E6%B1%82%EF%BC%9F"><span class="toc-number">2.0.4.5.</span> <span class="toc-text">5. 如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-XX-DoEscapeAnalysis%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">2.0.4.6.</span> <span class="toc-text">6. 逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94%EF%BC%88Inlining%EF%BC%89%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%8F%8A%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">2.0.4.7.</span> <span class="toc-text">7. 方法内联（Inlining）的条件及对性能的影响？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81JMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89%E4%B8%8E%E5%B9%B6%E5%8F%91-1"><span class="toc-number">2.0.5.</span> <span class="toc-text">五、JMM（Java内存模型）与并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JMM%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92%EF%BC%888%E7%A7%8D%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.5.1.</span> <span class="toc-text">1. JMM如何定义主内存与工作内存的交互（8种原子操作）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%EF%BC%88%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E7%A6%81%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%89%EF%BC%9F%E4%B8%8Esynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.0.5.2.</span> <span class="toc-text">2. volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-happens-before%E5%8E%9F%E5%88%99%E7%9A%84%E5%85%B7%E4%BD%93%E8%A7%84%E5%88%99%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">2.0.5.3.</span> <span class="toc-text">3. happens-before原则的具体规则及应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%88Memory-Barrier%EF%BC%89%EF%BC%9FJVM%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0volatile%E7%9A%84%E8%AF%AD%E4%B9%89%EF%BC%9F"><span class="toc-number">2.0.5.4.</span> <span class="toc-text">4. 什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%AA%E5%85%B1%E4%BA%AB%EF%BC%88False-Sharing%EF%BC%89%EF%BC%9F%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87-Contended%E6%88%96%E5%A1%AB%E5%85%85%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">2.0.5.5.</span> <span class="toc-text">5. 什么是伪共享（False Sharing）？如何通过@Contended或填充解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-CAS%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%88Unsafe%E7%B1%BB%E3%80%81CPU%E6%8C%87%E4%BB%A4%EF%BC%89%EF%BC%9FABA%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">2.0.5.6.</span> <span class="toc-text">6. CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5-1"><span class="toc-number">2.0.6.</span> <span class="toc-text">六、监控与故障排查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87jstat%E3%80%81jmap%E3%80%81jstack%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%88%96%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">1. 如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-MAT%EF%BC%88Memory-Analyzer-Tool%EF%BC%89%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7%EF%BC%9F"><span class="toc-number">2.0.6.2.</span> <span class="toc-text">2. MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8DCPU%E9%A3%99%E9%AB%98%E6%88%96%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%EF%BC%88%E7%BB%93%E5%90%88top-Hp%E3%80%81jstack%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.6.3.</span> <span class="toc-text">3. 如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%A3%E9%87%8AJVM%E7%9A%84SafePoint%EF%BC%88%E5%AE%89%E5%85%A8%E7%82%B9%EF%BC%89%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E5%AF%B9GC%E7%9A%84%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">2.0.6.4.</span> <span class="toc-text">4. 解释JVM的SafePoint（安全点）机制及其对GC的影响？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AFOOM-Killer%EF%BC%9FLinux%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DJVM%E8%BF%9B%E7%A8%8B%E8%A2%AB%E8%AF%AF%E6%9D%80%EF%BC%9F"><span class="toc-number">2.0.6.5.</span> <span class="toc-text">5. 什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Arthas%E5%9C%A8%E7%BA%BF%E8%AF%8A%E6%96%ADJVM%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB%E3%80%81%E7%9B%91%E6%8E%A7%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.6.6.</span> <span class="toc-text">6. 如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E9%AB%98%E7%BA%A7%E4%B8%8E%E6%89%A9%E5%B1%95-1"><span class="toc-number">2.0.7.</span> <span class="toc-text">七、高级与扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-JIT%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C-vs-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%EF%BC%89%EF%BC%9F%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91%EF%BC%88C1-C2%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.7.1.</span> <span class="toc-text">1. JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%A3%E9%87%8AJVM%E7%9A%84%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%8F%8A%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D%EF%BC%88Stack-Allocation%EF%BC%89%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">2.0.7.2.</span> <span class="toc-text">2. 解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%88%E5%A6%82%E5%BA%9F%E5%BC%83%E5%B8%B8%E9%87%8F%E3%80%81%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB%E5%8D%B8%E8%BD%BD%E6%9D%A1%E4%BB%B6%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.7.3.</span> <span class="toc-text">3. 如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9F%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.0.7.4.</span> <span class="toc-text">4. 什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-JVM%E5%AF%B9%E5%8D%8F%E7%A8%8B%EF%BC%88Loom%E9%A1%B9%E7%9B%AE%EF%BC%89%E7%9A%84%E6%94%AF%E6%8C%81%E5%8F%8A%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="toc-number">2.0.7.5.</span> <span class="toc-text">5. JVM对协程（Loom项目）的支持及与线程的对比？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%AE%B9%E5%99%A8%E5%8C%96%EF%BC%88Docker%EF%BC%89%E7%8E%AF%E5%A2%83%E4%B8%8BJVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">2.0.7.6.</span> <span class="toc-text">6. 容器化（Docker）环境下JVM内存参数设置的注意事项？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%AE%9E%E6%88%98%E5%9C%BA%E6%99%AF-1"><span class="toc-number">2.0.8.</span> <span class="toc-text">八、实战场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E9%A2%91%E7%B9%81Full-GC%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%A6%82%E4%BD%95%E9%80%90%E6%AD%A5%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">2.0.8.1.</span> <span class="toc-text">1. 如果线上服务出现频繁Full GC，你会如何逐步排查？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%EF%BC%88%E5%A6%82WeakHashMap%E3%80%81LRU%E7%AD%96%E7%95%A5%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.8.2.</span> <span class="toc-text">2. 如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JVM%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E5%87%8F%E5%B0%91GC%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">2.0.8.3.</span> <span class="toc-text">3. 高并发场景下，如何通过JVM参数优化减少GC停顿时间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E6%A8%A1%E6%8B%9F%E5%B9%B6%E5%88%86%E6%9E%90Metaspace%E7%9A%84OOM%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.0.8.4.</span> <span class="toc-text">4. 如何模拟并分析Metaspace的OOM问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87JMM%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%88%E7%BB%93%E5%90%88volatile%E3%80%81final%E3%80%81synchronized%EF%BC%89%EF%BC%9F"><span class="toc-number">2.0.8.5.</span> <span class="toc-text">5. 在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/15/%E5%9C%BA%E6%99%AF%E9%A2%98%E6%B1%87%E6%80%BB/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%B1%BB/" title="系统设计类场景题">系统设计类场景题</a><time datetime="2025-02-15T10:26:53.000Z" title="发表于 2025-02-15 18:26:53">2025-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/15/%E5%9C%BA%E6%99%AF%E9%A2%98%E6%B1%87%E6%80%BB/%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/" title="面试常见场景题汇总">面试常见场景题汇总</a><time datetime="2025-02-15T07:26:53.000Z" title="发表于 2025-02-15 15:26:53">2025-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/" title="RocketMQ 核心架构原理">RocketMQ 核心架构原理</a><time datetime="2024-12-08T09:02:36.000Z" title="发表于 2024-12-08 17:02:36">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A6%82%E8%BF%B0/" title="RocketMQ 概述">RocketMQ 概述</a><time datetime="2024-12-08T07:16:48.000Z" title="发表于 2024-12-08 15:16:48">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Kafka 经典面试题">Kafka 经典面试题</a><time datetime="2024-12-07T12:45:18.000Z" title="发表于 2024-12-07 20:45:18">2024-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ZengCP</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>