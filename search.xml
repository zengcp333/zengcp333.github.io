<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IPC --- 共享内存</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存基本概念"><a href="#共享内存基本概念" class="headerlink" title="共享内存基本概念"></a>共享内存基本概念</h1><p>共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的互斥访问，可以使用信号量。</p><h1 id="共享内存实现方式"><a href="#共享内存实现方式" class="headerlink" title="共享内存实现方式"></a>共享内存实现方式</h1><p>共享内存通常是各种 IPC 之中效率最高的方式。Linux 之中实现共享内存的方式通常有如下几类：</p><ul><li><strong>mmap</strong> 内存共享映射 （通常用于父子进程之间的内存共享，存在一定局限性，且用到更多的原因是其 零拷贝IO 的特性）</li><li>**System V **的共享内存</li><li><strong>POSIX</strong> 共享内存</li></ul><p>平时讨论主要的共享内存是后面两者，但是 System V 和 POSIX 的共享内存，底层都是基于内存文件系统 <strong>tmpfs</strong> 实现的，二者的主要区别是在接口设计上，</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将多个进程的地址空间映射到同一个物理内存，从而多个进程都能使用这块物理内存；从而可以用来实现不同进程间的数据共享，也即进程之间的通信</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2b5437ee0d9c422ea100773c6cc5523f.png" alt="img"></p><h3 id="shm-共享内存接口函数"><a href="#shm-共享内存接口函数" class="headerlink" title="shm 共享内存接口函数"></a>shm 共享内存接口函数</h3><h4 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="shmget-—-创建共享内存"><a href="#shmget-—-创建共享内存" class="headerlink" title="shmget() — 创建共享内存"></a>shmget() — 创建共享内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong>： 由 ftok 生成的 key 标识，标识系统的唯一 IPC 资源。</p><p><strong>size</strong>： 需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。</p><p><strong>shmflg</strong>： 如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。</p><p>**[返回值]**： 成功时返回一个新建或已经存在的的共享内存标识符，取决于 shmflg 的参数。失败返回 -1 并设置错误码。</p><h4 id="shmat-—-挂接共享内存"><a href="#shmat-—-挂接共享内存" class="headerlink" title="shmat() — 挂接共享内存"></a>shmat() — 挂接共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong> ： <code>shmget()</code>返回的共享内存标识。</p><p><strong>shm_addr</strong> ： 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p><strong>shm_flg</strong> ： 一组标志位，通常为0。</p><p><strong>[返回值]</strong> ： 成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的 <code>shmid_ds</code> 结构中的 <code>shm_nattch</code> 计数器加1（类似于引用计数）；出错返回-1。</p><h4 id="shmdt-—-去关联共享内存"><a href="#shmdt-—-去关联共享内存" class="headerlink" title="shmdt() — 去关联共享内存"></a>shmdt() — 去关联共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shmaddr</strong>： <code>shmat()</code>返回的地址。</p><p>**[返回值]**： 调用成功时返回0，失败时返回-1.</p><h4 id="shmctl-—-控制共享内存（仅删除）"><a href="#shmctl-—-控制共享内存（仅删除）" class="headerlink" title="shmctl() — 控制共享内存（仅删除）"></a>shmctl() — 控制共享内存（仅删除）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong>： <code>shmget()</code> 返回的共享内存标识符。</p><p><strong>command</strong>： 指定的执行操作，设置为<code>IPC_RMID</code>时表示可以删除共享内存。</p><p><strong>buf</strong>：  填 null 即可</p><p>**[返回值]**：成功返回0，失败返回-1。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><h3 id="MMAP-原理"><a href="#MMAP-原理" class="headerlink" title="MMAP 原理"></a>MMAP 原理</h3><ul><li><p>MMAP 本质是把 文件内容 映射到一段内存上 (准确说是虚拟内存上),  </p></li><li><p>因此通过对这段内存的读取和修改, 即可实现对文件的读取和修改,</p></li><li><p><code>mmap()</code> <strong>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存</strong>。</p></li><li><p>文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用 (read,write) 去操作。</p></li></ul><h4 id="MMAP-零拷贝原理："><a href="#MMAP-零拷贝原理：" class="headerlink" title="MMAP 零拷贝原理："></a>MMAP 零拷贝原理：</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240512223136171.png" alt="image-20240512223136171" style="zoom:67%;" /><h4 id="MMAP-共享内存原理："><a href="#MMAP-共享内存原理：" class="headerlink" title="MMAP 共享内存原理："></a>MMAP 共享内存原理：</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1723697-e4822f4555069606.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 管道</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="匿名管道-IPC"><a href="#匿名管道-IPC" class="headerlink" title="匿名管道 IPC"></a>匿名管道 IPC</h3><h4 id="管道创建"><a href="#管道创建" class="headerlink" title="管道创建"></a>管道创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span> <span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"> <span class="comment">// 返回:成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>fd 为 文件描述符数组，是函数的核心返回值， fd[0] 指向管道 读端 ， fd[1]指向管道写端，也即 fd[1] 是 fd[0] 的输入</p><h4 id="管道实现进程间通信"><a href="#管道实现进程间通信" class="headerlink" title="管道实现进程间通信"></a>管道实现进程间通信</h4><p>（1）父进程创建管道，得到两个⽂件描述符指向管道的两端</p><p>（2）父进程 fork 出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 </p><p>（3）父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要在 fork 之前创建管道 ， 这样子进程与父进程 对应相同的管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//read会阻塞，进行读取数据</span></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s ,pid:%d \n&quot;</span>,buf,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//子进程 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;Hello ,I am child &quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 信号量</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h1><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值 0 和 1 的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少，本文只介绍二元信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code>和<code>V(sv)</code>,他们的行为是这样的：</p><p>**P(sv)**：如果 sv 的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行</p><p>**V(sv)**：如果有其他进程因等待 sv 而被挂起，就让它恢复运行，如果没有进程因等待 sv 而挂起，就给它加 1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Linux的信号量机制"><a href="#Linux的信号量机制" class="headerlink" title="Linux的信号量机制"></a>Linux的信号量机制</h2><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<code>sys/sem.h</code>中。</p><h3 id="semget-—-信号量创建"><a href="#semget-—-信号量创建" class="headerlink" title="semget() — 信号量创建"></a>semget() — 信号量创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>key</strong>： 整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用 <code>semget()</code> 函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有 <code>semget()</code> 函数才直接使用信号量键，所有其他的信号量函数使用由 <code>semget()</code> 函数返回的信号量标识符。如果多个程序使用相同的 key 值，key 将负责协调工作。</p></li><li><p><strong>num_sems</strong>： 指定需要的信号量数目，它的值几乎总是1。</p></li><li><p><strong>sem_flags</strong>： 一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值 IPC_CREAT 做按位或操作。设置了 IPC_CREAT 标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而  IPC_EXCL 则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code> 函数成功返回一个相应信号标识符（非零），失败返回-1.</p><h3 id="semop-—-改变信号量的值"><a href="#semop-—-改变信号量的值" class="headerlink" title="semop() — 改变信号量的值"></a>semop() — 改变信号量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_opa, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_id</code> 是由 <code>semget()</code> 返回的信号量标识符，<code>sembuf</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> sem_num; <span class="comment">// 除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="type">short</span> sem_op;  <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                   <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">// 通常为SEM_UNDO,使操作系统跟踪信号，</span></span><br><span class="line">                   <span class="comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="semctl-—-修改信号量信息"><a href="#semctl-—-修改信号量信息" class="headerlink" title="semctl() — 修改信号量信息"></a>semctl() — 修改信号量信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_id: semget() 返回的 sem Id</li><li>sem_num: 指定需要的信号量数目，它的值几乎总是1</li><li>command: 通常是下面两个值中的其中一个:<ul><li>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</li><li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符</li></ul></li></ul><p>如果有第四个参数，它通常是一个 <code>union semum</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用信号量实现多进程并发安全"><a href="#用信号量实现多进程并发安全" class="headerlink" title="用信号量实现多进程并发安全"></a>用信号量实现多进程并发安全</h1><h2 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h2><p><strong>进程互斥</strong>：不同进程之间的代码，A进程执行到部分代码字段 时，其他进程不能执行自身特定的代码字段，仅A进程将该字段执行完毕，其他程序才能继续执行</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 信号量机制实现互斥 */</span><br><span class="line">semaphore mutex = 1; // 初始化信号量</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);   // 使用临界资源前需要加锁</span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   // 使用临界资源后需要解锁</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);  </span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h2><p><strong>进程同步</strong>： 散布在不同进程之间的若干程序片段，它们的运行必须严格按照一定的先后次序来运行，这种次序依赖于要完成的任务。比如数据的收发，必须发送方发送了接收方才能收</p><p>用例： 保证代码 4 必须在代码 1,2 之后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程</title>
      <link href="/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA-并发编程基础"><a href="#JAVA-并发编程基础" class="headerlink" title="JAVA 并发编程基础"></a>JAVA 并发编程基础</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/11183270-40bf3033d3e24a39.png" alt="img"></p><p>JVM 线程对主存中的共享变量进行修改时，必须先将共享变量读到自身工作内存中（实际就是CPU Cache），并在工作内存中进行修改，最后再刷回主存。</p><p>（CPU Cache： 缓解 内存 和 CPU 速度相差过大问题， 但 Cache 引入势必造成一致性问题）</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="内存交互操作（保证原子性）"><a href="#内存交互操作（保证原子性）" class="headerlink" title="内存交互操作（保证原子性）"></a>内存交互操作（保证原子性）</h3><ul><li><strong>read</strong>： 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li><strong>load</strong>： 把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use</strong>： 把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign</strong>： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li><strong>store</strong>： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li><strong>write</strong>： 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li><li><strong>lock</strong>： 作用于主内存的变量，把一个变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li></ul><p><strong>相关规则：</strong></p><ul><li>read &#x2F; load 和 store &#x2F; write  操作必须成对按序使用</li><li>变量 assign 之后必须存在 stire&#x2F;write 将其写回主存</li><li>加载完但未执行 assign 的变量 ，不允许重新写回主存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个线程 lock 了一个变量，后续该线程 且 仅有该线程能继续 lock 该变量； 直至调用相同 次数 unlock ，完成解锁</li><li>变量被 lock ，所有工作内存中的副本将被清除，因此执行引擎使用该变量前，必须重新 load 或 assign 以初始化变量的值</li><li>只能 unlock 被当前线程 lock 了的变量</li><li>对一个变量进行 unlock 操作之前，必须把此变量同步回主内存</li></ul><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h3><ul><li>继承Thread 类</li><li>实现 Runable 接口</li><li>实现 callable 接口</li><li>使用线程池</li></ul><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>此外，严格来说，Java 其实只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h3 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h3><ul><li><p><strong>wait()</strong></p><ul><li>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，</li><li>会释放对象的锁</li></ul></li><li><p><strong>sleep()</strong></p><ul><li>sleep 导致当前线程休眠，sleep(long)会导致线程进入TIMED-WATING 状态</li><li>不会释放锁</li></ul></li><li><p><strong>yield()</strong></p><ul><li>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。</li><li>不释放锁</li></ul></li><li><p><strong>join()</strong></p><ul><li>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位，这个线程本身并不会因此而改变状态(如阻塞，终止等)。</li></ul></li><li><p><strong>interrupt()</strong></p><ul><li>将一个阻塞状态线程的中断标志位置位，并使其中断&#x2F;抛出异常，抛出异常后 清楚中断标记位</li><li></li></ul></li></ul><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1383841-20190624155001636-644135935.jpg" alt="img"></p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><h3 id="volatile-关键字作用"><a href="#volatile-关键字作用" class="headerlink" title="volatile 关键字作用"></a>volatile 关键字作用</h3><p>烂八股：</p><ul><li><strong>保证可见性</strong>： 线程对 volatile 变量修改后，强制将其刷回主存，并使其他 CPU 中的对应缓存行失效（MESI 和 内存屏障的作用）</li><li><strong>禁止指令重排：</strong> 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果 （阿里开发手册中关于 DCL 单例中的说明）</li></ul><h3 id="volatile-原理"><a href="#volatile-原理" class="headerlink" title="volatile 原理"></a>volatile 原理</h3><p>从汇编角度看，volatile 的作用基于 lock 前缀指令 —— 在线程对缓存行内变量执行写操作时，发出一个 lock 指令，锁住总线&#x2F;或缓存行，同时让 其他cpu中的缓存行失效，并将修改后的数据强制写回主存</p><h3 id="volatile-int-i-错误原因分析："><a href="#volatile-int-i-错误原因分析：" class="headerlink" title="volatile int i++ 错误原因分析："></a>volatile int i++ 错误原因分析：</h3><p>i++ 非原子性操作，</p><ul><li>读取 i</li><li>i 自增</li><li>回写 i</li></ul><p>volatile 可以保证第二 和 第三步 会合并成一个原子操作</p><p>但若两个 thread 读取操作发生在 peer 的改值操作之前，还是不能保证线程安全</p><p><strong>【参考】</strong></p><ul><li><a href="https://www.cnblogs.com/badboys/p/12695183.html">volatile与lock前缀指令 - 干饭人~ - 博客园 (cnblogs.com)</a></li></ul><h2 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h2><h3 id="synchronized-概述"><a href="#synchronized-概述" class="headerlink" title="synchronized 概述"></a>synchronized 概述</h3><p>~ 是 java 中用来实现 线程同步&#x2F;互斥 编程的一个关键字，可以用来修饰</p><ul><li>实例方法 —— 锁住当前对象</li><li>静态方法 —— 锁住当前类对象</li><li>代码块 —— 静态代码块，锁住当前类对象； 普通代码块，锁住当前对象</li></ul><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>无论是哪种使用方法，<code>synchronized</code> 底层都是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 两个 jvm 指令实现的</p><p>而 <code>monitorenter</code> 和 <code>monitorexit</code> 则是基于 <code>markworkd 及 </code>objectmonitor&#96; 实现</p><h3 id="markword-对象头"><a href="#markword-对象头" class="headerlink" title="markword &#x2F; 对象头"></a>markword &#x2F; 对象头</h3><h4 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h4><ul><li>对象头</li><li>实例数据</li><li>对其填充字节</li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul><li>Markword</li><li>类指针</li><li>数组长度（仅数组对象有）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/aa.png" alt="aa"></p><h3 id="Synchronized-锁升级"><a href="#Synchronized-锁升级" class="headerlink" title="Synchronized 锁升级"></a>Synchronized 锁升级</h3><ol><li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li><li>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在 Markword 的偏向线程 ID 里存储当前线程的操作系统线程 ID，偏向锁标识位是1，锁标识位是01。<ul><li>从jdk1.6之后，JVM有两个默认参数是开启的，-XX:+UseBiasedLocking（表示启用偏向锁，想要关闭偏向锁，可添加JVM参数：-XX:-UseBiasedLocking），-XX:BiasedLockingStartupDelay&#x3D;4000（表示JVM启动4秒后打开偏向锁，也可以自定义这个延迟时间，如果设置成0，那么JVM启动就打开偏向锁）。</li><li>此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。</li><li>另外需要注意的是，由于硬件资源的不断升级，获取锁的成本随之下降，jdk15版本后默认关闭了偏向锁。<br>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前）有线程访问共享资源则直接由无锁升级为轻量级锁，</li></ul></li><li>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<ul><li>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。</li></ul></li><li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的 mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter 指令插入到同步代码块在编译后的开始位置，monitorexit 指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240528011826870.png" alt="image-20240528011826870"></p><h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/932045510502514689.png" alt="932045510502514689"></p><p><strong>【参考】</strong></p><ul><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现–概论 · Issue #12 · farmerjohngit&#x2F;myblog (github.com)</a></li></ul><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>Java 自带的各种同步工具类的 基石</p><p>将临界资源抽象成一个 volatile int state，并通过 cas 操作进行加减锁</p><p>此外，AQS 设计了一个 FIFO 的线程等待 （双向）队列，用以帮助并发竞争的线程间 进行 阻塞、唤醒等功能</p><p>而且，提供基础的 排它锁、共享锁设计基础， 实现类可在此基础上进一步补充 公平、非公平机制，实现常用锁功能和特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span>/Setter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁相关"><a href="#写锁相关" class="headerlink" title="写锁相关"></a>写锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>acquire 由 实现类的 lock() 调用，调用前 及 tryAcquire 具体实现中可自定义 公平&#x2F;非公平策略</li></ul><h2 id="共享锁相关"><a href="#共享锁相关" class="headerlink" title="共享锁相关"></a>共享锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">// 由子类实现</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 找到前继节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);<span class="comment">// 由子类实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平-与-非公平-写锁-–-以-ReentrantLock-为例"><a href="#公平-与-非公平-写锁-–-以-ReentrantLock-为例" class="headerlink" title="公平 与 非公平 写锁 – 以 ReentrantLock 为例"></a>公平 与 非公平 写锁 – 以 ReentrantLock 为例</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li><h4 id="fair-lock"><a href="#fair-lock" class="headerlink" title="fair lock"></a>fair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="unfair-lock"><a href="#unfair-lock" class="headerlink" title="unfair lock"></a>unfair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="乐观锁-与-悲观锁"><a href="#乐观锁-与-悲观锁" class="headerlink" title="乐观锁 与 悲观锁"></a>乐观锁 与 悲观锁</h1><p>~ 是并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><p>悲观锁和乐观锁是实现并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>悲观锁 的 线程安全控制策略 适用于 并发写操作较多的场景，</li><li>悲观锁 在加锁期间，其他线程无法访问被锁定的资源，从而保证了数据的完整性。</li><li>悲观锁 需要频繁地进行加锁和解锁操作，开销较大。</li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>乐观锁适用于并发读操作较多的场景，因为读操作不涉及到数据的修改，不需要加锁。</li><li>乐观锁在更新数据时，只有在提交更新操作时才对数据进行版本检查，减少了加锁和解锁的开销。</li><li>乐观锁可能需要进行重试，以处理并发修改引起的冲突。</li></ul><p>乐观锁常用 <strong>CAS</strong> 或 **版本号 ** 机制 进行实现</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ， 即 仅比较通过才会进行设值， CAS 是乐观锁的主要实现方式之一</p><p>CAS 依赖于操作系统原语，更底层则依赖于 硬件指令集，即 CAS 最终由 硬件保证操作的原子性</p><h3 id="JAVA-CAS"><a href="#JAVA-CAS" class="headerlink" title="JAVA CAS"></a>JAVA CAS</h3><p>java cas 相关实现依赖于 Unsafe 类提供的一系列 JNI 接口</p><h3 id="CAS-相关问题"><a href="#CAS-相关问题" class="headerlink" title="CAS 相关问题"></a>CAS 相关问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><ul><li><p>CAS 操作成功，并不意味着值在 cas 所处指令序列的 值读取 与 CAS 设值 之间没有发生过 变更</p></li><li><p>解决：在变量前面追加上<strong>版本号或者时间戳</strong></p></li></ul><h4 id="自旋空转"><a href="#自旋空转" class="headerlink" title="自旋空转"></a>自旋空转</h4><p><strong>说明</strong>： CAS 经常会用自旋操作来进行重试，即不成功就一直循环直至成功为止。但若如果长时间不成功，会给 CPU 造成较大负担</p><p><strong>解决</strong>：参考 synchronized 引入适应性自旋，或限制自旋次数</p><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>废话不多说，直接看代码</p><p>先是 ThreadLocal 类本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>ThreadLocal</code> 设值是找到当前线程的 <code>ThreadLocalMap</code> 对象，并以 <code>ThreadLocal</code> 对象自身为 key，以传入值为 value 添加 entry </p><p>所以再看 <code>Thread</code>  中的相关定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 对象实际是 <code>ThreadLocal</code> 的 静态内部类，看一下类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal Map</code> 还包含几个核心方法——<code>getEntry</code>、<code>set()</code>、<code>remove()</code>， 其总体实现逻辑与 常规 Map 没什么太大差别，这里就不展开细讲了</p><p>这里主要讲一下 <code>ThreadLocalMap</code> 中这个 <code>WeakReference</code>， 这也是 ThreadLocal 常被诟病的内存泄漏的问题分析基石</p><h2 id="ThreadLocal-内存泄漏问题分析"><a href="#ThreadLocal-内存泄漏问题分析" class="headerlink" title="ThreadLocal 内存泄漏问题分析"></a>ThreadLocal 内存泄漏问题分析</h2><ul><li><code>Entry</code> 继承自 <code>ThreadLocal&lt;?&gt;</code> 的弱引用， 而 <code>Entry</code> 构造时，父类构造函数调用传入的是参数是 key 也即 <code>ThreadLocal</code> 对象，而 <code>super()</code> 调用过程也就是 弱引用的创建过程，因此，<code>ThreadLocal</code> 中的弱引用实际是 <code>Entry</code> -&gt; <code>ThreadLocal</code> (key) 的弱引用</li><li>而实际上存在 <code>thread</code> -&gt; <code>threadLocalMap</code> -&gt; <code>Entry[]</code> -&gt; <code>entry</code> -&gt; <code>value</code> 的强引用链</li></ul><p>所以在以下场景中，<code>threadlocal</code> 会有内存泄漏问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        createThreadLocal();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601012342860.png" alt="image-20240601012342860"></p><h3 id="ThreadLocal-中-弱引用的作用"><a href="#ThreadLocal-中-弱引用的作用" class="headerlink" title="ThreadLocal 中 弱引用的作用"></a>ThreadLocal 中 弱引用的作用</h3><p>到这，弱引用的作用就比较清楚了</p><ul><li>可以保证 <code>threadLocal</code> 对象本身 可以在 GC 时被正常回收</li><li>但 <code>Value</code> 实际上还是强引用可达，因此并不能被 GC 自动回收，可能还是会造成内存泄漏</li></ul><h3 id="ThreadLocal-如何防止内存泄漏"><a href="#ThreadLocal-如何防止内存泄漏" class="headerlink" title="ThreadLocal 如何防止内存泄漏"></a>ThreadLocal 如何防止内存泄漏</h3><ul><li>使用完手动 <code>remove()</code></li></ul><h2 id="JAVA-引用类型"><a href="#JAVA-引用类型" class="headerlink" title="JAVA 引用类型"></a>JAVA 引用类型</h2><ul><li>强引用 —— 无论内存是否充足，均不回收</li><li>软引用 —— GC 时内存充足不回收，不充足时会回收<ul><li>意思是内存充足也会发生GC ?   手动触发 <code>System.gc()</code> ?</li></ul></li><li>弱引用 —— 无论内存是否充足，只要发生 GC ，都会将其回收</li><li>虚引用 —— 普通开发中几乎不会用到，一般在 GC 过程当中有使用<ul><li>参考： <a href="https://www.cnblogs.com/mfrank/p/9837070.html">你不可不知的Java引用类型之——虚引用 - 弗兰克的猫 - 博客园 (cnblogs.com)</a></li></ul></li></ul><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>两个线程各自锁住一个资源，并无限期等待&#x2F;请求 对方锁住的资源，导致两个线程相互等待，导致程序无限期卡死</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601020943517.png" alt="image-20240601020943517"></p><h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul><li><p><strong>互斥使用</strong>，即当资源被一个线程占用时，别的线程不能使用</p></li><li><p><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</p></li></ul><ul><li><strong>请求和保持</strong>，当资源请求者在请求其他资源的同时保持对原因资源的占有</li><li><strong>循环等待</strong>，多个线程存在环路的锁依赖关系而永远等待下去，例如T1占有T2的资源，T2占有T3的资源，T3占有T1的资源，这种情况可能会形成一个等待环路</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>从死锁条件着手，破坏其中一个即可（互斥是基本需求，不能破坏）</p><p>实际常用的有：</p><ul><li>一次性申请所有资源</li><li>各方按相同顺序申请资源</li><li>给申请资源的等待时间设置限制</li><li>无法实现前面几种，还可以升级锁粒度，用一个大的锁控制全局互斥</li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul><li>jstack 进程号<ul><li>指令运行结果会提示 相应 进程存在死锁问题</li><li>可先用 jps -l 查看所有java 进程</li></ul></li><li>使用图形化工具 jconsole.exe 或 jvisualvm.exe 会自动检测死锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程</title>
      <link href="/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux线程概念"><a href="#一、Linux线程概念" class="headerlink" title="一、Linux线程概念"></a>一、Linux线程概念</h1><h2 id="1、什么是线程"><a href="#1、什么是线程" class="headerlink" title="1、什么是线程"></a>1、什么是线程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509040108318.png" alt="image-20240509040108318"></p><p>首先从 <strong>进程</strong> 讲起，一个进程有自己对应的 PCB，虚拟地址空间，页表以及映射的物理内存，也即 <code>进程 = 内核数据结构 + 进程对应的代码和数据</code>。</p><p>对于<strong>虚存</strong>：虚拟内存决定了进程能够看到的”资源”。因为每一个进程都有对应的虚拟内存，所以进程具有独立性，从而进程需要通信的前提是看到同一份资源。</p><p>通过 fork 创建子进程的时候，会将父进程的PCB的内容，进程地址空间和页表都给子进程拷贝一份。</p><p><code>而如果创建多个 PCB，并将这些 PCB 使用同一个进程地址空间和页表，这样就可以看到同一份资源了，这就是线程。</code></p><p>因此可以将 线程 理解为 进程 内的一个执行流，线程在进程内运行，线程在进程的地址空间内运行，拥有该进程的一部分资源。</p><p>也即 线程是 CPU 调度的基本单位。进程 则是承担系统资源的基本实体，内部可以有一个或多个执行流。因为我们可以通过虚拟地址空间+页表的方式对进程的资源进行划分，单个”进程”(线程)执行粒度，一定要比之前的进程要细。</p><p>如果 OS 要专门设计线程的概念，就需要对线程进行管理，也就需要先描述，再组织，即一定要为线程设计专门的数据结构表示线程对象TCB。但是线程和进程一样都需要被执行，被调度(id,状态，优先级，上下文，栈…)，二者十分相似，所以单纯从线程调度角度，线程和进程有很多的地方是重叠的。所以Linux工程师不想给”线程”专门设计对应的数据结构，而是直接复用PCB，用 PCB 用来表示 Linux 内部的”线程”, 所以在Linux中，进程我们称为轻量级进程。而 windows 有单独的TCB结构</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>.Linux 内核中没有真正意义是线程，Linux是用进程的 PCB 来进行模拟，是一种完全属于自己的一套线程方案</p></li><li><p>站在 CPU视角，每一个PCB，都可以称之为轻量级进程</p></li><li><p>Linux 线程是 CPU 调度的基本单位，而进程是承担资源分配的基本单位</p></li><li><p>进程用来整体申请资源，线程用来伸手向进程要资源</p></li><li><p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”</p></li><li><p>一切进程至少都有一个执行线程</p></li><li><p>线程在进程内部运行，本质是在进程地址空间内运行</p></li><li><p>在 Linux 系统中，在 CPU 眼中，看到的 PCB 都要比传统的进程更加轻量化</p></li><li><p>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</p></li></ol><p>Linux内核中没有真正意义是线程，所以Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口，但是操作系统只认线程，用户(程序员)也只认线程，所以Linux在软件层提供了一个原生的线程库。</p><p>任何 Linux 操作系统，都必须默认携带这个原生线程库–用户级线程库</p><p>线程创建用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是新线程, 我正在运行! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> n = pthread_create(&amp;tid, nullptr, start_routine, (<span class="type">void</span> *)<span class="string">&quot;thread one&quot;</span>);</span><br><span class="line">    assert(<span class="number">0</span> == n);</span><br><span class="line">    (<span class="type">void</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是主线程, 我正在运行!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多<ul><li>进程：切换页表 &amp;&amp; 虚拟地址空间 &amp;&amp; 切换PCB &amp;&amp;上下文切换</li><li>线程：切换PCB &amp;&amp;上下文切换</li></ul></li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I&#x2F;O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I&#x2F;O密集型应用，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能损失</strong> —— 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><strong>健壮性降低</strong> —— 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><strong>缺乏访问控制</strong> —— 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><strong>编程难度提高</strong> —— 编写与调试一个多线程程序比单线程程序困难得多</li></ol><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃，<strong>因为信号在整体发给进程的</strong></p><p>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</p><h1 id="二、线程控制"><a href="#二、线程控制" class="headerlink" title="二、线程控制"></a>二、线程控制</h1><h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><h4 id="创建线程函数接口-–-pthread-create"><a href="#创建线程函数接口-–-pthread-create" class="headerlink" title="创建线程函数接口 – pthread_create"></a>创建线程函数接口 – pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建一个新的线程</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// thread_label: 线程标识符</span></span><br><span class="line"><span class="comment">// attr:设置线程的属性，attr为NULL表示使用默认属性</span></span><br><span class="line"><span class="comment">// start_routine:是个函数地址，线程启动后要执行的函数</span></span><br><span class="line"><span class="comment">// arg:传给线程启动函数的参数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread_label, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread_label 实际上是进程地址空间上的一个地址</li><li>用户线程、用户进程、内核线程 关系后续补充</li></ul><h2 id="2-线程终止"><a href="#2-线程终止" class="headerlink" title="2. 线程终止"></a>2. 线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法</p><ul><li>从线程函数 return。这种方法对主线程不适用，因为从 main 函数 return 相当于调用 exit。</li><li>线程调用 pthread_ exit 终止自己。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value_ptr:value_ptr不要指向一个局部变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure><ul><li>一个线程可以调用 pthread_ cancel 终止同一进程中的另一个线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread:线程ID</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程基础</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul><li>进程可以理解为程序的一次执行过程，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>现代操作系统对于进程会分配独立的 内存地址空间和其他系统资源（IO）</li><li>对 Java 而言，<code>main()</code> 函数启动时其实就是启动了一个 JVM 的进程，而 <code>main()</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul><li>线程是依托于进程的一个指令执行序列</li><li>一个进程可以产生多个线程</li><li>linux中，线程又叫做轻量级进程（light-weight process LWP），也有PCB，创建线程使用的底层函数和进程底层一样，都是clone，但没有独立的地址空间；而进程有独立地址空间，拥有PCB。</li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>包含关系</strong>：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>资源开销</strong>：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><strong>管道 pipe</strong><ul><li><strong>管道概念</strong>：<ul><li>管道是一种半双工的通信方式，用以传输字节流</li><li>本质是内核中基于环形队列设计的一段缓冲区，对应着两个文件描述符，一个赋予读权限，一个赋予写权限</li><li>数据只能单向流动，一端写和一端读</li></ul></li><li><strong>分类</strong><ul><li><strong>匿名管道</strong>： 只能在父子或亲缘进程间使用</li><li><strong>命名管道</strong>：允许非情缘关系进程间进行通信</li></ul></li></ul></li></ul><ul><li><strong>消息队列</strong>：本质是 OS 内核中维护的一个 尾插头读 的链表，<ul><li>与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息</li></ul></li><li><strong>共享存储</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<ul><li><strong>优点</strong>：其他IPC一般涉及数据拷贝、传输，而共享内存不需要，因此 CPU、内存负载更低，同时提高了处理速度</li><li><strong>缺点</strong>：会引入并发安全问题，需引入信号量等机制，确保线程安全性</li><li><strong>实现方式</strong>：有 mmap 和 shmget 两种</li></ul></li><li><strong>信号量</strong>：信号量本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</li><li><strong>套接字</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li><strong>信号</strong>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul><h2 id="进程互斥-与-同步"><a href="#进程互斥-与-同步" class="headerlink" title="进程互斥 与 同步"></a>进程互斥 与 同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>在操作系统中，进程是占有资源的最小单位。对于某些资源来说，可能有多个进程需要占用，但是为了保障操作系统和指令的正常执行，有些资源在同一时间只能被其中一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p><p>典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p><p> 对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p><p>  对于临界区的访问过程分为四个部分：</p><ol><li><strong>进入区</strong>:  查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li><li><strong>临界区</strong>:  在临界区做操作</li><li><strong>退出区</strong>:  清除临界区被占用的标志</li><li><strong>剩余区</strong>：进程与临界区不相关部分的代码</li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>多进程完成某个任务时，进程之间 部分指令 或 代码块 的执行需按照指定先后关系按序执行</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>并行的多个进程 访问临界资源，在其中一个进程A进入临界区后，其他线程在进入临界区前必须阻塞等待进程 A 退出临界区</p><h1 id="CPU-Cache-一致性"><a href="#CPU-Cache-一致性" class="headerlink" title="CPU Cache 一致性"></a>CPU Cache 一致性</h1><p>在单核 CPU 中，只需要考虑 Cache 与 内存 的一致性。但是在多核 CPU 中，由于每个核心都有一份独占的 Cache，就会存在一个核心修改数据后，两个核心 Cache 数据不一致的问题。因此， CPU 缓存一致性问题应该从 2 个维度理解：</p><ul><li><strong>纵向：Cache 与 内存 的一致性问题：</strong> 在修改 Cache 数据后，如何同步回内存？</li><li><strong>横向：多核心 Cache 的一致性问题：</strong> 在一个核心修改 Cache 数据后，如何同步给其他核心 Cache？</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511022424797.png" alt="image-20240511022424797" style="zoom:50%;" /><h2 id="单核场景-cache-与-内存数据一致性"><a href="#单核场景-cache-与-内存数据一致性" class="headerlink" title="单核场景 cache 与 内存数据一致性"></a>单核场景 cache 与 内存数据一致性</h2><ul><li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li><li><strong>写回</strong>：数据在被写入到 CPU 缓存时不会立即同步到内存，而是暂时保存在缓存中。只有在缓存行被替换出缓存（缓存算法对其进行淘汰）时，才会将该缓存行的数据写回到内存中。</li></ul><h2 id="多核场景-cache-一致性"><a href="#多核场景-cache-一致性" class="headerlink" title="多核场景 cache 一致性"></a>多核场景 cache 一致性</h2><h3 id="多核-cache-一致性保证条件"><a href="#多核-cache-一致性保证条件" class="headerlink" title="多核 cache 一致性保证条件"></a>多核 cache 一致性保证条件</h3><ul><li><strong>写传播</strong> —— 某个core 修改某个变量后，其他 core 需要及时感知</li><li>**串行化 ** —— 某个 core 的连续操作，对其他 core 而言，观察到的顺序一致</li></ul><h3 id="cache-一致性协议基石"><a href="#cache-一致性协议基石" class="headerlink" title="cache 一致性协议基石"></a>cache 一致性协议基石</h3><ul><li><strong>写传播 - 总线嗅探：</strong> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。要实现写传播，其实就是将所有的读写操作广播到所有 CPU 核心，而其它 CPU 核心时刻监听总线上的广播，再修改本地的数据；</li><li><strong>事务串行化 - 总线仲裁：</strong> 总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。</li></ul><h2 id="MESI-协议-（默认生效）"><a href="#MESI-协议-（默认生效）" class="headerlink" title="MESI 协议 （默认生效）"></a><strong>MESI 协议</strong> （默认生效）</h2><p>MESI 对应 CPU Cache 中的四种状态</p><ul><li><strong>M</strong>: modified</li><li><strong>E</strong>: Exclusive</li><li><strong>S</strong>: Share</li><li><strong>I</strong>: invalid</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015059650.png" alt="image-20240511015059650" style="zoom:60%;" /><p>由于 修改等操作 需其他 CPU 进行ACK ，影响速率，因此引入 Store Buffer 和 Invalid Queue</p><p>CPU A 修改某个值时，直接将值写入 Store Buffer，并向其他 CPU 失效队列投递 invalid 通知，Invalid 通知成功（兑入对应invalid queue） 再将 store buffer 值 写入 cache</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015623898.png" alt="image-20240511015623898" style="zoom:50%;" /><p>store buffer 和 invalid queue 加快了程序运行速度，但 也带来了问题 —— CPU 间 数据强一致性为了最终一致 &#x2F; 弱一致</p><h2 id="内存屏障解决-有序性问题"><a href="#内存屏障解决-有序性问题" class="headerlink" title="内存屏障解决 有序性问题"></a>内存屏障解决 有序性问题</h2><h3 id="编译器内存屏障"><a href="#编译器内存屏障" class="headerlink" title="编译器内存屏障"></a>编译器内存屏障</h3><p>Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成——内存屏障调用前后指令不乱序执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="CPU-内存屏障"><a href="#CPU-内存屏障" class="headerlink" title="CPU 内存屏障"></a>CPU 内存屏障</h3><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>先看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;   </span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若某一时刻， CPU0 cache 占有 变量 b&#x3D;0，准备执行 func0()， CPU1 cache 占有变量 a&#x3D;0， 准备执行 func1()； 且后续执行流程如下：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>CPU 0 继续执行赋值语句 b&#x3D;1，由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line。</li><li>CPU 1执行 while (b &#x3D;&#x3D; 0) 循环，由于 b 不在CPU 1 的 cache 中，因此，CPU发送一个 read message 到总线上，尝试从其他 cpu 的 localcache 或者 memory 中读取数据。</li><li>CPU 0 收到 read message，将最新的 b 值 1 回送给 CPU1，同时将 b cacheline的状态设定为 S。</li><li>CPU 1 收到了来自 CPU 0 的 read response，将 b 变量最新值 1 值写入自己的 cacheline，状态修改为shared。</li><li>由于 b 值等于 1 ，CPU 1跳出while (b &#x3D;&#x3D; 0)的循环，继续执行。</li><li>CPU 1 执行 assert(a &#x3D;&#x3D; 1)，这时候 CPU1 中的local cache中还是旧的a值，因此assert(a &#x3D;&#x3D; 1)失败。<strong>程序异常</strong></li></ol><p>为避免缓存不一致问题引起的 异常结果， 可在 a&#x3D;1 的赋值操作之后加上写内存屏障，此时 ：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>cpu0 完成 a&#x3D;1 复制操作之后，遇到写内存屏障，执行 flush store buffer</li><li>cpu0 阻塞等待 store buffer 中所有记录 得到 ACK</li><li>cpu1 cache line 收到 a 变量 invalid 消息，并自动 ACK</li><li><strong>cpu1 完成 invalid  queue 处理，修改 local cache 中 cacheline a&#x3D;1 状态为 I</strong></li><li>cpu0 阻塞结束，继续执行 b&#x3D;1 赋值， 由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line</li><li>若不考虑 cpu1 的 invalid queue 主动 ack，则cpu1 判断 a&#x3D;&#x3D;1 时，将发现cache line 中的 缓存已失效，需重新从总线获取，此时 assert t通过</li></ol><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>仍以上例说明，由于 cpu1 存在 invalid queue ，会自动回复 ACK，所以：</p><ul><li>若 cpu1 未及时完成 invalid queue 处理， 则 CPU1 后续执行 a&#x3D;&#x3D;1 判断时，会判断 cache 中 有cacheline 命中，因此仍有可能失败</li></ul><p>因此，为确保 invalid queue 数据及时处理</p><ul><li>进一步在 assert(a&#x3D;&#x3D;1) 之前加上 读内存屏障</li></ul><p>读内存屏障作用为——cpu 下一次读取操作前，必须 flush invalid queue</p><p>因此，以上例子在无锁添加下，可通过以下改造确保程序运行正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  smp_mb();  <span class="comment">// 写内存屏障</span></span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  smp_rmb();<span class="comment">// 读内存屏障</span></span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发安全性基础"><a href="#并发安全性基础" class="headerlink" title="并发安全性基础"></a>并发安全性基础</h1><ul><li><strong>原子性</strong> —— 一个线程的一组操作要么未执行，要么全部执行，即使中间因线程调度而中断，其总体执行结果与一次性执行完毕的结果无异，本质就是 多线程&#x2F;进程 对临界资源的互斥访问</li><li><strong>可见性</strong> —— 多个线程修改同一个共享变量时，一个线程修改后，其他线程能马上获得修改后的值</li><li><strong>有序性</strong> —— 即程序执行的顺序按照代码的先后顺序执行</li></ul><h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><h2 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h2><p>指令重排是计算机编译器或处理器为了提高性能而对指令执行顺序进行的一种优化手段。</p><p>在多核和多线程的计算机系统中，指令重排的目标是通过优化执行顺序来提高指令级别的并行度，充分发挥计算资源，加速程序的执行</p><h2 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><h3 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h3><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p><h3 id="指令级并行的重排序"><a href="#指令级并行的重排序" class="headerlink" title="指令级并行的重排序"></a>指令级并行的重排序</h3><p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><h3 id="内存系统的重排"><a href="#内存系统的重排" class="headerlink" title="内存系统的重排"></a>内存系统的重排</h3><p>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>也即源代码从编译到最终运行之间可能涉及的重排序流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240526135057956.png" alt="image-20240526135057956"></p><h2 id="指令重排的准则-（以-java-为例）"><a href="#指令重排的准则-（以-java-为例）" class="headerlink" title="指令重排的准则 （以 java 为例）"></a>指令重排的准则 （以 java 为例）</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><h4 id="语义"><a href="#语义" class="headerlink" title="语义:"></a><strong>语义:</strong></h4><p><strong>不管怎么重排序</strong> ，程序在单线程情况下的运行结果不能改变。</p><p>编译器、runtime和处理器都必须遵守as-if-serial语 义。</p><p>为了遵守 as-if-serial ，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。</p><p>但是，如果操作之间不存在数据依赖关系，这些操作就可 能被编译器和处理器重排序。但这种重排序可能在多线程情况下引入问题</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><h4 id="程序顺序原则"><a href="#程序顺序原则" class="headerlink" title="程序顺序原则"></a>程序顺序原则</h4><p>　　即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p><h4 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则"></a>锁规则</h4><p>　　解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</p><h4 id="volatile规则"><a href="#volatile规则" class="headerlink" title="volatile规则"></a>volatile规则</h4><p>　　volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，<strong>都强迫从主内存中读该变量的 值</strong>，而<strong>当该变量发生变化时，又会强迫将最新的值刷新到主内存</strong>，任何时刻，不同的 线程总是能够看到该变量的最新值。</p><h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>　　线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>　　A先于B ，B先于C 那么A必然先于C</p><h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p>　　线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p>　　对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>　　对象的构造函数执行，结束先于finalize()方法 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，<code>Collection</code> 接口派生三个子接口 <code>List</code> <code>Set</code> <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240506003529811.png" alt="image-20240506003529811"></p><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>: 底层 Object 数组</li><li><code>Vector</code>: 底层 Object 数组</li><li><code>LinkedList</code>: 底层双向链表</li></ul></li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code> : 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆</li><li><code>DelayQueue</code>:&#96;PriorityQueue&#96;&#96;</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值<ul><li><code>HashMap</code>：数组 + 链表 + 红黑树</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-Array（数组）的区别"><a href="#ArrayList-和-Array（数组）的区别" class="headerlink" title="ArrayList 和 Array（数组）的区别"></a>ArrayList 和 Array（数组）的区别</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h2 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h2><h3 id="插入——add-："><a href="#插入——add-：" class="headerlink" title="插入——add()："></a>插入——add()：</h3><ul><li>头插：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾插：<ul><li>当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul></li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul><li><strong>头部删除</strong>：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li><strong>尾部删除</strong>：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li><strong>指定位置删除</strong>：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)</li></ul><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;</h2><p>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><p>ArrayList 的扩容是创建一个<strong>1.5 倍</strong>的新数组，然后把原数组的值拷贝过去。</p><h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>不推荐使用</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>写时复制技术，可以保障读写并发安全性</li></ul><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><ul><li>代理对象，额外创建mutex ，执行相关操作时，对mutex 加锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><h4 id="Queue-相关API"><a href="#Queue-相关API" class="headerlink" title="Queue 相关API"></a>Queue 相关API</h4><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><h4 id="Deque-相关API"><a href="#Deque-相关API" class="headerlink" title="Deque 相关API"></a>Deque 相关API</h4><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>此外，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-对比"><a href="#ArrayDeque-与-LinkedList-对比" class="headerlink" title="ArrayDeque 与 LinkedList 对比"></a>ArrayDeque 与 LinkedList 对比</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个<code>queue</code>的子接口。<code>BlockingQueue</code> 定义了阻塞式等待的插入和拿取操作（也可指定超时时间）</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制</li><li>读写&#x2F;生产消费 使用一把锁</li><li>提前分配内存，可能存在内存浪费，但是会快些</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>基于链表实现的阻塞队列</li><li>读写锁分离</li><li>无内存浪费，但是需要动态申请堆内存，会慢些</li></ul><h4 id="其他阻塞队列"><a href="#其他阻塞队列" class="headerlink" title="其他阻塞队列"></a>其他阻塞队列</h4><ul><li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p></li><li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p></li><li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的hash表，已不建议使用</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ul><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="&#x3D;&#x3D;HashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>&#x3D;&#x3D;<strong>数组 + 链表 + 红黑树</strong>&#x3D;&#x3D; （1.8 以后）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509021422847.png" alt="image-20240509021422847"></p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>默认长度： 16</li><li>最大长度： 2^30</li><li>负载因子： 0.75</li><li>链表树化阈值： 8</li><li>红黑树退化阈值： 6</li><li>链表树化时数组长度阈值： 64</li><li>node 数组扩容倍数： 2</li></ul><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509022413104.png" alt="image-20240509022413104"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><h4 id="常用的hash冲突解决办法"><a href="#常用的hash冲突解决办法" class="headerlink" title="常用的hash冲突解决办法"></a>常用的hash冲突解决办法</h4><ul><li>再哈希，直至找到空槽</li><li>开放地址法，寻找下一个空槽<ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数</li></ul></li><li>拉链法——也即JDK 1.8 HashMap 所采用方法</li></ul></li><li><h4 id="为什么-node-数组长度要是-2的幂次方"><a href="#为什么-node-数组长度要是-2的幂次方" class="headerlink" title="为什么 node 数组长度要是 2的幂次方"></a>为什么 node 数组长度要是 2的幂次方</h4><ul><li><strong>两点原因： 插入时定下标快，扩容时重新确定下标块</strong><ul><li>hash 过多，内存放不下，进而</li><li>一般通过 hash（或再映射）对数组长区域确定下标</li><li>而用 2的整数次幂为长度，余运算可以转为位运算，计算更快</li><li>此外，初始数组在没有把握的情况下，不宜设得过大，因此存在数组的后续扩容操作</li><li>以2的整数次幂为长度，且以 2 做扩容倍数时，可以方便的确定原数组链表内所有节点在扩容后的位置</li></ul></li></ul></li><li><h4 id="为什么选-0-75-为扩容因子"><a href="#为什么选-0-75-为扩容因子" class="headerlink" title="为什么选 0.75 为扩容因子"></a>为什么选 0.75 为扩容因子</h4></li><li><p>由加载因子的定义，其取值范围是 (0, 1]。</p></li><li><p>还有一个因素是为了提升扩容效率。因为<code>HashMap</code>的容量（<code>size</code>属性，构造函数中的<code>initialCapacity</code>变量）有一个要求：它一定是 2 的幂 （4,8,16，……）。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。</p></li><li><p>经验</p><ul><li>如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。</li><li>如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。</li></ul></li><li><h4 id="死循环问题"><a href="#死循环问题" class="headerlink" title="死循环问题"></a>死循环问题</h4><ul><li>1.8 之后改为尾插法不存在此问题， 1.7 及之前，头插法可能导致此问题</li></ul></li><li><h4 id="Hash-扰动"><a href="#Hash-扰动" class="headerlink" title="Hash 扰动"></a>Hash 扰动</h4><ul><li><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>一般数组长度可能不会太长，扰动后可使高16位也能参与下标计算，可在一定程度上缓解 hash 碰撞，使 key 分布更均衡</li><li>同时位运算消耗较低</li></ul></li><li><h4 id="为什么采用-红黑树-而不是-AVL-树"><a href="#为什么采用-红黑树-而不是-AVL-树" class="headerlink" title="为什么采用 红黑树 而不是 AVL 树"></a>为什么采用 红黑树 而不是 AVL 树</h4><ul><li><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p></li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>JDK1.7 的 采用 <strong>分段的数组+链表</strong> 实现， 每一个分段类似于一个子 Map ，一般也称 segment</li><li>JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，</li></ul><h3 id="实现线程安全的方式"><a href="#实现线程安全的方式" class="headerlink" title="&#x3D;&#x3D;实现线程安全的方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>实现线程安全的方式</strong>&#x3D;&#x3D;</h3><ul><li>JDK1.7 时，针对 segment 加锁</li><li>JDK 1.8 时数据结构跟 <code>HashMap</code> 1.8 的结构一样。并采用 <code>Node + CAS + synchronized</code> 来保证并发安全，同时降低了锁粒度，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</li><li>并发度层面 JDK 1.7 时最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap-中-key-和-value-不能为-null"><a href="#ConcurrentHashMap-中-key-和-value-不能为-null" class="headerlink" title="ConcurrentHashMap 中 key 和 value 不能为 null"></a>ConcurrentHashMap 中 key 和 value 不能为 null</h3><p><strong>原因</strong>： 主要是为了避免二义性。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-语言特点"><a href="#1-Java-语言特点" class="headerlink" title="1.    Java 语言特点"></a>1.    Java 语言特点</h2><ul><li><strong>面向对象</strong></li><li><strong>平台无关</strong></li><li><strong>支持多线程</strong><br>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li><li><strong>编译与解释并存</strong></li></ul><h2 id="2-JDK、JRE、JVM-关系"><a href="#2-JDK、JRE、JVM-关系" class="headerlink" title="2.    JDK、JRE、JVM 关系"></a>2.    JDK、JRE、JVM 关系</h2><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。</p><p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p><p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><h2 id="3-什么是字节码"><a href="#3-什么是字节码" class="headerlink" title="3.    什么是字节码"></a>3.    什么是字节码</h2><p>字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p>Java 跨平台特性其实就是为不同平台提供不同的 JVM，JVM 基于平台特性调整字节码解释实现，从而使得字节码在不同平台均可运行</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505211415926.png" alt="image-20240505211415926" style="zoom:67%;" /><h2 id="4-什么是面向对象"><a href="#4-什么是面向对象" class="headerlink" title="4.    什么是面向对象"></a>4.    什么是面向对象</h2><p><strong>面向对象是一种 相对面向过程 而言的编程范式</strong></p><p><strong>面向过程</strong>程序设计是具体化的，流程化的；面向过程的代码设计通过着手于事物的实现流程，根据已有条件如何一步一步生成结果。</p><p>因此，基于面向过程思路所涉及的代码通常不便于扩展和代码复用，此外，面向过程的思路在处理复杂问题时，编程难度将显著增加。</p><p>而<strong>面向对象</strong>程序设计是模型化的，把对象作为基本单位，将问题抽象建模为一系列对象之间的交互，使得程序易于理解、维护。具有相同行为和属性的对象泛化为类的实例。此外，面向对象具有三大特性——封装、继承与多态</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1    封装"></a>4.1    封装</h4><p><strong>概念</strong>：将一些属性和相关方法封装在一个对象中，对外隐藏内部实现细节。内部具体实现，外界不需要关心，而只需要根据”内部提供的接口“去使用就可以。</p><p><strong>好处</strong>：</p><ul><li><p>使用起来更加方便</p></li><li><p>保证数据的安全，针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改）</p></li><li><p>利于代码维护：如果后期功能实现逻辑需要调整，则保持接口名不变，修改实现代码即可，外界不需要做任何代码修改。</p></li></ul><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2    继承"></a>4.2    继承</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。</p><p>可提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p><h4 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3    多态"></a>4.3    多态</h4><p>同一个方法，在不同的对象上有不同的表现形式</p><p><strong>多态的要点：</strong></p><ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol><h2 id="5-访问权限"><a href="#5-访问权限" class="headerlink" title="5.    访问权限"></a>5.    访问权限</h2><ul><li><strong><code>default</code></strong> （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong><code>private</code></strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong><code>public</code></strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong><code>protected</code></strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="6-final-关键字"><a href="#6-final-关键字" class="headerlink" title="6.    final 关键字"></a>6.    final 关键字</h2><ul><li>当 <code>final</code> 修饰一个类时，表明这个类不能被继承。比如，<code>String</code> 类、<code>Integer</code> 类和其他包装类都是用 <code>final</code> 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（<code>@Override</code>）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 <code>final</code> 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。<ul><li>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；</li><li>如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。</li></ul></li></ul><h2 id="7-引用数据类型-、基本数据类型-与-包装类"><a href="#7-引用数据类型-、基本数据类型-与-包装类" class="headerlink" title="7.    引用数据类型 、基本数据类型 与 包装类"></a>7.    引用数据类型 、基本数据类型 与 包装类</h2><h4 id="7-1-引用数据类型"><a href="#7-1-引用数据类型" class="headerlink" title="7.1    引用数据类型"></a>7.1    引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="7-2-基本数据类型"><a href="#7-2-基本数据类型" class="headerlink" title="7.2    基本数据类型"></a>7.2    基本数据类型</h4><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1 比特</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h4 id="7-3-包装类"><a href="#7-3-包装类" class="headerlink" title="7.3    包装类"></a>7.3    包装类</h4><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，而几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h5 id="7-3-1-包装类常量池-缓存"><a href="#7-3-1-包装类常量池-缓存" class="headerlink" title="7.3.1    包装类常量池(缓存)"></a>7.3.1    包装类常量池(缓存)</h5><p>byte、int、long 类型 均缓存有 -128~127 的值在常量池中</p><p>char 缓存所有char</p><h2 id="8-Java-拷贝机制"><a href="#8-Java-拷贝机制" class="headerlink" title="8.    Java 拷贝机制"></a>8.    Java 拷贝机制</h2><ul><li><strong>浅拷贝</strong>：值类型拷贝，引用类型指向同一对象</li><li><strong>深拷贝</strong>：值类型拷贝，引用类型则拷贝了一个新对象，且引用类型内部按此规则递归</li></ul><h4 id="8-1-cloneable-接口与-clone"><a href="#8-1-cloneable-接口与-clone" class="headerlink" title="8.1    cloneable 接口与 clone()"></a>8.1    cloneable 接口与 clone()</h4><p><code>clone()</code> 默认浅拷贝， 且相应对象若未实现 <code>cloneable</code> 接口，会抛出异常</p><h4 id="8-2-如何实现-深拷贝"><a href="#8-2-如何实现-深拷贝" class="headerlink" title="8.2    如何实现 深拷贝"></a>8.2    如何实现 深拷贝</h4><ul><li>自定义拷贝构造函数（递归）</li><li>递归实现 <code>cloneable</code> 接口并重写 <code>clone()</code> 方法</li><li>序列化</li></ul><h2 id="9-String-相关"><a href="#9-String-相关" class="headerlink" title="9.    String 相关"></a>9.    String 相关</h2><h4 id="9-1-String、StringBuffer、StringBuilder"><a href="#9-1-String、StringBuffer、StringBuilder" class="headerlink" title="9.1    String、StringBuffer、StringBuilder"></a>9.1    String、StringBuffer、StringBuilder</h4><p><code>String</code> 是不可变的（自然线程安全）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，且 <code>StringBuffer</code> 对字符串的操作方法都添加了同步锁，因此性能安全，但同时影响了性能</p><h4 id="9-2-String-为什么不可变"><a href="#9-2-String-为什么不可变" class="headerlink" title="9.2    String 为什么不可变"></a>9.2    String 为什么不可变</h4><ul><li>String 类中 核心数组 被final修饰，此外，String 类中未提供修改 数组内元素的方法</li><li>String 类自身也是 final 的，可以避免子类提供数组修改方法</li></ul><h4 id="9-3-String-为什么要设计成不可变的"><a href="#9-3-String-为什么要设计成不可变的" class="headerlink" title="9.3    String 为什么要设计成不可变的"></a>9.3    String 为什么要设计成不可变的</h4><ul><li><strong>安全</strong> —— String 类型经常用来做参数，比如 url、pwd 之类的</li><li><strong>允许缓存 HashCode</strong> —— Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存</li><li><strong>字符串常量池需要</strong></li></ul><h2 id="10-Object"><a href="#10-Object" class="headerlink" title="10.    Object"></a>10.    Object</h2><h4 id="10-1-常用方法"><a href="#10-1-常用方法" class="headerlink" title="10.1    常用方法"></a>10.1    常用方法</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505224438372.png" alt="image-20240505224438372"></p><h4 id="10-2-和-equals"><a href="#10-2-和-equals" class="headerlink" title="10.2    &#x3D;&#x3D; 和 equals"></a>10.2    &#x3D;&#x3D; 和 equals</h4><ul><li>&#x3D;&#x3D; 判断值类型是否相等，引用类型是否指向同一对象</li><li><code>equals</code> 默认情况下与 &#x3D;&#x3D; 等价，重写后可能不等价</li></ul><h4 id="10-3-为什么重写-equals-时必须重写-hashCode-方法"><a href="#10-3-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="10.3    为什么重写 equals() 时必须重写 hashCode() 方法"></a>10.3    为什么重写 equals() 时必须重写 hashCode() 方法</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>导致 HashMap 可能存入两个逻辑相等的对象</p><h2 id="11-序列化、反序列化"><a href="#11-序列化、反序列化" class="headerlink" title="11.    序列化、反序列化"></a>11.    序列化、反序列化</h2><h4 id="11-1-什么是序列化、反序列化"><a href="#11-1-什么是序列化、反序列化" class="headerlink" title="11.1    什么是序列化、反序列化"></a>11.1    什么是序列化、反序列化</h4><ul><li>序列化：把 Java 对象转换为字节序列的过程</li><li>反序列：把字节序列恢复为 Java 对象的过程</li></ul><h4 id="11-2-注意点"><a href="#11-2-注意点" class="headerlink" title="11.2    注意点"></a>11.2    注意点</h4><ul><li>static 静态变量和 transient 修饰的字段是不会被序列化的</li><li>serialVersionUID问题</li><li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li><li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li></ul><h4 id="11-3-不推荐使用-JDK-自带的序列化"><a href="#11-3-不推荐使用-JDK-自带的序列化" class="headerlink" title="11.3    不推荐使用 JDK 自带的序列化"></a>11.3    不推荐使用 JDK 自带的序列化</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.    异常"></a>12.    异常</h2><h4 id="12-1-异常层级"><a href="#12-1-异常层级" class="headerlink" title="12.1    异常层级"></a>12.1    异常层级</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505230455539.png" alt="image-20240505230455539"></p><ul><li>**<code>Throwable</code>**：是 java 中所有异常和错误的超类,其两个子类为 <strong><code>Error</code></strong>(错误) 和 <strong><code>Exception</code></strong>(异常)<ul><li><strong>Error</strong>： 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</li><li>**<code>Exception</code>**： 是程序本身可以捕获并且可以处理的异常。其中可分为运行时异常（RuntimeException）和非运行时异常，也叫做受检异常<ul><li>**运行时异常(不受检异常)**： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li><li>**非运行时异常(受检异常)**： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</li></ul></li></ul></li></ul><h4 id="12-1-try-with-finally"><a href="#12-1-try-with-finally" class="headerlink" title="12.1    try - with - finally"></a>12.1    try - with - finally</h4><ul><li><p>无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p></li><li><p>不要在 finally 语句块中使用 return， 因为当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略</p></li><li><p>finally 语句在 线程被杀死、JVM 关闭等情况时也不一定会执行</p></li><li><p>对必须关闭的资源，推荐使用 <code>try with resources</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注解"><a href="#13-注解" class="headerlink" title="13.    注解"></a>13.    注解</h2><h4 id="13-1-注解作用"><a href="#13-1-注解作用" class="headerlink" title="13.1    注解作用"></a>13.1    注解作用</h4><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，并可添加根据注解内容而执行的特定逻辑。</p><h4 id="13-2-注解类型"><a href="#13-2-注解类型" class="headerlink" title="13.2    注解类型"></a>13.2    注解类型</h4><ul><li><p>元注解</p><ul><li>@Retention</li><li>@Documented</li><li>@Target</li><li>@Inherited</li><li>@Repeatable</li></ul></li><li><p>内置普通注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SupressWarnings</li><li>@SafeVarargs</li></ul></li><li><p>自定义注解</p></li></ul><h4 id="13-3-其他"><a href="#13-3-其他" class="headerlink" title="13.3    其他"></a>13.3    其他</h4><ul><li>注解也是一个类，可以添加属性，并设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Coder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GRQ&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">language</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">company</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;China_Company&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
