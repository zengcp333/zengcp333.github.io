<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/02/27/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/ShardingSphere%20%E5%88%86%E6%9E%90/"/>
      <url>/2025/02/27/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/ShardingSphere%20%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="ShardingSphere"><a href="#ShardingSphere" class="headerlink" title="ShardingSphere"></a>ShardingSphere</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的<strong>生态圈</strong>，它由<strong>Sharding-JDBC</strong>、<strong>Sharding-Proxy</strong>和<strong>Sharding-Sidecar</strong>（计划中）这3款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景。</p><p>ShardingSphere 定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。 它与NoSQL和NewSQL是并存而非互斥的关系。NoSQL和NewSQL作为新技术探索的前沿，放眼未来，拥抱变化，是非常值得推荐的。反之，也可以用另一种思路看待问题，放眼未来，关注不变的东西，进而抓住事物本质。 关系型数据库当今依然占有巨大市场，是各个公司核心业务的基石，未来也难于撼动，我们目前阶段更加关注在原有基础上的增量，而非颠覆。</p><p>ShardingSphere已经在2020年4月16日从Apache孵化器毕业，成为Apache顶级项目。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/shardingsphere-scope_cn.png" alt="ShardingSphere Scope" style="zoom:60%;" /><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding-JDBC"></a>Sharding-JDBC</h3><p>定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p><ul><li>适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。</li><li>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。</li><li>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/sharding-jdbc-brief.png" alt="Sharding-JDBC Architecture" style="zoom:60%;" /><h3 id="Sharding-Proxy"><a href="#Sharding-Proxy" class="headerlink" title="Sharding-Proxy"></a>Sharding-Proxy</h3><p>定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前先提供MySQL&#x2F;PostgreSQL版本，它可以使用任何兼容MySQL&#x2F;PostgreSQL协议的访问客户端(如：MySQL Command Client, MySQL Workbench, Navicat等)操作数据，对DBA更加友好。</p><ul><li>向应用程序完全透明，可直接当做MySQL&#x2F;PostgreSQL使用。</li><li>适用于任何兼容MySQL&#x2F;PostgreSQL协议的的客户端。</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/sharding-proxy-brief_v2.png" alt="Sharding-Proxy Architecture" style="zoom: 38%;" /><h3 id="Sharding-Sidecar（TODO）"><a href="#Sharding-Sidecar（TODO）" class="headerlink" title="Sharding-Sidecar（TODO）"></a>Sharding-Sidecar（TODO）</h3><p>定位为Kubernetes的云原生数据库代理，以Sidecar的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即Database Mesh，又可称数据网格。</p><p>Database Mesh的关注重点在于如何将分布式的数据访问应用与数据库有机串联起来，它更加关注的是交互，是将杂乱无章的应用与数据库之间的交互有效的梳理。使用Database Mesh，访问数据库的应用和数据库终将形成一个巨大的网格体系，应用和数据库只需在网格体系中对号入座即可，它们都是被啮合层所治理的对象。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/sharding-sidecar-brief_v2.png" alt="Sharding-Sidecar Architecture" style="zoom:60%;" /><table><thead><tr><th align="left"></th><th align="left"><em>Sharding-JDBC</em></th><th align="left"><em>Sharding-Proxy</em></th><th align="left"><em>Sharding-Sidecar</em></th></tr></thead><tbody><tr><td align="left">数据库</td><td align="left">任意</td><td align="left">MySQL</td><td align="left">MySQL</td></tr><tr><td align="left">连接消耗数</td><td align="left">高</td><td align="left">低</td><td align="left">高</td></tr><tr><td align="left">异构语言</td><td align="left">仅Java</td><td align="left">任意</td><td align="left">任意</td></tr><tr><td align="left">性能</td><td align="left">损耗低</td><td align="left">损耗略高</td><td align="left">损耗低</td></tr><tr><td align="left">无中心化</td><td align="left">是</td><td align="left">否</td><td align="left">是</td></tr><tr><td align="left">静态入口</td><td align="left">无</td><td align="left">有</td><td align="left">无</td></tr></tbody></table><h3 id="混合架构"><a href="#混合架构" class="headerlink" title="混合架构"></a>混合架构</h3><p>Sharding-JDBC采用无中心化架构，适用于Java开发的高性能的轻量级OLTP应用；Sharding-Proxy提供静态入口以及异构语言的支持，适用于OLAP应用以及对分片数据库进行管理和运维的场景。</p><p>ShardingSphere是多接入端共同组成的生态圈。 通过混合使用Sharding-JDBC和Sharding-Proxy，并采用同一注册中心统一配置分片策略，能够灵活的搭建适用于各种场景的应用系统，架构师可以更加自由的调整适合于当前业务的最佳系统架构。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/shardingsphere-hybrid.png" alt="ShardingSphere Hybrid Architecture" style="zoom:58%;" /><h2 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h2><h3 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h3><ul><li>分库 &amp; 分表</li><li>读写分离</li><li>分片策略定制化</li><li>无中心化分布式主键</li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><ul><li>标准化事务接口</li><li>XA强一致事务</li><li>柔性事务</li></ul><h3 id="数据库治理"><a href="#数据库治理" class="headerlink" title="数据库治理"></a>数据库治理</h3><ul><li>配置动态化</li><li>编排 &amp; 治理</li><li>数据脱敏</li><li>可视化链路追踪</li><li>弹性伸缩(规划中)</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/02/26/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/02/26/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="MySQL-分库分表详解"><a href="#MySQL-分库分表详解" class="headerlink" title="MySQL 分库分表详解"></a>MySQL 分库分表详解</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h2><p>在互联网还未崛起的时代,我们的传统应用都有这样一个特点：访问量、数据量都比较小，单库单表都完全可以支撑整个业务。随着互联网的发展和用户规模的迅速扩大,对系统的要求也越来越高。因此传统的MySQL单库单表架构的性能问题就暴露出来了。而有下面几个因素会影响数据库性能:</p><h3 id="1-1-数据量"><a href="#1-1-数据量" class="headerlink" title="1.1 数据量"></a><strong>1.1 数据量</strong></h3><p>MySQL单库数据量在5000万以内性能比较好,超过阈值后性能会随着数据量的增大而变弱。MySQL单表数据量是500w-1000w之间性能比较好,超过1000w性能也会下降。</p><h3 id="1-2-磁盘"><a href="#1-2-磁盘" class="headerlink" title="1.2 磁盘"></a><strong>1.2 磁盘</strong></h3><p>因为单个服务的磁盘空间是有限制的,如果并发压力下,所有的请求都访问同一个节点,肯定会对磁盘IO造成非常大的影响。</p><h3 id="1-3-数据库连接"><a href="#1-3-数据库连接" class="headerlink" title="1.3 数据库连接"></a><strong>1.3 数据库连接</strong></h3><p>数据库连接是非常稀少的资源,如果一个库里既有用户、商品、订单相关的数据,当海量用户同时操作时,数据库连接就很可能成为瓶颈。</p><p>为了提升性能,所以我们必须要解决上述几个问题,那就有必要引进<strong>分库分表</strong>。</p><h2 id="二、垂直拆分-or-水平拆分？"><a href="#二、垂直拆分-or-水平拆分？" class="headerlink" title="二、垂直拆分 or 水平拆分？"></a><strong>二、垂直拆分 or 水平拆分？</strong></h2><p>关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。此时就要考虑对其进行切分了，切分的目的就在于减少数据库的负担，缩短查询时间。</p><p>数据库分布式核心内容无非就是<strong>数据切分（Sharding）</strong>，以及切分后对数据的定位、整合。数据切分就是将数据分散存储到多个数据库中，使得单一数据库中的数据量变小，通过扩充主机的数量缓解单一数据库的性能问题，从而达到提升数据库操作性能的目的。</p><p>数据切分根据其切分类型，可以分为两种方式：<strong>垂直（纵向）切分</strong>和<strong>水平（横向）切分</strong></p><p>当我们单个库太大时,我们先要看一下是因为表太多还是数据量太大，如果是<strong>表太多</strong>,则应该将部分表进行迁移(可以按业务区分),这就是所谓的<strong>垂直切分</strong>。如果是<strong>数据量太大</strong>,则需要将表拆成更多的小表,来减少单表的数据量,这就是所谓的<strong>水平拆分</strong>。</p><h2 id="三、垂直拆分"><a href="#三、垂直拆分" class="headerlink" title="三、垂直拆分"></a><strong>三、垂直拆分</strong></h2><p>垂直切分常见有<strong>垂直分库</strong>和<strong>垂直分表</strong>两种。</p><h3 id="3-1-垂直分库"><a href="#3-1-垂直分库" class="headerlink" title="3.1 垂直分库"></a><strong>3.1 垂直分库</strong></h3><p>垂直分库针对的是一个系统中的不同业务进行拆分,比如用户一个库,商品一个库,订单一个库。 一个购物网站对外提供服务时,会同时对用户、商品、订单表进行操作。没拆分之前, 全部都是落到单一的库上的,这会让数据库的单库处理能力成为瓶颈。如果垂直分库后还是将用户、商品、订单放到同一个服务器上,只是分到了不同的库,这样虽然会减少单库的压力,但是随着用户量增大,这会让整个数据库的处理能力成为瓶颈,还有单个服务器的磁盘空间、内存也会受非常大的影响。 所以我们要将其拆分到多个服务器上，这样上面的问题都解决了，以后也不会面对单机资源问题。这种做法与”微服务治理”的做法相似，每个微服务使用单独的一个数据库。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/ed6b4d93e5250a6e1268702c1e6cb5a4.jpeg" alt="img"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="3-2-垂直分表"><a href="#3-2-垂直分表" class="headerlink" title="3.2 垂直分表"></a><strong>3.2 垂直分表</strong></h3><p>也就是“大表拆小表”，<strong>基于列字段</strong>进行的。一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的字段数据拆分到“扩展表“。一般是针对那种几百列的大表，也避免查询时，数据量太大造成的<strong>“跨页”问题</strong>。MySQL底层是通过<strong>数据页</strong>存储的，一条记录占用空间过大会导致跨页（<strong>页溢出</strong>），造成额外的性能开销（IO操作变多）。另外数据库以页为单位将数据加载到内存中，而页中存储的是行数据，页大小固定，一行数据占用空间越小，页中存储的行数据就越多。这样表中字段长度较短且访问频率较高，内存能加载更多的数据，内存命中率更高，减少了磁盘IO，从而提升了数据库性能。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/df31bea40a5ca7305b0332643c92323c.jpeg" alt="img" style="zoom: 60%;" /><h3 id="3-3-垂直拆分的优缺点"><a href="#3-3-垂直拆分的优缺点" class="headerlink" title="3.3 垂直拆分的优缺点"></a><strong>3.3 垂直拆分的优缺点</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul><li><strong>解决业务系统层面的耦合，业务清晰</strong></li><li><strong>与微服务的治理类似，也能对不同业务的数据进行分级管理、维护、监控、扩展等</strong></li><li><strong>高并发场景下，垂直切分一定程度的提升IO、数据库连接数、单机硬件资源的瓶颈</strong></li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul><li><strong>部分表无法join，只能通过接口聚合方式解决，提升了开发的复杂度</strong></li><li><strong>单机的ACID被打破，需要引入分布式事务，而分布式事务处理复杂</strong></li><li><strong>依然存在单表数据量过大的问题（需要水平切分）</strong></li><li><strong>靠外键去进行约束的场景会受到影响</strong></li></ul><h2 id="四、水平拆分"><a href="#四、水平拆分" class="headerlink" title="四、水平拆分"></a><strong>四、水平拆分</strong></h2><p>当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平切分了。</p><p>水平切分分为<strong>库内分表</strong>和<strong>分库分表</strong>，是根据表内数据内在的逻辑关系，将同一个表按不同的条件分散到多个数据库或多个表中，每个表中只包含一部分数据，从而使得单个表的数据量变小，达到分布式的效果。如图所示：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/beeff42c447f15d3961f412777bd5cff.jpeg" alt="img"></p><h3 id="4-1-水平分表"><a href="#4-1-水平分表" class="headerlink" title="4.1 水平分表"></a><strong>4.1 水平分表</strong></h3><p>和垂直分表有一点类似,不过垂直分表是基于列的,而水平分表是基于全表的。水平拆分可以大大减少单表数据量,提升查询效率。这里的水平分表指的是在一个数据库进行的<strong>库内分表</strong>。</p><p>库内分表只解决了单一表数据量过大的问题，但没有将表分布到不同机器的库上，因此对于减轻MySQL数据库的压力来说，帮助不是很大，大家还是竞争同一个物理机的CPU、内存、网络IO，最好通过分库分表来解决。</p><h3 id="4-2-水平分库分表"><a href="#4-2-水平分库分表" class="headerlink" title="4.2 水平分库分表"></a><strong>4.2 水平分库分表</strong></h3><p>将单张表的数据切分到多个服务器上去，每个服务器具有相同的库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源等的瓶颈。</p><h3 id="4-3-水平拆分的优缺点"><a href="#4-3-水平拆分的优缺点" class="headerlink" title="4.3 水平拆分的优缺点"></a><strong>4.3 水平拆分的优缺点</strong></h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul><li><strong>不存在单库数据量过大、高并发的性能瓶颈，提升系统稳定性和负载能力</strong></li><li><strong>应用端改造较小，不需要拆分业务模块</strong></li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul><li><strong>ACID被打破，跨分片的事务一致性难以保证</strong></li><li><strong>跨库的 join 关联查询性能较差</strong></li><li><strong>数据多次扩展难度和维护量极大</strong></li><li><strong>靠外键去进行约束的场景会受到影响</strong> </li><li><strong>依赖单库的自增 ID 会受到影响</strong></li></ul><h2 id="五、几种常用的分库分表的策略"><a href="#五、几种常用的分库分表的策略" class="headerlink" title="五、几种常用的分库分表的策略"></a><strong>五、几种常用的分库分表的策略</strong></h2><h3 id="5-1-根据数值范围"><a href="#5-1-根据数值范围" class="headerlink" title="5.1 根据数值范围"></a><strong>5.1 根据数值范围</strong></h3><p>按照时间区间或ID区间来切分。例如：按日期将不同月甚至是日的数据分散到不同的库中；将userId在 (1, 9999) 中的记录分到第一个库，（10000， 20000） 的分到第二个库，以此类推。某种意义上，某些系统中使用的“冷热数据分离“，将一些使用较少的历史数据迁移到其他库中，业务功能上只提供热点数据的查询，也是类似的实践。</p><p>这样的优点在于：</p><ul><li>单表大小可控</li><li>天然便于水平扩展，后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移</li><li>使用分片字段进行范围查找时，连续分片可快速定位分片进行快速查询，有效避免跨分片查询的问题。</li></ul><p>缺点：</p><ul><li><strong>热点数据</strong>成为性能瓶颈。连续分片可能存在数据热点，例如按时间字段分片，有些分片存储最近时间段内的数据，可能会被频繁的读写，而有些分片存储的历史数据，则很少被查询</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/a10468c14bdefe0392dc08ba8d794225.jpeg" alt="img" style="zoom:60%;" /><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><h3 id="5-2-根据数值取模"><a href="#5-2-根据数值取模" class="headerlink" title="5.2 根据数值取模"></a><strong>5.2 根据数值取模</strong></h3><p>一般采用hash取模mod的切分方式，例如：将 Customer 表根据 cusno 字段切分到4个库中，余数为0的放到第一个库，余数为1的放到第二个库，以此类推。这样同一个用户的数据会分散到同一个库中，如果查询条件带有cusno字段，则可明确定位到相应库去查询。再比如说有用户表user,将其分成3个表user0,user1,user2.路由规则是对3取模,当uid&#x3D;1时,对应到的是user1,uid&#x3D;2时,对应的是user2.</p><p>优点：</p><ul><li>数据分片相对比较均匀，不容易出现热点和并发访问的瓶颈</li></ul><p>缺点：</p><ul><li>后期分片集群扩容时，需要迁移旧的数据（使用<strong>一致性hash算法</strong>能较好的避免这个问题），否则会导致历史数据失效。</li><li>容易面临跨分片查询的复杂问题。比如上例中，如果频繁用到的查询条件中不带cusno时，将会导致无法定位数据库，从而需要同时向4个库发起查询，再在内存中合并数据，取最小集返回给应用，分库反而成为拖累。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/c0a496a154fa4dec70babf78b0a5e00b.jpeg" alt="img"></p><h3 id="5-3-根据地理位置"><a href="#5-3-根据地理位置" class="headerlink" title="5.3 根据地理位置"></a><strong>5.3 根据地理位置</strong></h3><p>根据地理位置，将相同地区的放到一张表中，比如华南区一个表,华北一个表。</p><h2 id="六、分库分表后带来的问题"><a href="#六、分库分表后带来的问题" class="headerlink" title="六、分库分表后带来的问题"></a><strong>六、分库分表后带来的问题</strong></h2><p>分库分表能有效的缓解单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题。下面将描述这些技术挑战以及对应的解决思路。 </p><h3 id="6-1-事务一致性问题"><a href="#6-1-事务一致性问题" class="headerlink" title="6.1 事务一致性问题"></a><strong>6.1 事务一致性问题</strong></h3><h4 id="6-1-1-分布式事务"><a href="#6-1-1-分布式事务" class="headerlink" title="6.1.1 分布式事务"></a><strong>6.1.1 分布式事务</strong></h4><p>当更新内容同时分布在不同库中，不可避免会带来跨库事务问题。跨分片事务也是分布式事务，没有简单的方案，一般可使用“XA协议“和“两阶段提交“处理。</p><p>分布式事务的几种解决方案：</p><ol><li>使用分布式事务中间件</li><li>使用MySQL自带的针对跨库的事务一致性方案(XA),不过性能要比单库的慢10倍左右。</li><li>能否避免掉跨库操作(比如将用户和商品放在同一个库中)</li></ol><p>分布式事务能最大限度保证了数据库操作的原子性。但在提交事务时需要协调多个节点，推后了提交事务的时间点，延长了事务的执行时间。导致事务在访问共享资源时发生冲突或死锁的概率增高。随着数据库节点的增多，这种趋势会越来越严重，从而成为系统在数据库层面上水平扩展的枷锁。</p><h4 id="6-1-2-最终一致性"><a href="#6-1-2-最终一致性" class="headerlink" title="6.1.2 最终一致性"></a><strong>6.1.2 最终一致性</strong></h4><p>对于那些性能要求很高，但对一致性要求不高的系统，往往不苛求系统的实时一致性，只要在允许的时间段内达到最终一致性即可，可采用事务补偿的方式。与事务在执行中发生错误后立即回滚的方式不同，<strong>事务补偿</strong>是一种事后检查补救的措施，一些常见的实现方法有：对数据进行对账检查，基于日志进行对比，定期同标准数据来源进行同步等等。事务补偿还要结合业务系统来考虑。</p><h3 id="6-2-跨节点关联查询-join-问题"><a href="#6-2-跨节点关联查询-join-问题" class="headerlink" title="6.2 跨节点关联查询 join 问题"></a><strong>6.2 跨节点关联查询 join 问题</strong></h3><p>切分之前，系统中很多列表和详情页所需的数据可以通过sql join来完成。而切分之后，数据可能分布在不同的节点上，此时join带来的问题就比较麻烦了，考虑到性能，尽量避免使用join查询。</p><p>解决这个问题的一些方法：</p><h4 id="6-2-1-全局表"><a href="#6-2-1-全局表" class="headerlink" title="6.2.1 全局表"></a><strong>6.2.1 全局表</strong></h4><p>全局表，也可看做是“数据字典表“，就是系统中所有模块都可能依赖的一些表，为了避免跨库join查询，可以将这类表在每个数据库中都保存一份。这些数据通常很少会进行修改，所以也不担心一致性的问题。</p><h4 id="6-2-2-字段冗余"><a href="#6-2-2-字段冗余" class="headerlink" title="6.2.2 字段冗余"></a><strong>6.2.2 字段冗余</strong></h4><p>一种典型的反范式设计，利用空间换时间，为了性能而避免 join 查询。例如：订单表保存 userId 时候，也将 userName 冗余保存一份，这样查询订单详情时就不需要再去查询“买家user表“了。</p><p>但这种方法适用场景也有限，比较适用于依赖字段比较少的情况。而冗余字段的数据一致性也较难保证，就像上面订单表的例子，买家修改了userName后，是否需要在历史订单中同步更新呢？这也要结合实际业务场景进行考虑。</p><h4 id="6-2-3-数据组装"><a href="#6-2-3-数据组装" class="headerlink" title="6.2.3 数据组装"></a><strong>6.2.3 数据组装</strong></h4><p>在系统层面，分两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据。最后将获得到的数据进行字段拼装。</p><h4 id="6-2-4-ER分片"><a href="#6-2-4-ER分片" class="headerlink" title="6.2.4 ER分片"></a><strong>6.2.4 ER分片</strong></h4><p>关系型数据库中，如果可以先确定表之间的关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能较好的避免跨分片join问题。在1:1或1:n的情况下，通常按照主表的ID主键切分。如下图所示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/f9fb4305b5496422fac3a26d71d3987b.jpeg" alt="img" style="zoom:67%;" /><p>这样一来，Data Node1上面的order订单表与orderdetail订单详情表就可以通过orderId进行局部的关联查询了，Data Node2上也一样。</p><h3 id="6-3-跨节点分页、排序、函数问题"><a href="#6-3-跨节点分页、排序、函数问题" class="headerlink" title="6.3 跨节点分页、排序、函数问题"></a><strong>6.3 跨节点分页、排序、函数问题</strong></h3><p>跨节点多库进行查询时，会出现limit分页、order by排序等问题。分页需要按照指定字段进行排序，当排序字段就是分片字段时，通过分片规则就比较容易定位到指定的分片；当排序字段非分片字段时，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序，最终返回给用户。如图所示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/0d892ebded66056a9eb3f74c5652aec7.jpeg" alt="img" style="zoom:67%;" /><p>上图中只是取第一页的数据，对性能影响还不是很大。但是如果取得页数很大，情况则变得复杂很多，因为各分片节点中的数据可能是随机的，为了排序的准确性，需要将所有节点的前N页数据都排序好做合并，最后再进行整体的排序，这样的操作时很耗费CPU和内存资源的，所以页数越大，系统的性能也会越差。</p><p>在使用Max、Min、Sum、Count之类的函数进行计算的时候，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。如图所示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/19ad7a2499557729a50cc923d1e565fe.jpeg" alt="img" style="zoom:67%;" /><p>总之<strong>，</strong>因为我们是将数据分散存储到不同的库、表里的,当我们查询指定数据列表时,数据来源于不同的子库或者子表,就必然会引发结果集合并、排序的问题。如果每次查询都需要排序、合并等操作,性能肯定会受非常大的影响。走缓存是一种解决方案。</p><h3 id="6-4-全局主键避重问题"><a href="#6-4-全局主键避重问题" class="headerlink" title="6.4 全局主键避重问题"></a><strong>6.4 全局主键避重问题</strong></h3><p>参考 [分布式ID方案 | ZengCP’s BLOGS](<a href="https://zengcp333.github.io/2024/11/24/%E5%88%86%E5%B8%83%E5%BC%8F">https://zengcp333.github.io/2024/11/24/分布式</a> 与 服务治理&#x2F;分布式ID&#x2F;)</p><h3 id="6-5-数据迁移、扩容问题"><a href="#6-5-数据迁移、扩容问题" class="headerlink" title="6.5 数据迁移、扩容问题"></a><strong>6.5 数据迁移、扩容问题</strong></h3><p>当业务高速发展，面临性能和存储的瓶颈时，才会考虑分片设计，此时就不可避免的需要考虑历史数据迁移的问题。一般做法是先读出历史数据，然后按指定的分片规则再将数据写入到各个分片节点中。此外还需要根据当前的数据量和QPS，以及业务发展的速度，进行容量规划，推算出大概需要多少分片（一般建议单个分片上的单表数据量不超过1000W）</p><p>如果采用数值范围分片，只需要添加节点就可以进行扩容了，不需要对分片数据迁移。如果采用的是数值取模分片，针对数据量的递增,可能需要动态的增加表，此时因为reHash有可能导致数据迁移问题，则考虑后期的扩容问题就相对比较麻烦。</p><h3 id="6-6-外键约束问题"><a href="#6-6-外键约束问题" class="headerlink" title="6.6 外键约束问题"></a><strong>6.6 外键约束问题</strong></h3><p>外键约束问题比较难解决，不能完全依赖数据库本身来完成之前的功能。如果需要对分库后的单表做外键约束，就需要分库后每个单库的数据是内聚的，否则就只能靠应用层的判断，容错方式了。</p><h2 id="七-什么时候考虑切分"><a href="#七-什么时候考虑切分" class="headerlink" title="七. 什么时候考虑切分"></a><strong>七. 什么时候考虑切分</strong></h2><p>下面讲述一下什么时候需要考虑做数据切分。</p><h3 id="7-1-能不切分尽量不要切分"><a href="#7-1-能不切分尽量不要切分" class="headerlink" title="7.1 能不切分尽量不要切分"></a><strong>7.1 能不切分尽量不要切分</strong></h3><p>并不是所有表都需要进行切分，主要还是看数据的增长速度。切分后会在某种程度上提升业务的复杂度，数据库除了承载数据的存储和查询外，协助业务更好的实现需求也是其重要工作之一。</p><p>不到万不得已不用轻易使用分库分表这个大招，避免“过度设计“和“过早优化“。分库分表之前，不要为分而分，先尽力去做力所能及的事情，例如：升级硬件、升级网络、读写分离、索引优化等等。当数据量达到单表的瓶颈时候，再考虑分库分表。</p><h3 id="7-2-数据量过大，正常运维影响业务访问"><a href="#7-2-数据量过大，正常运维影响业务访问" class="headerlink" title="7.2 数据量过大，正常运维影响业务访问"></a><strong>7.2 数据量过大，正常运维影响业务访问</strong></h3><p>这里说的运维，指：</p><ol><li>对<a href="https://cloud.tencent.com/product/dbs?from_column=20065&from=20065">数据库备份</a>，如果单表太大，备份时需要大量的磁盘IO和网络IO。例如1T的数据，网络传输占50MB时候，需要20000秒才能传输完毕，整个过程的风险都是比较高的</li><li>对一个很大的表进行DDL修改时，MySQL会锁住全表，这个时间会很长，这段时间业务不能访问此表，影响很大。如果使用pt-online-schema-change，使用过程中会创建触发器和影子表，也需要很长的时间。在此操作过程中，都算为风险时间。将数据表拆分，总量减少，有助于降低这个风险。</li><li>大表会经常访问与更新，就更有可能出现锁等待。将数据切分，用空间换时间，变相降低访问压力</li></ol><h3 id="7-3-随着业务发展，需要对某些字段垂直拆分"><a href="#7-3-随着业务发展，需要对某些字段垂直拆分" class="headerlink" title="7.3 随着业务发展，需要对某些字段垂直拆分"></a><strong>7.3 随着业务发展，需要对某些字段垂直拆分</strong></h3><p>举个例子，假如项目一开始设计的用户表如下：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>复制</p><p>Cloud Studio代码运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id                   bigint             #用户的<span class="variable constant_">ID</span></span><br><span class="line">name                 varchar            #用户的名字</span><br><span class="line">last_login_time      datetime           #最近登录时间</span><br><span class="line">personal_info        text               #私人信息</span><br><span class="line">.....                                   #其他信息字段</span><br></pre></td></tr></table></figure><p>在项目初始阶段，这种设计是满足简单的业务需求的，也方便快速迭代开发。而当业务快速发展时，用户量从10w激增到10亿，用户非常的活跃，每次登录会更新 last_login_name 字段，使得 user 表被不断update，压力很大。而其他字段：id, name, personal_info 是不变的或很少更新的，此时在业务角度，就要将 last_login_time 拆分出去，新建一个 user_time 表。</p><p>personal_info 属性是更新和查询频率较低的，并且text字段占据了太多的空间。这时候，就要对此垂直拆分出 user_ext 表了。</p><h3 id="7-4-数据量快速增长"><a href="#7-4-数据量快速增长" class="headerlink" title="7.4 数据量快速增长"></a><strong>7.4 数据量快速增长</strong></h3><p>随着业务的快速发展，单表中的数据量会持续增长，当性能接近瓶颈时，就需要考虑水平切分，做分库分表了。此时一定要选择合适的切分规则，提前预估好数据容量</p><h3 id="7-5-安全性和可用性"><a href="#7-5-安全性和可用性" class="headerlink" title="7.5 安全性和可用性"></a><strong>7.5 安全性和可用性</strong></h3><p>鸡蛋不要放在一个篮子里。在业务层面上垂直切分，将不相关的业务的数据库分隔，因为每个业务的数据量、访问量都不同，不能因为一个业务把数据库搞挂而牵连到其他业务。利用垂直切分，一个数据库出现问题，只会影响到部分业务，不会使所有的业务都瘫痪。利用水平切分，当一个数据库出现问题时，不会影响到100%的用户，每个库只承担业务的一部分数据，这样整体的可用性就能提高。</p><h2 id="八、案例分析"><a href="#八、案例分析" class="headerlink" title="八、案例分析"></a><strong>八、案例分析</strong></h2><h3 id="8-1-用户中心业务场景"><a href="#8-1-用户中心业务场景" class="headerlink" title="8.1 用户中心业务场景"></a><strong>8.1 用户中心业务场景</strong></h3><p>用户中心是一个非常常见的业务，主要提供用户注册、登录、查询&#x2F;修改等功能，其核心表为：</p><p>代码语言：javascript</p><p>代码运行次数：0</p><p>复制</p><p>Cloud Studio代码运行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">User</span>(uid, login_name, passwd, sex, age, nickname)</span><br><span class="line">uid为用户<span class="variable constant_">ID</span>,  主键</span><br><span class="line">login_name, passwd, sex, age, nickname,  用户属性</span><br></pre></td></tr></table></figure><p>任何脱离业务的架构设计都是耍流氓，在进行分库分表前，需要对业务场景需求进行梳理：</p><ul><li>用户侧：前台访问，访问量较大，需要保证高可用和高一致性。主要有两类需求： <ul><li>用户登录：通过login_name&#x2F;phone&#x2F;email查询用户信息，1%请求属于这种类型</li><li>用户信息查询：登录之后，通过uid来查询用户信息，99%请求属这种类型</li></ul></li><li>运营侧：后台访问，支持运营需求，按照年龄、性别、登陆时间、注册时间等进行分页的查询。是内部系统，访问量较低，对可用性、一致性的要求不高。</li></ul><h3 id="8-2-水平切分方法"><a href="#8-2-水平切分方法" class="headerlink" title="8.2 水平切分方法"></a><strong>8.2 水平切分方法</strong></h3><p>当数据量越来越大时，需要对数据库进行水平切分，上文描述的切分方法有”根据数值范围”和”根据数值取模”。</p><p>“根据数值范围“：以主键uid为划分依据，按uid的范围将数据水平切分到多个数据库上。例如：user-db1存储uid范围为0<del>1000w的数据，user-db2存储uid范围为1000w</del>2000wuid数据。</p><ul><li>优点是：扩容简单，如果容量不够，只要增加新db即可。</li><li>不足是：请求量不均匀，一般新注册的用户活跃度会比较高，所以新的user-db2会比user-db1负载高，导致服务器利用率不平衡</li></ul><p>“根据数值取模“：也是以主键uid为划分依据，按uid取模的值将数据水平切分到多个数据库上。例如：user-db1存储uid取模得1的数据，user-db2存储uid取模得0的uid数据。</p><ul><li>优点是：数据量和请求量分布均均匀</li><li>不足是：扩容麻烦，当容量不够时，新增加db，需要rehash。需要考虑对数据进行平滑的迁移。</li></ul><h3 id="8-3-非uid的查询方法"><a href="#8-3-非uid的查询方法" class="headerlink" title="8.3 非uid的查询方法"></a><strong>8.3 非uid的查询方法</strong></h3><p>水平切分后，对于按uid查询的需求能很好的满足，可以直接路由到具体数据库。而按非uid的查询，例如login_name，就不知道具体该访问哪个库了，此时需要遍历所有库，性能会降低很多。</p><p>对于用户侧，可以采用“建立非uid属性到uid的映射关系“的方案；对于运营侧，可以采用“前台与后台分离“的方案。</p><h4 id="8-3-1-建立非uid属性到uid的映射关系"><a href="#8-3-1-建立非uid属性到uid的映射关系" class="headerlink" title="8.3.1 建立非uid属性到uid的映射关系"></a><strong>8.3.1</strong> <strong>建立非uid属性到uid的映射关系</strong></h4><p><strong>1）映射关系</strong></p><p>例如：login_name不能直接定位到数据库，可以建立login_name→uid的映射关系，用索引表或缓存来存储。当访问login_name时，先通过映射表查询出login_name对应的uid，再通过uid定位到具体的库。</p><p>映射表只有两列，可以承载很多数据，当数据量过大时，也可以对映射表再做水平切分。这类kv格式的索引结构，可以很好的使用cache来优化查询性能，而且映射关系不会频繁变更，缓存命中率会很高。</p><p><strong>2）基因法</strong></p><p>分库基因：假如通过uid分库，分为8个库，采用uid%8的方式进行路由，此时是由uid的最后3bit来决定这行User数据具体落到哪个库上，那么这3bit可以看为分库基因。</p><p>上面的映射关系的方法需要额外存储映射表，按非uid字段查询时，还需要多一次数据库或cache的访问。如果想要消除多余的存储和查询，可以通过f函数取login_name的基因作为uid的分库基因。生成uid时，参考上文所述的分布式唯一ID生成方案，再加上最后3位bit值&#x3D;f(login_name)。当查询login_name时，只需计算f(login_name)%8的值，就可以定位到具体的库。不过这样需要提前做好容量规划，预估未来几年的数据量需要分多少库，要预留一定bit的分库基因。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/4bdd0ab7a35c375aa932a6067b67fafb.jpeg" alt="img"></p><h4 id="8-3-2-前台与后台分离"><a href="#8-3-2-前台与后台分离" class="headerlink" title="8.3.2 前台与后台分离"></a><strong>8.3.2 前台与后台分离</strong></h4><p>对于用户侧，主要需求是以单行查询为主，需要建立login_name&#x2F;phone&#x2F;email到uid的映射关系，可以解决这些字段的查询问题。</p><p>而对于运营侧，很多批量分页且条件多样的查询，这类查询计算量大，返回数据量大，对数据库的性能消耗较高。此时，如果和用户侧公用同一批服务或数据库，可能因为后台的少量请求，占用大量数据库资源，而导致用户侧访问性能降低或超时。</p><p>这类业务最好采用“前台与后台分离“的方案，运营侧后台业务抽取独立的service和db，解决和前台业务系统的耦合。由于运营侧对可用性、一致性的要求不高，可以不访问实时库，而是通过binlog异步同步数据到运营库进行访问。在数据量很大的情况下，还可以使用ES搜索引擎或Hive来满足后台复杂的查询方式。</p><h2 id="九、使用分库分表中间件"><a href="#九、使用分库分表中间件" class="headerlink" title="九、使用分库分表中间件"></a><strong>九、使用分库分表中间件</strong></h2><p>站在巨人的肩膀上能省力很多，目前分库分表已经有一些较为成熟的开源解决方案：</p><ul><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/shardingjdbc&objectId=2054754&objectType=1&isNewArticle=undefined">sharding-jdbc（当当）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/baihui212/tsharding&objectId=2054754&objectType=1&isNewArticle=undefined">TSharding（蘑菇街）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/Qihoo360/Atlas&objectId=2054754&objectType=1&isNewArticle=undefined">Atlas（奇虎360）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/alibaba/cobar&objectId=2054754&objectType=1&isNewArticle=undefined">Cobar（阿里巴巴）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://www.mycat.io/&objectId=2054754&objectType=1&isNewArticle=undefined">MyCAT（基于Cobar）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/58code/Oceanus&objectId=2054754&objectType=1&isNewArticle=undefined">Oceanus（58同城）</a></li><li><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://github.com/vitessio/vitess&objectId=2054754&objectType=1&isNewArticle=undefined">Vitess（谷歌）</a></li></ul><p><strong>简单介绍其中的两个中简介：</strong></p><p><strong>Mycat</strong></p><p>Mycat发展到现在，适用的场景已经很丰富，而且不断有新用户给出新的创新性的方案，以下是几个典型的应用场景：</p><ul><li>单纯的读写分离，此时配置最为简单，支持读写分离，主从切换</li><li>分库分表，对于超过1000万的表进行分片，最大支持1000亿的单表分片</li><li>多租户应用，每个应用一个库，但应用程序只连接Mycat，从而不改造程序本身，实现多租户化报表系统，借助于Mycat的分表能力，处理大规模报表的统计</li><li>替代Hbase，分析大数据作为海量数据实时查询的一种简单有效方案，比如100亿条频繁查询的记录需要在3秒内查询出来结果，除了基于主键的查询，还可能存在范围查询或其他属性查询，此时Mycat可能是最简单有效的选择.</li></ul><p><strong>Sharding-JDBC</strong></p><p>当当网开发的简单易用、轻量级的中间件。</p><p><strong>一些分库分表中间件的简介图：</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/343c4adb84af09097a2af7b2ff3476c9.jpeg" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 核心架构原理</title>
      <link href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
      <url>/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-总技术架构图"><a href="#一、-总技术架构图" class="headerlink" title="一、 总技术架构图"></a>一、 总技术架构图</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/584866-20210720170211789-338741620.jpg" alt="img"></p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/584866-20210720170224800-1741215271.jpg" alt="img"></p><h1 id="二、-生产者原理"><a href="#二、-生产者原理" class="headerlink" title="二、 生产者原理"></a>二、 生产者原理</h1><p>rocketMQ 消息发送没有 Kafka 那样复杂，没有 底层通用的  batch、sender 线程、inFlightRequest 等机制 或限制，关键问题就下面三个：</p><h2 id="1、-发给谁-——-Broker-Queue-选取-以及-负载均衡"><a href="#1、-发给谁-——-Broker-Queue-选取-以及-负载均衡" class="headerlink" title="1、 发给谁 —— Broker&#x2F;Queue 选取 以及 负载均衡"></a>1、 发给谁 —— Broker&#x2F;Queue 选取 以及 负载均衡</h2><p>在 RocketMQ 中，消息发送时的负载均衡机制是<strong>先选择队列（MessageQueue），再通过队列找到对应的 Broker</strong>。具体过程如下：</p><ul><li><strong>队列选择</strong>：生产者通过负载均衡策略（如轮询、随机选择等）从 Topic 的队列列表中选择一个队列。</li><li><strong>Broker 定位</strong>：根据队列的元信息（QueueId 和 BrokerName），生产者找到对应的 Broker，并将消息发送到该队列。</li></ul><p>这种设计简化了消息发送的逻辑，同时通过队列的负载均衡策略，实现了消息的均匀分布。</p><h3 id="默认轮询策略"><a href="#默认轮询策略" class="headerlink" title="默认轮询策略"></a><strong>默认轮询策略</strong></h3><p>发消息的时候，<strong>默认会轮询所有的message queue发送</strong>，以达到让消息平均落在不同的queue上。而由于queue可以散落在不同的broker，所以消息就发送到不同的broker下</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250220232425239.png" alt="image-20250220232425239" style="zoom:67%;" /><h3 id="自定义队列选择器"><a href="#自定义队列选择器" class="headerlink" title="自定义队列选择器"></a>自定义队列选择器</h3><p>RocketMQ 允许开发者通过实现 <code>MessageQueueSelector</code> 接口来自定义队列选择逻辑。例如，在发送顺序消息时，可以通过自定义队列选择器根据消息的唯一标识选择特定的队列</p><h3 id="MessageGroupHash-模式"><a href="#MessageGroupHash-模式" class="headerlink" title="MessageGroupHash 模式"></a>MessageGroupHash 模式</h3><p>对于顺序消息，相同的<code>shading key</code>只会对应一个<code>Queue</code>发送消息（5.0以上版本发送顺序消息时可配置 MessageGroupHash 模式）</p><p>【注意】： 使用MessageGroupHash模式时，避免出现热点队列</p><h2 id="2、-怎么发-——-消息发送方式-（同步、异步、单向）"><a href="#2、-怎么发-——-消息发送方式-（同步、异步、单向）" class="headerlink" title="2、 怎么发 —— 消息发送方式 （同步、异步、单向）"></a>2、 怎么发 —— 消息发送方式 （同步、异步、单向）</h2><h3 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h3><p>在同步发送模式下，RocketMQ 默认采用同步刷盘方式，当生产者将消息发送到 Broker 后，会等待 Broker 的响应（默认超时 5分钟），Broker 接收消息后，会将其写入内存缓存，并进行刷盘操作。因此，如果 Broker 响应成功，代表消息一定成功写入磁盘。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-sync-send2.png" alt="img" style="zoom: 40%;" /><p>同步消息发出数据后，等到收到接收方发回响应之后才发下一个请求。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-sync-send.png" alt="img" style="zoom:50%;" /><h3 id="异步发送"><a href="#异步发送" class="headerlink" title="异步发送"></a>异步发送</h3><p>在异步发送模式下，RocketMQ 默认采用异步刷盘方式，当生产者发送消息到 Broker 后，消息写入内存缓存成功后，Broker 立即返回响应（默认超时 5分钟），后台线程再异步将消息批量写入磁盘。因此，这种方式提高了系统的吞吐量和性能，但在系统崩溃时可能会丢失部分未刷盘的消息。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-async-send2.png" alt="img" style="zoom:40%;" /><p>异步消息通常用在对响应时间敏感的业务场景，即发送端不能容忍长时间地等待Broker的响应。消息发送方在发送了一条消息后，不等接收方发回响应，接着进行第二条消息发送。发送方通过回调接口的方式接收服务器响应，并对响应结果进行处理</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-async-send.png" alt="img" style="zoom:50%;" /><h3 id="单向发送"><a href="#单向发送" class="headerlink" title="单向发送"></a>单向发送</h3><p>单向（OneWay）发送是一种只负责发送消息而不等待任何响应的方式。生产者将消息发送到 Broker 后（默认超时 5分钟），不关心消息是否成功到达或被持久化，主要依赖 Broker 进行刷盘操作，单向发送通常与异步刷盘结合使用，以提高发送效率。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-oneway-send2.png" alt="img" style="zoom:40%;" /><p>这种方式主要用在不特别关心发送结果的场景，例如日志发送。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/rocketmq-oneway-send.png" alt="img" style="zoom:50%;" /><h2 id="3、-可靠性保障-——-发完之后如何保证不丢"><a href="#3、-可靠性保障-——-发完之后如何保证不丢" class="headerlink" title="3、 可靠性保障 —— 发完之后如何保证不丢"></a>3、 可靠性保障 —— 发完之后如何保证不丢</h2><ul><li><h3 id="同步发送模式"><a href="#同步发送模式" class="headerlink" title="同步发送模式"></a><strong>同步发送模式</strong></h3><ul><li><p><strong>机制</strong>：在同步发送模式下，生产者会等待 Broker 的确认响应，只有在收到 Broker 的成功响应后，才认为消息发送成功。</p></li><li><p><strong>优点</strong>：可靠性最高，因为生产者会确保消息已经成功写入 Broker。</p></li><li><p><strong>缺点</strong>：性能较低，因为每次发送都需要等待响应。</p></li></ul></li><li><h3 id="发送重试机制"><a href="#发送重试机制" class="headerlink" title="发送重试机制"></a><strong>发送重试机制</strong></h3><ul><li><p><strong>机制</strong>：如果消息发送失败（如网络异常或 Broker 不可用），生产者会自动重试发送。可以通过 <code>setRetryTimesWhenSendFailed</code> 方法设置重试次数。</p></li><li><p><strong>优点</strong>：提高了消息发送的成功率，尤其是在网络不稳定或 Broker 短暂不可用的情况下。</p></li><li><p><strong>缺点</strong>：如果重试次数过多，可能会导致消息发送延迟增加。</p></li></ul></li><li><h3 id="消息幂等性-——-避免因保障可靠性导致的消息重复"><a href="#消息幂等性-——-避免因保障可靠性导致的消息重复" class="headerlink" title="消息幂等性 —— 避免因保障可靠性导致的消息重复"></a><strong>消息幂等性</strong> —— 避免因保障可靠性导致的消息重复</h3><ul><li><p><strong>机制</strong>：生产者可以为每条消息设置一个唯一的 ID（<code>MessageId</code> 或自定义的 <code>Keys</code>）。Broker 在接收消息时会根据这个 ID 进行去重处理，确保相同 ID 的消息不会被重复处理。</p></li><li><p><strong>优点</strong>：避免了因重试导致的消息重复问题，确保消息的幂等性。</p></li><li><p><strong>缺点</strong>：需要生产者端进行额外的逻辑处理，确保消息 ID 的唯一性。</p></li></ul></li></ul><h1 id="三、-Broker-消息存储机制"><a href="#三、-Broker-消息存储机制" class="headerlink" title="三、 Broker 消息存储机制"></a>三、 Broker 消息存储机制</h1><p>RocketMQ 的消息存储机制是其高性能、高可靠性的核心设计之一。其存储架构通过 <strong>顺序写、内存映射、异步刷盘、主从同步</strong> 等多种技术手段，实现了高吞吐量和低延迟。以下是 RocketMQ 消息存储机制的详细梳理：</p><h2 id="1、-核心存储结构"><a href="#1、-核心存储结构" class="headerlink" title="1、 核心存储结构"></a>1、 核心存储结构</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250221002404162.png" alt="image-20250221002404162"></p><p>如上图所示，RocketMQ 的存储模型围绕 <strong>CommitLog</strong>、<strong>ConsumeQueue</strong> 和 <strong>IndexFile</strong> 三个核心文件展开：</p><h3 id="CommitLog（提交日志）"><a href="#CommitLog（提交日志）" class="headerlink" title="CommitLog（提交日志）"></a>CommitLog（提交日志）</h3><ul><li><strong>作用</strong>：所有消息的 <strong>主体内容</strong> 和 <strong>元数据</strong> 均以 <strong>顺序追加（Append-Only）</strong> 的方式写入 CommitLog 文件。</li><li><strong>特点</strong>：<ul><li>所有 Topic 的消息统一存储到 CommitLog，避免随机写磁盘。</li><li>单个文件大小默认 <code>1GB</code>，写满后生成新文件（文件名以起始偏移量命名，如 <code>00000000000000000000</code>）。</li><li>消息存储格式包括：消息长度、存储时间、Topic、Queue ID、物理偏移量（PhyOffset）、Body 内容等。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/O1CN0117cgOP1WYuMLLPmeP_!!6000000002801-0-tps-1080-250.jpg" alt="img"></p><blockquote><p>RocketMQ 有一套相对复杂的消息存储编码用来将消息对象序列化，随后再将一个非定长的数据落到上述的真实的写入到文件中，值得注意的存储格式中包括了索引队列的编号和位置。</p></blockquote><blockquote><p>存储时单条消息本身元数据占用的存储空间为固定的 91B + 部分属性，而消息的 payload 通常大于 2K，也就是说元数据带来的额外存储开销只增加了 5%-10% 左右。很明显，单条消息越大，存储本身额外的开销（比例）就相对的越少。但如果有大消息的诉求，例如想在 body 中保存一张序列化后的图片（二进制大对象），从目前的实现上说，在消息中保存引用，将真实数据保存到到其他组件，消费时读取引用（比如文件名或者 uk）其实是一个更合适的设计。</p></blockquote><blockquote><p><strong>在数据写入 CommitLog 后，在服务端当 MessageStore 向 CommitLog 写入一些消息后，有一个后端的 ReputMessageService 服务 (dispatch 线程) 会异步的构建多种索引，满足不同形式的读取诉求。</strong></p></blockquote><h3 id="ConsumeQueue（消费队列）"><a href="#ConsumeQueue（消费队列）" class="headerlink" title="ConsumeQueue（消费队列）"></a>ConsumeQueue（消费队列）</h3><ul><li><strong>作用</strong>：作为 CommitLog 的 <strong>逻辑索引</strong>，按 Topic 和 Queue 分目录存储，用于加速消费时的消息查找。</li><li><strong>结构</strong>：<ul><li>每个 ConsumeQueue 条目固定 <code>20B</code>，包含：<ul><li><code>CommitLog Offset</code>（8B）：消息在 CommitLog 中的物理偏移量。</li><li><code>Message Size</code>（4B）：消息大小。</li><li><code>Message Tag HashCode</code>（8B）：消息 Tag 的哈希值（用于 Tag 过滤）。</li></ul></li><li>单个文件默认存储 <code>30万</code> 条记录，文件大小约 <code>5.72MB</code>。</li></ul></li><li><strong>写入流程</strong>：<ul><li>由 dispatch 线程异步地将消息从 CommitLog 取出，再拿出消息在 CommitLog 中的物理偏移量 (相对于文件存储的 Index)，消息长度以及Tag Hash 作为单条消息的索引，分发到对应的消费队列</li></ul></li></ul><blockquote><p>偏移 + 长度构成了对 CommitLog 的引用 (Ref)。这种 Ref 机制对于单挑消息只有 20B，显著降低了索引存储开销。ConsumeQueue 实际写入的实现与 CommitLog 不同，CommitLog 有很多存储策略可以选择且混合存储，一个 ConsumeQueue 只会保存一个 Topic 的一个分区的索引，持久化默认使用 FileChannel，实际上这里使用 mmap 的话对小数据量的请求更加友好，不用陷入中断。</p></blockquote><ul><li><strong>消费流程</strong>：<ul><li>根据 Tag 的 Hash 值查询 ConsumeQueue 文件（由 physicOffset + size + Tag HashCode 组成）</li><li>根据 ConsumeQueue 拿到 physicOffset + size</li><li>根据 physicOffset 查询 CommitLog 文件（上文的MappedFileQueue）获得消息</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/O1CN01aEJjNQ1G61WsrhHRq_!!6000000000572-0-tps-1080-615.jpg" alt="img"></p><h3 id="IndexFile（索引文件）"><a href="#IndexFile（索引文件）" class="headerlink" title="IndexFile（索引文件）"></a>IndexFile（索引文件）</h3><ul><li><strong>作用</strong>：提供基于 <strong>Key</strong>（如 Message ID 或业务 Key）或 <strong>时间区间</strong> 的消息查询能力。</li><li><strong>结构</strong>：<ul><li>单个 IndexFile 大小固定为 <code>400MB</code>，包含：<ul><li><strong>索引头</strong>：存储时间戳等信息。</li><li><strong>哈希槽（Slot）</strong>：用于快速定位 Key 对应的索引条目。</li><li><strong>索引条目</strong>：记录 Key 的 Hash 值、CommitLog Offset、时间差等信息。</li></ul></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/O1CN01JyXo5V1ROJ72cbxLf_!!6000000002101-0-tps-1080-172.jpg" alt="img"></p><h2 id="2、-持久化机制"><a href="#2、-持久化机制" class="headerlink" title="2、 持久化机制"></a>2、 持久化机制</h2><p>在 RocketMQ 中提供了三种方式来持久化，对应了三个不同的线程实现，实际使用中只会选择一个。</p><ul><li>同步持久化，使用 GroupCommitService。</li><li>异步持久化且未开启 TransientStorePool 缓存，使用 FlushRealTimeService。</li><li>异步持久化且开启 TransientStorePool 缓存，使用 CommitRealService。</li></ul><p>同步刷盘的落盘线程统一都是 GroupCommitService。写入线程仅仅负责唤醒落盘线程，将消息转交给存储线程，而不会等待消息存储完成之后就立刻返回了。</p><p>从同步刷盘的实现看，落盘线程每隔 10 ms 会检查一次，如果有数据未持久化，便将 page cache 中的数据刷入磁盘。</p><blockquote><p>Q： 此时操作系统 crash 或者断电，那未落盘的数据丢失会不会对生产者有影响呢？</p><p>A： 此时生产者只要使用了可靠发送 (指非 oneway 的 rpc 调用)，这时对于发送者来说还没有收到成功的响应，此时客户端会进行重试，将消息写入其他可用的节点。</p></blockquote><p>异步持久化对应的线程是 FlushRealTimeService，实现上又分为 固定频率 和 非固定频率 ，核心区别是线程是否响应中断。</p><p>所谓的固定频率是指每次有新的消息到来的时候不管，不响应中断，每隔 500ms（可配置）flush 一次，如果发现未落盘数据不足（默认 16K），直接进入下一个循环，如果数据写入量很少，一直没有填充满16K，就不会落盘了吗？这里还有一个基于时间的兜底方案，即线程发现距离上次写入已经很久了（默认 10 秒），也会执行一次 flush。但事实上 FileChannel 还是 MappedByteBuffer 的 force() 方法都不能精确控制写入的数据量，这里的写行为也只是对内核的一种建议。</p><p>对于非固定频率实现，即每次有新的消息到来的时候，都会发送唤醒信号，当唤醒动作在数据量较大时，存在性能损耗，但消息量较少且情况下实时性好，更省资源。在生产中，具体选择哪种持久化实现由具体的场景决定。是同步写还是多副本异步写来保证数据存储的可靠性，本质上是读写延迟和和成本之间的权衡。<img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/O1CN01sGVd9c1HaXXADzyCy_!!6000000000774-0-tps-1080-370.jpg" alt="img"></p><h2 id="3、-消息清理机制"><a href="#3、-消息清理机制" class="headerlink" title="3、 消息清理机制"></a>3、 消息清理机制</h2><p>由于消息是被顺序存储在CommitLog文件中的，且消息长度不定长，因此消息的清理不是以消息为单位进行的，而是以CommitLog为单位进行的。</p><p>默认情况下，Broker会清理单个 CommitLog 文件中最后一条消息超过<strong>72小时的 CommitLog 文件</strong>，除了用户手动清理为，下面几种情况会被默认清理。</p><ul><li><strong>CommitLog清理机制</strong><ul><li>CommitLog文件过期(72小时)，且达到清理时间点(<strong>默认为04:00~05:00</strong>)，自动清理过期的CommitLog文件</li><li>CommitLog文件过期(72小时)，且CommitLog所在磁盘分区占用率已经达到<strong>过期清理警戒线</strong>(默认75%)，无论是否到达清理时间点都会自动清理过期文件</li><li>CommitLog所在磁盘分区占用率已经达到<strong>清理警戒线</strong>(默认85%)，无论是否过期，都会从最早的文件开始清理，一次最多清理10个文件</li><li>CommitLog所在磁盘分区占用率已经达到<strong>系统危险警戒线</strong>(默认90%)，Broker将拒绝消息写入</li><li>Broker至少会保留最新的CommitLog文件</li></ul></li><li><strong>ConsumeQueue清理机制</strong><ul><li>如果ConsumeQueue文件关联CommitLog都被清理，则清理此ConsumeQueue文件</li><li>Broker每个Topic-QueueId至少会保留最新的文件</li></ul></li><li><strong>IndexFile清理机制</strong><ul><li>如果IndexFile所有索引单元关联CommitLog都被清理，则清理此IndexFile</li></ul></li></ul><h4 id="Broker与消息清理相关配置"><a href="#Broker与消息清理相关配置" class="headerlink" title="Broker与消息清理相关配置"></a>Broker与消息清理相关配置</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">properties</span> <span class="string">代码解读复制代码# 文件自动清理时间，单位H，默认72</span></span><br><span class="line"><span class="attr">fileReservedTime</span>=<span class="string">72</span></span><br><span class="line"><span class="comment"># CommitLog物理文件删除间隔，但是ms，默认100</span></span><br><span class="line"><span class="attr">deleteCommitLogFilesInterval</span> = <span class="string">100</span></span><br><span class="line"><span class="comment"># 文件自动清理时间，默认04，即凌晨4点</span></span><br><span class="line"><span class="attr">deleteWhen</span> = <span class="string">&quot;04&quot;</span></span><br><span class="line"><span class="comment"># 硬盘占用率所在分区过期清理警戒线，超过这个值，无论是否到达清理时间，都会自动清理过期文件</span></span><br><span class="line"><span class="attr">diskMaxUsedSpaceRatio</span> = <span class="string">75</span></span><br></pre></td></tr></table></figure><h1 id="四、RocketMQ消费原理"><a href="#四、RocketMQ消费原理" class="headerlink" title="四、RocketMQ消费原理"></a>四、RocketMQ消费原理</h1><h2 id="1、-消费模型"><a href="#1、-消费模型" class="headerlink" title="1、 消费模型"></a>1、 消费模型</h2><h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><p>RocketMQ 提供了两种主要的消费模式：<strong>集群模式</strong>和<strong>广播模式</strong>。</p><ul><li><strong>集群模式</strong>：同一消费组（Consumer Group）内的多个消费者共享消息。每个消息只会被其中一个消费者消费，适用于负载均衡的场景。</li><li><strong>广播模式</strong>：同一消费组内的每个消费者都会收到所有消息，适用于每个消费者都需要处理每条消息的场景。</li></ul><h3 id="消息获取方式"><a href="#消息获取方式" class="headerlink" title="消息获取方式"></a>消息获取方式</h3><ul><li><strong>拉模式</strong>：消费者主动从 Broker 拉取消息。这种方式由消费者控制，适合对实时性要求较低的场景。</li><li><strong>推模式</strong>：基于拉模式实现，Broker 在消息到达后主动推送给消费者。这种方式实时性更高，适合对消息响应速度要求较高的场景。</li></ul><h3 id="消费线程模型"><a href="#消费线程模型" class="headerlink" title="消费线程模型"></a>消费线程模型</h3><p>RocketMQ 为每个消费组创建独立的消费线程池：</p><ul><li><strong>并发消费</strong>：线程池中的线程并行处理消息，适合对性能要求较高的场景。</li><li><strong>顺序消费</strong>：通过锁机制保证消息按顺序处理，适用于对消息顺序性要求较高的场景。</li></ul><h2 id="2、-消费可靠性"><a href="#2、-消费可靠性" class="headerlink" title="2、 消费可靠性"></a>2、 消费可靠性</h2><h3 id="消费负载均衡-与-Rebalance"><a href="#消费负载均衡-与-Rebalance" class="headerlink" title="消费负载均衡 与 Rebalance"></a>消费负载均衡 与 Rebalance</h3><ul><li><strong>触发条件</strong>：消费者数量变化、Topic队列数变化。</li><li><strong>分配策略</strong>：平均分配、循环分配、一致性哈希等。</li><li><strong>问题</strong>：Rebalance可能导致短暂消费暂停或重复消费。</li></ul><h3 id="消费进度管理"><a href="#消费进度管理" class="headerlink" title="消费进度管理"></a>消费进度管理</h3><ul><li><strong>存储位置</strong>：集群模式存于Broker，广播模式存于本地。</li><li><strong>提交方式</strong>：同步提交（可靠但延迟高）、异步提交（低延迟但可能丢失）。</li><li><strong>重置策略</strong>：<code>CONSUME_FROM_LAST_OFFSET</code>（默认）、<code>CONSUME_FROM_FIRST_OFFSET</code>等。</li></ul><h3 id="消费重试"><a href="#消费重试" class="headerlink" title="消费重试"></a>消费重试</h3><h4 id="顺序消息的重试"><a href="#顺序消息的重试" class="headerlink" title="顺序消息的重试"></a>顺序消息的重试</h4><p>对于顺序消息，当消费者消费消息失败后，消息队列 RocketMQ 会自动不断进行消息重试</p><p><strong>【注意】</strong>： 重试发生也就意味着应用出现消息消费阻塞情况。因此，在使用顺序消息时，务必保证应用能够及时监控并处理消费失的情况，避免阻塞现象发生。</p><h4 id="无序消息的重试"><a href="#无序消息的重试" class="headerlink" title="无序消息的重试"></a>无序消息的重试</h4><p>对于无序消息（普通、定时、延时、事务消息），当消费者消费消息失败时，您可以通过设置返回状态达到消息重试的结果。</p><p><strong>【注意】</strong>：无序消息的重试只针对集群消费方式生效；广播方式不提供失败重试特性，即消费失败后，失败消息不再重试，继续消费新的消息。</p><h4 id="重试策略"><a href="#重试策略" class="headerlink" title="重试策略"></a>重试策略</h4><ul><li><strong>最大重试次数</strong>：默认情况下，消息会被重试 16 次。可以通过设置 <code>consumer.setMaxReconsumeTimes()</code> 方法自定义最大重试次数。</li><li><strong>重试间隔</strong>：<ul><li>对于无序消息，重试间隔为阶梯时间，随着重试次数增加而逐渐延长。</li><li>对于顺序消息，重试间隔为固定时间，默认为 3 秒。</li></ul></li></ul><h1 id="五、-NameServer-解析"><a href="#五、-NameServer-解析" class="headerlink" title="五、 NameServer 解析"></a>五、 NameServer 解析</h1><p>RocketMQ 的 NameServer 是一个轻量级的无状态服务注册与发现中心，主要负责管理和维护 Broker 集群的路由信息，并为生产者和消费者提供服务发现功能。以下是关于 NameServer 的全面梳理：</p><h2 id="1、-作用"><a href="#1、-作用" class="headerlink" title="1、 作用"></a>1、 作用</h2><p>NameServer 在 RocketMQ 架构中扮演着以下关键角色：</p><ul><li><strong>Broker 注册中心</strong>：Broker 启动时会向所有 NameServer 实例注册自身信息（包括 IP 地址、端口、主题配置等），NameServer 会将这些信息保存下来并对外提供查询服务。</li><li><strong>路由信息管理</strong>：NameServer 负责存储 Broker 集群的路由信息，包括主题（Topic）到 Broker 的映射关系。生产者和消费者通过 NameServer 获取路由信息，从而找到对应的 Broker。</li><li><strong>服务发现</strong>：当 Broker 发生变更（如上线、下线或配置变更）时，NameServer 会及时更新路由信息，确保生产者和消费者能够动态感知 Broker 的变化。</li><li><strong>高可用保障</strong>：NameServer 通常以集群方式部署，各实例之间相互独立，没有主从之分。即使部分 NameServer 宕机，系统仍能正常运行。</li></ul><h2 id="2、-工作原理"><a href="#2、-工作原理" class="headerlink" title="2、 工作原理"></a>2、 工作原理</h2><h3 id="（1）Broker-注册与心跳机制"><a href="#（1）Broker-注册与心跳机制" class="headerlink" title="（1）Broker 注册与心跳机制"></a>（1）<strong>Broker 注册与心跳机制</strong></h3><ul><li><strong>注册流程</strong>：Broker 启动后，会向所有 NameServer 实例注册自身信息，并每隔 30 秒发送心跳包以保持连接。</li><li><strong>心跳检测</strong>：NameServer 接收到心跳包后，会更新 Broker 的状态信息。如果在 120 秒内未收到某个 Broker 的心跳包，NameServer 会认为该 Broker 已下线，并从路由表中移除其信息。</li></ul><h3 id="（2）路由信息的存储与更新"><a href="#（2）路由信息的存储与更新" class="headerlink" title="（2）路由信息的存储与更新"></a>（2）<strong>路由信息的存储与更新</strong></h3><ul><li><strong>存储结构</strong>：NameServer 使用 <code>HashMap</code> 存储路由信息，主要包括：<ul><li><code>topicQueueTable</code>：存储 Topic 的消息队列路由信息。</li><li><code>brokerAddrTable</code>：存储 Broker 的基础信息。</li><li><code>brokerLiveTable</code>：存储 Broker 的状态信息。</li></ul></li><li><strong>更新机制</strong>：NameServer 定期扫描 <code>brokerLiveTable</code>，移除超时未响应的 Broker，并更新路由表。</li></ul><h3 id="（3）路由查询"><a href="#（3）路由查询" class="headerlink" title="（3）路由查询"></a>（3）<strong>路由查询</strong></h3><ul><li>生产者和消费者在发送或接收消息时，会从 NameServer 查询路由信息，获取对应 Topic 的 Broker 地址。之后，它们会直接与 Broker 通信。</li></ul><h2 id="3、-特性"><a href="#3、-特性" class="headerlink" title="3、 特性"></a>3、 特性</h2><h3 id="（1）-散装"><a href="#（1）-散装" class="headerlink" title="（1） 散装"></a>（1） 散装</h3><p>NameServer 可以配成一个集群，但是NameServer 之间没有主从关系，相互独立，甚至不会进行通信。不会在 NameServer 内部去协商出一致性</p><h3 id="（2）-CA"><a href="#（2）-CA" class="headerlink" title="（2） CA"></a>（2） CA</h3><p>RocketMQ的架构设计决定了只需要一个轻量级的元数据服务器就足够了，只需要保持最终一致，而不需要Zookeeper这样的强一致性解决方案，不需要再依赖另一个中间件，从而减少整体维护成本。</p><p>因此，根据CAP理论，NameServer 这个模块的设计上选择了AP，而不是CP</p><h1 id="六、-功能特性"><a href="#六、-功能特性" class="headerlink" title="六、 功能特性"></a>六、 功能特性</h1><h2 id="1、事务消息原理"><a href="#1、事务消息原理" class="headerlink" title="1、事务消息原理"></a>1、事务消息原理</h2><p>RocketMQ 的事务消息是一种分布式事务解决方案，用于保证消息发送与本地事务的最终一致性。它通过事务消息机制，确保在分布式系统中，消息的发送和业务操作的执行能够保持一致性。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dv4i6hph3af2c_a542c054daf6446699ec449e4a6c30f8.png" alt="rocketmq-transaction-message-process.png"></p><p><strong>优点</strong>：</p><ul><li><strong>保证消息一致性</strong>：能够确保分布式系统中消息发送与业务逻辑的一致性。</li><li><strong>高性能</strong>：事务消息的处理机制经过优化，能够满足高并发场景。</li><li><strong>易用性</strong>：提供了简单易用的 API，开发者可以通过 <code>TransactionListener</code> 接口实现本地事务逻辑。</li></ul><p><strong>缺点</strong>：</p><ul><li><strong>系统复杂性增加</strong>：引入事务消息后，系统复杂性增加，开发者需要处理事务状态回查等问题。</li><li><strong>消息时延增加</strong>：由于涉及半事务消息存储、事务状态确认和回查等操作，可能会增加消息的处理时延。</li></ul><h2 id="2、-死信队列"><a href="#2、-死信队列" class="headerlink" title="2、 死信队列"></a>2、 死信队列</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h3><ul><li>当消息重试次数达到最大值仍未成功消费时，消息会被发送到死信队列。</li><li>死信队列用于存储那些无法正常消费的消息，方便后续人工介入或特殊处理。</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><ul><li>死信队列的名称以 <code>%DLQ%</code> 开头，与消费者组一一对应。</li><li>死信队列中的消息不会自动消费，需要人工介入或编写专门的消费者程序来处理。</li><li>死信消息的有效期默认为三天，到期后会被自动删除。</li></ul><h3 id="处理方式"><a href="#处理方式" class="headerlink" title="处理方式"></a><strong>处理方式</strong></h3><ul><li>可以通过控制台或编写代码的方式查询死信队列中的消息。</li><li>如果排查并解决了消息消费失败的原因，可以将死信消息重新发送到原队列进行消费。</li><li>对于顺序消息的死信，不支持直接从死信队列重新发送，需要导出后自行处理</li></ul><h2 id="3、-定时-延时-消息"><a href="#3、-定时-延时-消息" class="headerlink" title="3、 定时&#x2F;延时 消息"></a>3、 定时&#x2F;延时 消息</h2><p>RocketMQ 的定时消息和延时消息是两种重要的消息类型，它们在功能上非常相似，本质上都是通过设置消息的投递时间来实现延迟消费的效果</p><h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><ul><li><strong>定义</strong>：定时消息是指消息发送到服务端后，按照指定的时间戳被投递到消费者端。消息的投递时间由生产者设置为一个未来的毫秒级 Unix 时间戳。</li><li><strong>使用场景</strong>：适用于需要在特定时间触发业务逻辑的场景，例如定时任务、定时通知等。</li><li><strong>设置限制</strong>：<ul><li>定时时间必须是当前时间之后，否则消息会立即投递。</li><li>定时时间范围因 RocketMQ 版本和部署方式而异，标准版最大支持 7 天，专业版和铂金版最大支持 40 天。</li></ul></li></ul><h3 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h3><ul><li><strong>定义</strong>：延时消息是指消息发送到服务端后，按照指定的延时时间（如 1 秒、10 分钟、1 小时等）后被投递到消费者端。</li><li><strong>使用场景</strong>：适用于需要在特定时间间隔后触发业务逻辑的场景，例如订单超时未支付提醒、任务调度等。</li><li><strong>设置限制</strong>：<ul><li>延时时间需转换为 Unix 时间戳，且必须在当前时间之后。</li><li>RocketMQ 默认支持 18 种预设的延时时间，包括 1 秒、5 秒、10 秒、30 秒、1 分钟、2 分钟、1 小时、2 小时等。</li></ul></li></ul><h3 id="延迟队列原理"><a href="#延迟队列原理" class="headerlink" title="延迟队列原理"></a>延迟队列原理</h3><p>所有的延迟消息由producer发出之后，都会存放到同一个topic（<code>SCHEDULE_TOPIC_XXXX</code>）下，不同的延迟级别会对应不同的队列序号，当延迟时间到之后，由<strong>定时线程</strong>读取转换为普通的消息存的真实指定的topic下，此时对于consumer端此消息才可见，从而被consumer消费。</p><p><strong>【注意】：RocketMQ不支持任意时间的延时</strong>，只支持以下几个固定的延时等级<br><code>private String messageDelayLevel = &quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;;</code></p><h3 id="消息生命周期"><a href="#消息生命周期" class="headerlink" title="消息生命周期"></a>消息生命周期</h3><ol><li><strong>初始化</strong>：消息被生产者构建并发送到服务端。</li><li><strong>定时中</strong>：消息存储在定时存储系统中，等待定时时刻到达。</li><li><strong>待消费</strong>：定时时刻到达后，消息被重新写入普通存储引擎，对消费者可见。</li><li><strong>消费中</strong>：消费者获取消息并处理，服务端等待消费者提交消费结果。</li><li><strong>消费提交</strong>：消费者完成消费并向服务端提交结果，消息被逻辑标记为已消费。</li><li><strong>消息删除</strong>：消息在保存时间到期或存储空间不足时被物理删除。</li></ol><h1 id="七、-常见问题"><a href="#七、-常见问题" class="headerlink" title="七、 常见问题"></a>七、 常见问题</h1><h2 id="1、-如何保障顺序消费"><a href="#1、-如何保障顺序消费" class="headerlink" title="1、 如何保障顺序消费"></a>1、 如何保障顺序消费</h2><ul><li>默认保障局部消费顺序， 全局消费顺序需限制queue&#x3D;1<ul><li>或者也可以通过设置分区键（如 <code>ShardingKey</code>），确保相关消息进入同一队列</li></ul></li><li>queue 自身 FIFO</li><li>消费者单线程消费</li></ul><h2 id="2、-消息幂等"><a href="#2、-消息幂等" class="headerlink" title="2、 消息幂等"></a>2、 消息幂等</h2><h3 id="自然幂等"><a href="#自然幂等" class="headerlink" title="自然幂等"></a>自然幂等</h3><p>如HTTP协议中，GET、POST、PUT、DELETE，GET、DELETE方法幂等的，而POST方法不是幂等的。</p><h3 id="限制性幂等"><a href="#限制性幂等" class="headerlink" title="限制性幂等"></a>限制性幂等</h3><p>【核心】 记录已消费信息 —— 唯一标识符 + 去重表等</p><h2 id="3、如何保障消息不丢失"><a href="#3、如何保障消息不丢失" class="headerlink" title="3、如何保障消息不丢失"></a>3、如何保障消息不丢失</h2><h3 id="（1）生产阶段"><a href="#（1）生产阶段" class="headerlink" title="（1）生产阶段"></a>（1）生产阶段</h3><p>通过请求、确认机制来保证消息的可靠传递 —— <strong>同步生产</strong></p><h3 id="（2）消息存储阶段"><a href="#（2）消息存储阶段" class="headerlink" title="（2）消息存储阶段"></a>（2）消息存储阶段</h3><p>如果对消息的可靠性要求非常高，通过调整Broker的参数避免因为服务器故障而丢失消息。</p><p>在RocketMQ中，可以将刷盘的方式 flushDiskType 配置为 SYCN_FLUSH 同步刷盘。</p><p>如果Broker是多个节点组成的集群，至少将消息发送到2个以上的节点，再给客户端发送确认响应。 </p><p><strong>核心——同步全量复制</strong></p><h3 id="（3）消费阶段"><a href="#（3）消费阶段" class="headerlink" title="（3）消费阶段"></a>（3）消费阶段</h3><p>客户端从MQ拉取消息后，执行用户的业务逻辑成功之后，再给MQ发送消费确认响应 —— OFFSET 同步提交</p><h3 id="Q：-如何知道消息丢失"><a href="#Q：-如何知道消息丢失" class="headerlink" title="Q： 如何知道消息丢失"></a>Q： 如何知道消息丢失</h3><p><strong>利用消息队列的有序性来验证是否有消息丢失。</strong>在消息生产端，给每个发出的消息都指定一个附加一个连续递增的版本号，然后在消费端检查序号的连续性。</p><p>落地方案：</p><p>利用拦截器机制，在 Producer 发送消息之前的拦截器中将序号注入到消息中，在 Consumer 收到消息的拦截器中检测序号的连续性。</p><p>细节问题：</p><p>不能能保证在Topic是严格顺序的，只能保证Queue&#x2F;分区的消息是有序的，发消息的必须要指定的分区，在每个分区单独监测消息序号的连续性。</p><p>一般服务都是多实例进行部署，不好协调全局的Producer的发送顺序，每个Producer分别生成各自的消息序号，附加Producer的标识，在Comsumer端按照每个Producer分别来监测序号的连续性。</p><p>Comsumer实例的数量最好和分区数量保持一致。</p><h2 id="4、如何保障精准一次消费"><a href="#4、如何保障精准一次消费" class="headerlink" title="4、如何保障精准一次消费"></a>4、如何保障精准一次消费</h2><p>（2） &#x3D; At most once</p><p>（3） &#x3D; At leastonce</p><p>Exactly Once &#x3D; (2) + (3)</p><h2 id="5、-消费堆积问题处理"><a href="#5、-消费堆积问题处理" class="headerlink" title="5、 消费堆积问题处理"></a>5、 消费堆积问题处理</h2><p><strong>消息积压 &#x3D; 消费者的消费能力不足引起</strong></p><ul><li>如果是突发问题，临时扩容，增加消费者的数量。通过扩容和降级承担流量，应急问题的处理。</li><li>其次，才是排查解决异常问题。监控、日志分析是否消费端的业务逻辑代码出现了问题，优化消费端的业务处理逻辑。</li><li>最后，如果消费端处理不足，水平扩容提升消费端并发处理能力。<strong>在扩容消费者实例的同时，必须要同步扩容Topic分区的数量，确保消费者的实例数和分区数是相同的，分区是单线程消费。</strong></li></ul><p><strong>在设计系统的时候，一定要保障消费端的消费的性能要高于生产端生产的性能。</strong></p><h2 id="6、-Rebalance"><a href="#6、-Rebalance" class="headerlink" title="6、 Rebalance"></a>6、 Rebalance</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li><strong>消息队列分配</strong>：RocketMQ 中的消息是按主题（Topic）分类的，每个主题下包含多个消息队列。</li><li><strong>消费者注册</strong>：消费者实例启动时会向 Broker 注册，并加入指定的消费者组。</li><li><strong>触发 Rebalance</strong>：当消费者组中的消费者实例数量发生变化（如新增、移除或崩溃）时，Broker 会触发 Rebalance。</li><li><strong>重新分配队列</strong>：Broker 根据当前消费者实例数量，重新计算每个消费者应消费的消息队列，并通知消费者实例。</li><li><strong>消费者调整</strong>：消费者根据新的分配结果调整消息拉取策略。</li></ol><h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><ol><li><strong>消费者实例新增</strong>：当新的消费者实例加入消费者组时。</li><li><strong>消费者实例移除</strong>：当消费者实例从消费者组中移除时。</li><li><strong>消费者实例崩溃</strong>：当消费者实例崩溃或网络异常时。</li><li><strong>消息队列变化</strong>：当主题下的消息队列数量发生变化时。</li></ol><h3 id="对业务影响"><a href="#对业务影响" class="headerlink" title="对业务影响"></a>对业务影响</h3><ol><li><strong>重复消费</strong>：Rebalance 可能导致部分消息被重复消费，尤其是当消费者的 offset 提交不及时时。</li><li><strong>消费突刺</strong>：Rebalance 可能导致积压消息在结束后瞬间需要大量消费，造成消费突刺。</li><li><strong>性能开销</strong>：频繁的 Rebalance 操作会增加系统开销，影响消息消费的效率。</li><li><strong>消费延迟</strong>：Rebalance 过程中，部分消费者可能会暂停消费，导致消息处理延迟。</li></ol><h3 id="优化策略"><a href="#优化策略" class="headerlink" title="优化策略"></a>优化策略</h3><ol><li><strong>合理配置消费者组</strong>：根据业务需求和系统架构，合理设置消费者组和实例数量，避免频繁触发 Rebalance。</li><li><strong>选择合适的分配策略</strong>：根据业务场景选择合适的负载均衡算法（如轮询、随机、最少消费等），确保消息均匀分布。</li><li><strong>优化 Rebalance 间隔</strong>：调整 Rebalance 的间隔时间（默认 20 秒），避免频繁 Rebalance。</li><li><strong>监控和告警</strong>：建立监控机制，关注 Rebalance 频率、消费者负载等指标，及时发现异常。</li><li><strong>关闭主动触发</strong>：在消费者数量较多或频繁上下线时，可以通过配置关闭主动触发 Rebalance。</li><li><strong>幂等性设计</strong>：在业务逻辑中实现幂等性，避免重复消费导致的问题。</li></ol>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ 概述</title>
      <link href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、概览"><a href="#一、概览" class="headerlink" title="一、概览"></a>一、概览</h1><p> RocketMQ是按照典型的生产-消费模型设计的。</p><h2 id="1、部署架构图"><a href="#1、部署架构图" class="headerlink" title="1、部署架构图"></a>1、部署架构图</h2><p>官网架构图黑白色太单调，从网上下了张彩图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/584866-20210421154844939-1788481425.jpg" alt="RocketMQ技术架构图"></p><p> 如上图，RocketMQ主要由 Producer、Consumer、Broker、NameServer 四部分组成。</p><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>负责发布消息，支持集群部署。Producer通过负载均衡选择Broker集群队列进行消息投递。</p><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p>负责消费消息，支持集群部署。支持以push推，pull拉两种模式对消息进行消费。群组消费支持：集群方式和广播方式（见2.3）。</p><h3 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h3><p>消息中转角色，负责存储消息、转发消息。主要包含2个功能：</p><ul><li>接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。</li><li>存储消息相关的元数据：消费者组consumer Group、消费进度偏移offset、主题Topic、队列消息Message Queue等。</li></ul><h3 id="Name-Server"><a href="#Name-Server" class="headerlink" title="Name Server"></a>Name Server</h3><p>Name Server是Topic路由的注册中心，支持Broker的动态注册与发现。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，无状态（每个实例数据一样）。</p><h2 id="2、-其他核心概念"><a href="#2、-其他核心概念" class="headerlink" title="2、 其他核心概念"></a>2、 其他核心概念</h2><h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p><h4 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h4><ul><li><p><strong>系统保留属性</strong></p><ul><li><p><strong>Topic</strong>：消息所属的主题名称，用于分类消息，集群内全局唯一。</p></li><li><p><strong>Message ID</strong>：消息的唯一标识符，由生产者客户端自动生成，格式为数字和大写字母组成的32位字符串。</p></li><li><p><strong>Queue ID</strong>：消息存储的队列编号，由服务端指定。</p></li><li><p><strong>Queue Offset</strong>：消息在队列中的存储位置，由服务端指定。</p></li><li><p><strong>Born Timestamp</strong>：消息在生产者端生成的时间戳。</p></li><li><p><strong>Store Timestamp</strong>：消息在 Broker 端存储的时间戳。</p></li><li><p><strong>Retry Count</strong>：消息消费失败后的重试次数，由服务端标记。</p></li></ul></li><li><p><strong>消息类型相关属性</strong></p><ul><li><p><strong>消息类型</strong>：包括普通消息（Normal）、顺序消息（FIFO）、延时消息（Delay）、事务消息（Transaction）。</p></li><li><p><strong>Delay Level</strong>：延时消息的延迟级别，用于控制消息的投递时间。</p></li></ul></li><li><p><strong>消息过滤与索引</strong></p><ul><li><p><strong>Tag</strong>：消息的过滤标签，用于消息过滤，消费者可以通过 Tag 订阅特定类型的消息。</p></li><li><p><strong>Keys</strong>：消息的索引键，用于快速检索消息，多个 Key 用空格分隔。</p></li></ul></li><li><p><strong>扩展属性</strong></p><ul><li><p><strong>Properties</strong>：以键值对形式存储的扩展属性，用户可以自定义，例如设置消息优先级、重试次数等。</p></li><li><p><strong>Flag</strong>：由应用设置的标志位，RocketMQ 不做处理。</p></li><li><p><strong>Transaction ID</strong>：事务消息中使用的事务标识符。</p></li></ul></li><li><p><strong>其他属性</strong></p></li><li><p><strong>Body</strong>：消息的主体内容，通常是业务数据的二进制表示。</p></li><li><p><strong>Max Retry Count</strong>：消息的最大重试次数</p></li></ul><h3 id="Consumer-消费模式"><a href="#Consumer-消费模式" class="headerlink" title="Consumer 消费模式"></a>Consumer 消费模式</h3><ul><li><h4 id="集群消费"><a href="#集群消费" class="headerlink" title="集群消费"></a>集群消费</h4><ul><li><strong>定义</strong>：在集群消费模式下，一条消息只会被集群内的一个消费者消费。</li><li><strong>适用场景</strong>：适用于消息不需要被重复消费的场景，例如任务分发、日志处理等。</li><li><strong>负载均衡</strong>：RocketMQ 会根据队列分配策略将消息队列分配给不同的消费者，确保负载均衡</li></ul></li><li><h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><ul><li><strong>定义</strong>：在广播消费模式下，一条消息会被推送给集群内的所有消费者。</li><li><strong>适用场景</strong>：适用于消息需要被每个消费者独立消费的场景，例如配置更新、通知广播等。</li><li><strong>特点</strong>：广播模式下，每个消费者都会独立消费消息，不会影响其他消费者。</li></ul></li></ul><h3 id="消息获取方式"><a href="#消息获取方式" class="headerlink" title="消息获取方式"></a>消息获取方式</h3><ul><li><p><strong>PULL 式</strong> —— 应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p></li><li><p><strong>PUSH 式</strong> —— Broker收到数据后主动推送给消费端，该消费模式一般实时性较高。</p></li></ul><h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h3><p> 同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p><h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h3><p> 同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p><h1 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h1><h2 id="1、-业务特性"><a href="#1、-业务特性" class="headerlink" title="1、 业务特性"></a>1、 业务特性</h2><p>Apache RocketMQ上描述了6个业务特性：</p><ol><li>低延迟</li><li>面向金融（可跟踪）</li><li>行业支撑（万亿级消息验证）</li><li>标准</li><li>大数据友好</li><li>支持大量消息堆积。</li></ol><h2 id="2、-设计特性"><a href="#2、-设计特性" class="headerlink" title="2、 设计特性"></a>2、 设计特性</h2><h4 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h4><p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p><h4 id="消息顺序"><a href="#消息顺序" class="headerlink" title="消息顺序"></a>消息顺序</h4><p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p><ul><li><p><strong>全局顺序</strong> —— 对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p></li><li><p><strong>适用场景</strong>：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</p></li><li><p><strong>分区顺序</strong> —— 对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。</p><ul><li><strong>适用场景</strong>：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li></ul></li></ul><h4 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a>消息过滤</h4><p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p><h4 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h4><p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p><ol><li><p>Broker非正常关闭</p></li><li><p>Broker异常Crash</p></li><li><p>OS Crash</p></li><li><p>机器掉电，但是能立即恢复供电情况</p></li><li><p>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</p></li><li><p>磁盘设备损坏</p></li></ol><p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p><p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h4 id="至少一次"><a href="#至少一次" class="headerlink" title="至少一次"></a>至少一次</h4><p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p><h4 id="回溯消费"><a href="#回溯消费" class="headerlink" title="回溯消费"></a>回溯消费</h4><p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X&#x2F;Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><h4 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h4><p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。<br>broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p><ul><li>level &#x3D;&#x3D; 0，消息为非延迟消息</li><li>1&lt;&#x3D;level&lt;&#x3D;maxLevel，消息延迟特定时间，例如level&#x3D;&#x3D;1，延迟1s</li><li>level &gt; maxLevel，则level&#x3D;&#x3D; maxLevel，例如level&#x3D;&#x3D;20，延迟2h</li></ul><p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId &#x3D; delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p><p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h4 id="消息重试（消费者）"><a href="#消息重试（消费者）" class="headerlink" title="消息重试（消费者）"></a>消息重试（消费者）</h4><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ul><p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><h4 id="消息重投（生产者）"><a href="#消息重投（生产者）" class="headerlink" title="消息重投（生产者）"></a>消息重投（生产者）</h4><p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p><ul><li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li><strong>retryAnotherBrokerWhenNotStoreOK</strong>:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。<strong>十分重要消息可以开启</strong>。</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p><ul><li><p>生产者流控：</p><ul><li><p>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</p></li><li><p>如果开启transientStorePoolEnable &#x3D;&#x3D; true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</p></li><li><p>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</p></li><li><p>broker通过拒绝send 请求方式实现流量控制。</p></li></ul></li></ul><p>注意，<strong>生产者流控，不会尝试消息重投</strong>。</p><ul><li><p>消费者流控：</p><ul><li><p>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</p></li><li><p>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</p></li><li><p>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</p></li></ul></li></ul><p>消费者流控的结果是降低拉取频率。</p><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p><p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台（官方提供的后台管理WEB界面）对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 经典面试题</title>
      <link href="/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka-经典面试题"><a href="#Kafka-经典面试题" class="headerlink" title="Kafka 经典面试题"></a>Kafka 经典面试题</h1><hr><h3 id="1-Kafka-如何保障或提升消息可靠性"><a href="#1-Kafka-如何保障或提升消息可靠性" class="headerlink" title="1. Kafka 如何保障或提升消息可靠性"></a>1. Kafka 如何保障或提升消息可靠性</h3><p>Kafka 提供了多种机制来保障消息的可靠性：</p><ul><li><strong>副本机制（Replication）</strong>：Kafka 将每个 Partition 的数据复制到多个 Broker 上。通过设置 <code>replication.factor</code> 参数，可以指定副本的数量。当 Leader 副本发生故障时，Follower 副本可以接管，从而保证数据的可用性。</li><li><strong>ISR（In-Sync Replicas）机制</strong>：Kafka 维护一个同步副本集，只有当消息被 ISR 中的副本确认后，才会向生产者返回确认消息。通过设置 <code>acks</code> 参数（如 <code>acks=all</code>），可以确保消息被所有同步副本接收，从而提高可靠性。</li><li><strong>日志持久化</strong>：Kafka 将消息持久化到磁盘，通过设置 <code>log.flush.interval.messages</code> 和 <code>log.flush.interval.ms</code> 参数，可以控制消息的持久化频率，减少数据丢失的风险。</li><li><strong>消息重试机制</strong>：生产者在发送消息失败时，可以根据配置进行重试，通过设置 <code>retries</code> 和 <code>retry.backoff.ms</code> 参数，可以调整重试策略。</li></ul><hr><h3 id="2-Kafka-如何开启消息的幂等性"><a href="#2-Kafka-如何开启消息的幂等性" class="headerlink" title="2. Kafka 如何开启消息的幂等性"></a>2. Kafka 如何开启消息的幂等性</h3><p>Kafka 的幂等性是指生产者可以多次发送相同的消息，而不会导致重复消息被写入。幂等性可以通过以下方式开启：</p><ul><li>在生产者客户端配置中，设置 <code>enable.idempotence=true</code>。</li><li>Kafka 会为每个生产者分配一个唯一的 PID（Producer ID），并为每个 Partition 维护一个序列号。当生产者发送消息时，Kafka 会根据 PID 和序列号检查消息是否重复，从而保证幂等性。</li><li>注意：幂等性需要与 <code>acks=all</code> 配合使用，以确保消息的可靠性。</li></ul><hr><h3 id="3-如何保障精准一次性消费"><a href="#3-如何保障精准一次性消费" class="headerlink" title="3. 如何保障精准一次性消费"></a>3. 如何保障精准一次性消费</h3><p>Kafka 默认支持“最多一次”（At-Most-Once）和“至少一次”（At-Least-Once）语义，但不直接支持“精准一次”（Exactly-Once）。要实现精准一次消费，可以结合幂等性和事务：</p><ul><li><strong>幂等性</strong>：通过设置 <code>enable.idempotence=true</code>，确保生产者不会重复发送消息。</li><li><strong>事务</strong>：Kafka 提供了事务机制，允许生产者将多个消息组合成一个事务，并通过 <code>BEGIN_TRANSACTION</code>、<code>SEND</code> 和 <code>COMMIT_TRANSACTION</code> 操作来保证消息的原子性。</li><li><strong>消费者端去重</strong>：在消费者端，可以通过存储已消费消息的偏移量或消息 ID，来避免重复消费。</li></ul><hr><h3 id="4-如何评估和优化-Kafka-集群的性能？"><a href="#4-如何评估和优化-Kafka-集群的性能？" class="headerlink" title="4. 如何评估和优化 Kafka 集群的性能？"></a>4. 如何评估和优化 Kafka 集群的性能？</h3><p>评估 Kafka 集群性能可以从以下几个方面入手：</p><ul><li><strong>吞吐量</strong>：通过工具（如 <code>kafka-producer-perf-test</code> 和 <code>kafka-consumer-perf-test</code>）测试生产者和消费者的吞吐量。</li><li><strong>延迟</strong>：监控消息从生产者发送到消费者消费的延迟，可以通过 <code>JMX</code> 指标（如 <code>lag</code>）来评估。</li><li><strong>资源使用</strong>：监控 Broker 的 CPU、内存、磁盘 I&#x2F;O 和网络带宽使用情况。</li></ul><p>优化 Kafka 集群性能的策略：</p><ul><li><strong>调整 Partition 数量</strong>：增加 Partition 数量可以提高并行度，但过多的 Partition 会增加管理开销。</li><li><strong>优化磁盘性能</strong>：使用 SSD 或高 IOPS 的磁盘，减少磁盘 I&#x2F;O 延迟。</li><li><strong>调整 JVM 参数</strong>：优化 Kafka Broker 的 JVM 参数（如堆大小、垃圾回收策略）以提高性能。</li><li><strong>合理配置缓存</strong>：调整 <code>num.network.threads</code>、<code>num.io.threads</code> 和 <code>socket.request.max.bytes</code> 等参数，优化网络和 I&#x2F;O 性能。</li><li><strong>清理策略</strong>：根据业务需求选择合适的日志清理策略（如 <code>delete</code> 或 <code>compact</code>），减少磁盘占用。</li></ul><hr><h3 id="5-Kafka-的吞吐量和延迟是如何权衡的？"><a href="#5-Kafka-的吞吐量和延迟是如何权衡的？" class="headerlink" title="5. Kafka 的吞吐量和延迟是如何权衡的？"></a>5. Kafka 的吞吐量和延迟是如何权衡的？</h3><p>Kafka 的吞吐量和延迟是一对矛盾：</p><ul><li><strong>高吞吐量</strong>：可以通过增加 Partition 数量、使用批量发送（<code>batch.size</code> 和 <code>linger.ms</code>）、减少副本数量（<code>replication.factor</code>）等方式提高吞吐量。但这些优化可能会增加延迟。</li><li><strong>低延迟</strong>：可以通过减少消息批量大小、降低 <code>linger.ms</code>、增加副本数量等方式降低延迟。但这些优化可能会降低吞吐量。</li><li><strong>权衡策略</strong>：根据业务需求进行调整。如果业务对实时性要求高，则优先优化延迟；如果业务对数据量要求大，则优先优化吞吐量。</li></ul><hr><h3 id="6-Kafka-集群的扩展性如何实现？"><a href="#6-Kafka-集群的扩展性如何实现？" class="headerlink" title="6. Kafka 集群的扩展性如何实现？"></a>6. Kafka 集群的扩展性如何实现？</h3><p>Kafka 集群的扩展性主要通过以下方式实现：</p><ul><li><strong>增加 Broker 节点</strong>：向集群中添加新的 Broker 节点，并通过重新分配 Partition 来平衡负载。</li><li><strong>动态调整 Partition</strong>：根据业务需求增加或减少 Partition 数量，以提高并行度和负载均衡。</li><li><strong>使用分布式存储</strong>：Kafka 支持将数据存储在分布式存储系统（如 HDFS）中，以扩展存储容量。</li><li><strong>配置负载均衡</strong>：通过合理配置 <code>num.network.threads</code>、<code>num.io.threads</code> 等参数，确保集群的负载均衡。</li></ul><hr><h3 id="7-Kafka-的副本机制（Replication）是如何工作的"><a href="#7-Kafka-的副本机制（Replication）是如何工作的" class="headerlink" title="7. Kafka 的副本机制（Replication）是如何工作的"></a>7. Kafka 的副本机制（Replication）是如何工作的</h3><p>Kafka 的副本机制通过以下步骤工作：</p><ul><li><strong>副本分配</strong>：在创建 Topic 时，Kafka 会根据 <code>replication.factor</code> 参数将 Partition 分配到多个 Broker 上，其中一个副本成为 Leader，其他副本成为 Follower。</li><li><strong>数据同步</strong>：Leader 接收生产者的消息，并将消息同步到 Follower 副本。Follower 会定期从 Leader 拉取数据，并将其写入本地日志。</li><li><strong>ISR 维护</strong>：Kafka 维护一个 ISR（In-Sync Replicas）列表，只有与 Leader 同步的副本才会被加入 ISR。如果 Follower 副本落后太多（超过 <code>replica.lag.time.max.ms</code>），会被移出 ISR。</li><li><strong>故障转移</strong>：当 Leader 副本发生故障时，Kafka 会从 ISR 中选择一个 Follower 副本作为新的 Leader，从而保证服务的可用性。</li></ul><hr><h3 id="8-如何设计-Kafka-的-Topic-和-Partition？"><a href="#8-如何设计-Kafka-的-Topic-和-Partition？" class="headerlink" title="8. 如何设计 Kafka 的 Topic 和 Partition？"></a>8. 如何设计 Kafka 的 Topic 和 Partition？</h3><p>设计 Kafka 的 Topic 和 Partition 时需要考虑以下因素：</p><ul><li><strong>业务需求</strong>：根据业务场景设计 Topic，例如，不同类型的事件可以使用不同的 Topic。</li><li><strong>负载均衡</strong>：合理分配 Partition 数量，以提高并行度和负载均衡。Partition 数量应根据集群规模和业务负载进行调整。</li><li><strong>消费者组</strong>：确保 Partition 数量大于或等于消费者组的消费者数量，以充分利用并行消费能力。</li><li><strong>存储和性能</strong>：过多的 Partition 会增加管理开销和存储压力，因此需要根据实际需求进行权衡。</li></ul><hr><h3 id="9-如何处理-Kafka-中的消息积压问题？"><a href="#9-如何处理-Kafka-中的消息积压问题？" class="headerlink" title="9. 如何处理 Kafka 中的消息积压问题？"></a>9. 如何处理 Kafka 中的消息积压问题？</h3><p>消息积压通常是由于消费者消费速度跟不上生产者生产速度导致的。处理积压的策略包括：</p><ul><li><strong>增加消费者数量</strong>：通过增加消费者组中的消费者数量，提高消费速度。</li><li><strong>调整 Partition 数量</strong>：增加 Partition 数量以提高并行度，但需注意 Partition 数量不能超过消费者数量。</li><li><strong>优化消费者性能</strong>：通过优化消费者代码（如批量消费、减少处理时间）来提高消费速度。</li><li><strong>调整生产者策略</strong>：在生产者端进行限流，减少消息的生产速度。</li><li><strong>使用死信队列</strong>：将积压的消息转移到死信队列中，后续进行批量处理。</li></ul><hr><h3 id="10-Kafka-的日志清理机制有哪些？它们的区别是什么？"><a href="#10-Kafka-的日志清理机制有哪些？它们的区别是什么？" class="headerlink" title="10. Kafka 的日志清理机制有哪些？它们的区别是什么？"></a>10. Kafka 的日志清理机制有哪些？它们的区别是什么？</h3><p>Kafka 提供了两种日志清理机制：</p><ul><li><strong>删除清理（Delete）</strong>：根据日志的大小或时间来删除旧的消息。通过设置 <code>log.retention.bytes</code> 和 <code>log.retention.hours</code> 参数来控制。</li><li><strong>压缩清理（Compact）</strong>：根据消息的 Key 进行压缩，保留每个 Key 的最新消息。适用于需要保留状态信息的场景，例如，日志清理时会保留每个 Key 的最新值，而不是简单地删除旧消息。</li></ul><p>两者的区别：</p><ul><li><strong>适用场景</strong>：删除清理适用于日志量较大但不需要保留历史状态的场景；压缩清理适用于需要保留状态信息的场景。</li><li><strong>性能影响</strong>：删除清理对性能影响较小，但可能会浪费存储空间；压缩清理需要额外的计算资源来维护 Key 的状态。</li></ul><hr><h3 id="11-消费者如何处理消息的重试机制？"><a href="#11-消费者如何处理消息的重试机制？" class="headerlink" title="11. 消费者如何处理消息的重试机制？"></a>11. 消费者如何处理消息的重试机制？</h3><p>消费者可以通过以下方式处理消息重试：</p><ul><li><strong>自动提交偏移量</strong>：如果消费者在处理消息时失败，可以通过设置 <code>enable.auto.commit=false</code>，手动提交偏移量，以便在重试时重新消费消息。</li><li><strong>重试次数</strong>：可以通过设置 <code>max.poll.interval.ms</code> 和 <code>session.timeout.ms</code> 参数，控制消费者重试的间隔和超时时间。</li><li><strong>死信队列</strong>：对于无法处理的消息，可以将其发送到死信队列，后续进行手动处理。</li><li><strong>幂等性处理</strong>：在消费者端对消息进行幂等性处理，避免重复消费导致的问题。</li></ul><hr><h3 id="12-如何实现消费者的负载均衡？"><a href="#12-如何实现消费者的负载均衡？" class="headerlink" title="12. 如何实现消费者的负载均衡？"></a>12. 如何实现消费者的负载均衡？</h3><p>Kafka 通过消费者组（Consumer Group）机制实现负载均衡：</p><ul><li><strong>Partition 分配策略</strong>：Kafka 提供了多种 Partition 分配策略（如 <code>RangeAssignor</code>、<code>RoundRobinAssignor</code>、<code>StickyAssignor</code>），可以根据业务需求选择合适的策略。</li><li><strong>动态调整</strong>：消费者组中的消费者数量可以动态调整，Kafka 会根据当前的消费者数量重新分配 Partition，以实现负载均衡。</li><li><strong>合理配置</strong>：确保 Partition 数量大于或等于消费者数量，以充分利用并行消费能力。同时，避免过多的消费者导致资源浪费。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 进阶</title>
      <link href="/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka-进阶"><a href="#Kafka-进阶" class="headerlink" title="Kafka 进阶"></a>Kafka 进阶</h1><h2 id="1、-Controller"><a href="#1、-Controller" class="headerlink" title="1、 Controller"></a>1、 Controller</h2><p>Controller 是 Kafka 集群中的一个特殊 Broker，扮演着“协调者”的角色。它负责管理和协调集群内的各种操作，确保集群的高可用性和一致性。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250218002602069.png" alt="image-20250218002602069" style="zoom:50%;" /><h3 id="1-1-Controller-的主要职责"><a href="#1-1-Controller-的主要职责" class="headerlink" title="1.1 Controller 的主要职责"></a>1.1 Controller 的主要职责</h3><h4 id="1-Leader-选举"><a href="#1-Leader-选举" class="headerlink" title="(1)  Leader 选举"></a>(1)  Leader 选举</h4><ul><li><strong>分区 Leader 选举</strong>：当分区的当前 Leader 不可用时，Controller 会从该分区的 ISR（In-Sync Replicas）列表中选择一个新的 Leader。</li><li><strong>Broker Leader 选举</strong>：在集群范围内选举唯一的 Controller 实例。Broker 启动时会尝试在 ZooKeeper 中创建 <code>/controller</code> 节点，第一个成功创建的 Broker 被指定为 Controller。</li></ul><h4 id="2-元数据管理"><a href="#2-元数据管理" class="headerlink" title="(2)  元数据管理"></a>(2)  元数据管理</h4><ul><li><strong>维护主题和分区信息</strong>：Controller 保存了集群中所有主题和分区的元数据，并将这些信息同步给所有 Broker。</li><li><strong>处理元数据变更</strong>：当创建、删除主题或修改分区时，Controller 会更新元数据，并通知所有 Broker。</li><li><strong>监控 Broker 状态</strong>：通过 ZooKeeper 的 Watch 机制，Controller 能够检测 Broker 的上线和下线事件，并触发相应的元数据更新。</li></ul><h4 id="3-分区再分配"><a href="#3-分区再分配" class="headerlink" title="(3)  分区再分配"></a>(3)  分区再分配</h4><ul><li><strong>手动或自动再分配</strong>：Controller 负责执行分区的再分配任务，例如在集群扩容或优化负载均衡时。</li><li><strong>管理 Leader 转移</strong>：在再分配过程中，Controller 确保分区的 Leader 转移顺利进行，避免数据丢失。</li></ul><h4 id="4-配置变更"><a href="#4-配置变更" class="headerlink" title="(4)   配置变更"></a>(4)   配置变更</h4><p>Controller 负责应用全局或特定主题的配置更新，并将这些配置同步到所有相关 Broker，以确保集群配置的一致性。</p><h4 id="5-容错与恢复"><a href="#5-容错与恢复" class="headerlink" title="(5)   容错与恢复"></a>(5)   容错与恢复</h4><ul><li><strong>自动检测 Broker 故障</strong>：当 Broker 失效时，Controller 会重新选举 Leader 或将分区迁移到其他健康的 Broker。</li><li><strong>协助 Broker 恢复</strong>：当失效的 Broker 重新加入集群时，Controller 会帮助其同步最新状态。</li><li><strong>日志清理与压缩</strong>：Controller 负责管理过期日志段的删除或压缩工作。</li></ul><hr><p><strong>Controller 中存储的信息如下：</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/97c4a417118bbbb28ea0e29ebc86357e.png" alt="img"></p><h3 id="1-2-Controller-的选举机制-与-高可用"><a href="#1-2-Controller-的选举机制-与-高可用" class="headerlink" title="1.2 Controller 的选举机制 与 高可用"></a>1.2 Controller 的选举机制 与 高可用</h3><p>Controller 的选举依赖于 <strong>ZooKeeper 的临时节点机制</strong>。</p><p>当 Controller 宕机时，通过选举机制，Kafka 确保集群能够快速选举出新的 Controller，从而保证集群的高可用性。</p><p><strong>流程说明</strong>：</p><ul><li><p>当一个 Broker 启动时，它会尝试在 ZooKeeper 中创建 <code>/controller</code> 节点。</p><ul><li><p>如果创建成功，则该 Broker 成为 Controller；</p></li><li><p>如果创建失败，则表示已有 Controller 存在。</p></li></ul></li><li><p>如果当前 Controller 宕机，ZooKeeper 会删除 <code>/controller</code> 节点，其他 Broker 会尝试重新创建该节点，从而选举出新的 Controller。</p></li></ul><h2 id="2、-Zookeeper-作用"><a href="#2、-Zookeeper-作用" class="headerlink" title="2、 Zookeeper 作用"></a>2、 Zookeeper 作用</h2><p>ZooKeeper 是 Kafka 集群早期版本的核心组件，用于管理和协调 Kafka 集群的元数据和状态信息。以下是 ZooKeeper 在 Kafka 中的具体作用：</p><h3 id="2-1-元数据管理"><a href="#2-1-元数据管理" class="headerlink" title="2.1 元数据管理"></a>2.1 元数据管理</h3><p>ZooKeeper 是 Kafka 集群的“中央存储”，负责存储以下关键元数据：</p><ul><li><strong>主题和分区信息</strong>：存储主题的元数据，包括主题名称、分区数量、分区的 Leader 和副本分布等。</li><li><strong>Broker 信息</strong>：记录集群中所有 Broker 的状态、ID 和地址。</li><li><strong>消费者组信息</strong>：存储消费者组的偏移量（Offset）信息，用于跟踪消费者消费到的消息位置。</li><li><strong>配置信息</strong>：存储 Kafka 集群的全局配置以及主题级别的配置。</li></ul><h3 id="2-2-集群协调"><a href="#2-2-集群协调" class="headerlink" title="2.2 集群协调"></a>2.2 集群协调</h3><p>ZooKeeper 提供高效的协调机制，用于管理 Kafka 集群的动态变化：</p><ul><li><strong>Controller 选举</strong>：Kafka Controller 是集群的“大脑”，负责协调集群的操作。当集群启动时，所有 Broker 会通过 ZooKeeper 选举出一个 Controller。如果当前 Controller 出现故障，ZooKeeper 会触发新的选举。</li><li><strong>Broker 状态监控</strong>：每个 Broker 在 ZooKeeper 中创建临时节点（ephemeral node），用于监控 Broker 的存活状态。如果某个 Broker 崩溃，其对应的临时节点会被删除，Controller 会收到通知并重新分配分区。</li><li><strong>分区 Leader 选举</strong>：当某个分区的 Leader 不可用时，Controller 会通过 ZooKeeper 获取该分区的副本列表，并从中选择一个新的 Leader。</li></ul><h3 id="2-3-集群状态同步"><a href="#2-3-集群状态同步" class="headerlink" title="2.3 集群状态同步"></a>2.3 集群状态同步</h3><p>ZooKeeper 提供分布式锁和事件通知机制，用于同步集群的状态变化：</p><ul><li><strong>分布式锁</strong>：通过 ZooKeeper 的临时顺序节点（sequential ephemeral node），Kafka 可以实现分布式锁，确保集群操作的原子性。</li><li><strong>事件通知</strong>：ZooKeeper 的 Watcher 机制允许 Kafka 的各个组件订阅元数据的变化。当元数据发生变化时（如 Broker 崩溃、分区 Leader 更改等），ZooKeeper 会通知相关组件，确保集群状态的及时更新。</li></ul><h3 id="2-4-消费者偏移量管理"><a href="#2-4-消费者偏移量管理" class="headerlink" title="2.4 消费者偏移量管理"></a>2.4 消费者偏移量管理</h3><p>在 Kafka 的早期版本中，ZooKeeper 还用于存储消费者组的偏移量（Offset）。消费者会定期将消费的偏移量提交到 ZooKeeper，以便在消费者崩溃或重新启动时能够从上次的位置继续消费。</p><h3 id="2-5-Kafka-与-ZooKeeper-的交互流程"><a href="#2-5-Kafka-与-ZooKeeper-的交互流程" class="headerlink" title="2.5 Kafka 与 ZooKeeper 的交互流程"></a>2.5 Kafka 与 ZooKeeper 的交互流程</h3><p>以下是 Kafka 和 ZooKeeper 交互的典型流程：</p><ol><li><strong>集群启动</strong>：<ul><li>每个 Broker 启动时，会在 ZooKeeper 中注册自己的信息，并尝试创建 <code>/controller</code> 节点。</li><li>第一个成功创建 <code>/controller</code> 节点的 Broker 被选为 Controller。</li></ul></li><li><strong>Controller 运行</strong>：<ul><li>Controller 监听 ZooKeeper 中的元数据变化（如 Broker 上线&#x2F;下线、分区状态变化等）。</li><li>当检测到变化时，Controller 会更新元数据，并将新的状态推送给其他 Broker。</li></ul></li><li><strong>Broker 状态监控</strong>：<ul><li>每个 Broker 在 ZooKeeper 中创建一个临时节点（<code>/brokers/ids/&#123;broker_id&#125;</code>）。</li><li>如果 Broker 崩溃，其临时节点会被删除，Controller 会收到通知并重新分配分区。</li></ul></li><li><strong>分区 Leader 选举</strong>：<ul><li>当某个分区的 Leader 不可用时，Controller 会从 ZooKeeper 中获取该分区的副本列表，并选择一个新的 Leader。</li></ul></li></ol><h3 id="2-6-ZooKeeper-的局限性"><a href="#2-6-ZooKeeper-的局限性" class="headerlink" title="2.6 ZooKeeper 的局限性"></a>2.6 ZooKeeper 的局限性</h3><p>尽管 ZooKeeper 在 Kafka 的早期版本中发挥了重要作用，但它也存在一些局限性：</p><ul><li><strong>单点瓶颈</strong>：ZooKeeper 集群的性能可能成为 Kafka 的瓶颈。</li><li><strong>运维复杂性</strong>：需要额外维护 ZooKeeper 集群，增加了运维成本。</li><li><strong>延迟问题</strong>：ZooKeeper 的网络延迟可能影响 Kafka 的性能。</li></ul><h3 id="2-7-Kafka-3-4-的-KRaft-模式"><a href="#2-7-Kafka-3-4-的-KRaft-模式" class="headerlink" title="2.7 Kafka 3.4+ 的 KRaft 模式"></a>2.7 Kafka 3.4+ 的 KRaft 模式</h3><p>为了克服 ZooKeeper 的局限性，Kafka 3.4 引入了 KRaft（Kafka Raft Metadata）模式。KRaft 使用 Raft 协议直接管理 Kafka 的元数据，而不再依赖 ZooKeeper。KRaft 模式提供了更高的性能和更好的可扩展性，是 Kafka 未来的发展方向。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 Kafka 的早期版本中，ZooKeeper 是 Kafka 集群的核心组件，负责元数据管理、集群协调和状态同步等功能。然而，随着 Kafka 的发展，ZooKeeper 的局限性逐渐显现。因此，Kafka 社区引入了 KRaft 模式，逐步替代 ZooKeeper，以实现更高效、更可靠的集群管理。</p><h2 id="3、-消费再平衡"><a href="#3、-消费再平衡" class="headerlink" title="3、 消费再平衡"></a>3、 消费再平衡</h2><p>再平衡是指当消费者组中的成员数量发生变化（如新增或移除消费者）、订阅的主题发生变化（如新增主题或分区），或者分区数量发生变化时，Kafka 会重新分配分区，确保每个消费者都能均匀地处理一定数量的分区。</p><h3 id="3-1-再平衡的触发条件"><a href="#3-1-再平衡的触发条件" class="headerlink" title="3.1 再平衡的触发条件"></a>3.1 再平衡的触发条件</h3><p>再平衡会在以下情况下被触发：</p><ul><li><strong>消费者加入或离开消费者组</strong>：当新的消费者加入或现有消费者离开消费者组时。</li><li><strong>消费者心跳超时或会话过期</strong>：如果消费者长时间未发送心跳或会话超时，协调者会认为该消费者已失效。</li><li><strong>订阅主题或分区发生变化</strong>：例如主题分区数增加或消费者订阅的主题发生变化。</li><li><strong>协调者故障</strong>：如果消费者组协调者（Group Coordinator）发生故障，Kafka 会选举新的协调者并触发再平衡。</li></ul><h3 id="3-2-再平衡的工作流程"><a href="#3-2-再平衡的工作流程" class="headerlink" title="3.2 再平衡的工作流程"></a>3.2 再平衡的工作流程</h3><p>再平衡过程可以分为以下几个步骤：</p><ol><li><strong>触发再平衡</strong>：当检测到上述触发条件之一时，协调者会向所有消费者发送再平衡请求。</li><li><strong>停止消费</strong>：消费者收到再平衡请求后，会停止从 Kafka 读取数据。</li><li><strong>加入组</strong>：消费者向协调者发送 <code>JoinGroup</code> 请求，加入消费组。</li><li><strong>分区分配</strong>：协调者根据分区分配策略（如 RoundRobin、Range、Sticky 等）为每个消费者分配分区。</li><li><strong>同步状态</strong>：协调者将新的分区分配方案同步给所有消费者。</li><li><strong>恢复消费</strong>：消费者根据新的分区分配方案更新消费进度，并开始从新的分区中读取消息。</li></ol><h3 id="3-3-分区分配策略"><a href="#3-3-分区分配策略" class="headerlink" title="3.3 分区分配策略"></a>3.3 分区分配策略</h3><p>Kafka 提供了多种分区分配策略，可以通过配置参数 <code>partition.assignment.strategy</code> 来选择：</p><ul><li><strong>Range 分配策略</strong>：将分区按范围分配给消费者。</li><li><strong>RoundRobin 分配策略</strong>：以轮询的方式将分区均匀分配给消费者。</li><li><strong>Sticky 分配策略</strong>：尽量保持原有分配，减少分区迁移。</li><li><strong>CooperativeSticky 分配策略</strong>：在消费过程中动态调整分区分配，实现负载均衡。</li></ul><h3 id="3-4-再平衡对系统和业务的影响分析"><a href="#3-4-再平衡对系统和业务的影响分析" class="headerlink" title="3.4 再平衡对系统和业务的影响分析"></a>3.4 再平衡对系统和业务的影响分析</h3><h4 id="对系统层面影响"><a href="#对系统层面影响" class="headerlink" title="对系统层面影响"></a>对系统层面影响</h4><ul><li><strong>性能开销</strong>：<ul><li>再平衡期间，消费者会暂停消费消息，导致消息处理延迟和堆积。</li><li>频繁的再平衡会增加消费者与协调者之间的通信开销，尤其是在大规模集群中，可能影响 Kafka 集群的整体吞吐量。</li></ul></li><li><strong>服务中断</strong>：<ul><li>在再平衡过程中，消费者需要重新加入组并同步新的分区分配方案，这会导致短暂的服务中断。</li><li>对于高负载场景，服务中断时间可能会延长，影响系统的可用性。</li></ul></li><li><strong>资源竞争</strong>：<ul><li>再平衡过程中，多个消费者可能同时与协调者通信，导致资源竞争，增加网络和 CPU 使用率。</li></ul></li></ul><h4 id="对业务层面影响"><a href="#对业务层面影响" class="headerlink" title="对业务层面影响"></a>对业务层面影响</h4><ul><li><strong>消息处理延迟</strong>：<ul><li>再平衡期间，消费者无法处理消息，可能导致消息堆积，影响业务的实时性。</li></ul></li><li><strong>重复消费问题</strong>：<ul><li>再平衡可能导致消费者重新分配到之前已经消费过的分区，从而引发重复消费。虽然 Kafka 提供了机制来避免重复消费，但在某些情况下（如分区状态变化）仍可能无法完全避免。</li></ul></li><li><strong>业务连续性受损</strong>：<ul><li>再平衡过程中的短暂服务中断可能影响业务的连续性，尤其是在消费者频繁加入或离开、分区数量变化等场景下。</li></ul></li><li><strong>数据一致性问题</strong>：<ul><li>在某些极端情况下，再平衡可能导致消费者在重新分配分区之前已读取的消息丢失，从而影响业务数据的一致性。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka 原理总结</title>
      <link href="/2024/12/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/"/>
      <url>/2024/12/06/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka-原理总结"><a href="#Kafka-原理总结" class="headerlink" title="Kafka 原理总结"></a>Kafka 原理总结</h1><h2 id="一、-Kafka-基本组件与架构"><a href="#一、-Kafka-基本组件与架构" class="headerlink" title="一、 Kafka 基本组件与架构"></a>一、 Kafka 基本组件与架构</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217220733386.png" alt="image-20250217220733386"></p><ul><li><strong>Producer：</strong> 消息生产者，向 Kafka Broker 发消息的客户端。</li><li><strong>Consumer：</strong> 消息消费者，从 Kafka Broker 取消息的客户端。</li><li><strong>Consumer Group：</strong> 消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。</li><li><strong>Broker：</strong> 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li><li><strong>Topic：</strong> 可以理解为一个队列，topic 将消息分类，生产者和消费者面向的是同一个 topic。</li><li><strong>Partition：</strong> 为了实现扩展性，提高并发能力，一个非常大的 topic 可以分布到多个 broker （即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个 有序的队列。</li><li><strong>Replica：</strong> 副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。</li><li><strong>Leader：</strong> 每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 leader。</li><li><strong>Follower：</strong> 每个分区多个副本的“从”副本，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 还会成为新的 leader。</li><li><strong>offset：</strong>消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</li><li><strong>Zookeeper：</strong> Kafka 集群能够正常工作，需要依赖于 zookeeper，zookeeper 帮助 Kafka 存储和管理集群信息。</li></ul><h2 id="二、Kafka-生产者原理"><a href="#二、Kafka-生产者原理" class="headerlink" title="二、Kafka 生产者原理"></a>二、Kafka 生产者原理</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217221423259.png" alt="image-20250217221423259"></p><h3 id="1、发送流程"><a href="#1、发送流程" class="headerlink" title="1、发送流程"></a>1、发送流程</h3><ul><li><strong>Interceptors</strong>：拦截器，对数据进行处理（可选，一般不用）</li><li><strong>Serializer</strong>：序列化器，对数据序列化（Java 序列化器比较重，有效数据占比低）</li><li><strong>Partitioner</strong>：分区器，对数据进行分区处理，在内存中完成</li><li><strong>RecordAccumulator</strong>：一个队列容器类，默认32M，每个分区对应一个队列<ul><li>双端队列，一边从内存池申请内存（创建批次数据），一边释放内存（应答后删除数据）</li></ul></li><li><strong>Sender</strong>：将缓冲队列中的数据发送到 Kafka 集群<ul><li>Sender 发送数据的条件：<ul><li><code>batch.size</code>：批次数据量达到后发送，默认 <strong>16K</strong></li><li><code>linger.ms</code>：批次数据量未达到 batch.size，经过 linger.ms 时间后发送，默认 <strong>0ms</strong>，表示直接发送</li></ul></li><li>Sender 发送流程：<ul><li>分区数据要发往不同的 Broker 节点，以节点 broker id 为 key，需要发送的数据为 value，形成一个 request 请求，放在 InFlightRequests 队列中</li><li>若请求没有及时应答，仍可以继续发送请求，但每个 Broker 节点最多缓存 <strong>5</strong> 个请求</li><li>发送到 Broker 后，集群通过副本同步机制创建副本</li><li>若应答成功，生产者清理请求，并且清理缓冲队列中的数据</li><li>若应答失败，则请求重试，次数为 <code>retries</code>，默认为 int 的最大值，直到重试成功</li></ul></li></ul></li><li><strong>Selector</strong>：打通发送数据到 Broker 的链路</li></ul><h3 id="2、-应答机制"><a href="#2、-应答机制" class="headerlink" title="2、 应答机制"></a>2、 应答机制</h3><ul><li><p><strong>acks</strong>： </p><ul><li><p><strong>0</strong>：生产者发送的数据无需 Leader 应答。若 Leader 宕机且未落盘，则数据丢失。生产环境一般不用</p></li><li><p><strong>1</strong>：生产者发送的数据 Leader 落盘后应答。若 Leader 落盘应答后宕机，但尚未同步副本，则数据丢失（新的 Leader 没有该数据）。一般用于日志传输</p></li><li><p><strong>-1&#x2F;all</strong>：生产者发送的数据，Leader 和 ISR 队列的节点落盘后应答。一般用于可靠性要求高的场景，如金钱交易</p></li><li><p>如果分区副本设为 1 个，或者 ISR 里应答的最小副本数量（<code>min.insync.replicas</code>，默认 1）设为 1 个，此时相当于 ack 为 1</p></li></ul></li><li><p><strong>ISR 队列</strong>：</p><ul><li>Leader 维护了一个动态的 in-sync replica set（ISR）队列，表示和 Leader 保持同步的 Follower + Leader 集合（如 Leader: 0，ISR: 0,1,2）</li><li>如果 Follower 一段时间（<code>replica.lag.time.max.ms</code>，默认 30s）未向 Leader 发送通信请求或同步数据，则该 Follower 会从 ISR 队列中移除</li></ul></li></ul><h3 id="3、生产者重要参数"><a href="#3、生产者重要参数" class="headerlink" title="3、生产者重要参数"></a>3、生产者重要参数</h3><table><thead><tr><th>参数名称</th><th>描述</th></tr></thead><tbody><tr><td>bootstrap.servers</td><td>Broker 地址，用逗号分隔</td></tr><tr><td>key.serializer &#x2F; value.serializer</td><td>序列化类型的全类名</td></tr><tr><td>buffer.memory</td><td>RecordAccumulator 缓冲区总大小，默认 32M</td></tr><tr><td>batch.size</td><td>缓冲区一批数据的最大值，默认 16K</td></tr><tr><td>linger.ms</td><td>如果数据未达到 batch.size，sender 等待 linger.time 后发送数据。默认 0ms，建议 5~100ms</td></tr><tr><td>acks</td><td>见上文，默认 -1</td></tr><tr><td>max.in.flight.requests.per.connection</td><td>允许最多没有返回 ack 的次数，默认 5，开启幂等性要保证该值是 1~5</td></tr><tr><td>retries</td><td>消息发送失败时，系统重发消息的重试次数，默认 int 最大值。如果开启重试且要保证有序性，需设 max.in.flight.requests.per.connection 为 1，否则重试时其他消息可能发送成功了</td></tr><tr><td>retry.backoff.ms</td><td>两次重试之间的时间间隔，默认 100ms</td></tr><tr><td>enable.idempotence</td><td>是否开启幂等性，默认 true</td></tr><tr><td>compression.type</td><td>生产者发送数据的压缩方式，默认 none，可设置为 gzip、snappy、lz4、zstd</td></tr></tbody></table><h2 id="三、Kafka-消息存储原理"><a href="#三、Kafka-消息存储原理" class="headerlink" title="三、Kafka 消息存储原理"></a>三、Kafka 消息存储原理</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217225359339.png" alt="image-20250217225359339"></p><p>Kafka 的文件存储机制是其高效处理海量数据的关键设计之一，主要通过主题（Topic）、分区（Partition）、分段（Segment）以及索引机制实现高效的数据存储和查询。以下是 Kafka 文件存储机制的核心内容：</p><h3 id="1、存储结构"><a href="#1、存储结构" class="headerlink" title="1、存储结构"></a><strong>1、存储结构</strong></h3><p>Kafka 的存储结构基于 <strong>主题（Topic）+ 分区（Partition）+ 分段（Segment）</strong> 的设计：</p><ul><li><strong>主题（Topic）</strong>：逻辑上的数据分类单元，生产者和消费者通过 Topic 进行数据的发送和接收。</li><li><strong>分区（Partition）</strong>：物理存储单元，每个 Topic 被划分为多个 Partition，分布在不同的 Broker 上，用于水平扩展和负载均衡。</li><li><strong>分段（Segment）</strong>：Partition 被进一步划分为多个 Segment，每个 Segment 包含一个 <code>.log</code> 数据文件和一个 <code>.index</code> 索引文件。</li></ul><h3 id="2、-数据文件与索引文件"><a href="#2、-数据文件与索引文件" class="headerlink" title="2、 数据文件与索引文件"></a><strong>2、 数据文件与索引文件</strong></h3><p>每个 Partition 的数据以 Segment 的形式存储，每个 Segment 包含以下文件：</p><ul><li><strong><code>.log</code> 文件</strong>：存储实际的消息数据，消息以追加的方式写入，确保写入操作的高效性。</li><li><strong><code>.index</code> 文件</strong>：存储消息的偏移量（Offset）和物理位置的映射关系，用于快速定位消息。</li><li><strong><code>.timeindex</code> 文件</strong>：存储消息的时间戳和物理位置的映射关系，用于根据时间戳快速查询消息。</li></ul><h3 id="3、-索引机制"><a href="#3、-索引机制" class="headerlink" title="3、 索引机制"></a><strong>3、 索引机制</strong></h3><p>Kafka 使用稀疏索引（Sparse Index）来优化消息的查询效率：</p><ul><li><strong>稀疏索引</strong>：只记录每个 Segment 中部分消息的索引信息，通过二分查找快速定位到目标消息所在的 Segment。</li><li><strong>索引文件结构</strong>：每个索引项包含消息的相对偏移量和物理位置，通过这种方式可以快速从 <code>.log</code> 文件中读取消息。</li></ul><h3 id="4、-数据写入与读取"><a href="#4、-数据写入与读取" class="headerlink" title="4、 数据写入与读取"></a><strong>4、 数据写入与读取</strong></h3><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a><strong>写入机制</strong></h4><ul><li>生产者将消息追加到 Partition 的 <code>.log</code> 文件末尾，这种方式是顺序写入，效率极高。</li><li>数据首先写入操作系统的 Page Cache，然后由 Kafka 的后台线程异步刷入磁盘。</li></ul><h4 id="读取机制"><a href="#读取机制" class="headerlink" title="读取机制"></a><strong>读取机制</strong></h4><ul><li>消费者根据 Offset 从 <code>.index</code> 文件中快速定位消息的物理位置，然后从 <code>.log</code> 文件中读取消息。</li><li>如果消息不在 Page Cache 中，Kafka 会从磁盘加载数据到 Page Cache，然后直接发送给消费者。</li></ul><h3 id="5、-数据清理机制"><a href="#5、-数据清理机制" class="headerlink" title="5、 数据清理机制"></a><strong>5、 数据清理机制</strong></h3><p>Kafka 提供了两种数据清理策略：</p><ul><li><strong>基于时间</strong>：默认保留消息 7 天。</li><li><strong>基于大小</strong>：默认每个 Partition 的日志大小限制为 1GB。</li></ul><p>过期的 Segment 文件会被自动删除，从而释放磁盘空间。</p><h3 id="6、-高效存储设计特点"><a href="#6、-高效存储设计特点" class="headerlink" title="6、 高效存储设计特点"></a><strong>6、 高效存储设计特点</strong></h3><ul><li><strong>顺序写入</strong>：消息追加到 <code>.log</code> 文件末尾，避免随机写入的性能开销。</li><li><strong>零拷贝技术</strong>：通过 <code>sendfile</code> 和 <code>mmap</code>，减少数据在内核态和用户态之间的拷贝。</li><li><strong>分段存储</strong>：将大文件划分为多个小文件，便于管理和清理。</li><li><strong>稀疏索引</strong>：大幅减少索引文件的大小，同时提高查询效率。</li></ul><p>通过以上机制，Kafka 实现了高效的数据存储和查询，同时保证了系统的高吞吐量和可扩展性。</p><h2 id="四、-Kafka-消费原理"><a href="#四、-Kafka-消费原理" class="headerlink" title="四、 Kafka 消费原理"></a>四、 Kafka 消费原理</h2><h3 id="1、-消费方式"><a href="#1、-消费方式" class="headerlink" title="1、 消费方式"></a>1、 消费方式</h3><p>kafka采用发布订阅模式：一对多。发布订阅模式又分两种：</p><ul><li>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成 consumer 来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而 pull 模式则可以根据 consumer 的消费能力以适当的速率消费消息。</li><li>kafka consumer 采用 pull（拉）模式从 broker 中读取数据。pull 模式不足之处是，如果 kafka 没有数据，消费者可能会陷入循环中，一直返回空数据。针对这一点，Kafka 的消费者在消费数据时会传入一个时长参数 timeout，如果当前没有数据可供消费，consumer 会等待一段时间之后再返回，这段时长即为 timeout。</li></ul><h3 id="2、-消费者和消费者组"><a href="#2、-消费者和消费者组" class="headerlink" title="2、 消费者和消费者组"></a>2、 消费者和消费者组</h3><ul><li><strong>一个消费者</strong> 从一个Topic中消费数据 ：</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000037747257" alt="img"></p><ul><li><strong>2. 消费者群组 :</strong><br>当生产者向 Topic 写入消息的速度超过了现有消费者的处理速度，此时需要对消费者进行横向伸缩，用多个消费者从同一个主题读取消息，对消息进行分流。<strong>同一个分区不能被一个组中的多个 consumer 消费。</strong></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000037747258" alt="two"></p><h3 id="3、-分区分配策略"><a href="#3、-分区分配策略" class="headerlink" title="3、 分区分配策略"></a>3、 分区分配策略</h3><p>在 Kafka 中，一个主题（Topic）被划分为多个分区（Partition），每个分区只能由一个消费者组（Consumer Group）中的一个消费者（Consumer）消费。分区分配的目标是将分区均匀地分配给消费者组中的消费者，从而实现负载均衡。</p><p>Kafka 提供了多种分区分配策略，这些策略通过 <code>partition.assignment.strategy</code> 参数配置。常用的分配策略包括：</p><h4 id="Range"><a href="#Range" class="headerlink" title="Range"></a><strong>Range</strong></h4><p>RangeAssignor 是 Kafka 最早支持的分区分配策略之一。它的核心思想是将分区按范围分配给消费者，具体步骤如下：</p><ol><li>对所有分区和消费者按序编号。</li><li>计算每个消费者应分配的分区范围，确保分区均匀分配。</li><li>如果分区数不能被消费者数整除，多余的分区会分配给前几个消费者。</li></ol><p><strong>特点</strong>：</p><ul><li>简单直观，适合分区数较多、消费者数较少的场景。</li><li>分区分配连续，便于管理，但可能不够灵活。</li></ul><h4 id="RoundRobin"><a href="#RoundRobin" class="headerlink" title="RoundRobin"></a><strong>RoundRobin</strong></h4><p>RoundRobinAssignor 是另一种经典的分区分配策略，它通过轮询的方式将分区分配给消费者，具体步骤如下：</p><ol><li>将所有分区和消费者按序排列。</li><li>从第一个分区开始，依次分配给每个消费者，直到所有分区分配完毕。</li></ol><p><strong>特点</strong>：</p><ul><li>分区分配均匀，适合分区数和消费者数相近的场景。</li><li>不依赖分区的顺序，更加灵活。</li></ul><h4 id="StickyAssignor（粘性分配）"><a href="#StickyAssignor（粘性分配）" class="headerlink" title="StickyAssignor（粘性分配）"></a><strong>StickyAssignor（粘性分配）</strong></h4><p>StickyAssignor 是 Kafka 0.11.0.0 版本引入的分区分配策略，其目标是在保证分区分配均衡的前提下，尽量保持原有的分区分配结果，减少不必要的分区重新分配。</p><p><strong>特点</strong>：</p><ul><li>在消费者组成员变化时，尽量减少分区的重新分配，降低对系统的影响。</li><li>适合动态扩展消费者组的场景。</li></ul><h3 id="4、-Offset-维护"><a href="#4、-Offset-维护" class="headerlink" title="4、 Offset 维护"></a>4、 Offset 维护</h3><p>在 Kafka 中，偏移量（Offset）是消费者在分区中读取消息的位置标识，正确管理偏移量对于确保消息的可靠消费、避免重复处理或丢失至关重要。以下是 Kafka 偏移量维护的核心原理和策略：</p><p><strong>偏移量的作用</strong>： 偏移量记录了消费者在分区中的消费进度，用于：</p><ul><li>确保消息不会被重复消费或遗漏。</li><li>在消费者故障或重启后，能够从上次提交的偏移量处恢复消费。</li></ul><p><strong>偏移量的维护策略</strong>： Kafka 提供了两种偏移量提交策略—— <strong>自动提交</strong>和<strong>手动提交</strong>。</p><h4 id="4-1-自动提交"><a href="#4-1-自动提交" class="headerlink" title="4.1 自动提交"></a><strong>4.1 自动提交</strong></h4><p>自动提交是 Kafka 的默认行为，消费者在每次轮询（poll）后自动提交偏移量。这种方式简单方便，但可能会导致消息重复消费或丢失。</p><ul><li><strong>配置参数</strong>：<ul><li><code>enable.auto.commit</code>：默认为 <code>true</code>，启用自动提交。</li><li><code>auto.commit.interval.ms</code>：自动提交的间隔时间，默认为 5 秒。</li></ul></li></ul><h4 id="4-2-手动提交"><a href="#4-2-手动提交" class="headerlink" title="4.2 手动提交"></a><strong>4.2 手动提交</strong></h4><p>手动提交需要消费者显式调用提交偏移量的 API，这种方式提供了更细粒度的控制，能够确保消息处理成功后再提交偏移量。</p><ul><li><p><strong>同步提交</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.commitSync();</span><br></pre></td></tr></table></figure><p>同步提交会阻塞直到偏移量提交成功。</p></li><li><p><strong>异步提交</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Error committing offsets: &quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>异步提交会立即返回，提交操作在后台进行，适合高吞吐量场景，但需要处理提交失败的异常。</p></li></ul><h4 id="4-3-偏移量的重置策略"><a href="#4-3-偏移量的重置策略" class="headerlink" title="4.3 偏移量的重置策略"></a>4.3 偏移量的重置策略</h4><p>当消费者启动时，如果 Kafka 中没有保存的偏移量，或者偏移量无效，消费者会根据 <code>auto.offset.reset</code> 参数决定如何处理：</p><ul><li><code>earliest</code>：从分区的最早消息开始消费。</li><li><code>latest</code>：从分区的最新消息开始消费。</li><li><code>none</code>：如果找不到偏移量，则抛出异常。</li></ul><h4 id="4-4-高级偏移量管理"><a href="#4-4-高级偏移量管理" class="headerlink" title="4.4 高级偏移量管理"></a><strong>4.4 高级偏移量管理</strong></h4><p>在一些复杂场景下，可能需要更细粒度的偏移量控制：</p><ul><li><p><strong>指定偏移量消费</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">consumer.assign(Arrays.asList(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(<span class="string">&quot;topic&quot;</span>, <span class="number">0</span>)));</span><br><span class="line">consumer.seek(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(<span class="string">&quot;topic&quot;</span>, <span class="number">0</span>), <span class="number">10</span>); <span class="comment">// 从偏移量 10 开始消费</span></span><br></pre></td></tr></table></figure><p>这种方式允许消费者从特定偏移量处开始消费。</p></li><li><p><strong>基于时间戳的偏移量查询</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;TopicPartition, Long&gt; timestamps = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">timestamps.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(<span class="string">&quot;topic&quot;</span>, <span class="number">0</span>), System.currentTimeMillis());</span><br><span class="line">Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsets = consumer.offsetsForTimes(timestamps);</span><br></pre></td></tr></table></figure><p>通过 <code>offsetsForTimes</code> 方法，可以根据时间戳查询对应的偏移量。</p></li></ul><h4 id="4-5-偏移量存储"><a href="#4-5-偏移量存储" class="headerlink" title="4.5 偏移量存储"></a>4.5 偏移量存储</h4><p>Kafka 默认将偏移量存储在内部主题 <code>__consumer_offsets</code> 中，但也可以通过外部存储（如数据库）来管理偏移量，以实现更灵活的偏移量管理。</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一致性 Hash 详解</title>
      <link href="/2024/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E4%B8%80%E8%87%B4%E6%80%A7Hash%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E4%B8%80%E8%87%B4%E6%80%A7Hash%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="一致性Hash-详解"><a href="#一致性Hash-详解" class="headerlink" title="一致性Hash 详解"></a>一致性Hash 详解</h1><p>分布式系统中对象与节点的映射关系，传统方案是使用对象的哈希值，对节点个数取模，再映射到相应编号的节点，这种方案在节点个数变动时，绝大多数对象的映射关系会失效而需要迁移；而一致性哈希算法中，当节点个数变动时，映射关系失效的对象非常少，迁移成本也非常小。本文总结了一致性哈希的算法原理和Java实现，并列举了其应用。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-传统哈希-硬哈希"><a href="#1-1-传统哈希-硬哈希" class="headerlink" title="1.1 传统哈希(硬哈希)"></a>1.1 传统哈希(硬哈希)</h3><p>分布式系统中，假设有 n 个节点，传统方案使用 mod(key, n) 映射数据和节点。 当扩容或缩容时(哪怕只是增减1个节点)，映射关系变为 mod(key, n+1) &#x2F; mod(key, n-1)，绝大多数数据的映射关系都会失效。</p><h3 id="1-2-一致性哈希-Consistent-Hashing"><a href="#1-2-一致性哈希-Consistent-Hashing" class="headerlink" title="1.2 一致性哈希(Consistent Hashing)"></a>1.2 一致性哈希(Consistent Hashing)</h3><p>1997年，麻省理工学院(MIT)的 David Karger 等6个人发布学术论文《Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web（一致性哈希和随机树：用于缓解万维网上热点的分布式缓存协议）》，对于 K 个关键字和 n 个槽位(分布式系统中的节点)的哈希表，增减槽位后，平均只需对 K&#x2F;n 个关键字重新映射。</p><h3 id="1-3-哈希指标"><a href="#1-3-哈希指标" class="headerlink" title="1.3 哈希指标"></a>1.3 哈希指标</h3><p>评估一个哈希算法的优劣，有如下指标，而一致性哈希全部满足：</p><ul><li>**均衡性(Balance)**：将关键字的哈希地址均匀地分布在地址空间中，使地址空间得到充分利用，这是设计哈希的一个基本特性。</li><li><strong>单调性(Monotonicity)</strong>: 单调性是指当地址空间增大时，通过哈希函数所得到的关键字的哈希地址也能映射的新的地址空间，而不是仅限于原先的地址空间。或等地址空间减少时，也是只能映射到有效的地址空间中。简单的哈希函数往往不能满足此性质。</li><li><strong>分散性(Spread)</strong>: 哈希经常用在分布式环境中，终端用户通过哈希函数将自己的内容存到不同的缓冲区。此时，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</li><li><strong>负载(Load)</strong>: 负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li></ul><h2 id="2-算法原理"><a href="#2-算法原理" class="headerlink" title="2 算法原理"></a>2 算法原理</h2><h3 id="2-1-映射方案"><a href="#2-1-映射方案" class="headerlink" title="2.1 映射方案"></a>2.1 映射方案</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/wpwqmsk5jd.jpeg" alt="img"></p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="2-1-1-公用哈希函数和哈希环"><a href="#2-1-1-公用哈希函数和哈希环" class="headerlink" title="2.1.1 公用哈希函数和哈希环"></a>2.1.1 公用哈希函数和哈希环</h4><p>设计哈希函数 Hash(key)，要求取值范围为 [0, 2^32) 各哈希值在上图 Hash 环上的分布：时钟12点位置为0，按顺时针方向递增，临近12点的左侧位置为2^32-1。</p><h4 id="2-1-2-节点-Node-映射至哈希环"><a href="#2-1-2-节点-Node-映射至哈希环" class="headerlink" title="2.1.2 节点(Node)映射至哈希环"></a>2.1.2 节点(Node)映射至哈希环</h4><p>如图哈希环上的绿球所示，四个节点 Node A&#x2F;B&#x2F;C&#x2F;D， 其 IP 地址或机器名，经过同一个 Hash() 计算的结果，映射到哈希环上。</p><h4 id="2-1-3-对象-Object-映射于哈希环"><a href="#2-1-3-对象-Object-映射于哈希环" class="headerlink" title="2.1.3 对象(Object)映射于哈希环"></a>2.1.3 对象(Object)映射于哈希环</h4><p>如图哈希环上的黄球所示，四个对象 Object A&#x2F;B&#x2F;C&#x2F;D， 其键值，经过同一个 Hash() 计算的结果，映射到哈希环上。</p><h4 id="2-1-4-对象-Object-映射至节点-Node"><a href="#2-1-4-对象-Object-映射至节点-Node" class="headerlink" title="2.1.4 对象(Object)映射至节点(Node)"></a>2.1.4 对象(Object)映射至节点(Node)</h4><p>在对象和节点都映射至同一个哈希环之后，要确定某个对象映射至哪个节点， 只需从该对象开始，沿着哈希环顺时针方向查找，找到的第一个节点，即是。 可见，Object A&#x2F;B&#x2F;C&#x2F;D 分别映射至 Node A&#x2F;B&#x2F;C&#x2F;D。</p><h3 id="2-2-删除节点"><a href="#2-2-删除节点" class="headerlink" title="2.2 删除节点"></a>2.2 删除节点</h3><p>现实场景：服务器缩容时删除节点，或者有节点宕机。如下图，要删除节点 Node C： 只会影响欲删除节点(Node C)与上一个(顺时针为前进方向)节点(Node B)与之间的对象，也就是 Object C， 这些对象的映射关系，按照 2.1.4 的规则，调整映射至欲删除节点的下一个节点 Node D。 其他对象的映射关系，都无需调整。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/ksr83gb3pk.jpeg" alt="img"></p><h4 id="2-3-增加节点"><a href="#2-3-增加节点" class="headerlink" title="2.3 增加节点"></a>2.3 增加节点</h4><p>现实场景：服务器扩容时增加节点。比如要在 Node B&#x2F;C 之间增加节点 Node X： 只会影响欲新增节点(Node X)与上一个(顺时针为前进方向)节点(Node B)与之间的对象，也就是 Object C， 这些对象的映射关系，按照 2.1.4 的规则，调整映射至新增的节点 Node X。 其他对象的映射关系，都无需调整。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/29li72wnhn.jpeg" alt="img"></p><h4 id="2-4-虚拟节点"><a href="#2-4-虚拟节点" class="headerlink" title="2.4 虚拟节点"></a>2.4 虚拟节点</h4><p>对于前面的方案，节点数越少，越容易出现节点在哈希环上的分布不均匀，导致各节点映射的对象数量严重不均衡(数据倾斜)；相反，节点数越多越密集，数据在哈希环上的分布就越均匀。 但实际部署的物理节点有限，我们可以用有限的物理节点，虚拟出足够多的虚拟节点(Virtual Node)，最终达到数据在哈希环上均匀分布的效果： 如下图，实际只部署了2个节点 Node A&#x2F;B， 每个节点都复制成3倍，结果看上去是部署了6个节点。 可以想象，当复制倍数为 2^32 时，就达到绝对的均匀，通常可取复制倍数为32或更高。 虚拟节点哈希值的计算方法调整为：对“节点的IP(或机器名)+虚拟节点的序号(1~N)”作哈希。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/0xopzy41xs.jpeg" alt="img"></p><h3 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3 算法实现"></a>3 算法实现</h3><p>一致性哈希算法有多种具体的实现，包括 Chord 算法，KAD 算法等，都比较复杂。 这里给出一个简易实现及其演示，可以看到一致性哈希的均衡性和单调性的优势。 单调性在本例中没有统计数据，但根据前面原理可知，增删节点后只有很少量的数据需要调整映射关系。</p><h4 id="3-1-源码实现"><a href="#3-1-源码实现" class="headerlink" title="3.1 源码实现"></a>3.1 源码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashing</span> &#123;</span><br><span class="line">    <span class="comment">// 物理节点</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; physicalNodes = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            add(<span class="string">&quot;192.168.1.101&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;192.168.1.102&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;192.168.1.103&quot;</span>);</span><br><span class="line">            add(<span class="string">&quot;192.168.1.104&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VIRTUAL_COPIES</span> <span class="operator">=</span> <span class="number">1048576</span>; <span class="comment">// 物理节点至虚拟节点的复制倍数</span></span><br><span class="line">    <span class="keyword">private</span> TreeMap&lt;Long, String&gt; virtualNodes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// 哈希值 =&gt; 物理节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 32位的 Fowler-Noll-Vo 哈希算法</span></span><br><span class="line">    <span class="comment">// https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long <span class="title function_">FNVHash</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">16777619</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">hash</span> <span class="operator">=</span> <span class="number">2166136261L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>, num = key.length(); idx &lt; num; ++idx) &#123;</span><br><span class="line">            hash = (hash ^ key.charAt(idx)) * p;</span><br><span class="line">        &#125;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">7</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">3</span>;</span><br><span class="line">        hash ^= hash &gt;&gt; <span class="number">17</span>;</span><br><span class="line">        hash += hash &lt;&lt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            hash = Math.abs(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据物理节点，构建虚拟节点映射表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConsistentHashing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String nodeIp : physicalNodes) &#123;</span><br><span class="line">            addPhysicalNode(nodeIp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加物理节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addPhysicalNode</span><span class="params">(String nodeIp)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; VIRTUAL_COPIES; ++idx) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> FNVHash(nodeIp + <span class="string">&quot;#&quot;</span> + idx);</span><br><span class="line">            virtualNodes.put(hash, nodeIp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除物理节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removePhysicalNode</span><span class="params">(String nodeIp)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; idx &lt; VIRTUAL_COPIES; ++idx) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> FNVHash(nodeIp + <span class="string">&quot;#&quot;</span> + idx);</span><br><span class="line">            virtualNodes.remove(hash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找对象映射的节点</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjectNode</span><span class="params">(String object)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">hash</span> <span class="operator">=</span> FNVHash(object);</span><br><span class="line">        SortedMap&lt;Long, String&gt; tailMap = virtualNodes.tailMap(hash); <span class="comment">// 所有大于 hash 的节点</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">key</span> <span class="operator">=</span> tailMap.isEmpty() ? virtualNodes.firstKey() : tailMap.firstKey();</span><br><span class="line">        <span class="keyword">return</span> virtualNodes.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计对象与节点的映射关系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dumpObjectNodeMap</span><span class="params">(String label, <span class="type">int</span> objectMin, <span class="type">int</span> objectMax)</span> &#123;</span><br><span class="line">        <span class="comment">// 统计</span></span><br><span class="line">        Map&lt;String, Integer&gt; objectNodeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(); <span class="comment">// IP =&gt; COUNT</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">object</span> <span class="operator">=</span> objectMin; object &lt;= objectMax; ++object) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nodeIp</span> <span class="operator">=</span> getObjectNode(Integer.toString(object));</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> objectNodeMap.get(nodeIp);</span><br><span class="line">            objectNodeMap.put(nodeIp, (count == <span class="literal">null</span> ? <span class="number">0</span> : count + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">totalCount</span> <span class="operator">=</span> objectMax - objectMin + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;======== &quot;</span> + label + <span class="string">&quot; ========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : objectNodeMap.entrySet()) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">percent</span> <span class="operator">=</span> (<span class="type">int</span>) (<span class="number">100</span> * entry.getValue() / totalCount);</span><br><span class="line">            System.out.println(<span class="string">&quot;IP=&quot;</span> + entry.getKey() + <span class="string">&quot;: RATE=&quot;</span> + percent + <span class="string">&quot;%&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConsistentHashing</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConsistentHashing</span>();</span><br><span class="line">        <span class="comment">// 初始情况</span></span><br><span class="line">        ch.dumpObjectNodeMap(<span class="string">&quot;初始情况&quot;</span>, <span class="number">0</span>, <span class="number">65536</span>);</span><br><span class="line">        <span class="comment">// 删除物理节点</span></span><br><span class="line">        ch.removePhysicalNode(<span class="string">&quot;192.168.1.103&quot;</span>);</span><br><span class="line">        ch.dumpObjectNodeMap(<span class="string">&quot;删除物理节点&quot;</span>, <span class="number">0</span>, <span class="number">65536</span>);</span><br><span class="line">        <span class="comment">// 添加物理节点</span></span><br><span class="line">        ch.addPhysicalNode(<span class="string">&quot;192.168.1.108&quot;</span>);</span><br><span class="line">        ch.dumpObjectNodeMap(<span class="string">&quot;添加物理节点&quot;</span>, <span class="number">0</span>, <span class="number">65536</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-应用"><a href="#4-应用" class="headerlink" title="4 应用"></a>4 应用</h2><p>一致性哈希是分布式系统组件负载均衡的首选算法，它既可以在客户端实现，也可以在中间件上实现。其应用有：</p><ul><li>分布式散列表(DHT)的设计；</li><li>分布式关系数据库(MySQL)：分库分表时，计算数据与节点的映射关系；</li><li>分布式缓存：Memcached 的客户端实现了一致性哈希，还可以使用中间件 twemproxy 管理 redis&#x2F;memcache 集群；</li><li>RPC 框架 Dubbo：用来选择服务提供者；</li><li>亚马逊的云存储系统 Dynamo；</li><li>分布式 Web 缓存；</li><li>Bittorrent DHT；</li><li>LVS。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务总结</title>
      <link href="/2024/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2024/12/01/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务总结"><a href="#分布式事务总结" class="headerlink" title="分布式事务总结"></a>分布式事务总结</h1><p>在分布式系统中一次操作需要由多个服务协同完成，这种由不同的服务之间通过网络协同完成的事务称为分布式事务</p><p>目前常用的分布式事务解决方案包含以下几种</p><h2 id="一、2PC："><a href="#一、2PC：" class="headerlink" title="一、2PC："></a>一、2PC：</h2><p> 2PC，两阶段提交，将事务的提交过程分为资源准备和资源提交两个阶段，并且由事务协调者来协调所有事务参与者，如果准备阶段所有事务参与者都预留资源成功，则进行第二阶段的资源提交，否则事务协调者回滚资源。</p><h3 id="1、第一阶段：准备阶段"><a href="#1、第一阶段：准备阶段" class="headerlink" title="1、第一阶段：准备阶段"></a>1、第一阶段：准备阶段</h3><p>由事务协调者询问通知各个事务参与者，是否准备好了执行事务，具体流程图如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/6bed52512281daa18cf6b26b04b805c1.png" alt="img"></p><ul><li><p>协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待答复</p></li><li><p>各参与者执行本地事务操作，将 undo 和 redo 信息记入事务日志中（但不提交事务）</p></li><li><p>如参与者执行成功，给协调者反馈同意，否则反馈中止，表示事务不可以执行</p></li></ul><h3 id="2、第二阶段：提交阶段"><a href="#2、第二阶段：提交阶段" class="headerlink" title="2、第二阶段：提交阶段"></a>2、第二阶段：提交阶段</h3><p>协调者收到各个参与者的准备消息后，根据反馈情况通知各个参与者commit提交或者rollback回滚</p><h4 id="（1）事务提交："><a href="#（1）事务提交：" class="headerlink" title="（1）事务提交："></a>（1）事务提交：</h4><p>当第一阶段所有参与者都反馈同意时，协调者发起正式提交事务的请求，当所有参与者都回复同意时，则意味着完成事务，具体流程如下：</p><ul><li><p>协调者节点向所有参与者节点发出正式提交的 commit 请求。</p></li><li><p>收到协调者的 commit 请求后，参与者正式执行事务提交操作，并释放在整个事务期间内占用的资源。</p></li><li><p>参与者完成事务提交后，向协调者节点发送ACK消息。</p></li><li><p>协调者节点收到所有参与者节点反馈的ACK消息后，完成事务。</p></li></ul><p>所以，正常提交时，事务的完整流程图如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/98b7b50902b02eebb65cb5e47afc29f7.png" alt="img"></p><h4 id="（2）事务回滚："><a href="#（2）事务回滚：" class="headerlink" title="（2）事务回滚："></a>（2）事务回滚：</h4><p>如果任意一个参与者节点在第一阶段返回的消息为中止，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时，那么这个事务将会被回滚，具体流程如下：</p><ul><li><p>协调者向所有参与者发出 rollback 回滚操作的请求</p></li><li><p>参与者利用阶段一写入的undo信息执行回滚，并释放在整个事务期间内占用的资源</p></li><li><p>参与者在完成事务回滚之后，向协调者发送回滚完成的ACK消息</p></li><li><p>协调者收到所有参与者反馈的ACK消息后，取消事务</p></li></ul><p>所以，事务回滚时，完整流程图如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/bd005f7012197b1edb5e8abbc55617f5.png" alt="img"></p><h3 id="3、2PC的缺点："><a href="#3、2PC的缺点：" class="headerlink" title="3、2PC的缺点："></a>3、2PC的缺点：</h3><p>二阶段提交确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p><ul><li><strong>性能问题</strong>：执行过程中，所有参与节点都是事务阻塞性的，当参与者占有公共资源时，其他第三方节点访问公共资源就不得不处于阻塞状态，为了数据的一致性而牺牲了可用性，对性能影响较大，不适合高并发高性能场景</li><li><strong>可靠性问题</strong>：2PC非常依赖协调者，当协调者发生故障时，尤其是第二阶段，那么所有的参与者就会都处于锁定事务资源的状态中，而无法继续完成事务操作（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</li><li><strong>数据一致性问题</strong>：在阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li><li><strong>二阶段无法解决的问题</strong>：协调者在发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了，那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ul><h2 id="二、3PC："><a href="#二、3PC：" class="headerlink" title="二、3PC："></a>二、3PC：</h2><p>3PC，三阶段提交协议，是二阶段提交协议的改进版本，三阶段提交有两个改动点：</p><ul><li>在协调者和参与者中都引入超时机制</li><li>在第一阶段和第二阶段中插入一个准备阶段，保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>所以3PC会分为3个阶段，CanCommit 准备阶段、PreCommit 预提交阶段、DoCommit 提交阶段，处理流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/cbaf836526bd932362ee664c77b3f8e8.png" alt="img"></p><h3 id="阶段一：CanCommit-准备阶段"><a href="#阶段一：CanCommit-准备阶段" class="headerlink" title="阶段一：CanCommit 准备阶段"></a>阶段一：CanCommit 准备阶段</h3><p>协调者向参与者发送 canCommit 请求，参与者如果可以提交就返回Yes响应，否则返回No响应，具体流程如下：</p><p>（1）<strong>事务询问</strong>：协调者向所有参与者发出包含事务内容的 canCommit 请求，询问是否可以提交事务，并等待所有参与者答复。<br>（2）<strong>响应反馈</strong>：参与者收到 canCommit 请求后，如果认为可以执行事务操作，则反馈 yes 并进入预备状态，否则反馈 no。</p><h3 id="阶段二：PreCommit-阶段"><a href="#阶段二：PreCommit-阶段" class="headerlink" title="阶段二：PreCommit 阶段"></a>阶段二：PreCommit 阶段</h3><p>协调者根据参与者的反应情况来决定是否可以进行事务的 PreCommit 操作。根据响应情况，有以下两种可能：</p><h4 id="（1）执行事务："><a href="#（1）执行事务：" class="headerlink" title="（1）执行事务："></a>（1）执行事务：</h4><p>假如所有参与者均反馈 yes，协调者预执行事务，具体如下：</p><ul><li><strong>发送预提交请求</strong>：协调者向参与者发送 PreCommit 请求，并进入准备阶段</li><li><strong>事务预提交</strong> ：参与者接收到 PreCommit 请求后，会执行本地事务操作，并将 undo 和 redo 信息记录到事务日志中（但不提交事务）</li><li><strong>响应反馈</strong> ：如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/ba34b5d7980fc051bd9b274cc135bcb0.png" alt="img"></p><h4 id="（2）中断事务："><a href="#（2）中断事务：" class="headerlink" title="（2）中断事务："></a>（2）中断事务：</h4><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断，流程如下：</p><ul><li><strong>发送中断请求</strong> ：协调者向所有参与者发送 abort 请求。</li><li><strong>中断事务</strong> ：参与者收到来自协调者的 abort 请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/8d00689783a6ea10a843f4cf3bef54c3.png" alt="img"></p><h3 id="阶段三：doCommit阶段"><a href="#阶段三：doCommit阶段" class="headerlink" title="阶段三：doCommit阶段"></a>阶段三：doCommit阶段</h3><p>该阶段进行真正的事务提交，也可以分为以下两种情况：</p><h4 id="（1）提交事务："><a href="#（1）提交事务：" class="headerlink" title="（1）提交事务："></a>（1）提交事务：</h4><ul><li><p>发送提交请求：协调接收到所有参与者发送的ACK响应，那么他将从预提交状态进入到提交状态，并向所有参与者发送 doCommit 请求</p></li><li><p>本地事务提交：参与者接收到doCommit请求之后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源</p></li><li><p>响应反馈：事务提交完之后，向协调者发送ack响应。</p></li><li><p>完成事务：协调者接收到所有参与者的ack响应之后，完成事务。</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/6d6c26e7fb78ee605e18231e3bd8ebcd.png" alt="img"></p><h4 id="（2）中断事务：-1"><a href="#（2）中断事务：-1" class="headerlink" title="（2）中断事务："></a>（2）中断事务：</h4><p>任何一个参与者反馈 no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务</p><ul><li><p>发送中断请求：如果协调者处于工作状态，向所有参与者发出 abort 请求</p></li><li><p>事务回滚：参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li><li><p>反馈结果：参与者完成事务回滚之后，向协调者反馈ACK消息</p></li><li><p>中断事务：协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/e17f344a28ff044e857f712251b979ed.png" alt="img"></p><p>进入doCommit阶段后，无论协调者出现问题，或者协调者与参与者之间的网络出现问题，都会导致参与者无法接收到协调者发出的 doCommit 请求或 abort 请求。此时，参与者都会在等待超时之后，继续执行事务提交。这其实基于概率来决定的，当进入第三阶段时，说明第一阶段收到所有参与者的CanCommit响应都是Yes，意味着大家都同意修改了，并且第二阶段所有的参与者对协调者的PreCommit请求也都是同意的。所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到commit或者abort响应，但是他有理由相信：成功提交的几率很大。</p><h3 id="4、3PC的优缺点："><a href="#4、3PC的优缺点：" class="headerlink" title="4、3PC的优缺点："></a>4、3PC的优缺点：</h3><ul><li><p>与2PC相比，3PC降低了阻塞范围，并且在等待超时后，协调者或参与者会中断事务，避免了协调者单点问题，阶段三中协调者出现问题时，参与者会继续提交事务。</p></li><li><p>数据不一致问题依然存在，当在参与者收到 preCommit 请求后等待 doCommit 指令时，此时如果协调者请求中断事务，而协调者因为网络问题无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</p></li><li><p>2PC和3PC都无法保证数据绝对的一致性，一般为了预防这种问题，可以添加一个报警，比如监控到事务异常的时候，通过脚本自动补偿差异的信息。</p></li></ul><h2 id="三、TCC："><a href="#三、TCC：" class="headerlink" title="三、TCC："></a>三、TCC：</h2><h3 id="1、什么是TCC："><a href="#1、什么是TCC：" class="headerlink" title="1、什么是TCC："></a>1、什么是TCC：</h3><p>TCC（Try Confirm Cancel）是应用层的两阶段提交，所以对代码的侵入性强，其核心思想是：针对每个操作，都要实现对应的确认和补偿操作，也就是业务逻辑的每个分支都需要实现 try、confirm、cancel 三个操作，第一阶段由业务代码编排来调用Try接口进行资源预留，当所有参与者的 Try 接口都成功了，事务协调者提交事务，并调用参与者的 confirm 接口真正提交业务操作，否则调用每个参与者的 cancel 接口回滚事务，并且由于 confirm 或者 cancel 有可能会重试，因此对应的部分需要支持幂等。</p><h3 id="2、TCC的执行流程："><a href="#2、TCC的执行流程：" class="headerlink" title="2、TCC的执行流程："></a>2、TCC的执行流程：</h3><p>TCC的执行流程可以分为两个阶段，分别如下：</p><p>（1）第一阶段：Try，业务系统做检测并预留资源 (加锁，锁住资源)，比如常见的下单，在try阶段，我们不是真正的减库存，而是把下单的库存给锁定住。</p><p>（2）第二阶段：根据第一阶段的结果决定是执行confirm还是cancel</p><ul><li>Confirm：执行真正的业务（执行业务，释放锁）</li><li>Cancle：是对Try阶段预留资源的释放（出问题，释放锁）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250225230319843.png" alt="image-20250225230319843"></p><h3 id="3、TCC如何保证最终一致性："><a href="#3、TCC如何保证最终一致性：" class="headerlink" title="3、TCC如何保证最终一致性："></a>3、TCC如何保证最终一致性：</h3><ul><li><p>TCC 事务机制以 Try 为中心的，Confirm 确认操作和 Cancel 取消操作都是围绕 Try 而展开。因此，Try 阶段中的操作，其保障性是最好的，即使失败，仍然有 Cancel 取消操作可以将其执行结果撤销。</p></li><li><p>Try阶段执行成功并开始执行 Confirm 阶段时，默认 Confirm 阶段是不会出错的，也就是说只要 Try 成功，Confirm 一定成功（TCC设计之初的定义）</p></li><li><p>Confirm 与 Cancel 如果失败，由TCC框架进行重试补偿</p></li><li><p>存在极低概率在CC环节彻底失败，则需要定时任务或人工介入</p></li></ul><h3 id="4、TCC的注意事项："><a href="#4、TCC的注意事项：" class="headerlink" title="4、TCC的注意事项："></a>4、TCC的注意事项：</h3><h4 id="（1）允许空回滚："><a href="#（1）允许空回滚：" class="headerlink" title="（1）允许空回滚："></a>（1）允许空回滚：</h4><p>空回滚出现的原因是 Try 超时或者丢包，导致 TCC 分布式事务二阶段的 回滚，触发 Cancel 操作，此时事务参与者未收到Try，但是却收到了Cancel 请求，如下图所示：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/e592cf382d23d3db57bc62173ec99cea.png" alt="img"></p><p>所以 cancel 接口在实现时需要允许空回滚，也就是 Cancel 执行时如果发现没有对应的事务 xid 或主键时，需要返回回滚成功，让事务服务管理器认为已回滚。</p><h4 id="（2）防悬挂控制："><a href="#（2）防悬挂控制：" class="headerlink" title="（2）防悬挂控制："></a>（2）防悬挂控制：</h4><p>悬挂指的是二阶段的 Cancel 比 一阶段的Try 操作先执行，出现该问题的原因是 Try 由于网络拥堵而超时，导致事务管理器生成回滚，触发 Cancel 接口，但之后拥堵在网络的 Try 操作又被资源管理器收到了，但是 Cancel 比 Try 先到。但按照前面允许空回滚的逻辑，回滚会返回成功，事务管理器认为事务已回滚成功，所以此时应该拒绝执行空回滚之后到来的 Try 操作，否则会产生数据不一致。因此我们可以在 Cancel 空回滚返回成功之前，先记录该条事务 xid 或业务主键，标识这条记录已经回滚过，Try 接口执行前先检查这条事务xid或业务主键是否已经标记为回滚成功，如果是则不执行 Try 的业务操作。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/9f9a803b45a06324541dbdf60dcce0f9.png" alt="img"></p><h4 id="（3）幂等控制："><a href="#（3）幂等控制：" class="headerlink" title="（3）幂等控制："></a>（3）幂等控制：</h4><p>由于网络原因或者重试操作都有可能导致 Try - Confirm - Cancel 3个操作的重复执行，所以使用 TCC 时需要注意这三个操作的幂等控制，通常我们可以使用事务 xid 或业务主键判重来控制。</p><h3 id="5、TCC方案的优缺点："><a href="#5、TCC方案的优缺点：" class="headerlink" title="5、TCC方案的优缺点："></a>5、TCC方案的优缺点：</h3><p>（1）TCC 事务机制相比于上面介绍的 XA 事务机制，有以下优点：</p><ul><li><p>性能提升：具体业务来实现，控制资源锁的粒度变小，不会锁定整个资源。</p></li><li><p>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</p></li><li><p>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</p></li></ul><p>（2）缺点：TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p><h2 id="四、Saga事务："><a href="#四、Saga事务：" class="headerlink" title="四、Saga事务："></a>四、Saga事务：</h2><h3 id="1、什么是Saga事务："><a href="#1、什么是Saga事务：" class="headerlink" title="1、什么是Saga事务："></a>1、什么是Saga事务：</h3><p>Saga 事务核心思想是将长事务拆分为多个本地短事务并依次正常提交，如果所有短事务均执行成功，那么分布式事务提交；如果出现某个参与者执行本地事务失败，则由 Saga 事务协调器协调根据相反顺序调用补偿操作，回滚已提交的参与者，使分布式事务回到最初始的状态。Saga 事务基本协议如下：</p><p>（1）每个 Saga 事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。<br>（2）每个 Ti 都有对应的幂等补偿动作 Ci，补偿动作用于撤销 Ti 造成的结果。</p><p>与TCC事务补偿机制相比，TCC有一个预留(Try)动作，相当于先报存一个草稿，然后才提交；Saga事务没有预留动作，直接提交。</p><h3 id="2、Saga的恢复策略："><a href="#2、Saga的恢复策略：" class="headerlink" title="2、Saga的恢复策略："></a>2、Saga的恢复策略：</h3><p>对于事务异常，Saga提供了两种恢复策略，分别如下：</p><h4 id="（1）向后恢复-backward-recovery-："><a href="#（1）向后恢复-backward-recovery-：" class="headerlink" title="（1）向后恢复(backward recovery)："></a>（1）向后恢复(backward recovery)：</h4><p>当执行事务失败时，补偿所有已完成的事务，是“一退到底”的方式，这种做法的效果是撤销掉之前所有成功的子事务，使得整个 Saga 的执行结果撤销。如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/11d104d5c608de20bb4dc25a40922c72.png" alt="img"></p><p>从上图可知事务执行到了支付事务T3，但是失败了，因此事务回滚需要从C3,C2,C1依次进行回滚补偿，对应的执行顺序为：T1,T2,T3,C3,C2,C1。</p><h4 id="（2）向前恢复-forward-recovery-："><a href="#（2）向前恢复-forward-recovery-：" class="headerlink" title="（2）向前恢复(forward recovery)："></a>（2）向前恢复(forward recovery)：</h4><p>对于执行不通过的事务，会尝试重试事务，这里有一个假设就是每个子事务最终都会成功，这种方式适用于必须要成功的场景，事务失败了重试，不需要补偿。流程如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1008dd6a23ba8926b19deb9213fbccd2.png" alt="img"></p><h3 id="3、Saga事务的实现方式："><a href="#3、Saga事务的实现方式：" class="headerlink" title="3、Saga事务的实现方式："></a>3、Saga事务的实现方式：</h3><p>Saga事务有两种不同的实现方式，分别如下：</p><ul><li><p>命令协调（Order Orchestrator）</p></li><li><p>事件编排（Event Choreographyo）</p></li></ul><h4 id="（1）命令协调："><a href="#（1）命令协调：" class="headerlink" title="（1）命令协调："></a>（1）命令协调：</h4><p>中央协调器（Orchestrator，简称 OSO）以命令&#x2F;回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。整体流程如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/fc53d4bdc5270dc66c23c9f277df5ed4.png" alt="img"></p><ul><li>事务发起方的主业务逻辑请求 OSO 服务开启订单事务</li><li>OSO 向库存服务请求扣减库存，库存服务回复处理结果。</li><li>OSO 向订单服务请求创建订单，订单服务回复创建结果。</li><li>OSO 向支付服务请求支付，支付服务回复处理结果。</li><li>主业务逻辑接收并处理 OSO 事务处理结果回复。</li></ul><p>中央协调器 OSO 必须事先知道执行整个事务所需的流程，如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚，基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p><h4 id="（2）事件编排："><a href="#（2）事件编排：" class="headerlink" title="（2）事件编排："></a>（2）事件编排：</h4><p>命令协调方式基于中央协调器实现，所以有单点风险，但是事件编排方式没有中央协调器。事件编排的实现方式中，每个服务产生自己的时间并监听其他服务的事件来决定是否应采取行动。<br>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件，该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何 Saga 参与者听到都意味着事务结束。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/810bed2b3754a914aab2eb0eab732794.png" alt="img"></p><ol><li><p>事务发起方的主业务逻辑发布开始订单事件。</p></li><li><p>库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件。</p></li><li><p>订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件。</p></li><li><p>支付服务监听订单已创建事件，进行支付，并发布订单已支付事件。</p></li><li><p>主业务逻辑监听订单已支付事件并处理。</p></li></ol><p>如果事务涉及 2 至 4 个步骤，则非常合适使用事件编排方式，它是实现 Saga 模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。</p><h3 id="4、Saga事务的优缺点："><a href="#4、Saga事务的优缺点：" class="headerlink" title="4、Saga事务的优缺点："></a>4、Saga事务的优缺点：</h3><h4 id="（1）命令协调设计的优缺点："><a href="#（1）命令协调设计的优缺点：" class="headerlink" title="（1）命令协调设计的优缺点："></a>（1）命令协调设计的优缺点：</h4><ul><li><p>优点：</p><ul><li>服务之间关系简单，避免服务间循环依赖，因为 Saga 协调器会调用 Saga 参与者，但参与者不会调用协调器。</li><li>程序开发简单，只需要执行命令&#x2F;回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li><li>易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试。</li></ul></li><li><p>缺点：</p><ul><li>中央协调器处理逻辑容易变得庞大复杂，导致难以维护。</li><li>存在协调器单点故障风险。</li></ul></li></ul><h4 id="（2）事件编排设计的优缺点："><a href="#（2）事件编排设计的优缺点：" class="headerlink" title="（2）事件编排设计的优缺点："></a>（2）事件编排设计的优缺点：</h4><ul><li>优点：<ul><li>避免中央协调器单点故障风险。</li><li>当涉及的步骤较少服务开发简单，容易实现。</li></ul></li><li>缺点：<ul><li>服务之间存在循环依赖的风险。</li><li>当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li></ul></li></ul><blockquote><p>由于 Saga 模型没有 Prepare 阶段，因此事务间不能保证隔离性。当多个 Saga 事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p></blockquote><h2 id="五、本地消息表："><a href="#五、本地消息表：" class="headerlink" title="五、本地消息表："></a>五、本地消息表：</h2><h3 id="1、什么是本地消息表"><a href="#1、什么是本地消息表" class="headerlink" title="1、什么是本地消息表"></a>1、什么是本地消息表</h3><p>本地消息表的核心思路就是将分布式事务拆分成本地事务进行处理，在该方案中主要有两种角色：<strong>事务主动方</strong>和<strong>事务被动方</strong>。</p><ul><li>事务主动发起方需要额外新建事务消息表，并在本地事务中完成业务处理和记录事务消息，并轮询事务消息表的数据发送事务消息，</li><li>事务被动方基于消息中间件消费事务消息表中的事务。</li></ul><p>这样可以避免以下两种情况导致的数据不一致性：</p><ul><li><p>业务处理成功、事务消息发送失败</p></li><li><p>业务处理失败、事务消息发送成功</p></li></ul><h3 id="2、本地消息表的执行流程"><a href="#2、本地消息表的执行流程" class="headerlink" title="2、本地消息表的执行流程"></a>2、本地消息表的执行流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/0a5d1a9dee731fff1ac86fd49159358b.png" alt="img"></p><ol><li>事务主动方在同一个本地事务中处理业务和写消息表操作</li><li>事务主动方通过消息中间件，通知事务被动方处理事务消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li><li>事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li><li>事务主动方接收中间件的消息，更新消息表的状态为已处理。</li></ol><p>一些必要的容错处理如下：</p><p>当 ① 处理出错，由于还在事务主动方的本地事务中，直接回滚即可<br>当 ②、③ 处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，通知事务被动方重新读取消息处理业务即可。<br>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务<br>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</p><h3 id="3、本地消息表的优缺点："><a href="#3、本地消息表的优缺点：" class="headerlink" title="3、本地消息表的优缺点："></a>3、本地消息表的优缺点：</h3><ul><li>优点：<ul><li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li><li>方案轻量，容易实现。</li></ul></li><li>缺点：<ul><li>与具体的业务场景绑定，耦合性强，不可公用</li><li>消息数据与业务数据同库，占用业务系统资源</li><li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限</li></ul></li></ul><h2 id="六、MQ事务消息："><a href="#六、MQ事务消息：" class="headerlink" title="六、MQ事务消息："></a>六、MQ事务消息：</h2><h3 id="1、MQ事务消息的执行流程"><a href="#1、MQ事务消息的执行流程" class="headerlink" title="1、MQ事务消息的执行流程"></a>1、MQ事务消息的执行流程</h3><p>基于MQ的分布式事务方案本质上是对本地消息表的封装，整体流程与本地消息表一致，唯一不同的就是将本地消息表存在了MQ内部，而不是业务数据库中，如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250225231651064.png" alt="image-20250225231651064"></p><p>由于将本地消息表存在了MQ内部，那么MQ内部的处理尤为重要，下面主要基于 RocketMQ4.3 之后的版本介绍 MQ 的分布式事务方案</p><h3 id="2、RocketMQ事务消息"><a href="#2、RocketMQ事务消息" class="headerlink" title="2、RocketMQ事务消息"></a>2、RocketMQ事务消息</h3><p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，而 RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/fd333886fc58c1c765b097df106ed89a.png" alt="img"></p><h4 id="（1）正常情况："><a href="#（1）正常情况：" class="headerlink" title="（1）正常情况："></a>（1）正常情况：</h4><p>在事务主动方服务正常，没有发生故障的情况下，发消息流程如下：</p><p>步骤①：发送方向 MQ Server(MQ服务方)发送 half 消息<br>步骤②：MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功<br>步骤③：发送方开始执行本地事务逻辑<br>步骤④：发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。<br>最终步骤：MQ Server 如果收到的是 commit 操作，则将半消息标记为可投递，MQ订阅方最终将收到该消息；若收到的是 rollback 操作则删除 half 半消息，订阅方将不会接受该消息</p><h4 id="（2）异常情况："><a href="#（2）异常情况：" class="headerlink" title="（2）异常情况："></a>（2）异常情况：</h4><p>在断网或者应用重启等异常情况下，图中的步骤④提交的二次确认超时未到达 MQ Server，此时的处理逻辑如下：</p><p>步骤⑤：MQ Server 对该消息发起消息回查<br>步骤⑥：发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果<br>步骤⑦：发送方根据检查得到的本地事务的最终状态再次提交二次确认。<br>最终步骤：MQ Server基于 commit&#x2F;rollback 对消息进行投递或者删除。</p><h3 id="3、MQ事务消息的优缺点："><a href="#3、MQ事务消息的优缺点：" class="headerlink" title="3、MQ事务消息的优缺点："></a>3、MQ事务消息的优缺点：</h3><ul><li>优点：(相比本地消息表方案)<ul><li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合</li><li>吞吐量大于使用本地消息表方案</li></ul></li><li>缺点：<ul><li>一次消息发送需要两次网络请求(half 消息 + commit&#x2F;rollback 消息) 。</li><li>业务处理服务需要实现消息状态回查接口。</li></ul></li></ul><h2 id="七、最大努力通知："><a href="#七、最大努力通知：" class="headerlink" title="七、最大努力通知："></a>七、最大努力通知：</h2><p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到主动方发送的消息，此时可以调用事务主动方提供的消息校对的接口主动获取</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1c76689e0f818908ffd544b357584e34.png" alt="img"></p><p>在可靠消息事务中，事务主动方需要将消息发送出去，并且让接收方成功接收消息，这种可靠性发送是由事务主动方保证的；但是最大努力通知，事务主动方仅仅是尽最大努力（重试，轮询….）将事务发送给事务接收方，所以存在事务被动方接收不到消息的情况，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p><p>所以最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p><h2 id="八、各方案常见使用场景总结："><a href="#八、各方案常见使用场景总结：" class="headerlink" title="八、各方案常见使用场景总结："></a>八、各方案常见使用场景总结：</h2><ul><li><strong>2PC&#x2F;3PC</strong>：依赖于数据库，能够很好的提供强一致性和强事务性，但延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li><li><strong>TCC</strong>：适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li><li><strong>本地消息表&#x2F;MQ 事务</strong>：适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账&#x2F;校验系统兜底。</li><li><strong>Saga 事务</strong>：由于 Saga 事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga 由于缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。所以，Saga 事务较适用于补偿动作容易处理的场景</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁总结</title>
      <link href="/2024/11/30/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/11/30/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h1><p>分布式锁是一种常用的技术，在分布式并发场景下，为了避免分分布式的多个进程或线程同时操作同一资源造成冲突，进而引入分布式锁机制</p><h2 id="分布式锁特点"><a href="#分布式锁特点" class="headerlink" title="分布式锁特点"></a>分布式锁特点</h2><p><strong>互斥</strong>：不同线程之间互斥，只有一个线程能持有锁。</p><p><strong>超时机制</strong>：代码耗时过长，网络原因等，导致锁一直被占用，造成死锁，所以引入超时机制，超过指定时间自动释放锁。</p><p><strong>完备的锁接口</strong>：阻塞的和非阻塞的接口都要有，lock 和 tryLock。</p><p><strong>可重入性</strong>：当前请求的节点 + 线程唯一标识，可以再次获取同一把锁</p><p><strong>公平性</strong>：锁唤醒时候，按照顺序唤醒，不公平的话，有可能出现饥饿现象</p><h2 id="分布式锁的使用场景"><a href="#分布式锁的使用场景" class="headerlink" title="分布式锁的使用场景"></a>分布式锁的使用场景</h2><p>分布式锁的核心目的是保证共享资源的独占。其使用场景有如下：</p><ul><li>多个应用实例需要同时修改同一份数据，需要保证数据的一致性。例如：秒杀抢购、优惠券领取等。</li><li>系统需要进行任务调度，任务之间需要互斥执行。例如：定时任务等。</li><li>避免重复处理数据。例如：调度任务在多台机器重复执行，缓存过期所有请求都去加载数据库。</li><li>保证数据的正确性。例如：秒杀的时候防止商品超卖，表单重复提交，接口幂等性。</li></ul><h2 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h2><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="基于索引"><a href="#基于索引" class="headerlink" title="基于索引"></a>基于索引</h4><p>基于索引的实现，是通过在数据库的某个字段上加了唯一的索引，那么只有一个线程能够对写入同一个数据，其他的线程由于索引的唯一性而无法写入，只能等待资源释放——这个唯一值被 DELETE 掉，那么可以重新写入来获取锁</p><p>我们可以先创建一个类似的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `database_lock` (</span><br><span class="line"> `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `resource` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line"> `description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> <span class="keyword">UNIQUE</span> KEY `uiq_idx_resource` (`resource`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;数据库分布式锁表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>其中的 resource 就是锁的名字，locked_at 就是锁的创建时间。</p><p>这里我们给数据库加了一个唯一索引，目的是对资源进唯一性约束。这样在写入同一个数据时，只能有一个线程写入，其他线程只能失败。通过这样的方法就实现了一个分布式锁。</p><p>这种锁的实现比较简单，但也会面临锁无法过期，锁的可靠性依赖于 MySQL 数据库的可用性等等问题。</p><h4 id="基于乐观锁"><a href="#基于乐观锁" class="headerlink" title="基于乐观锁"></a>基于乐观锁</h4><p>基于乐观锁的实现原理是多个线程可以同时对资源进行修改，但最终只能有一个修改成功，其他的回退。乐观锁的实现一般是基于版本号的机制，比如在更新数据时，先获取当前版本号，然后更新数据，再更新版本号。如果更新失败，说明数据已经被其他线程更新过了，那么就需要重试。</p><p>例如建立如下的数据库表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `optimistic_lock` (</span><br><span class="line"> `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line"> `resource` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line"> `version` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;版本信息&#x27;</span>,</span><br><span class="line"> `created_at` datetime COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line"> `updated_at` datetime COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line"> `deleted_at` datetime COMMENT <span class="string">&#x27;删除时间&#x27;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line"> <span class="keyword">UNIQUE</span> KEY `uiq_idx_resource` (`resource`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;数据库分布式锁表&#x27;</span>;</span><br></pre></td></tr></table></figure><p>每个线程的执行逻辑如下：</p><ul><li>获取资源： SELECT resource, version FROM optimistic_lock WHERE id &#x3D; 1</li><li>执行业务逻辑</li><li>更新资源：UPDATE optimistic_lock SET resource &#x3D; resource -1, version &#x3D; version + 1 WHERE id &#x3D; 1 AND version &#x3D; oldVersion</li></ul><p>通过比对修改后的 version 和修改之前的 oldVersion，如果一致，说明数据没有被其他线程更新过，那么就更新成功，否则就需要重试。</p><p>这种锁的实现比较复杂，但也能保证数据的一致性。在检测数据冲突时并不依赖数据库本身的锁机制，不会影响请求的性能。但是需要对表的设计增加额外的字段，增加了数据库的冗余。并且高并发的情况下增加了重试的次数，会影响性能。</p><h4 id="基于悲观锁"><a href="#基于悲观锁" class="headerlink" title="基于悲观锁"></a>基于悲观锁</h4><p>基于悲观锁的实现原理是多个线程只能一个一个地获取锁，直到获取锁的线程释放锁，其他线程才能获取锁。我们在基于 MySQL 的悲观锁的实现中，一般采用 MySQL 自带的锁机制，比如 SELECT … FOR UPDATE。数据库会在查询的过程中加上排他锁，那么这样别的事务就无法对该资源进行修改。</p><p>基于悲观锁的实现过程如下：</p><ul><li>获取资源： SELECT * FROM optimistic_lock WHERE id &#x3D; 1 FOR UPDATE</li><li>执行业务逻辑</li><li>释放资源：COMMIT</li></ul><p>相当于我们基于 SELECT … FOR UPDATE 获取了这行数据的锁，并且在同一事务下执行修改的业务逻辑，最终在 COMMIT 提交事务时释放锁。</p><p>这种锁的的实现也比较简单，主要是基于数据库的事务和行锁。但要注意行锁失效的情况。并且每次请求都会额外产生加锁的开销且未获取到锁的请求将会阻塞等待锁的获取，在高并发环境下，容易造成大量请求阻塞，影响系统可用性。</p><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>基于 Zookeeper 的分布式锁，主要来自于 Zookeeper 的两个机制</p><ul><li>临时顺序节点机制</li></ul><p>Zookeeper 的节点是一个类似于文件系统的目录结构，每个节点都可以设置临时顺序节点，也就是说，在创建节点时，可以指定一个顺序，然后 Zookeeper 会根据这个顺序来分配节点的唯一标识符。除此以外节点也可以被标记为持久节点，持久节点会一直存在直到主动删除。</p><ul><li>watch 机制</li></ul><p>Zookeeper 的 watch 机制允许用户在指定的节点上注册一个监听器，当节点发生变化时，Zookeeper 会通知监听器，并触发监听器的回调函数。</p><p>基于这两个机制，我们可以实现一个基于 Zookeeper 的分布式锁。</p><p>我们首先建立一个父节点，这个父节点是一个持久节点，用来表示共享资源。然后在父节点下创建临时顺序节点，这个临时顺序节点用来标识当前获得锁的线程。最终在父节点之下建立了一个类似于队列的结构。然后判断当前节点是不是最小的节点，如果是最小的节点，那么就获取锁，否则就监听前一个节点的删除事件，直到获得锁。每次节点使用完共享资源，就会删除该节点，进而释放锁，后面的节点通过 watch 监听前一个节点的删除事件，获得锁。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250225214841237.png" alt="image-20250225214841237"></p><p>Zookeeper 实现分布式锁的好处就是可以实现顺序的公平锁。并且可以实现强一致性，所有的操作都可以被保证是原子性的。假如某个节点宕机了，那么会自动释放锁，防止了死锁，提高了系统的可用性。</p><p>但是坏处就是，节点的创建和销毁对性能开销比较大，在高并发的环境下可能有较大的性能问题。另外，Zookeeper 的 watch 机制也会增加系统的复杂度，需要考虑节点的删除和创建的时机，以及节点的连接状态等。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>用 Redis 实现分布式锁，利用的是 SETNX+EXPIRE 命令。</p><p>SETNX 命令的作用是设置一个 key，当 key 不存在时，返回 1，如果 key 已经存在，返回 0。EXPIRE 命令的作用是设置一个 key 的过期时间，当 key 过期时，Redis 会自动删除该 key。</p><p>一般这两条命令写在一行来确保指令的原子性，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock_key some_unique_value EXPIRE lock_key 10  # 设置过期时间为10秒</span><br></pre></td></tr></table></figure><p>其中 lock_key 是锁的名字，some_unique_value 是唯一的值，10 是过期时间。</p><p>当两个线程同时执行这个命令时，只有一个线程会成功对 lock_key 的值进行修改，其他线程会失败，这样就达到了分布式锁的目的。</p><p>基于 Redis 实现分布式锁，由于是对值的修改，性能比较高。但是如果是在 Redis 集群环境下，由于 Redis 集群同步是异步的。如果在 Master 节点上设置锁，Slave 节点可能没有同步到最新的数据。此时 Master 节点崩溃了但是理论上锁不应当被释放，但由于 Master 的宕机导致了锁物理上被释放，所以其他客户端可能会加新的锁来对共享资源进行修改，这样就出现了问题。</p><p>解决这个问题的方法就是 RedLock 算法——也就是 Redisson 的实现原理。</p><h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson 的特性有：看门狗机制、集群支持、公平锁等等</p><p>Redisson 的公平锁的实现原理类似于 ReentrankLock 的公平锁机制，主要维护一个等待队列，通过控制锁的获取顺序来实现。</p><p>Redisson 的看门狗机制目的是检查锁的状态，自动管理分布式锁过期时间。其实现主要通过一个后台线程（俗称看门狗），每隔锁的 1&#x2F;3 时间检查锁的状态，只要持有锁的线程仍在执行且没有主动释放锁，看门狗就会持续进行续期操作。如果没有线程持有锁，看门狗就会自动释放锁。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250225214901170.png" alt="image-20250225214901170"></p><p>RedLock 算法的主要目的是为了解决 Master 节点宕机导致锁的释放问题。RedLock 算法的基本思路是，在多个 Redis 节点上同时加锁，只要大多数 Redis 节点都加锁成功，那么加锁成功；如果加锁失败，则释放所有锁并重试。</p><p>RedLock 算法的流程如下：</p><ol><li>客户端获取当前时间戳。</li><li>客户端在每个 Redis 节点上尝试用相同的锁名和 UUID 获取锁，并设置一个较短的过期时间。获取成功则记录加锁节点，否则记录失败节点。并记录加锁的总用时。</li><li>如果成功加锁的节点大于等于 N&#x2F;2+1（N 为 Redis 节点数），并且获取锁的总时间小于锁的过期时间，则认为加锁成功并执行业务逻辑；否则认为获取锁失败，释放所有锁</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/D2B5CA33BD970F64A6301FA75AE2EB22" alt="img"></p><p>Redisson 通过 RedLock 算法，保证了集群环境中锁的可靠性。</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式ID方案</title>
      <link href="/2024/11/24/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
      <url>/2024/11/24/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式-ID-方案"><a href="#分布式-ID-方案" class="headerlink" title="分布式 ID 方案"></a>分布式 ID 方案</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="什么是-分布式-ID"><a href="#什么是-分布式-ID" class="headerlink" title="什么是 分布式 ID"></a>什么是 分布式 ID</h3><p>拿MySQL数据库举个栗子：</p><p>在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。</p><p>但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</p><h3 id="分布式-ID-条件"><a href="#分布式-ID-条件" class="headerlink" title="分布式 ID 条件"></a>分布式 ID 条件</h3><p>一个最基本的分布式 ID 需要满足下面这些要求：</p><ul><li><strong>全局唯一</strong>：ID 的全局唯一性肯定是首先要满足的！</li><li><strong>高性能</strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。</li><li><strong>高可用</strong>：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li><li><strong>方便易用</strong>：拿来即用，使用方便，快速接入！</li></ul><p>除了这些之外，一个比较好的分布式 ID 还应保证：</p><ul><li><strong>安全</strong>：ID 中不包含敏感信息。</li><li><strong>有序递增</strong>：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li><li><strong>有具体的业务含义</strong>：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li><li><strong>独立部署</strong>：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的</li></ul><h2 id="2、-常用分布式-ID-生成方式"><a href="#2、-常用分布式-ID-生成方式" class="headerlink" title="2、 常用分布式 ID 生成方式"></a>2、 常用分布式 ID 生成方式</h2><h3 id="雪花算法（Snowflake）"><a href="#雪花算法（Snowflake）" class="headerlink" title="雪花算法（Snowflake）"></a>雪花算法（Snowflake）</h3><p><strong>说明</strong><br>由Twitter开源的分布式ID生成算法，生成64位的长整型ID。</p><p><strong>原理</strong></p><ul><li><strong>符号位（1 bit）</strong>：始终为0，表示ID为正数。</li><li><strong>时间戳（41 bit）</strong>：记录生成ID时的时间戳，精确到毫秒，支持约69年。</li><li><strong>数据中心ID（5 bit）</strong>：标识数据中心，最多支持32个数据中心。</li><li><strong>机器ID（5 bit）</strong>：标识机器，最多支持32台机器。</li><li><strong>序列号（12 bit）</strong>：同一毫秒内生成的序号，每毫秒可生成4096个唯一ID。</li></ul><p><strong>特点</strong></p><ul><li><strong>全局唯一</strong>：通过时间戳、数据中心ID、机器ID和序列号组合实现。</li><li><strong>有序性</strong>：ID大致按时间递增。</li><li><strong>高性能</strong>：在内存中生成，速度快。</li><li><strong>依赖时钟</strong>：时钟回拨可能导致重复ID。</li></ul><h3 id="基于Redis的ID生成"><a href="#基于Redis的ID生成" class="headerlink" title="基于Redis的ID生成"></a>基于Redis的ID生成</h3><p><strong>说明</strong><br>利用Redis的<code>INCR</code>或<code>INCRBY</code>命令生成唯一ID。</p><p><strong>原理</strong></p><ul><li><strong>单线程模型</strong>：Redis的单线程模型保证了<code>INCR</code>命令的原子性。</li><li><strong>单机模式</strong>：直接使用<code>INCR</code>命令生成自增ID。</li><li><strong>集群模式</strong>：为每个节点设置不同的初始偏移量和步长，防止重复。</li></ul><p><strong>特点</strong></p><ul><li><strong>全局唯一</strong>：通过原子性操作和偏移量设计保证唯一性。</li><li><strong>有序性</strong>：生成的ID是递增的。</li><li><strong>高性能</strong>：Redis的内存操作速度快。</li><li><strong>依赖Redis</strong>：需要Redis服务支持，集群模式下需配置偏移量。</li></ul><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p><strong>说明</strong><br>生成一组32位的16进制字符串，格式为<code>8-4-4-4-12</code>。</p><p><strong>原理</strong></p><ul><li>基于时间戳、随机数或MAC地址生成唯一标识符。</li></ul><p><strong>特点</strong></p><ul><li><strong>全局唯一</strong>：基于时间戳和随机数，几乎不可能重复。</li><li><strong>无序性</strong>：生成的ID无序，不适合作为主键。</li><li><strong>长度较长</strong>：32位字符串，占用空间较大。</li></ul><h3 id="基于数据库的号段模式"><a href="#基于数据库的号段模式" class="headerlink" title="基于数据库的号段模式"></a>基于数据库的号段模式</h3><p><strong>说明</strong><br>通过数据库分配一段连续的ID号段，应用在本地缓存中使用。</p><p><strong>原理</strong></p><ul><li>数据库预先分配一段ID号段，应用在本地使用，用完后再申请。</li></ul><p><strong>特点</strong></p><ul><li><strong>全局唯一</strong>：通过数据库分配保证唯一性。</li><li><strong>性能较高</strong>：减少数据库访问次数。</li><li><strong>依赖数据库</strong>：需要数据库支持，存在单点故障风险。</li></ul><h3 id="基于Zookeeper的ID生成"><a href="#基于Zookeeper的ID生成" class="headerlink" title="基于Zookeeper的ID生成"></a>基于Zookeeper的ID生成</h3><p><strong>说明</strong><br>利用Zookeeper的<code>znode</code>数据版本生成序列号。</p><p><strong>原理</strong></p><ul><li>每次创建一个临时有序<code>znode</code>，通过<code>znode</code>的路径或版本号生成唯一ID。</li></ul><p><strong>特点</strong></p><ul><li><strong>全局唯一</strong>：通过Zookeeper的分布式协调能力保证唯一性。</li><li><strong>依赖网络</strong>：性能受限于网络延迟。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>雪花算法</strong>：适合需要有序、高性能且全局唯一的场景，但需注意时钟回拨问题。</li><li><strong>Redis</strong>：适合高并发场景，生成速度快，但需配置偏移量。</li><li><strong>UUID</strong>：适合对唯一性要求极高且不依赖外部服务的场景，但ID较长。</li><li><strong>数据库号段模式</strong>：适合对数据库依赖较强的场景，但需注意性能瓶颈。</li><li><strong>Zookeeper</strong>：适合分布式协调场景，但性能受限。</li></ul><p>根据具体业务需求选择合适的分布式ID生成方案。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性算法详解</title>
      <link href="/2024/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/"/>
      <url>/2024/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Paxos 算法是 Leslie Lamport 在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题）。</p><p>为了介绍 Paxos 算法，兰伯特专门写了一篇生动幽默的论文，并虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。不过审稿人并不认可这份幽默，并建议兰伯特进行删除，兰伯特不干，于是乎那篇论文在当时并没有被成功发表。</p><p>直到 1998 年，系统研究中心 (Systems Research Center）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，并发现 Paxos 算法刚好可以解决他们的部分需求。于是，兰伯特就把论文发给了他们。看完论文之后，两位研究员觉得还不错。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">《The Part-Time Parliament》</a>。</p><p>不过，论文发表之后，各路学者直呼看不懂，于是 <strong>2001</strong> 年时，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">《Paxos Made Simple》</a> 的论文来简化对 Paxos 的介绍</p><h3 id="拜占庭将军问题概述"><a href="#拜占庭将军问题概述" class="headerlink" title="拜占庭将军问题概述"></a>拜占庭将军问题概述</h3><p>拜占庭将军问题，其实是一个共识问题。通过比喻的方式来描述分布式一致性中一类最难的问题，这里大致叙述一下：</p><blockquote><p>拜占庭帝国派出多支军队去围攻一个强大的敌人，每支军队有一个将军，但由于彼此距离较远，他们之间只能通过信使传递消息。敌方很强大，必须有超过半数的拜占庭军队一同参与进攻才可能击败敌人。在此期间，将军们彼此之间需要通过信使传递消息并协商一致后，在同一时间点发动进攻。</p></blockquote><p><strong>问题难点</strong>：困扰这些将军的问题，是他们不确定他们中是否有叛徒，叛徒可能会擅自变更进攻意向或者进攻时间。在这种状态下，拜占庭的将军们能否找到一种分布式的协议来让他们能够远程协商，从而赢取战斗？</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>Paxos 主要解决的是 共识问题 —— 在分布式系统中，多个节点需要就某个值达成一致。共识问题的核心在于：即使有些节点故障或网络通信出现问题，如何确保整个系统的其他节点能够得出同样的结果。</p><p>举个栗子：</p><p>假设你和三个朋友（小明、小红和小华）在不同的房间内，讨论今晚去哪吃饭。每个人只能通过手机短信沟通，网络信号时好时坏。你们想要最终达成一致的决定——比如决定去火锅店。但是问题来了：</p><ul><li><strong>网络延迟</strong>：你发的信息可能延迟到达别人手机。</li><li><strong>掉线问题</strong>：有的人可能暂时掉线，无法及时回复。</li><li><strong>冲突提议</strong>：有时候你可能提议去火锅店，而另一个人同时提议去烧烤店。</li></ul><p>在这种情况下，Paxos 协议能帮助你们解决这些问题，确保最后每个人都知道同一个决定——无论是火锅还是烧烤</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在深入了解 Paxos 的工作流程之前，我们先来认识 Paxos 协议中的角色和它如何运作。Paxos 的核心思想是通过多个参与者协作，逐步达成一致的决策，即便在不完美的分布式环境中（如消息丢失、网络延迟等）。</p><h3 id="Paxos-角色"><a href="#Paxos-角色" class="headerlink" title="Paxos 角色"></a>Paxos 角色</h3><p>Paxos 协议中有三个关键角色：</p><ul><li><strong>提议者（Proposer）</strong>：提议者是发起提案的人。在 Paxos 中，提议者负责提出一个具体的建议或决策，并试图让其他人同意这个提议。提议者可能有多个，它们可以同时或不同时发出不同的提案。</li><li><strong>接受者（Acceptor）</strong>：接受者是负责“投票”的人，决定是否接受提议者提出的提案。”接受者就是负责做出是否同意的决定。接受者的同意是保证一致性的关键，因为一旦大多数接受者同意某个提案，它就有资格成为最终决定。</li><li><strong>学习者（Learner）</strong>：学习者是“知晓结果的人”。一旦有提案达成一致（通过大多数接受者同意），学习者的任务就是得知这个结果。</li></ul><p>在 Paxos 的流程中，提议者发起提案，接受者决定是否接受，最终学习者会学习到达成的结果；另外分布式系统中的一个独立对象实际可以同时扮演多个角色</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-2c0d971fcca713a8e045a93d7881aedc_1440w.jpg" alt="img"></p><h3 id="多数原则"><a href="#多数原则" class="headerlink" title="多数原则"></a>多数原则</h3><p>多数原则 要求在一组接受者中，提案必须得到 大多数接受者 的同意才能通过。为什么这样能保证一致性呢？这是因为多个大多数集合之间 总会有交集，确保每个新提案能够了解到旧提案的历史，从而避免冲突。</p><p>例如，如果有 5 个接受者，那么大多数就是至少 3 个同意。如果你发起了一个提案并得到了 3 个接受者的同意，无论后续有多少个新的提案，新提案必须得到至少另外 3 个接受者的同意，而这些新的 3 个接受者中至少会有一个参与过前一个提案，这就保证了系统的一致性。</p><p>这个多数原则是 Paxos 保证多个节点最终达成一致的重要基础。</p><h3 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h3><p>Paxos算法通过一个决议分为两个阶段（Learn阶段之前决议已经形成）：</p><ol><li><strong>第一阶段：Prepare阶段</strong>。Proposer向Acceptors发出Prepare请求，Acceptors针对收到的Prepare请求进行Promise承诺。</li><li><strong>第二阶段：Accept阶段</strong>。Proposer收到多数Acceptors承诺的Promise后，向Acceptors发出Propose请求，Acceptors针对收到的Propose请求进行Accept处理。</li><li><strong>第三阶段：Learn阶段</strong>。Proposer在收到多数Acceptors的Accept之后，标志着本次Accept成功，决议形成，将形成的决议发送给所有Learners。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-a6cd35d4045134b703f9d125b1ce9671_1440w.jpg" alt="img"></p><p><strong>Paxos算法流程</strong></p><p>Paxos算法流程中的每条消息描述如下：</p><ul><li><strong>Prepare</strong>: Proposer生成全局唯一且递增的Proposal ID (可使用时间戳加Server ID)，向所有Acceptors发送Prepare请求，这里无需携带提案内容，只携带Proposal ID即可。</li><li><strong>Promise</strong>: Acceptors收到Prepare请求后，做出“两个承诺，一个应答”。</li></ul><p><strong>两个承诺：</strong></p><ol><li>不再接受Proposal ID小于等于（注意：这里是&lt;&#x3D; ）当前请求的Prepare请求。</li><li>不再接受Proposal ID小于（注意：这里是&lt; ）当前请求的Propose请求。</li></ol><p><strong>一个应答：</strong></p><p>不违背以前作出的承诺下，回复已经Accept过的提案中Proposal ID最大的那个提案的Value和Proposal ID，没有则返回空值。</p><ul><li><strong>Propose</strong>: Proposer 收到多数Acceptors的Promise应答后，从应答中选择Proposal ID最大的提案的Value，作为本次要发起的提案。如果所有应答的提案Value均为空值，则可以自己随意决定提案Value。然后携带当前Proposal ID，向所有Acceptors发送Propose请求。</li><li><strong>Accept</strong>: Acceptor收到Propose请求后，在不违背自己之前作出的承诺下，接受并持久化当前Proposal ID和提案Value。</li><li><strong>Learn</strong>: Proposer收到多数Acceptors的Accept后，决议形成，将形成的决议发送给所有Learners。</li></ul><p>Paxos算法伪代码描述如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-8d4eaf5fdeb145e8bdf5e3bb1af408c9_1440w.jpg" alt="img"></p><p>Paxos算法伪代码</p><ol><li>获取一个Proposal ID n，为了保证Proposal ID唯一，可采用时间戳+Server ID生成；</li><li>Proposer向所有Acceptors广播Prepare(n)请求；</li><li>Acceptor比较n和minProposal，如果n&gt;minProposal，minProposal&#x3D;n，并且将 acceptedProposal 和 acceptedValue 返回；</li><li>Proposer接收到过半数回复后，如果发现有acceptedValue返回，将所有回复中acceptedProposal最大的acceptedValue作为本次提案的value，否则可以任意决定本次提案的value；</li><li>到这里可以进入第二阶段，广播Accept (n,value) 到所有节点；</li><li>Acceptor比较n和minProposal，如果n&gt;&#x3D;minProposal，则acceptedProposal&#x3D;minProposal&#x3D;n，acceptedValue&#x3D;value，本地持久化后，返回；否则，返回minProposal。</li><li>提议者接收到过半数请求后，如果发现有返回值result &gt;n，表示有更新的提议，跳转到1；否则value达成一致。</li></ol><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>Basic Paxos 通过二阶段方式来达成共识，即准备阶段和接受阶段</li><li>Basic Paxos 除了达成共识功能，还实现了容错，在少于一半节点出现故障时，集群也能工作</li><li>提案编号大小代表优先级。对于提案编号，接受者提供三个承诺：<ul><li>如果准备请求的提案编号，小于等于接受者已经响应的准备请求的提案编号，那么接受者承诺不响应这个准备请求</li><li>如果接受请求中的提案编号，小于接受者已经响应的准备请求的提案编号，那么接受者承诺不通过这个提案</li><li>如果按受者已通过提案，那些接受者承诺会在准备请求的响应中，包含已经通过的最大编号的提案信息</li></ul></li><li><strong>Paxos 的目的是分布式系统进行值写入的时候通过选举规则（如 Raft 的 Term 机制）和多数派原则，确保即使发生脑裂，只有一个分区能继续写入（拥有多数节点的分区才能选举新 Leader）</strong></li></ul><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi-Paxos"></a>Multi-Paxos</h2><p>原始的Paxos算法（Basic Paxos）只能对一个值形成决议，决议的形成至少需要两次网络来回，在高并发情况下可能需要更多的网络来回，极端情况下甚至可能形成活锁。如果想连续确定多个值，Basic Paxos搞不定了。因此Basic Paxos几乎只是用来做理论研究，并不直接应用在实际工程中。</p><p>实际应用中几乎都需要连续确定多个值，而且希望能有更高的效率。Multi-Paxos正是为解决此问题而提出。Multi-Paxos基于Basic Paxos做了两点改进：</p><ol><li>针对每一个要确定的值，运行一次Paxos算法实例（Instance），形成决议。每一个Paxos实例使用唯一的Instance ID标识。</li><li>在所有Proposers中选举一个Leader，由Leader唯一地提交Proposal给Acceptors进行表决。这样没有Proposer竞争，解决了活锁问题。在系统中仅有一个Leader进行Value提交的情况下，Prepare阶段就可以跳过，从而将两阶段变为一阶段，提高效率。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-e5cd197abc9c922ca4ca91c3df74fa70_1440w.jpg" alt="img"></p><h3 id="Multi-Paxos流程"><a href="#Multi-Paxos流程" class="headerlink" title="Multi-Paxos流程"></a>Multi-Paxos流程</h3><p>Multi-Paxos首先需要选举Leader，Leader的确定也是一次决议的形成，所以可执行一次Basic Paxos实例来选举出一个Leader。选出Leader之后只能由Leader提交Proposal，在Leader宕机之后服务临时不可用，需要重新选举Leader继续服务。在系统中仅有一个Leader进行Proposal提交的情况下，Prepare阶段可以跳过。</p><p>Multi-Paxos通过改变Prepare阶段的作用范围至后面Leader提交的所有实例，从而使得Leader的连续提交只需要执行一次Prepare阶段，后续只需要执行Accept阶段，将两阶段变为一阶段，提高了效率。为了区分连续提交的多个实例，每个实例使用一个Instance ID标识，Instance ID由Leader本地递增生成即可。</p><p>Multi-Paxos允许有多个自认为是Leader的节点并发提交Proposal而不影响其安全性，这样的场景即退化为Basic Paxos。</p><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>由于 Paxos 算法过于复杂、实现困难，极大地制约了其应用，而分布式系统领域又亟需一种高效而易于实现的分布式一致性算法，在此背景下，Raft 算法应运而生。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>根据官方文档解释，一个 Raft 集群包含若干节点，Raft 把这些节点分为三种状态：Leader、 Follower、Candidate，每种状态负责的任务也是不一样的。正常情况下，集群中的节点只存在 Leader 与 Follower 两种状态。</p><p>• <strong>Leader（领导者）</strong> ：负责日志的同步管理，处理来自客户端的请求，与Follower保持heartBeat的联系；</p><p>• <strong>Follower（追随者）</strong> ：响应 Leader 的日志同步请求，响应Candidate的邀票请求，以及把客户端请求到Follower的事务转发（重定向）给Leader；</p><p>• <strong>Candidate（候选者）</strong> ：负责选举投票，集群刚启动或者Leader宕机时，状态为Follower的节点将转为Candidate并发起选举，选举胜出（获得超过半数节点的投票）后，从Candidate转为Leader状态。</p><h2 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h2><p>通常，Raft 集群中只有一个 Leader，其它节点都是 Follower。Follower 都是被动的，不会发送任何请求，只是简单地响应来自 Leader 或者 Candidate 的请求。Leader 负责处理所有的客户端请求（如果一个客户端和 Follower 联系，那么 Follower 会把请求重定向给 Leader）。</p><p>为简化逻辑和实现，Raft 将一致性问题分解成了三个相对独立的子问题。</p><p>• <strong>选举（Leader Election）</strong> ：当 Leader 宕机或者集群初创时，一个新的 Leader 需要被选举出来；</p><p>• <strong>日志复制（Log Replication）</strong> ：Leader 接收来自客户端的请求并将其以日志条目的形式复制到集群中的其它节点，并且强制要求其它节点的日志和自己保持一致；</p><p>• <strong>安全性（Safety）</strong> ：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其它服务器节点不能在同一个日志索引位置应用一个不同的指令。</p><h2 id="流程-模型设计"><a href="#流程-模型设计" class="headerlink" title="流程&#x2F;模型设计"></a>流程&#x2F;模型设计</h2><p>相关流程参考： <a href="http://www.kailing.pub/raft/index.html">Raft 分布式共识算法动画演示</a>，可获得更为直观的了解</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>以 Log 维护系统的业务数据</li><li>通过 Leader 选举的赞成性判断，在一定程度上提高 日志安全性</li><li>以Leader 为准的强一致性 —— 可能丢失部分日志<ul><li>小部分节点刚完成持久化就宕机了，而后续选了一个压根没记录该日志的节点</li></ul></li></ul><h1 id="ZAB"><a href="#ZAB" class="headerlink" title="ZAB"></a>ZAB</h1><p>基本和 Raft 一致， 只有些细节方面的差别，以下是梳理：</p><ul><li><h3 id="数据的年代的设计"><a href="#数据的年代的设计" class="headerlink" title="数据的年代的设计"></a>数据的年代的设计</h3></li></ul><p><strong>raft</strong>：每条数据的日志都记录着数据对应的 term，以及对应的 index</p><p><strong>zab</strong>：每条数据都有一个 zxid，它的高 32 位是数据的 epoch，低 32 位是版本号，直接通过每个节点的最大 zxid 就能判断哪个节点的数据最新。</p><ul><li><h3 id="选举流程"><a href="#选举流程" class="headerlink" title="选举流程"></a>选举流程</h3></li></ul><p><strong>raft</strong>：通过随机的时间抖动来避免多个节点同时作为 candidate 开始拉票。通过跟 candidate 对比日志最大的 term 和 index，来决定是否投票给 candidate，在一轮选举中只能投一次票，不能修改。</p><p><strong>zab</strong>：多个节点的 zxid 相同的情况下，会投票给节点 id 较小的节点。在一轮投票中，每个节点的投票是可以修改的，投完自己的票后如果发现有一个更合适的节点，可以修改选票，把票给更合适的那个节点。</p><ul><li><h3 id="日志同步"><a href="#日志同步" class="headerlink" title="日志同步"></a>日志同步</h3></li></ul><p><strong>raft</strong>：leader 节点的日志是最权威的，所有 follower 的日志必须跟 leader 的一致，一旦有 follower 发现和 leader 的日志不一致，会告诉 leader，在 leader 的帮助下，把错误的日志删掉，并且同步最新的日志。</p><p><strong>zab</strong>：leader 在上位后，会和所有的 follower 通信，将遗留下来的所有未提交的 proposal 提交。zab 通过选举具有最大 zxid 的节点，保证了所有节点数据的一致性。leader 收到一条消息后，自身并不会立刻提交，会先发送给 follower，只有收到过半节点的 ack 后，才会提交，同时发送 commit 给所有 follower，让它们也进行提交。如果发送 commit 给 follower 之前，它自己就挂了，新的 leader 一定包含了最新的未提交的消息，它会跟所有 follower 确认这条消息是否需要被提交。这样，就保证了新的 leader 和上一代的 leader 不会产生数据不一致，因为新的 leader 一定包含上一代 leader 的所有数据。</p><ul><li><h3 id="处理请求的过程："><a href="#处理请求的过程：" class="headerlink" title="处理请求的过程："></a>处理请求的过程：</h3></li></ul><p><strong>raft</strong>：leader 收到请求，发送给 follower，有过半的 follower 确认后，leader 自身先提交，下一次心跳时会将自身最新的 index 传递给 follower，follower 再将之前的收到的日志 apply。</p><p><strong>zab</strong>：leader 收到请求，发送给 follower，有过半的 follower 确认后，leader 立刻发送 commit 给 follower，立刻提交。</p><ul><li><h3 id="follower-挂掉又重启的过程"><a href="#follower-挂掉又重启的过程" class="headerlink" title="follower 挂掉又重启的过程"></a>follower 挂掉又重启的过程</h3></li></ul><p><strong>raft</strong>：重启之后，follower 重新识别到 leader，leader 会按照顺序把 follower 确实的消息复制过去，不影响复制期间添加新的日志，在下一次同步时会自动同步。</p><p><strong>zab</strong>：重启后，follower 需要和当前的 leader 确定数据的差异，如果此时有新的请求到来，无法处理新的请求，需要现将差异数据放入 follower 的队列，差异确定完毕后，还需要将 leader 中的已提交的和未提交的 proposal 都放入队列。</p><h1 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h1><p>Gossip 协议是一种简单高效的分布式通信机制，特别适合大规模、去中心化的分布式系统。它通过节点之间的随机通信和定期信息交换，逐步传播信息并保持系统的一致性。虽然它不适用于对一致性要求极高的场景，但在需要高扩展性和容错性的系统中表现出色</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/gossip-rumor-mongering-D0IpXnM4.gif" alt="Gossip 传播示意图"></p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Gossip 协议的核心在于节点之间的随机通信和信息交换，具体步骤如下：</p><ul><li><strong>节点选择</strong>：每个节点定期随机选择其他节点进行信息交换。</li><li><strong>信息交换</strong>：节点之间交换的信息可以包括节点状态、数据更新、故障检测结果等。</li><li><strong>状态更新</strong>：节点通过合并操作更新自己的状态，例如根据时间戳或版本号选择最新的信息。</li><li><strong>定时传播</strong>：节点按照预定的时间间隔发送 Gossip 消息，以确保信息逐步同步和传播。</li></ul><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>Gossip 协议中存在三种常见的通信方式：</p><ul><li><strong>Push（推）</strong>：节点向随机选择的其他节点发送自己的信息。</li><li><strong>Pull（拉）</strong>：节点从随机选择的其他节点获取信息。</li><li><strong>Push&amp;Pull（推拉结合）</strong>：节点在发送信息的同时，也从对方获取信息，这种方式可以更高效地同步数据。</li></ul><h2 id="优点与缺点"><a href="#优点与缺点" class="headerlink" title="优点与缺点"></a>优点与缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul><li><strong>高扩展性</strong>：适合大规模分布式系统，性能不会因节点数量增加而大幅下降。</li><li><strong>容错性强</strong>：即使部分节点失效，协议仍能正常工作。</li><li><strong>实现简单</strong>：协议逻辑简单，易于在分布式系统中快速实现。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul><li><strong>收敛速度较慢</strong>：信息传播是随机的，达到最终一致性可能需要较长时间。</li><li><strong>冗余通信</strong>：节点之间可能重复传播相同的信息，浪费带宽。</li><li><strong>不适合强一致性场景</strong>：Gossip 协议只保证最终一致性。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Gossip 协议广泛应用于以下场景：</p><ul><li><strong>分布式数据库</strong>：如 Apache Cassandra 和 DynamoDB，用于节点间的健康检查和元数据传播。</li><li><strong>分布式缓存</strong>：如 Redis Cluster，用于传播节点状态和槽位分布信息。</li><li><strong>分布式服务发现</strong>：如 Consul，用于服务发现和节点健康状态传播。</li><li><strong>故障检测</strong>：快速传播节点故障信息，触发故障转移或恢复机制。</li></ul><h3 id="实际应用案例"><a href="#实际应用案例" class="headerlink" title="实际应用案例"></a>实际应用案例</h3><ul><li><strong>Redis Cluster</strong>：使用 Gossip 协议传播节点状态信息，包括节点在线状态、槽位分布等。</li><li><strong>Consul</strong>：通过 Gossip 协议快速传播服务状态和配置更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 一致性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统理论概述 —— CAP、PACELC、BASE</title>
      <link href="/2024/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0%20%E2%80%94%E2%80%94%20CAP%E3%80%81PACELC%E3%80%81BASE/"/>
      <url>/2024/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA%E6%A6%82%E8%BF%B0%20%E2%80%94%E2%80%94%20CAP%E3%80%81PACELC%E3%80%81BASE/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式系统理论概述-——-CAP、PACELC、BASE"><a href="#分布式系统理论概述-——-CAP、PACELC、BASE" class="headerlink" title="分布式系统理论概述 —— CAP、PACELC、BASE"></a>分布式系统理论概述 —— CAP、PACELC、BASE</h1><h2 id="从-CAP-说起"><a href="#从-CAP-说起" class="headerlink" title="从 CAP 说起"></a>从 CAP 说起</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/OIP-C.SRq-YhA-je6nz_s614CHRQHaGY" alt="CAP原则_百度百科"></p><p>CAP 理论指出，分布式系统在设计时只能同时满足以下三个特性中的两个：</p><ul><li><strong>一致性（Consistency）</strong></li><li><strong>可用性（Availability）</strong> </li><li><strong>分区容忍性（Partition Tolerance）</strong></li></ul><p>其中，CA 比较好理解， 核心在于 P， 个人的理解如下</p><blockquote><p>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</p><p>当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的</p><p>提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。</p></blockquote><p>因此， CAP 中， P 其实是 前提， 必选的， 如果不考虑 P ，那也就没有分布式的问题了</p><p>然后再说回 A 和 C，就比较好理解了</p><blockquote><p>接着上面的，要把数据复制到多个节点，就会带来一致性的问题 —— 多个节点上面的数据可能是不一致的。</p><p>要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。</p></blockquote><p>总的来说就是，存储某一数据的节点数越多，分区容错性越高，一致性就越难以保障，如果强行提升一致性，可用性就必然受到影响。</p><p>回过头再说常容易搞混的 A 和 P 的关系：</p><ul><li>P 指的是 网络分区发生时，还能否提供服务<ul><li><strong>特点：</strong><ul><li>强调系统对<strong>网络故障的容忍能力</strong>。</li><li>当分区发生时，系统需要选择如何处理一致性和可用性的权衡。</li><li>没有 P，系统将无法在分区时运行，但分布式系统通常必须支持 P（否则等同于单机系统）。</li></ul></li></ul></li><li>A 指的是系统在<strong>任何时刻</strong>都能响应客户端的请求，即使部分节点故障或数据不一致，系统仍能正常处理请求。<ul><li><strong>特点</strong>：<ul><li>强调系统的<strong>服务持续性</strong>。</li><li>所有节点（无论是否最新状态）都必须能响应请求。</li><li>不保证返回的数据是最新的（可能牺牲一致性）。</li></ul></li></ul></li></ul><h2 id="再到-PACELC"><a href="#再到-PACELC" class="headerlink" title="再到 PACELC"></a>再到 PACELC</h2><p>PACELC 理论是对 CAP 定理的扩展，旨在更全面地指导分布式系统设计。它不仅考虑了网络分区（Partition）场景下的权衡，还引入了<strong>正常运行时延迟（Latency）</strong>与 <strong>一致性（Consistency）</strong> 的平衡，从而弥补了 CAP 理论在实际应用中的局限性。以下是 PACELC 的核心要点和实际应用分析：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250223195029597.png" alt="image-20250223195029597" style="zoom:80%;" /><h3 id="1-PACELC-的定义"><a href="#1-PACELC-的定义" class="headerlink" title="1. PACELC 的定义"></a><strong>1. PACELC 的定义</strong></h3><ul><li><strong>PAC</strong>（Partition-Availability-Consistency）：<br>当系统发生网络分区（P）时，需在可用性（A）和一致性（C）之间做出选择，这与 CAP 定理一致。</li><li><strong>ELC</strong>（Else-Latency-Consistency）：<br>当系统无分区（Else，E）时，需在延迟（L）和一致性（C）之间权衡。例如，强一致性可能增加读写延迟，而弱一致性可提升响应速度。</li></ul><h3 id="2-为何需要-PACELC？"><a href="#2-为何需要-PACELC？" class="headerlink" title="2. 为何需要 PACELC？"></a><strong>2. 为何需要 PACELC？</strong></h3><ul><li><strong>CAP 的局限性</strong>：<br>CAP 仅关注分区场景，但系统大部分时间处于无分区状态，此时延迟与一致性的平衡更为关键。例如，即使网络正常，强一致性要求同步所有副本数据，可能导致高延迟。</li><li><strong>业务场景的多样性</strong>：<br>不同业务对一致性和延迟的容忍度不同。例如，电商系统可能允许短暂不一致以降低延迟（最终一致性），而金融系统需优先保证强一致性。</li></ul><h3 id="3-PACELC-的典型实现策略"><a href="#3-PACELC-的典型实现策略" class="headerlink" title="3. PACELC 的典型实现策略"></a><strong>3. PACELC 的典型实现策略</strong></h3><h4 id="（1）分区场景（PAC）的权衡"><a href="#（1）分区场景（PAC）的权衡" class="headerlink" title="（1）分区场景（PAC）的权衡"></a><strong>（1）分区场景（PAC）的权衡</strong></h4><ul><li><strong>AP 系统</strong>：优先保证可用性，牺牲一致性。<ul><li><strong>案例</strong>：Cassandra、DynamoDB 默认允许分区期间写入成功，数据最终一致。</li></ul></li><li><strong>CP 系统</strong>：优先保证一致性，牺牲可用性。<ul><li><strong>案例</strong>：ZooKeeper 在分区期间暂停服务，确保数据强一致。</li></ul></li></ul><h4 id="（2）无分区场景（ELC）的权衡"><a href="#（2）无分区场景（ELC）的权衡" class="headerlink" title="（2）无分区场景（ELC）的权衡"></a><strong>（2）无分区场景（ELC）的权衡</strong></h4><ul><li><strong>高一致性配置</strong>：牺牲延迟，保证强一致。<ul><li><strong>案例</strong>：MySQL 全同步复制要求所有从库同步完成才返回成功，增加写入延迟。</li></ul></li><li><strong>低延迟配置</strong>：放宽一致性要求。<ul><li><strong>案例</strong>：MongoDB 默认异步复制，主节点写入后立即响应，从节点可能存在短暂不一致。</li></ul></li></ul><h3 id="4-实际系统的-PACELC-分类"><a href="#4-实际系统的-PACELC-分类" class="headerlink" title="4. 实际系统的 PACELC 分类"></a><strong>4. 实际系统的 PACELC 分类</strong></h3><table><thead><tr><th align="left"><strong>系统类型</strong></th><th align="left"><strong>分区场景（PAC）</strong></th><th align="left"><strong>正常场景（ELC）</strong></th><th align="left"><strong>典型案例</strong></th></tr></thead><tbody><tr><td align="left"><strong>PA&#x2F;EL 系统</strong></td><td align="left">选可用性（A）</td><td align="left">选低延迟（L）</td><td align="left">Cassandra、DynamoDB</td></tr><tr><td align="left"><strong>PC&#x2F;EC 系统</strong></td><td align="left">选一致性（C）</td><td align="left">选一致性（C）</td><td align="left">HBase、BigTable</td></tr><tr><td align="left"><strong>PA&#x2F;EC 系统</strong></td><td align="left">选可用性（A）</td><td align="left">选一致性（C）</td><td align="left">MongoDB（默认配置）</td></tr><tr><td align="left"><strong>PC&#x2F;EL 系统</strong></td><td align="left">选一致性（C）</td><td align="left">选低延迟（L）</td><td align="left">较少见，需定制化实现</td></tr></tbody></table><h3 id="5-应用-PACELC-的技术手段"><a href="#5-应用-PACELC-的技术手段" class="headerlink" title="5. 应用 PACELC 的技术手段"></a><strong>5. 应用 PACELC 的技术手段</strong></h3><ul><li><strong>NWR 模型</strong>：<br>通过配置副本数（N）、写入确认数（W）、读取确认数（R）实现灵活权衡。例如，设置 W&#x3D;1、R&#x3D;N 可优先写入速度（低延迟），但可能读到旧数据；设置 W&#x3D;N、R&#x3D;1 则保证强一致性，但写入延迟高。</li><li><strong>异步&#x2F;同步复制</strong>：<ul><li><strong>异步复制</strong>（如 MySQL 默认模式）：牺牲一致性换低延迟。</li><li><strong>半同步复制</strong>：折中方案，写入主库后至少同步到一个从库，平衡一致性与延迟。</li></ul></li></ul><h2 id="再说-BASE-理论"><a href="#再说-BASE-理论" class="headerlink" title="再说 BASE 理论"></a>再说 BASE 理论</h2><h3 id="1-BASE-理论的定义"><a href="#1-BASE-理论的定义" class="headerlink" title="1. BASE 理论的定义"></a><strong>1. BASE 理论的定义</strong></h3><p>BASE 是  。</p><h3 id="2-核心组成"><a href="#2-核心组成" class="headerlink" title="2. 核心组成"></a><strong>2. 核心组成</strong></h3><h4 id="1-基本可用（Basically-Available）"><a href="#1-基本可用（Basically-Available）" class="headerlink" title="(1) 基本可用（Basically Available）"></a><strong>(1) 基本可用（Basically Available）</strong></h4><ul><li><strong>定义</strong>：系统在发生故障时，允许部分功能降级（如响应延迟、非核心功能不可用），但核心功能仍可用。</li><li><strong>示例</strong>：<ul><li>电商系统在流量高峰时限制非核心功能（如商品评论），但保证下单和支付功能可用。</li><li>响应时间延长：正常查询耗时 0.5 秒，故障时可能延长至 2 秒。</li></ul></li></ul><h4 id="2-软状态（Soft-State）"><a href="#2-软状态（Soft-State）" class="headerlink" title="(2) 软状态（Soft State）"></a><strong>(2) 软状态（Soft State）</strong></h4><ul><li><strong>定义</strong>：允许数据在不同节点间存在中间状态（短暂不一致），且这种状态不影响系统整体可用性。</li><li><strong>示例</strong>：<ul><li>订单的“支付中”状态，数据同步完成前允许存在中间状态。</li><li>数据异步复制时，主节点与副本节点的数据可能短暂不同步。</li></ul></li></ul><h4 id="3-最终一致性（Eventually-Consistent）"><a href="#3-最终一致性（Eventually-Consistent）" class="headerlink" title="(3) 最终一致性（Eventually Consistent）"></a><strong>(3) 最终一致性（Eventually Consistent）</strong></h4><ul><li><strong>定义</strong>：系统经过一段时间后，所有副本数据最终达成一致。一致性时间窗口取决于网络延迟、负载等因素。</li><li><strong>一致性变种</strong>：<ul><li><strong>因果一致性</strong>：有因果关系的操作需按顺序生效（如用户 A 修改数据后，用户 B 的修改必须基于 A 的最新值）。</li><li><strong>会话一致性</strong>：同一会话内保证“读己所写”（如用户修改个人资料后，同一会话内读取到最新值）。</li></ul></li></ul><h3 id="3-BASE-与-CAP-的关系"><a href="#3-BASE-与-CAP-的关系" class="headerlink" title="3. BASE 与 CAP 的关系"></a><strong>3. BASE 与 CAP 的关系</strong></h3><ul><li><strong>CAP 的局限性</strong>：CAP 定理仅在网络分区（P）场景下要求选择 C 或 A，而 BASE 理论进一步细化了非分区场景下延迟（L）与一致性（C）的权衡。</li><li><strong>核心区别</strong>：<ul><li><strong>CAP</strong>：强调整体系统在分区时的选择（C 或 A）。</li><li><strong>BASE</strong>：弱化一致性，通过最终一致性和软状态实现高可用性，更适合业务容忍短暂不一致的场景。</li></ul></li></ul><h3 id="4-实际应用场景"><a href="#4-实际应用场景" class="headerlink" title="4. 实际应用场景"></a><strong>4. 实际应用场景</strong></h3><ol><li><strong>电商系统</strong><ul><li>购物车数据允许短暂不一致，异步同步后最终一致。</li></ul></li><li><strong>分布式缓存</strong><ul><li>Redis、Memcached 使用异步更新策略，容忍缓存与数据库的短暂不一致。</li></ul></li><li><strong>消息队列</strong><ul><li>Kafka、RabbitMQ 通过异步消费保证消息最终被处理。</li></ul></li></ol><h3 id="5-实现技术"><a href="#5-实现技术" class="headerlink" title="5. 实现技术"></a><strong>5. 实现技术</strong></h3><ul><li><strong>异步复制</strong>：主节点写入成功后，异步同步到从节点（如 MySQL 异步复制）。</li><li><strong>NWR 模型</strong>：通过调节副本数（N）、写入确认数（W）、读取确认数（R）平衡一致性与延迟。</li><li><strong>数据分区与冗余</strong>：分片存储数据并多副本冗余，提升容错性。</li></ul><h3 id="6-优缺点分析"><a href="#6-优缺点分析" class="headerlink" title="6. 优缺点分析"></a><strong>6. 优缺点分析</strong></h3><table><thead><tr><th align="left"><strong>优点</strong></th><th align="left"><strong>缺点</strong></th></tr></thead><tbody><tr><td align="left">高可用性（故障时仍可服务）</td><td align="left">数据一致性逻辑复杂（需处理冲突）</td></tr><tr><td align="left">高性能（异步操作减少延迟）</td><td align="left">开发难度高（需处理边界条件）</td></tr><tr><td align="left">容错性强（容忍网络分区）</td><td align="left">最终一致性时间窗口不可控</td></tr></tbody></table><h3 id="7-适用场景"><a href="#7-适用场景" class="headerlink" title="7. 适用场景"></a><strong>7. 适用场景</strong></h3><ul><li><strong>高并发、高可用需求</strong>：如电商秒杀、社交网络。</li><li><strong>容忍数据短暂不一致</strong>：如推荐系统、日志处理。</li><li><strong>最终一致性业务</strong>：如分布式数据库（Cassandra）、异步消息队列。</li></ul><h2 id="NWR-模型"><a href="#NWR-模型" class="headerlink" title="NWR 模型"></a>NWR 模型</h2><h2 id="什么是NWR协议？"><a href="#什么是NWR协议？" class="headerlink" title="什么是NWR协议？"></a>什么是NWR协议？</h2><p>NWR是一种在<strong>分布式存储系统</strong>中用于<strong>控制一致性级别</strong>的一种策略。在亚马逊的<strong>云存储系统（DynamoDB）中</strong>，就应用 <strong>NWR</strong>来控制一致性。</p><blockquote><p>N： 在分布式存储系统中，有多少份备份数据 。<br>W：代表一次成功的更新操作要求至少<strong>有w份数据写入成功</strong> <strong>。</strong><br>R： 代表一次成功的读数据操作要求至少<strong>有R份数据成功读取。</strong></p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h2><p>NWR值的不同组合会产生不同的一致性效果，当<strong>W+R&gt;N</strong>的时候，整个系统对于客户端来讲能保证<strong>强一致性</strong>。</p><blockquote><p>以常见的N&#x3D;3、W&#x3D;2、R&#x3D;2为例:<br>N&#x3D;3，表示，任何一个对象都必须有<strong>三个副本</strong><br>W&#x3D;2表示，对数据的修改操作只需要在3<strong>个副本中的2个上面完成</strong>就返回<br>R&#x3D;2表示，从<strong>三个对象中要读取到2个</strong>数据对象，才能返回</p></blockquote><p><strong>1.当W是2、R是2的时候，W+R&gt;N，这种情况对于客户端就是强一致性的。</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-df429eaa2f16310f80fd352d2e6ac401_1440w.jpg" alt="img"></p><p>如果<strong>R+W&gt;N</strong>,则<strong>读取操作和写入操作成功的数据一定会有交集</strong>（如图中的 Node2），这样就可以<strong>保证一定能够读取到最新版本的更新数据</strong>，数据的<strong>强一致性得到了保</strong>证。在满足数据一致性协议的前提下，<strong>R或者W设置的越大</strong>，则<strong>系统延迟越大</strong>，因为这取决于最慢的那份备份数据的响应时间。</p><p><strong>2. 当R+W&lt;&#x3D;N，无法保证数据的强一致性</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-d9cee1a1daf5924c72ed94be8a8651a1_1440w.jpg" alt="img"></p><p>因为成功<strong>写</strong>和成功<strong>读</strong>集合可能<strong>不存在交集</strong>，这样读操作<strong>无法读取到最新的更新数值</strong>，也就无法保证<strong>数据的强一致性</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
          <category> 一致性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常见问题总结</title>
      <link href="/2024/11/17/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/11/17/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL常见问题总结"><a href="#MySQL常见问题总结" class="headerlink" title="MySQL常见问题总结"></a>MySQL常见问题总结</h1><h2 id="面试题27：一颗B-Tree可以存放多少数据？"><a href="#面试题27：一颗B-Tree可以存放多少数据？" class="headerlink" title="面试题27：一颗B+Tree可以存放多少数据？"></a>面试题27：一颗B+Tree可以存放多少数据？</h2><p>MySQL设计者将一个B+Tree的节点的大小设置为等于一个页，InnoDB一个页的大小是16KB。</p><p>假设一个B+Tree高度2，存在一个根节点和若干个子节点，那么这颗树存放的总记录树为：<strong>根节点指针的数量</strong>*<strong>单个叶子节点记录行数*</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216134727848.png" alt="image-20250216134727848"></p><ol><li>计算根节点指针数：假设表的主键是int类型，占用的就是4个字节，指针的大小为6个字节，一个页大概可以存储： 16384B &#x2F; (4B+6B) &#x3D;1638,一个节点最多可以存储1638个索引指针。 </li><li>计算叶子节点的能够存储的记录数：假设一行记录的数据大小1KB,那么一页就可以存储16行数据。16KB &#x2F;1KB&#x3D;16。 </li><li>一颗高度为2的B+Tree可以存放的记录为：<br>1638 × 16 &#x3D; 26208条数据记录，同样的方式就可以推算出高度3的B+Tree可以存放：1638 × 1638 × 16 &#x3D;42938704，可以存放4000多万条的数据。 </li><li>所以InnoDB中<strong>B+Tree高度一般就是1-3层</strong>，就可以满足千万级别的数据的存储，在查找数据的时候一次页的查找代表一次IO，所以通过主键索引查询通常情况只需要 1-3次IO操作就可以查到数据。</li></ol><h2 id="面试题34：说一下MySQL的SQL的查询流程"><a href="#面试题34：说一下MySQL的SQL的查询流程" class="headerlink" title="面试题34：说一下MySQL的SQL的查询流程"></a>面试题34：说一下MySQL的SQL的查询流程</h2><p>MySQL的查询过程：</p><p>1）通过客户端&#x2F;服务器通信协议，与MySQL建立连接</p><ol><li>查询缓存（默认是关闭的），如果开启，就先从缓存中获取，获取直接返回，没有获取到的话，继续向下走 进行语法解析。</li></ol><p>3）预处理器生产一颗解析树。</p><p>4）查询优化器生产执行计划。</p><p>5）查询执行引擎执行SQL语句，与存储引擎交互返回结果。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216134847311.png" alt="image-20250216134847311"></p><h2 id="面试题60：介绍一下数据的设计范式？"><a href="#面试题60：介绍一下数据的设计范式？" class="headerlink" title="面试题60：介绍一下数据的设计范式？"></a>面试题60：介绍一下数据的设计范式？</h2><p>概念：三范式就是设计数据库的原则。</p><ul><li>第一范式：表字段列原子性，做到列的不可拆分的。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216140534239.png" alt="image-20250216140534239"></p><ul><li>第二范式：一张表只能描述一件事情。目的是让表中的每个列都与主键有关。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216140539654.png" alt="image-20250216140539654"></p><ul><li>第三范式：消除传递依赖，表的信息，如果能够被推导出来，就不应该单独的设计一个字段来进行存放。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216140544629.png" alt="image-20250216140544629"></p><p>数据库反三范式：</p><ul><li>反范式化指的是通过增加冗余或者重复的数据来提高数据库的读性能。</li><li>浪费存储的空间，节省查询时间。（以空间区换时间）</li></ul><p>什么是冗余字段？</p><ul><li>设置数据库时，某一个字段在多张表中出现了，并且完全等同于它在其他表中的表示的含义，这个字段就是冗余字段。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216140551842.png" alt="image-20250216140551842"></p><p>使用场景：</p><ul><li>当需要查询订单表所有数据并且只需要用户姓名信息时，如果没有冗余字段，通过JOIN进行表连接查询，加入数据量比较大，本次的连接查询就会带来很大性能消耗。<br>这时如果有冗余字段，就只需要查询一张表。</li></ul><p>总结一下：</p><ul><li>尽量遵循范式理论的约束，尽可能减少冗余字段，让数据库的设计更加的合理。</li><li>可以合理的加入冗余字段，减少不必要的表连接查询，让数据库的执行性能更快。</li></ul><h2 id="面试题62：InnoDB行锁如何进行优化？"><a href="#面试题62：InnoDB行锁如何进行优化？" class="headerlink" title="面试题62：InnoDB行锁如何进行优化？"></a>面试题62：InnoDB行锁如何进行优化？</h2><p>合理运用Innodb行级锁，应该做好以下几点：</p><ol><li>尽可能的让所有的数据检索都通过索引完成，避免Innodb因为无法对索引键加锁，导致升级为行级锁的问题。</li><li>合理的设计索引，让Innodb在索引键加锁的时候 准确度更高，锁定的范围更小，避免因为锁定导致影响其他的查询操作。</li><li>尽可能的减少基于范围的数据检索，避免因为间隙锁带来的负面影响，锁定了一些不应该锁定的记录。</li><li>尽可能的控制事务的大小，减少锁定的资源量和锁定的时间长度。</li><li>在业务允许的情况下，尽量选择使用较低的事务隔离界别，减少MySQL因为实现事务隔离级别所带来的附加成本。</li></ol><p>查询系统中行锁的使用情况</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;%innodb_row_lock%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                 <span class="operator">|</span> <span class="keyword">Value</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------------+--------+</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_current_waits <span class="operator">|</span> <span class="number">0</span>      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time          <span class="operator">|</span> <span class="number">156227</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_avg      <span class="operator">|</span> <span class="number">39056</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_time_max      <span class="operator">|</span> <span class="number">51081</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Innodb_row_lock_waits         <span class="operator">|</span> <span class="number">4</span>      <span class="operator">|</span></span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216140603714.png" alt="image-20250216140603714"></p><h2 id="面试题63：说一下乐观锁的实现方式？"><a href="#面试题63：说一下乐观锁的实现方式？" class="headerlink" title="面试题63：说一下乐观锁的实现方式？"></a>面试题63：说一下乐观锁的实现方式？</h2><p>实现乐观锁的步骤，主要有两步：</p><ol><li>冲突检测</li><li>数据更新</li></ol><p>CAS实现乐观锁：当多个线程尝试使用CAS同时更新一个变量时，只有其中一个线程能够完成变量值的更新，其他线程都失败了，失败之后线程也不会被挂起，而是会采用重试。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 扣减库存</span></span><br><span class="line"><span class="comment">-- 首先查询商品的库存，kucun = 3</span></span><br><span class="line"><span class="keyword">select</span> kucun <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 修改商品的库存</span></span><br><span class="line"><span class="keyword">update</span> products <span class="keyword">set</span> kucun <span class="operator">=</span> <span class="number">2</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> kucun <span class="operator">=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>CAS乐观锁机制能够提升吞吐量，并且保证一致性，但是在极端情况下可能会出现ABA问题。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135303836.png" alt="image-20250216135303836"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.并发线程1：获取出数据的初始值3，后续计划实施CAS乐观锁，期望数据仍然还是3，只有是3的时候，修改才能成功。</span><br><span class="line">2.并发线程2：将数据修改成2</span><br><span class="line">3.并发线程3：将数据修改回3</span><br><span class="line">这个个时候就出现了ABA问题</span><br></pre></td></tr></table></figure><p>解决ABA问题的方式：</p><ul><li>设计一个单独的可以顺序递增的version字段，每操作一次，将该字段的值 + 1，version字段用来查看被读记录有没有变化的，作用是防止记录在业务处理期间被其他的事务修改。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1.查询出商品sql,version =1</span></span><br><span class="line"><span class="keyword">select</span> kucun，version <span class="keyword">from</span> products <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 2. 根据商品生成订单</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders......</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> items...</span><br><span class="line"><span class="comment">-- 3. 修改商品的库存，同时增加版本字段的值+1</span></span><br><span class="line"><span class="keyword">update</span> products <span class="keyword">set</span> kucun<span class="operator">=</span> kucun <span class="operator">-</span> <span class="number">1</span>,version <span class="operator">=</span> version <span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> version <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="面试题64：count-列名-、count-1-和-count-有什么区别"><a href="#面试题64：count-列名-、count-1-和-count-有什么区别" class="headerlink" title="面试题64：count(列名)、count(1)和 count(*)有什么区别?"></a>面试题64：count(列名)、count(1)和 count(*)有什么区别?</h2><p>进行统计操作时，count中的统计条件可以有三种选择：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from user;</span><br><span class="line">select count(1) from user;</span><br><span class="line">select count(列名) from user;</span><br></pre></td></tr></table></figure><p>执行效果上：</p><ul><li>count(*) 包括了所有的列，在统计的时候不会忽略列值为null的数据。</li><li>count(1) 用1表示代码行，在统计时不会忽略列值为null的数据。</li><li>count(列名) 在统计时，会忽略值为null的数据，就是说某个字段的值为null时就不统计。</li></ul><p>执行效率上看：</p><ul><li><p>Innodb存储引擎：count(字段)  &lt; count(1) &#x3D; count(*) </p></li><li><p>Innodb通过遍历最小的可用的二级索引来处理select count(*)语句，如果二级索引不存在，则通过扫描聚簇索引来处理。</p></li><li><p>Innodb是以同样的方式区处理count(1)和count(*).</p></li><li><p>MyISAN存储引擎：count(字段)  &lt; count(1) &lt;&#x3D; count(*) </p></li><li><p>MyISAM存储量数据的准确的行数，使用count(*) 会直接返回总行数。优先选择count(**), 其次选择count(1)</p></li><li><p>count(列名) 会遍历整个表，但是不同的是，会先获取列，然后判断是否为空，然后再累加，因此count(列名) 不如前两者。</p></li></ul><h2 id="面试题65：说一下MySQL主从复制的作用及原理？"><a href="#面试题65：说一下MySQL主从复制的作用及原理？" class="headerlink" title="面试题65：说一下MySQL主从复制的作用及原理？"></a>面试题65：说一下MySQL主从复制的作用及原理？</h2><p>主从复制的用途：</p><ul><li>实时灾备，用于故障切换。</li><li>读写分离，提供查询服务。提高查询效率。</li><li>备份，避免影响业务。</li></ul><p>主从复制的必要条件：</p><ul><li>主库开启binlog日志。</li><li>主从server-id不能相同。</li><li>从库服务器能够联通主库。</li></ul><p>主从复制的原理：</p><ul><li>主从复制的实现是依赖于MySQL中binlog日志，该日志中记录了所有修改数据库的SQL语句（DML ，create drop…）。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135309733.png" alt="image-20250216135309733"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.主库有更新时间，就要记录到binlog。</span><br><span class="line">2.主库创建一个线程 binlog dump thread，把binlog内容发送到从库</span><br><span class="line">3.从库启动发起连接，连接到主库</span><br><span class="line">4.从库启动，创建一个IO线程，读取主库传过来的binlog内容，写入 relay log中。</span><br><span class="line">5.从库启动，创建一个SQL线程，从relay log中读取内容，执行读取到的更新时间，将更新的内容写入到从库。</span><br></pre></td></tr></table></figure><h2 id="面试题66：如何进行分页查询优化？"><a href="#面试题66：如何进行分页查询优化？" class="headerlink" title="面试题66：如何进行分页查询优化？"></a>面试题66：如何进行分页查询优化？</h2><p>一般的分页查询使用limit关键来实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from 表明 limit [offset,] rows;</span><br><span class="line">第一个参数：指定第一个返回记录行偏移量，注意是从 0 开始。</span><br><span class="line">第二个参数：指定返回记录行的最大数目。</span><br><span class="line">如果只给定了一个参数，他表示返回最大记录行数目</span><br></pre></td></tr></table></figure><p>情况1：如果偏移量是固定，返回的记录数是变化的，返回的记录数不断增加，对执行的效率有什么影响吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user limit 1000,1;</span><br><span class="line">select * from user limit 1000,10;</span><br><span class="line">select * from user limit 1000,100;</span><br><span class="line">select * from user limit 1000,1000;</span><br></pre></td></tr></table></figure><p>结论：在查询记录时，返回的记录量低于100条，查询的时间是基本没有变化的。但是随着查询的记录量越大，所花费的时间也就越多。</p><p>情况2：如果查询偏移量变化，返回的记录数固定，对执行时间有什么影响呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from user limit 1,1000;</span><br><span class="line">select * from user limit 100,1000;</span><br><span class="line">select * from user limit 1000,1000;</span><br><span class="line">select * from user limit 10000,1000;</span><br></pre></td></tr></table></figure><p>结论：在查询记录时，如果查询记录量相同，偏移量是不断变化的，那么超过100以后随着偏移量的不断的增加，查询的时间就会急剧增加。</p><p>优化方式1：通过索引进行分页</p><ul><li>直接进行limit操作，会产生全表扫描，速度会很慢，limit限制是从结果集M位置处取出N条数据，其他抛弃。 </li><li>假设id是连续递增，我们可以根据查询的页数和查询的记录数算出要查询的id的范围，然后配合limit使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where id &gt;= 1001 limit 100;</span><br></pre></td></tr></table></figure><p>优化方式2：利用子查询优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 首先定位偏移位置的ID</span><br><span class="line">select id from user where limit 10000,1;</span><br><span class="line"></span><br><span class="line">-- 根据获取到的ID向后查询</span><br><span class="line">select * from user where id &gt;= (select id from user where limit 10000,1) limit 1000;</span><br></pre></td></tr></table></figure><h2 id="面试题67：MySQL中都有哪几种加锁范围？"><a href="#面试题67：MySQL中都有哪几种加锁范围？" class="headerlink" title="面试题67：MySQL中都有哪几种加锁范围？"></a>面试题67：MySQL中都有哪几种加锁范围？</h2><p>MySQL中按照加锁范围分类，大致有三种：</p><ul><li>全局锁</li><li>表级锁</li><li>行级锁</li></ul><p>全局锁</p><ul><li><p>什么是全局锁，是对整个的数据库实例加锁，添加全局锁之后以下的一些语句会被阻塞 </p></li><li><p>数据更新（DML）</p></li><li><p>数据定义语句</p></li><li><p>更新类事务无法提交</p></li><li><p>全局锁的典型的应用场景：做全库的逻辑备份，重新做主从的时候。 </p></li><li><p>全局锁的使用方式</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一种方式 推荐使用</span></span><br><span class="line">flush tables <span class="keyword">with</span> read lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二种方式 不建议使用</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> readonly <span class="operator">=</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>全局锁的使用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> flush tables <span class="keyword">with</span> read lock;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> A    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> B    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> C    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">ERROR <span class="number">1223</span> (HY000): Can<span class="string">&#x27;t execute the query because you have a conflicting read lock</span></span><br><span class="line"><span class="string">mysql&gt; unlock tables;</span></span><br><span class="line"><span class="string">Query OK, 0 rows affected (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; insert into test1 values(4,&#x27;</span>D<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">Query OK, 1 row affected (0.01 sec)</span></span><br></pre></td></tr></table></figure><ul><li><p>表级锁 </p></li><li><p>是MySQL中锁定粒度最大的一种锁，表示是对当前操作的表加锁。</p></li><li><p>表级锁分为：共享锁，排他锁。</p></li><li><p>MyISAM引擎的表级锁使用</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> mylock01(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     title <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> )engine myisam;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> mylock02(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     title <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> )engine myisam;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> mylock01(title) <span class="keyword">values</span>(<span class="string">&#x27;a1&#x27;</span>),(<span class="string">&#x27;b1&#x27;</span>),(<span class="string">&#x27;c1&#x27;</span>),(<span class="string">&#x27;d1&#x27;</span>),(<span class="string">&#x27;e1&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">5</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">5</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> mylock02(title) <span class="keyword">values</span>(<span class="string">&#x27;a2&#x27;</span>),(<span class="string">&#x27;b2&#x27;</span>),(<span class="string">&#x27;c2&#x27;</span>),(<span class="string">&#x27;d2&#x27;</span>),(<span class="string">&#x27;e2&#x27;</span>);</span><br><span class="line">Query OK, <span class="number">5</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">5</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock01;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> a1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> b1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> c1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> d1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> e1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock02;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> a2    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> b2    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> c2    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> d2    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> e2    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>加锁语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">open</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock01 <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> test1    <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock02 <span class="operator">|</span>      <span class="number">0</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">open</span> tables <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>手动加锁 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加锁语法</span></span><br><span class="line">lock <span class="keyword">table</span> 表名 read(write),表明<span class="number">2</span> read(write);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> mylock01 read,mylock02 write;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">open</span> tables <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock01 <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock02 <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>测试读锁 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> mylock01 read,mylock02 write;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">open</span> tables <span class="keyword">where</span> In_use <span class="operator">&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> Database <span class="operator">|</span> <span class="keyword">Table</span>    <span class="operator">|</span> In_use <span class="operator">|</span> Name_locked <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock01 <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> testdb   <span class="operator">|</span> mylock02 <span class="operator">|</span>      <span class="number">1</span> <span class="operator">|</span>           <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+----------+--------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock01;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> a1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> b1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> c1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> d1    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> e1    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新报错，因为表已经被锁定，无法进行更新操作</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mylock01 <span class="keyword">set</span> title <span class="operator">=</span> <span class="string">&#x27;a123&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">ERROR <span class="number">1099</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;mylock01&#x27;</span> was locked <span class="keyword">with</span> a READ lock <span class="keyword">and</span> can<span class="string">&#x27;t be updated</span></span><br><span class="line"><span class="string">mysql&gt; select * from mylock02;</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">| id | title |</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">|  1 | a2    |</span></span><br><span class="line"><span class="string">|  2 | b2    |</span></span><br><span class="line"><span class="string">|  3 | c2    |</span></span><br><span class="line"><span class="string">|  4 | d2    |</span></span><br><span class="line"><span class="string">|  5 | e2    |</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">5 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 窗口2</span></span><br><span class="line"><span class="string">mysql&gt; select * from mylock01;</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">| id | title |</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">|  1 | a1    |</span></span><br><span class="line"><span class="string">|  2 | b1    |</span></span><br><span class="line"><span class="string">|  3 | c1    |</span></span><br><span class="line"><span class="string">|  4 | d1    |</span></span><br><span class="line"><span class="string">|  5 | e1    |</span></span><br><span class="line"><span class="string">+----+-------+</span></span><br><span class="line"><span class="string">5 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; update mylock01 set title = &#x27;</span>a123<span class="string">&#x27; where id = 1;</span></span><br><span class="line"><span class="string">-- 阻塞，因为窗口1中已经将该表锁定了，需等带窗口1释放锁。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 窗口1释放锁</span></span><br><span class="line"><span class="string">mysql&gt; unlock tables;</span></span><br><span class="line"><span class="string">Query OK, 0 rows affected (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 窗口2 整常执行了</span></span><br><span class="line"><span class="string">mysql&gt; update mylock01 set title = &#x27;</span>a123<span class="string">&#x27; where id = 1;</span></span><br><span class="line"><span class="string">Query OK, 1 row affected (44.67 sec)</span></span><br><span class="line"><span class="string">Rows matched: 1  Changed: 1  Warnings: 0</span></span><br></pre></td></tr></table></figure><p>总结： 对于MyISAM引擎表，加读锁，不会阻塞其他进程 对一表进行读取操作的，但是会阻塞对同一表的写请求，只有读锁释放之后，才会执行其他进程的写操作。<br>加写锁测试 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> lock <span class="keyword">table</span> mylock01 write;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock01 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> title <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> a123  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mylock01 <span class="keyword">set</span> title <span class="operator">=</span> <span class="string">&#x27;a123&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock02;</span><br><span class="line">ERROR <span class="number">1100</span> (HY000): <span class="keyword">Table</span> <span class="string">&#x27;mylock02&#x27;</span> was <span class="keyword">not</span> locked <span class="keyword">with</span> LOCK TABLES</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口2</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mylock01; </span><br><span class="line"><span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> mylock01 <span class="keyword">set</span> title <span class="operator">=</span> <span class="string">&#x27;a456&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure><p>总结：MyISAM表加写锁，会阻塞其他进程对同一表的读和写操作，只有写锁释放之后，才能执行其他进程的操作。注意：加写锁之后，当前进程页不被允许访问其他表。<br>行级锁测试<br>Innodb行锁的类型： </p><ul><li>共享锁（S）</li><li>排他锁（X）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> innodb_lock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">1</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> innodb_lock;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> aaa  <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> a    <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> a    <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> a    <span class="operator">|</span>   <span class="number">43</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> a    <span class="operator">|</span>   <span class="number">43</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> b    <span class="operator">|</span>   <span class="number">53</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> a    <span class="operator">|</span>   <span class="number">63</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">8</span> <span class="operator">|</span> d    <span class="operator">|</span>   <span class="number">73</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>总结：在有写锁的情况下，一个事务时不允许读取到其他事务没有提交的内容的。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> innodb_lock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> aaa  <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口2</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> ionodb_lock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;bbb&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> innodb_lock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> bbb  <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> innodb_lock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> aaa  <span class="operator">|</span>   <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>总结一下：在有写锁的情况下，一个事务内多次读取同一数据的结果，始终与第一次读取的结果保持一致。 </p><h2 id="面试题68：说一下行级锁的分类？"><a href="#面试题68：说一下行级锁的分类？" class="headerlink" title="面试题68：说一下行级锁的分类？"></a>面试题68：说一下行级锁的分类？</h2><p>回顾行级锁:</p><ul><li>Innodb存储引擎支持行级锁，MyISAM是不支持的。 </li><li>普通的select语句不会对记录加锁，因为它是快照读。 </li><li>如果要在查询时对记录加行锁，可以使用下面两种方式</li></ul><p>上面两条语句必须在一个事务中，因为事务提交时，锁就会被释放。 </p><p>行级锁的类型主要有三类：</p><ul><li>record lock：记录锁，指的是将一条记录加锁，锁上。</li><li>gap lock： 间隙锁，锁定的是一个范围，但是不包含记录本身。</li><li>next-key lock: 记录锁 + 间隙锁的组合，锁定一个范围，并且锁定记录本身。</li></ul><p>record lock：记录锁，锁住的是一条记录，记录锁是有共享锁和排他锁的区别。</p><ul><li>当一个事务对一条记录加了S锁之后，其他的事务也可以继续对该记录追加S型记录锁（S锁和S锁之间是兼容），但是不能加X型的记录锁。 </li><li>当一个事务对一条记录加了X锁之后，其他的事务不能添加S锁，也不能追加X锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>；</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure><p> gap lock: 间隙锁，只存在于RR隔离级别目的就是为了解决可重复读隔离级别下幻读的问题。</p><ul><li>假设，表中有一个范围是（3,5）间隙锁，其他事务就无法插入id&#x3D;4这条记录，这样就防止了幻读的发生。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135320492.png" alt="image-20250216135320492"></p><p>next-key-lock: 临键锁，记录锁+间隙锁的组合。</p><ul><li>假设，表中有一个范围ID为（3,5] 临键锁，其他事务不能插入ID&#x3D;4 的记录，也不能修改ID&#x3D;5的记录</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135326776.png" alt="image-20250216135326776"></p><ul><li>临键锁，既能保护记录，又能阻止其他事务将新纪录插入到被保护的记录前面的间隙。</li></ul><p>插入意向锁简介：</p><p>当一条记录，正在被某个事务操作时，其他事务就会进入阻塞状态，直到拥有间隙锁的事务提交位置，在此期间会生产一个插入意向锁，表明有事务想在某个区间插入新的记录， 现在正处在等待状态。</p><h2 id="面试题69：为什么说-插入、更新、删除操作，都归为当前读？"><a href="#面试题69：为什么说-插入、更新、删除操作，都归为当前读？" class="headerlink" title="面试题69：为什么说 插入、更新、删除操作，都归为当前读？"></a>面试题69：为什么说 插入、更新、删除操作，都归为当前读？</h2><p>MVCC多版本并发控制的机制中，读操作被分为两类：</p><p>快照读：简单的select操作时不加锁，属于快照读。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><p>当前读: 特殊的读操作，插入、更新、删除操作，都属于当前读，需要加锁。</p><p>当前读 读取的是最新的版本记录。并且，在读取之后，还需要保证其他并发事务不会修改当前的记录，对读取的记录加锁的，除了in share mode对读取的记录加的是共享锁意外，其他操作加的都是X锁 排他锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ...</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> ...</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> ...</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">in</span> share mode;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>update操作的流程：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135332101.png" alt="image-20250216135332101"></p><ol><li>当更新语句发送给MySQL后，MySQL Server会根据where条件， 读取第一个满足条件的记录，InnoDB引擎会将查询到的第一条记录返回，并加上锁(current read当前读)。</li><li>MySQL Server收到这条加锁的记录后，会再发起一个Update请求，更新这条记录。</li><li>一条记录操作完成，再读取下一条记录，直到没有满足条件的记录为止。</li></ol><p>总结：通过上面的分析，我们可以知道Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作有时可能会触发Unique Key 冲突检查，也会有一个当前读，读取这个主键是否已经存在。</p><h2 id="面试题70：说一下MySQL中对于不同的隔离级别和索引类型，行锁采用的加锁方式有什么不同？"><a href="#面试题70：说一下MySQL中对于不同的隔离级别和索引类型，行锁采用的加锁方式有什么不同？" class="headerlink" title="面试题70：说一下MySQL中对于不同的隔离级别和索引类型，行锁采用的加锁方式有什么不同？"></a>面试题70：说一下MySQL中对于不同的隔离级别和索引类型，行锁采用的加锁方式有什么不同？</h2><p>问： 下面的查询语句加锁了吗？加的是什么类型的锁？</p><p><strong>SQL1：select * from v1 where id &#x3D; 1;</strong></p><p>在串行化隔离级别下，是加了读锁。其余三种隔离级别，由于MVCC快照读，所以是不加锁</p><p>问： 下面的查询语句加锁了吗？加的是什么类型的锁？</p><p><strong>SQL1：delete from v1 where id &#x3D; 10;</strong></p><p>分析SQL语句的加锁情况时，应该注意以下几个问题：</p><ol><li>id 列是不是主键？ </li><li>当前系统的隔离级别是什么？ </li><li>id列如果不是主键，那么id列上有没有索引？ </li><li>id列上如果有索引，这个索引是不是唯一索引。 </li><li>SQL的执行计划是什么？索引扫描、全表扫描。</li></ol><p><strong>RC隔离级别加锁机制</strong></p><p>组合一：id主键 + RC级别。当id是主键时，只需要在该条SQL操作的数据记录上加写锁即可。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135338217.png" alt="image-20250216135338217"></p><p>组合二：id唯一索引 + RC级别。</p><p>因为id是唯一索引，where会走id列的索引进行过滤，在找到id&#x3D;10的记录后对唯一索引id&#x3D;10的记录加X锁。</p><p>同时会回表查询主键索引name&#x3D;d的数据，并对name&#x3D;d的数据也加上X锁。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135343620.png" alt="image-20250216135343620"></p><p>唯一索引与主键索引都需要加锁，因为如果在执行这条删除语句的时候，并发出现了一条更新语句，更新语句的where条件是name字段， 那么如果删除操作没有对主键索引加锁，那么更新语句不会知道有删除操作的存在从而进行更新，这样就违反了同一数据行上的写操作需要串行化执行的原则。</p><p>组合三：id非唯一索引 + RC级别。</p><p>1）对ID索引中符合条件的数据加上X锁。</p><p>2）再把对应的主键索引上的数据也加上X锁。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135348146.png" alt="image-20250216135348146"></p><p>与组合二的区别在于ID是非唯一索引的情况下，会对满足条件的多条数据都加上X锁。而组合二因为id是唯一索引列，所以只会对一条数据加上X锁。</p><p>组合四：id无索引 + RC级别。</p><p>由于没有索引，所以走的是全表扫描，所以会对主键索引上每一条记录施加X锁。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135352528.png" alt="image-20250216135352528"></p><p><strong>RR隔离级别加锁机制</strong></p><p>​id主键+RR隔离级别 与 组合一一致。</p><p>​id唯一索引 + RR隔离级别，与组合二一致。</p><p>组合五：id非唯一索引+RR：</p><p>RC 级别下允许幻读的出现。</p><p>RR级别不允许幻读的出现，InnoDB通过增加间隙锁来解决这个问题。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135358589.png" alt="image-20250216135358589"></p><p>1）首先对ID索引中符合条件的数据施加X锁。</p><p>2）对符合条件施加X锁的数据前后间隙施加间隙锁。</p><p>3）对ID索引对应的主键索引的数据施加X锁。</p><p>施加了GAP锁以后，数据的前后都不会插入新的数据，就可以保证两次当前读的结果完全一致。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135404703.png" alt="image-20250216135404703"></p><p>在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新&#x2F;删除&#x2F;插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p><h2 id="面试题71：MySQL何时需要进行分库分表？"><a href="#面试题71：MySQL何时需要进行分库分表？" class="headerlink" title="面试题71：MySQL何时需要进行分库分表？"></a>面试题71：MySQL何时需要进行分库分表？</h2><p>什么情况下需要用到分库分表：</p><ul><li>单机存储容量达到瓶颈。</li><li>服务器连接数和处理能里能力达到上限。</li><li>单表数据量超过1000万条或者达到100G时候，可以考虑分库分表。</li></ul><p>分库分表的方式：</p><ul><li><strong>垂直分库：</strong><br>按照业务不同，将不同的表进行分类，相同业务下的表放到一个数据库上。<br>将数据库部署到不同的服务器上，减轻单台服务器负载压力。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135410477.png" alt="image-20250216135410477"></p><ul><li><strong>垂直分表：</strong></li></ul><p>表中的字段太多，包含大字段的时候，在查询时对数据库IO、内存来说压力是比较大的，在数据更新时，会产生大量binlog日志，MySQL在进行主从同步时有延时风险。</p><p>垂直分表指的是将一个表，按照字段进行拆分，拆分成多个表。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135415571.png" alt="image-20250216135415571"></p><ul><li><strong>垂直拆分：垂直分库和垂直分表</strong><br> 解决业务层面的耦合，业务清晰。<br>可以针对不同业务的数据进行分级管理 。<br>在高并发场景下，垂直分库一定程度能够提高访问性能。<br>但是垂直拆分无法解决单表数据量多大的问题。 </li><li><strong>水平拆分：水平分库</strong><br>简单说： 水平分库指的是根据表中的数据的逻辑关系，将同一个表的数据按照某种条件拆分到多台数据库服务器中。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135420765.png" alt="image-20250216135420765"></p><ul><li><strong>水平拆分：水平分表</strong></li></ul><p>简单说：对于数据量比较大的一张表，按照规则把一张表的数据，拆分到多张表中，但是这些表还是在同一个数据库。 </p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135426302.png" alt="image-20250216135426302"></p><p><strong>垂直拆分：属于结构性的拆分，不会涉及到数据。一般是在数据库设计阶段就完成。</strong></p><p><strong>水平拆分：属于按照数据进行拆分。是在数据量达到一定阶段时，才会进行。</strong></p><h2 id="面试题72：MySQL出现死锁怎么办？"><a href="#面试题72：MySQL出现死锁怎么办？" class="headerlink" title="面试题72：MySQL出现死锁怎么办？"></a>面试题72：MySQL出现死锁怎么办？</h2><p>表级锁的死锁：</p><ul><li><p>产生原因 </p></li><li><p>用户A —》 锁定A表  —》 B表（表锁）</p></li><li><p>用户B —》锁定B表  —》A表 （表锁）</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135431638.png" alt="image-20250216135431638"></p><ul><li><p>解决方案 </p></li><li><p>上面的死锁产生的原因主要是程序的逻辑错误导致的，解决的方案就是首先要分析程序执行的逻辑，对于数据库的多表的操作时，尽量按照相同的顺序进行处理，避免同时锁定两个资源这种情况。</p></li></ul><p>行级锁的死锁</p><ul><li><p>产生的原因1 </p></li><li><p>如果在事务中执行了一条没有索引的SQL查询，引发全表扫描，把行级锁上升为全表锁定（等价于表锁），多个这样的事务执行后，就很容易产生死锁。</p></li><li><p>解决方案 </p></li><li><p>在SQL语句中要正确的使用索引，避免太复杂的关联查询，使用Explain执行计划对SQL进行分析，对于有全表扫描和全表锁定语句，建立相应的索引，进行优化。</p></li><li><p>产生的原因2: </p></li><li><p>两个事务分别想拿对方持有的锁，互相等待，产生死锁。</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135437985.png" alt="image-20250216135437985"></p><ul><li>产生原因3：每个事务只有一个SQL，但是有些情况还是会发生死锁。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135443931.png" alt="image-20250216135443931"></p><ul><li>解决方案：上面的原因2 和原因3，都是对索引加锁顺序的不一致导致的，所以如果可以应该尽量以相同的顺序访问索引记录和表。在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序处理记录，也可以降低出现死锁的可能。</li></ul><p>死锁案例演示：</p><ul><li>数据准备</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> test_deadLock(</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span>     name <span class="type">varchar</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> age <span class="type">int</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> test_deadLock <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;lisi&#x27;</span>,<span class="number">11</span>),(<span class="number">2</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">22</span>),(<span class="number">3</span>,<span class="string">&#x27;wangwu&#x27;</span>,<span class="number">33</span>);</span><br><span class="line">Query OK, <span class="number">3</span> <span class="keyword">rows</span> affected (<span class="number">0.02</span> sec)</span><br><span class="line">Records: <span class="number">3</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_deadLock;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> lisi     <span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu   <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>事务和锁相关的操作</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看当前MySQL的事务隔离级别</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@tx_isolation</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx_isolation</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看加锁信息</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前运行的所有事务</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看锁等待的信息</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_lock_waits;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看死锁日志</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engine innodb status;</span><br></pre></td></tr></table></figure><ul><li><p>案例分析 </p></li><li><p>窗口1</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> lisi <span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_id <span class="string">&#x27;事务ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_state <span class="string">&#x27;事务状态&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_started  <span class="string">&#x27;事务开始时间&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_weight <span class="string">&#x27;事务的权重&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_mysql_thread_id <span class="string">&#x27;事务线程ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_tables_locked  <span class="string">&#x27;事务拥有多少个锁&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_lock_memory_bytes <span class="string">&#x27;事务锁住的内存&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_rows_locked  <span class="string">&#x27;事务锁定的行数&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_rows_modified <span class="string">&#x27;事务修改的行数&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> information_schema.innodb_trx;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> 事务ID   <span class="operator">|</span> 事务状态     <span class="operator">|</span> 事务开始时间        <span class="operator">|</span> 事务的权重      <span class="operator">|</span> 事务线程ID     <span class="operator">|</span> 事务拥有多少个锁         <span class="operator">|</span> 事务锁住的内存        <span class="operator">|</span> 事务锁定的行数        <span class="operator">|</span> 事务修改的行数        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5023</span>     <span class="operator">|</span> <span class="keyword">RUNNING</span>      <span class="operator">|</span> <span class="number">2023</span><span class="number">-11</span><span class="number">-05</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13</span> <span class="operator">|</span>               <span class="number">2</span> <span class="operator">|</span>             <span class="number">24</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span>                  <span class="number">1136</span> <span class="operator">|</span>                     <span class="number">1</span> <span class="operator">|</span>                     <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>窗口2</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_id <span class="string">&#x27;事务ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_state <span class="string">&#x27;事务状态&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_started  <span class="string">&#x27;事务开始时间&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_weight <span class="string">&#x27;事务的权重&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_mysql_thread_id <span class="string">&#x27;事务线程ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_tables_locked  <span class="string">&#x27;事务拥有多少个锁&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_lock_memory_bytes <span class="string">&#x27;事务锁住的内存&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_rows_locked  <span class="string">&#x27;事务锁定的行数&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> trx_rows_modified <span class="string">&#x27;事务修改的行数&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> information_schema.innodb_trx;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> 事务ID   <span class="operator">|</span> 事务状态     <span class="operator">|</span> 事务开始时间        <span class="operator">|</span> 事务的权重      <span class="operator">|</span> 事务线程ID     <span class="operator">|</span> 事务拥有多少个锁         <span class="operator">|</span> 事务锁住的内存        <span class="operator">|</span> 事务锁定的行数        <span class="operator">|</span> 事务修改的行数        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5024</span>     <span class="operator">|</span> <span class="keyword">RUNNING</span>      <span class="operator">|</span> <span class="number">2023</span><span class="number">-11</span><span class="number">-05</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">23</span> <span class="operator">|</span>               <span class="number">3</span> <span class="operator">|</span>             <span class="number">25</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span>                  <span class="number">1136</span> <span class="operator">|</span>                     <span class="number">1</span> <span class="operator">|</span>                     <span class="number">1</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5023</span>     <span class="operator">|</span> <span class="keyword">RUNNING</span>      <span class="operator">|</span> <span class="number">2023</span><span class="number">-11</span><span class="number">-05</span> <span class="number">22</span>:<span class="number">38</span>:<span class="number">13</span> <span class="operator">|</span>               <span class="number">2</span> <span class="operator">|</span>             <span class="number">24</span> <span class="operator">|</span>                        <span class="number">1</span> <span class="operator">|</span>                  <span class="number">1136</span> <span class="operator">|</span>                     <span class="number">1</span> <span class="operator">|</span>                     <span class="number">0</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+--------------+---------------------+-----------------+----------------+--------------------------+-----------------------+-----------------------+-----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>窗口1</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> lisi <span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> test_deadLock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure><ul><li>查看当前锁信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> </span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_id <span class="string">&#x27;锁的ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_trx_id <span class="string">&#x27;拥有锁的事务ID&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_mode  <span class="string">&#x27;锁的模式&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_type <span class="string">&#x27;锁的类型&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_table <span class="string">&#x27;加锁的表&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_index <span class="string">&#x27;被锁的索引&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_space <span class="string">&#x27;被锁的表空间号&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_page <span class="string">&#x27;被锁的页号&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_rec <span class="string">&#x27;被锁的记录号&#x27;</span>,</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> lock_data <span class="string">&#x27;被锁的数据&#x27;</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">from</span> information_schema.innodb_locks;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------+--------------+--------------+--------------------------+-----------------+-----------------------+-----------------+--------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> 锁的ID      <span class="operator">|</span> 拥有锁的事务ID       <span class="operator">|</span> 锁的模式     <span class="operator">|</span> 锁的类型     <span class="operator">|</span> 加锁的表                 <span class="operator">|</span> 被锁的索引      <span class="operator">|</span> 被锁的表空间号        <span class="operator">|</span> 被锁的页号      <span class="operator">|</span> 被锁的记录号       <span class="operator">|</span> 被锁的数据      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------+--------------+--------------+--------------------------+-----------------+-----------------------+-----------------+--------------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5025</span>:<span class="number">42</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">5025</span>                 <span class="operator">|</span> X            <span class="operator">|</span> RECORD       <span class="operator">|</span> `testdb`.`test_deadLock` <span class="operator">|</span> <span class="keyword">PRIMARY</span>         <span class="operator">|</span>                    <span class="number">42</span> <span class="operator">|</span>               <span class="number">3</span> <span class="operator">|</span>                  <span class="number">4</span> <span class="operator">|</span> <span class="number">3</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5024</span>:<span class="number">42</span>:<span class="number">3</span>:<span class="number">4</span> <span class="operator">|</span> <span class="number">5024</span>                 <span class="operator">|</span> X            <span class="operator">|</span> RECORD       <span class="operator">|</span> `testdb`.`test_deadLock` <span class="operator">|</span> <span class="keyword">PRIMARY</span>         <span class="operator">|</span>                    <span class="number">42</span> <span class="operator">|</span>               <span class="number">3</span> <span class="operator">|</span>                  <span class="number">4</span> <span class="operator">|</span> <span class="number">3</span>               <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------+----------------------+--------------+--------------+--------------------------+-----------------+-----------------------+-----------------+--------------------+-----------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>查看锁等待的信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span>  </span><br><span class="line">requesting_trx_id <span class="string">&#x27;请求锁的事务ID&#x27;</span>, </span><br><span class="line">requested_lock_id <span class="string">&#x27;请求锁的锁ID&#x27;</span>, </span><br><span class="line">blocking_trx_id <span class="string">&#x27;当前拥有锁的事务ID&#x27;</span>, </span><br><span class="line">blocking_lock_id <span class="string">&#x27;当前拥有锁的锁ID&#x27;</span> </span><br><span class="line"><span class="keyword">from</span> information_schema.innodb_lock_waits;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------------------+----------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> 请求锁的事务ID       <span class="operator">|</span> 请求锁的锁ID      <span class="operator">|</span> 当前拥有锁的事务ID         <span class="operator">|</span> 当前拥有锁的锁ID        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------------------+----------------------------+-------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5025</span>                 <span class="operator">|</span> <span class="number">5025</span>:<span class="number">42</span>:<span class="number">3</span>:<span class="number">4</span>       <span class="operator">|</span> <span class="number">5024</span>                       <span class="operator">|</span> <span class="number">5024</span>:<span class="number">42</span>:<span class="number">3</span>:<span class="number">4</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+-------------------+----------------------------+-------------------------+</span></span><br></pre></td></tr></table></figure><ul><li>死锁的复现</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> lisi <span class="operator">|</span>   <span class="number">11</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口2</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> test_deadLock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">-- 阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口2 </span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> test_deadLock <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.01</span> sec) <span class="comment">-- 删除结果是成功的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 窗口1</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> test_deadLock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">ERROR <span class="number">1213</span> (<span class="number">40001</span>): Deadlock found <span class="keyword">when</span> trying <span class="keyword">to</span> <span class="keyword">get</span> lock; try restarting transaction</span><br></pre></td></tr></table></figure><ul><li>死锁日志的查看</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engine innodb status;</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"><span class="comment">------------------------</span></span><br><span class="line"><span class="number">2023</span><span class="number">-11</span><span class="number">-05</span> <span class="number">23</span>:<span class="number">10</span>:<span class="number">14</span> <span class="number">0x7f50b4774700</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) TRANSACTION:</span><br><span class="line">TRANSACTION <span class="number">5060</span>, ACTIVE <span class="number">82</span> sec starting index read</span><br><span class="line"><span class="comment">-- 事务的编号，活跃的秒数，starting index read表示事务状态为根据索引读取数据</span></span><br><span class="line">mysql tables <span class="keyword">in</span> use <span class="number">1</span>, locked <span class="number">1</span></span><br><span class="line"><span class="comment">-- 表示的有一张表被使用了，locked 1 表示表上有一个表锁，对于DML语句为LOCK_IX</span></span><br><span class="line">LOCK WAIT <span class="number">3</span> lock struct(s), heap size <span class="number">1136</span>, <span class="number">2</span> <span class="type">row</span> lock(s)</span><br><span class="line">MySQL thread id <span class="number">24</span>, OS thread handle <span class="number">139984601556736</span>, query id <span class="number">479</span> localhost root updating</span><br><span class="line"><span class="keyword">update</span> test_deadLock <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">3</span></span><br><span class="line"><span class="comment">-- 正在等待锁的SQL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> (<span class="number">1</span>) WAITING <span class="keyword">FOR</span> THIS LOCK <span class="keyword">TO</span> BE GRANTED:</span><br><span class="line">RECORD LOCKS space id <span class="number">42</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index <span class="keyword">PRIMARY</span> <span class="keyword">of</span> <span class="keyword">table</span> `testdb`.`test_deadLock` trx id <span class="number">5060</span> lock_mode X locks rec but <span class="keyword">not</span> gap waiting</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">4</span> PHYSICAL RECORD: n_fields <span class="number">5</span>; compact format; info bits <span class="number">32</span></span><br></pre></td></tr></table></figure><p>死锁的总结：</p><ol><li>对索引加锁的顺序不一致，很可能导致死锁，所以应该尽量以相同的顺序来访问索引记录和表。</li><li>间隙锁往往是程序中导致死锁的元凶，由于MySQL默认隔离级别是RR，会用到间隙锁，防止幻读。所以如果不可重复读和幻读对当前业务影响不大的话，可以考虑降低隔离级别为RC。</li><li>为表添加合理的索引，如果不走索引就会为表中的每一行数据加锁，死锁的概率增加。</li><li>避免大事务，尽量将大事务拆分成多个小事务来处理。</li><li>避免在同一时间点运行多个对同一表进行读写的脚本。</li><li>设置锁等待的超时参数。</li></ol><h2 id="面试题73：update-没加索引会锁全表吗？"><a href="#面试题73：update-没加索引会锁全表吗？" class="headerlink" title="面试题73：update 没加索引会锁全表吗？"></a>面试题73：update 没加索引会锁全表吗？</h2><p>update条件不加索引为什么会锁全表？</p><ul><li>Innodb存储引擎默认的隔离级别【可重复读】，在该隔离级别下可能会出现幻读的问题，因此Innodb自己实现了行锁，通过next-key-lock，来锁住记录本身以及记录之间的间隙，来防止幻读的产生。 </li><li>如果使用一张表中的主键或者唯一索引作为条件，那么next-key-lock就会退化成记录锁，也就是给一些行记录加锁。 </li><li>但是如果在update语句中where条件没有使用索引，就会产生全表扫描，就会对所有的记录加 next-key-lock(记录锁+间隙锁)，就相当于锁定了整张表。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135454533.png" alt="image-20250216135454533"></p><ul><li>在数据量非常大的数据库表执行update操作时，如果没有索引，就会给全表加上临键锁，这个锁会持续比较长的时间，直到事务结束，这期间就只能执行select语句，其他语句无法执行，业务就会停滞，影响非常大。</li></ul><p>如何避免这种问题的发生？</p><ul><li><p>设置 sql_safe_updates &#x3D;1，该参数值为1时，update语句必须满足下面的条件之一才能执行 </p></li><li><p>使用where，并且where条件中必须有索引列</p></li><li><p>使用limit</p></li><li><p>同时使用where和limit，这时where中可以没有索引。</p></li></ul><h2 id="面试题74：下面操作中，加了什么锁，会导致死锁吗？"><a href="#面试题74：下面操作中，加了什么锁，会导致死锁吗？" class="headerlink" title="面试题74：下面操作中，加了什么锁，会导致死锁吗？"></a>面试题74：下面操作中，加了什么锁，会导致死锁吗？</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135502690.png" alt="image-20250216135502690"></p><p>数据准备</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_student` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `<span class="keyword">no</span>` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `score` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_student <span class="keyword">values</span></span><br><span class="line">(<span class="number">15</span>,<span class="string">&#x27;s0001&#x27;</span>,<span class="string">&#x27;Bod&#x27;</span>,<span class="number">25</span>,<span class="number">24</span>),</span><br><span class="line">(<span class="number">18</span>,<span class="string">&#x27;s0002&#x27;</span>,<span class="string">&#x27;Alice&#x27;</span>,<span class="number">24</span>,<span class="number">77</span>),</span><br><span class="line">(<span class="number">20</span>,<span class="string">&#x27;s0003&#x27;</span>,<span class="string">&#x27;Jim&#x27;</span>,<span class="number">24</span>,<span class="number">5</span>),</span><br><span class="line">(<span class="number">30</span>,<span class="string">&#x27;s0004&#x27;</span>,<span class="string">&#x27;Eric&#x27;</span>,<span class="number">23</span>,<span class="number">91</span>),</span><br><span class="line">(<span class="number">37</span>,<span class="string">&#x27;s0005&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">22</span>,<span class="number">22</span>),</span><br><span class="line">(<span class="number">49</span>,<span class="string">&#x27;s0006&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="number">25</span>,<span class="number">83</span>),</span><br><span class="line">(<span class="number">50</span>,<span class="string">&#x27;s0007&#x27;</span>,<span class="string">&#x27;Rose&#x27;</span>,<span class="number">23</span>,<span class="number">89</span>);</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_student;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> <span class="keyword">no</span>    <span class="operator">|</span> name  <span class="operator">|</span> age  <span class="operator">|</span> score <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> s0001 <span class="operator">|</span> Bod   <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span>    <span class="number">24</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">18</span> <span class="operator">|</span> s0002 <span class="operator">|</span> Alice <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>    <span class="number">77</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> s0003 <span class="operator">|</span> Jim   <span class="operator">|</span>   <span class="number">24</span> <span class="operator">|</span>     <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">30</span> <span class="operator">|</span> s0004 <span class="operator">|</span> Eric  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span>    <span class="number">91</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">37</span> <span class="operator">|</span> s0005 <span class="operator">|</span> Tom   <span class="operator">|</span>   <span class="number">22</span> <span class="operator">|</span>    <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">49</span> <span class="operator">|</span> s0006 <span class="operator">|</span> Tom   <span class="operator">|</span>   <span class="number">25</span> <span class="operator">|</span>    <span class="number">83</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">50</span> <span class="operator">|</span> s0007 <span class="operator">|</span> Rose  <span class="operator">|</span>   <span class="number">23</span> <span class="operator">|</span>    <span class="number">89</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+-------+------+-------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>两个事务中的SQL的执行顺序：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135508769.png" alt="image-20250216135508769"></p><p>事务A和事务B 都在执行insert操作后，陷入了等待状态，也就是发生了死锁，双方都在等待对方释放锁。</p><p>为什么会发生死锁？</p><ul><li><p>Time1阶段加锁的分析，Time阶段事务A执行下面的语句 </p></li><li><p>执行更新操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_student <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>查看锁相关信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139758399749528</span>:<span class="number">1065</span>:<span class="number">139758302997200</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2073</span><span class="comment">-- 事务A ID</span></span><br><span class="line">            THREAD_ID: <span class="number">50</span></span><br><span class="line">             EVENT_ID: <span class="number">14</span></span><br><span class="line">        OBJECT_SCHEMA: testdb</span><br><span class="line">          OBJECT_NAME: t_student</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139758302997200</span></span><br><span class="line">            LOCK_TYPE: <span class="keyword">TABLE</span><span class="comment">-- 表锁</span></span><br><span class="line">            LOCK_MODE: IX<span class="comment">-- 意向锁</span></span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139758399749528</span>:<span class="number">2</span>:<span class="number">4</span>:<span class="number">5</span>:<span class="number">139758302994208</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2073</span><span class="comment">-- 事务A ID</span></span><br><span class="line">            THREAD_ID: <span class="number">50</span></span><br><span class="line">             EVENT_ID: <span class="number">14</span></span><br><span class="line">        OBJECT_SCHEMA: testdb</span><br><span class="line">          OBJECT_NAME: t_student</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">PRIMARY</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139758302994208</span></span><br><span class="line">            LOCK_TYPE: RECORD<span class="comment">-- 表示行级锁</span></span><br><span class="line">            LOCK_MODE: X,GAP<span class="comment">-- x类型间隙锁</span></span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="number">30</span><span class="comment">-- 锁范围最右值</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><p>通过查询锁信息，可以看出共加了两个锁： </p></li><li><p>表锁：X类型的意向锁</p></li><li><p>行锁：X类型的间隙锁</p></li><li><p>LOCK_TYPE中的record表示的是行级锁，不是行级锁分类下的记录锁，可以通过LOCK_MODE来来确定行级锁的类型 </p></li><li><p>LOCK_MODE &#x3D; X,GAP ，表示是间隙锁。</p></li><li><p>LOCK_MODE &#x3D; X，表示是next-key-lock临键锁。</p></li><li><p>LOCK_MODE&#x3D;X, REC_NOT_GAP ,表示是记录锁。</p></li><li><p>得出结论：此时事务A在主键索引上加的间隙锁，锁的范围是：（20，30）</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135514730.png" alt="image-20250216135514730"></p><ul><li><p>Time2阶段加锁的分析，Time2阶段事务B执行下面的语句 </p></li><li><p>执行更新操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> t_student <span class="keyword">set</span> score <span class="operator">=</span> <span class="number">100</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">0</span>  Changed: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li>查看锁信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> performance_schema.data_locks\G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139758399750384</span>:<span class="number">1065</span>:<span class="number">139758303003344</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2074</span><span class="comment">-- 事务B的ID</span></span><br><span class="line">            THREAD_ID: <span class="number">49</span></span><br><span class="line">             EVENT_ID: <span class="number">12</span></span><br><span class="line">        OBJECT_SCHEMA: testdb</span><br><span class="line">          OBJECT_NAME: t_student</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">NULL</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139758303003344</span></span><br><span class="line">            LOCK_TYPE: <span class="keyword">TABLE</span></span><br><span class="line">            LOCK_MODE: IX</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               ENGINE: INNODB</span><br><span class="line">       ENGINE_LOCK_ID: <span class="number">139758399750384</span>:<span class="number">2</span>:<span class="number">4</span>:<span class="number">5</span>:<span class="number">139758303000432</span></span><br><span class="line">ENGINE_TRANSACTION_ID: <span class="number">2074</span></span><br><span class="line">            THREAD_ID: <span class="number">49</span></span><br><span class="line">             EVENT_ID: <span class="number">12</span></span><br><span class="line">        OBJECT_SCHEMA: testdb</span><br><span class="line">          OBJECT_NAME: t_student</span><br><span class="line">       PARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">    SUBPARTITION_NAME: <span class="keyword">NULL</span></span><br><span class="line">           INDEX_NAME: <span class="keyword">PRIMARY</span></span><br><span class="line">OBJECT_INSTANCE_BEGIN: <span class="number">139758303000432</span></span><br><span class="line">            LOCK_TYPE: RECORD</span><br><span class="line">            LOCK_MODE: X,GAP</span><br><span class="line">          LOCK_STATUS: GRANTED</span><br><span class="line">            LOCK_DATA: <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li><p>事务B加的锁也是X型的间隙锁，锁定的范围还是（20，30）。</p></li><li><p>事务A和事务B的间隙锁的范围是一样的，为什么不会冲突呢？原因就是 两个事务之间的间隙锁是相互兼容的，不会成产生冲突。</p></li><li><p>Time3时刻加锁分析 </p></li><li><p>事务A中执行插入操作</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_student(id,<span class="keyword">no</span>,name,age,score) <span class="keyword">value</span>(<span class="number">25</span>,<span class="string">&#x27;soo25&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>,<span class="number">28</span>,<span class="number">90</span>);</span><br><span class="line"><span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure><ul><li>此时事务A陷入等待状态</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135520748.png" alt="image-20250216135520748"></p><ul><li><p>可以看到事务A的状态为， LOCK_STATUS: WAITING   。因为事务B生产了间隙锁,锁定的范围是（20,30）。事务A想要向该间隙插入数据，需要生成一个意向锁：LOCK_MODE: INSERT_INTENTION  ，插入意向锁。 </p></li><li><p>每插入一条新纪录，就需要看一下待插入的记录的下一条是否已经加了间隙锁，如果已经加了间隙锁，此时就会生成一个 插入意向锁，然后锁的状态设置为等待状态。 </p></li><li><p>Time4 事务B，插入一条数据</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> t_student(id,<span class="keyword">no</span>,name,age,score) <span class="keyword">value</span>(<span class="number">26</span>,<span class="string">&#x27;soo25&#x27;</span>,<span class="string">&#x27;sony&#x27;</span>,<span class="number">28</span>,<span class="number">90</span>);\</span><br><span class="line"><span class="comment">-- 阻塞</span></span><br></pre></td></tr></table></figure><ul><li>事务B进入了等待状态</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135526200.png" alt="image-20250216135526200"></p><ul><li><p>事务B在生成插入意向锁时被阻塞了，是因为事务B向事务A生成的间隙锁范围（20,30）内 插入数据导致的,插入意向锁和间隙锁是冲突，所以事务B陷入等待状态。 </p></li><li><p>为什么会发生死锁？<br>在当前案例中，事务A和事务B在执行完update操作后，都持有了范围是 （20,30）的间隙锁，接下来两个事务都去执行插入操作，但是插入操作需要获取插入意向锁，所以都需要等待对方释放各自的间隙锁。于是就造成了循环等待状态，发生死锁。 </p></li><li><p>死锁总结： </p></li><li><p>两个事务即使生成的间隙锁的范围是一样的，也不会冲突。因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁和间隙锁之间是兼容。</p></li><li><p>在执行插入语句的时候，如果插入的记录在其他事务持有的间隙锁的范围内，插入语句就会阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，插入意向锁和间隙锁时互斥的关系。</p></li><li><p>满足死锁有四个条件：互斥、占有且等待、不可强占用、循环等待，就会发生死锁。</p></li></ul><h2 id="面试题75：MySQL是怎么加行锁的？"><a href="#面试题75：MySQL是怎么加行锁的？" class="headerlink" title="面试题75：MySQL是怎么加行锁的？"></a>面试题75：MySQL是怎么加行锁的？</h2><p>级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。加锁的对象是索引，加锁的基本单位是next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock是前开后闭区间，而间隙锁是前开后开区间。但是，next-key lock在一些场景下会退化成记录锁或间隙锁。那到底是什么场景呢？总结一句，在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁。</p><p>行级锁加锁的对象是索引，加锁的基本单位 next-key lock，它是由记录锁和间隙锁组合成，临键锁是前开后闭的区间，而间隙锁是前开后开的区间。</p><p>但是一些情况下，临键锁会退化成记录锁或者间隙锁。</p><p><strong>在能使用记录锁或者间隙锁的情况下就可以避免幻读问题，那么next-key-lock就会退化为记录锁或者间隙锁。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_age` (`age`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(id,name,age) <span class="keyword">values</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>,<span class="number">19</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">5</span>,<span class="string">&#x27;jack&#x27;</span>,<span class="number">21</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">10</span>,<span class="string">&#x27;lucy&#x27;</span>,<span class="number">22</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">15</span>,<span class="string">&#x27;kobe&#x27;</span>,<span class="number">20</span>),</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> (<span class="number">20</span>,<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">39</span>);</span><br><span class="line">Query OK, <span class="number">5</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Records: <span class="number">5</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> tom      <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> jack     <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> lucy     <span class="operator">|</span>  <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> kobe     <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>1）通过主键唯一索引等值查询。</p><ul><li>查询记录是存在的，那么在索引树上定位到这一条记录后， 将该记录的索引中的next-key-lock退化成 记录锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> tom  <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>加锁信息查询：事务A在id&#x3D;1的记录的主键索引上加了记录锁，锁住的范围就是该条记录。 </p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135533719.png"></p><ul><li>注：由于主键具有唯一性，所以当针对主键进行等值查询时，<strong>next-key-lock会退化为记录锁</strong>。因为记录锁就可以防止幻读的出现了。 </li><li>查询记录不存在，在索引树中找到第一条大于该查询记录的记录后，将该记录的索引的next-key-lock退化成间隙锁。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135538977.png" alt="image-20250216135538977"></p><p> 当记录不存在是，事务A在id&#x3D;5的主键索引上加的是间隙锁，锁住的范围（1,5）;</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135549903.png" alt="image-20250216135549903"></p><ul><li>select * from user where id &#x3D; 2 for update; <strong>该查询语句中的条件id&#x3D;2 是不存在的，在索引树中找到第一条大于该该记录的记录后，将该记录中next-key-lock就会退化为间隙锁。</strong></li></ul><p>2）唯一索引范围查询</p><ul><li><p>当唯一索引进行范围查询时，会对每一个扫描到的索引加 next-key锁，然后遇到下面的情况，会退化为记录锁或者间隙锁。 </p></li><li><p>情况1：针对与 大于等于 的范围查询，因为存在等值查询条件，那么等值查询的记录如果存在于表中，那么该记录的索引中的锁就会由next-key lock 退化成记录锁。 </p></li><li><p>情况2：针对于 小于或者小于等于的范围查询，要看条件值的记录是否存在于表中 </p></li><li><p>存在:<br>如果是小于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引就会由next-key lock 退化为间隙锁，其他扫描的记录都是加的next-key lock 。<br>如果是小于等于条件的范围查询，扫描到终止范围查询的记录时，该记录的索引不会由next-key lock 退化为间隙锁，其他扫描的记录都是加的next-key lock 。 </p></li><li><p>不存在<br>当不存在于表中时。不管是小于还是小于等于条件范围查询，扫描到终止范围查询的记录时，该记录的索引就会有next-key lock 退化为间隙锁，其他扫描的记录都是加的next-key lock 。 </p></li><li><p>针对与大于的范围查询情况：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p> <img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135555220.png" alt="image-20250216135555220"></p><ul><li><p>上面的操作加了两个X型的 临键锁。 </p></li><li><p>在id&#x3D;20这条记录上，加了范围为 （15，20] 的临键锁。</p></li><li><p>在特殊记录supremum pseudo-record  的主键上加了范围为 20，无穷大的临键锁。</p></li><li><p>针对于大于等于的范围查询分析。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> kobe     <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> zhangsan <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135749448.png" alt="image-20250216135749448"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135742046.png" alt="image-20250216135742046"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135735930.png" alt="image-20250216135735930"></p><ul><li><p>针对与小于或者小于等于的范围查询 </p></li><li><p>针对与小于的范围查询时（小于等于也是一样的），查询记录不存在于表中的情况的分析：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> tom  <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> jack <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li><p>加锁信息查看 </p></li><li><p>在id&#x3D;1这条记录的主键索引上，加了范围为（无穷小，1）的临键锁，意味着其他事务无法更新或者删除id&#x3D;1的这条记录，同时也无法插入小于1 的新记录。</p></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135727904.png" alt="image-20250216135727904"></p><ul><li>在id&#x3D;5这条记录的主键上，加了范围索引（1,5] 的临键锁。意味着其他事务无法更新或者删除id&#x3D;5的这条记录的，同时也无法插入id为 2 3 4的新纪录。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135718180.png" alt="image-20250216135718180"></p><ul><li>在id&#x3D;10 这条记录的主键索引上加了间隙锁，范围是（5,10)。意味着无法插入ID值为 6 7 8 9的新纪录</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135712039.png" alt="image-20250216135712039"></p><hr><ul><li>针对于小于等于的范围查询，查询条件值的记录是存在于表中的。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;=</span><span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> tom  <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> jack <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>加锁信息</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135705855.png" alt="image-20250216135705855"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135659969.png" alt="image-20250216135659969"></p><p>针对于小于的范围查询，查询条件值的记录是存在于表中的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> tom  <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>加锁信息</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135653771.png" alt="image-20250216135653771"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216135646571.png" alt="image-20250216135646571"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理 -- 高可用集群</title>
      <link href="/2024/11/17/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/"/>
      <url>/2024/11/17/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-高可用集群剖析"><a href="#MySQL-高可用集群剖析" class="headerlink" title="MySQL 高可用集群剖析"></a>MySQL 高可用集群剖析</h1>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常见问题及排查方法</title>
      <link href="/2024/11/16/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/"/>
      <url>/2024/11/16/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="1-连接问题"><a href="#1-连接问题" class="headerlink" title="1. 连接问题"></a><strong>1. 连接问题</strong></h3><p><strong>现象</strong>：应用程序无法连接 MySQL。</p><ul><li><strong>可能原因</strong>：<ul><li>MySQL 服务未启动。</li><li>网络不通（防火墙、端口限制）。</li><li>用户权限配置错误。</li><li>连接数达到上限。</li></ul></li><li><strong>排查方法</strong>：<ul><li>检查服务状态：<code>systemctl status mysqld</code> 或 <code>service mysql status</code>。</li><li>测试网络连通性：<code>telnet &lt;IP&gt; 3306</code> 或 <code>nc -zv &lt;IP&gt; 3306</code>。</li><li>检查用户权限：<code>SHOW GRANTS FOR &#39;user&#39;@&#39;host&#39;;</code>。</li><li>查看连接数限制：<code>SHOW VARIABLES LIKE &#39;max_connections&#39;;</code> 和当前连接数 <code>SHOW STATUS LIKE &#39;Threads_connected&#39;;</code>。</li></ul></li></ul><hr><h3 id="2-性能问题"><a href="#2-性能问题" class="headerlink" title="2. 性能问题"></a><strong>2. 性能问题</strong></h3><p><strong>现象</strong>：查询缓慢、响应时间长。</p><ul><li><strong>可能原因</strong>：<ul><li>未合理使用索引（全表扫描）。</li><li>锁竞争（行锁、表锁、死锁）。</li><li>硬件资源瓶颈（CPU、内存、磁盘 I&#x2F;O）。</li><li>配置参数不合理（如 <code>innodb_buffer_pool_size</code> 过小）。</li></ul></li><li><strong>排查方法</strong>：<ul><li>启用慢查询日志，分析耗时 SQL：<code>SET GLOBAL slow_query_log = ON;</code>。</li><li>使用 <code>EXPLAIN</code> 分析查询执行计划。</li><li>检查锁状态：<code>SHOW ENGINE INNODB STATUS;</code> 或 <code>SELECT * FROM information_schema.INNODB_LOCKS;</code>。</li><li>监控资源使用：<code>top</code>, <code>vmstat</code>, <code>iostat</code> 或工具（如 Prometheus + Grafana）。</li></ul></li></ul><hr><h3 id="3-主从复制异常"><a href="#3-主从复制异常" class="headerlink" title="3. 主从复制异常"></a><strong>3. 主从复制异常</strong></h3><p><strong>现象</strong>：主从数据不同步、复制延迟或中断。</p><ul><li><strong>可能原因</strong>：<ul><li>主从网络中断。</li><li>主库或从库 SQL 执行失败（如约束冲突）。</li><li>二进制日志损坏或配置不一致。</li></ul></li><li><strong>排查方法</strong>：<ul><li>查看从库状态：<code>SHOW SLAVE STATUS\G</code>，关注 <code>Last_IO_Error</code> 和 <code>Last_SQL_Error</code>。</li><li>检查主从配置一致性（如 <code>server_id</code>、<code>binlog_format</code>）。</li><li>手动跳过错误（谨慎操作）：<code>SET GLOBAL SQL_SLAVE_SKIP_COUNTER=1;</code>。</li><li>重新同步数据：通过 <code>mysqldump</code> 或 <code>xtrabackup</code> 重建从库。</li></ul></li></ul><hr><h3 id="4-死锁问题"><a href="#4-死锁问题" class="headerlink" title="4. 死锁问题"></a><strong>4. 死锁问题</strong></h3><p><strong>现象</strong>：事务被回滚，日志中提示 <code>Deadlock found</code>。</p><ul><li><strong>排查方法</strong>：<ul><li>查看最近死锁信息：<code>SHOW ENGINE INNODB STATUS;</code>（输出中的 <code>LATEST DETECTED DEADLOCK</code> 部分）。</li><li>优化事务逻辑，减少事务粒度。</li><li>调整隔离级别：如从 <code>REPEATABLE READ</code> 改为 <code>READ COMMITTED</code>。</li></ul></li></ul><hr><h3 id="5-数据损坏或丢失"><a href="#5-数据损坏或丢失" class="headerlink" title="5. 数据损坏或丢失"></a><strong>5. 数据损坏或丢失</strong></h3><p><strong>现象</strong>：表无法打开，提示 <code>Table is marked as crashed</code>。</p><ul><li><strong>排查方法</strong>：<ul><li>使用修复工具：对 MyISAM 表执行 <code>REPAIR TABLE table_name;</code>，或命令行工具 <code>myisamchk</code>。</li><li>对 InnoDB 表尝试强制恢复模式：在 <code>my.cnf</code> 中添加 <code>innodb_force_recovery=1~6</code>（逐步尝试）。</li><li>从备份恢复数据，并检查硬件（如磁盘坏道）。</li></ul></li></ul><hr><h3 id="6-磁盘空间不足"><a href="#6-磁盘空间不足" class="headerlink" title="6. 磁盘空间不足"></a><strong>6. 磁盘空间不足</strong></h3><p><strong>现象</strong>：写入失败，提示 <code>No space left on device</code>。</p><ul><li><strong>排查方法</strong>：<ul><li>清理日志文件（如二进制日志、慢查询日志）：<code>PURGE BINARY LOGS BEFORE &#39;yyyy-mm-dd&#39;;</code>。</li><li>收缩表空间：对 InnoDB 表执行 <code>OPTIMIZE TABLE table_name;</code>。</li><li>扩展磁盘或迁移数据目录。</li></ul></li></ul><hr><h3 id="7-内存不足（OOM）"><a href="#7-内存不足（OOM）" class="headerlink" title="7. 内存不足（OOM）"></a><strong>7. 内存不足（OOM）</strong></h3><p><strong>现象</strong>：MySQL 进程被系统杀死，日志提示 <code>Out of memory</code>。</p><ul><li><strong>排查方法</strong>：<ul><li>调整内存参数：<code>innodb_buffer_pool_size</code>（通常设置为物理内存的 60-80%）、<code>key_buffer_size</code>。</li><li>监控内存使用：<code>free -h</code>、<code>pmap</code> 或 <code>/proc/&lt;pid&gt;/smaps</code>。</li><li>优化查询，减少内存临时表的使用。</li></ul></li></ul><hr><h3 id="8-权限问题"><a href="#8-权限问题" class="headerlink" title="8. 权限问题"></a><strong>8. 权限问题</strong></h3><p><strong>现象</strong>：用户无法执行操作，提示 <code>Access denied</code>。</p><ul><li><strong>排查方法</strong>：<ul><li>检查权限配置：<code>SHOW GRANTS FOR &#39;user&#39;@&#39;host&#39;;</code>。</li><li>确认用户密码是否过期：<code>ALTER USER &#39;user&#39;@&#39;host&#39; IDENTIFIED BY &#39;new_password&#39;;</code>。</li></ul></li></ul><hr><h3 id="9-字符集乱码"><a href="#9-字符集乱码" class="headerlink" title="9. 字符集乱码"></a><strong>9. 字符集乱码</strong></h3><p><strong>现象</strong>：数据存储或显示为乱码。</p><ul><li><strong>排查方法</strong>：<ul><li>检查字符集配置：<code>SHOW VARIABLES LIKE &#39;character_set%&#39;;</code>。</li><li>确保建表时指定字符集（如 <code>CREATE TABLE ... DEFAULT CHARSET=utf8mb4;</code>）。</li><li>客户端连接时指定字符集：添加参数 <code>--default-character-set=utf8mb4</code>。</li></ul></li></ul><hr><h3 id="10-版本兼容性问题"><a href="#10-版本兼容性问题" class="headerlink" title="10. 版本兼容性问题"></a><strong>10. 版本兼容性问题</strong></h3><p><strong>现象</strong>：升级后 SQL 报错或功能异常。</p><ul><li><strong>排查方法</strong>：<ul><li>查阅官方文档的版本变更说明，确认语法或配置变更。</li><li>使用 <code>mysql_upgrade</code> 工具升级系统表结构。</li><li>测试环境验证后再进行生产环境升级。</li></ul></li></ul><hr><h3 id="通用排查工具"><a href="#通用排查工具" class="headerlink" title="通用排查工具"></a><strong>通用排查工具</strong></h3><ol><li><strong>日志分析</strong>：<ul><li>错误日志：<code>SHOW VARIABLES LIKE &#39;log_error&#39;;</code>。</li><li>慢查询日志：<code>SHOW VARIABLES LIKE &#39;slow_query_log_file&#39;;</code>。</li></ul></li><li><strong>内置命令</strong>：<ul><li><code>SHOW PROCESSLIST;</code>：查看当前活跃会话。</li><li><code>SHOW STATUS;</code> 和 <code>SHOW VARIABLES;</code>：获取运行状态和配置。</li></ul></li><li><strong>外部工具</strong>：<ul><li><code>pt-query-digest</code>（Percona Toolkit）：分析慢查询日志。</li><li><code>mysqltuner.pl</code>：性能优化建议。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理 -- 架构体系</title>
      <link href="/2024/11/16/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/"/>
      <url>/2024/11/16/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-体系架构剖析"><a href="#MySQL-体系架构剖析" class="headerlink" title="MySQL 体系架构剖析"></a>MySQL 体系架构剖析</h1><h2 id="1、-体系架构"><a href="#1、-体系架构" class="headerlink" title="1、 体系架构"></a>1、 体系架构</h2><p>MySQL架构基本上是一个客户端-服务器（C&#x2F;S）系统。MySQL数据库服务器是服务器，连接到MySQL数据库服务器的应用程序是客户端。MySQL架构包含以下主要组件。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011303243.png" alt="image-20250217011303243"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011308210.png" alt="image-20250217011308210"></p><h3 id="1-1-连接层"><a href="#1-1-连接层" class="headerlink" title="1.1 连接层"></a>1.1 连接层</h3><p>MySQL的最上层是连接服务，引入了线程池的概念，允许多台客户端连接。主要工作是：<strong>连接处理、授权认证、安全防护、管理连接等</strong>。</p><p>当客户端连接到 MySQL 服务器时，服务器对其进行认证。基于用户名、原始主机信息和密码。一旦客户端连接成功，服务器会继续验证客户端是否具有执行某个特定权限（比如：是否对某张表具有某种操作权限）。</p><p>连接层为通过安全认证的接入用户提供线程，同样，在该层上可以实现基于SSL 的安全连接。连接层中还负责 MySQL Server 与客户端的通信，接受客户端的命令请求，传递 Server 端的结果信息等。</p><p>连接处理：每个客户端连接都会分配一个线程，来自客户端的所有查询都是在该线程中执行，从MySQL5.5版本开始支持线程池。</p><p>授权认证：对客户端进行身份验证，基于用户名、主机信息、密码。</p><p>安全防护：验证客户端发出某些查询的权限。</p><p>连接层为通过安全认证的用户提供线程，也支持SSL的安全连接，还负责MySQL Server与客户端的通信，接受客户端的命令请求，传递Server端处理的结果。</p><h3 id="1-2-服务层"><a href="#1-2-服务层" class="headerlink" title="1.2 服务层"></a>1.2 服务层</h3><ul><li>服务层用于处理核心服务，如标准的SQL接口、NoSQL接口、查询解析、SQL优化和统计、全局的和引擎依赖的缓存与缓冲器等等。</li><li>所有的与存储引擎无关的工作，如过程、函数等，都会在这一层来处理。该层负责MySQL关系数据库系统所有的逻辑功能。</li><li>在该层上，服务器会解析查询并创建相应的内部解析树，并对其完成优化，如确定查询表的顺序，是否利用索引等，最后生成相关的执行操作。</li><li>如果是SELECT 语句，服务器还会查询内部的缓存（Select Id，Name from User_Token where Id&#x3D;1）。如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能（MySQL8版本中已经将查询缓存移除）。</li></ul><p>MySQL的服务层分为各种子组件：</p><h4 id="组件一：系统管理和实用程序（Management-Service-Utilities）。"><a href="#组件一：系统管理和实用程序（Management-Service-Utilities）。" class="headerlink" title="组件一：系统管理和实用程序（Management Service &amp; Utilities）。"></a><strong>组件一：系统管理和实用程序（Management Service &amp; Utilities）。</strong></h4><p>包括备份恢复、安全管理、集群管理服务和工具。</p><h4 id="组件二：SQL接口（SQL-Interface）"><a href="#组件二：SQL接口（SQL-Interface）" class="headerlink" title="组件二：SQL接口（SQL Interface）"></a><strong>组件二：SQL接口（SQL Interface）</strong></h4><p>接收客户端发送的各种 SQL 语句，比如 DML、DDL 和存储过程等，并且返回用户执行的结果。</p><h4 id="组件三：缓存（Cache-Buffer）"><a href="#组件三：缓存（Cache-Buffer）" class="headerlink" title="组件三：缓存（Cache &amp; Buffer）"></a><strong>组件三：缓存（Cache &amp; Buffer）</strong></h4><p>主要功能是将客户端提交 给MySQL 的 Select 类 Query 请求的返回结果集 Cache 到内存中，与该 Query 的一个 Hash 值做一个对应（将Query对应的查询结果缓存起来，Query的SQL语句做一个Hash，得到一个Hash值。如果大小写、空格等会影响到Hash值的结果，比如：Select Id，Name from User_Token where Id&#x3D;1和Select id，Name from User_Token where Id&#x3D;1不一样的值）。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 Query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的，当然它对内存的消耗也是非常大的。</p><p>对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p><p>这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</p><p><strong>但不推荐使用查询缓存</strong>，即大多数情况下不建议使用查询缓存。为什么呢？</p><p>原因：查询缓存的失效机制是有缺陷的，只要对一个表有更新操作（增、删、改），这个表所有的查询缓存全部清空。除非你的业务就是一张静态表，很长时间才更新一次。比如：系统配置表、菜单表。</p><h4 id="组件四：SQL解析器（Parser）"><a href="#组件四：SQL解析器（Parser）" class="headerlink" title="组件四：SQL解析器（Parser）"></a><strong>组件四：SQL解析器（Parser）</strong></h4><p>如果缓存没有命中，SQL命令传递到解析器的时候会被解析器验证和解析，最终对 SQL 语句进行语法解析生成解析树（树形的数据结构）。</p><ul><li><p>词法分析 </p></li><li><p>需要识别出SQL语句中的字符串分别是什么，各代表什么</p></li><li><p>通过识别到的Select关键字就可以知道这是一个查询语句</p></li><li><p>把字符串“T”识别为表名，把“Col1”，“Col2”识别为列名</p></li><li><p>语法分析 </p></li><li><p>语法解析器会根据语法规则，判断输入的SQL语句是否满足MySQL语句要求</p></li><li><p>比如检查表名、列名是否正确等等。</p></li></ul><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，比如下面这个语句 select 少打了开头的字母“s”。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> elect <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;elect * from t where ID=1&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br></pre></td></tr></table></figure><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。</p><p><strong>【总结】：</strong></p><p>将SQL语句进行语义和语法的分析，分解成数据结构（解析树），然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。如果在分解构成中遇到错误，那么就说明这个SQL语句是不合理的。</p><p>解析树是通过解析器来解析SQL的关键字和非关键字，SQL语句按照关键字和非关键字进行分类，生成树。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011313374.png" alt="image-20250217011313374"></p><h4 id="组件五：查询优化器（Optimizer）"><a href="#组件五：查询优化器（Optimizer）" class="headerlink" title="组件五：查询优化器（Optimizer）"></a><strong>组件五：查询优化器（Optimizer）</strong></h4><p>接下来并不是直接执行，而是会在优化器这一层进行优化。</p><p>优化器是个非常复杂的部件，它会帮我们去使用他自己认为的最好的方式去优化这条 SQL  语句，并生成一条条的执行计划。</p><p>MySQL 使用 <code>explain + sql 语句</code>查看执行计划，该执行计划不一定完全正确但是可以参考。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">User</span> <span class="keyword">WHERE</span> nid <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011318465.png" alt="image-20250217011318465"></p><p>根据解析树生成最优的执行计划。MySQL使用很多优化策略生成最优的执行计划，可以分为两类：静态优化（编译时的优化），动态优化（运行时的优化）。</p><p>（1）等价变换策略：</p><p>​where 5&#x3D;5 and a&gt;5  —&gt;  where a&gt;5</p><p>（2）优化count、min、max等函数：</p><p>​Inno引擎min函数只需要查找索引最左边</p><p>​Inno引擎max函数只需要查找索引最又边</p><p>​Count()，不需要计算，直接返回</p><p>（3）提前终止查询：</p><p>​Limit查询，获得Limit所需要的数据之后，不需要遍历后面的数据了</p><p>（4）in的优化：</p><p>​MySQL针对in查询，会进行排序，再采用区分查找法去找数据。in(2,1,3)  —&gt;  in(1,2,3)</p><p>（5）条件查询：</p><p>SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求Query，根据客户端请求的 Query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 Query 语句的结果。使用的是“选取-投影-联接”策略进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uid,name <span class="keyword">from</span> <span class="keyword">User</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>选取：先根据where语句进行选择，而不是先将表全部查询出来之后再根据gender过滤。</p><p>投影：会根据uid和name进行属性投影，而不是将属性全部取出来再进行过滤。</p><p>联接：将上面这两个查询条件连接起来生成最终的查询结果。</p><p>（6）连接查询：</p><p>在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">join</span> t2 <span class="keyword">using</span>(ID)  <span class="keyword">where</span> t1.c<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> t2.d<span class="operator">=</span><span class="number">20</span>;</span><br></pre></td></tr></table></figure><ul><li>既可以先从表t1里面取出c&#x3D;10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。</li><li>也可以先从表t2里面取出d&#x3D;20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。</li></ul><p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p><p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p><h4 id="组件六：执行器"><a href="#组件六：执行器" class="headerlink" title="组件六：执行器"></a><strong>组件六：执行器</strong></h4><p>工作内容：</p><ol><li>判断对这个表有没有查询权限</li><li>有权限, 则继续执行；如果没有，就会返回没有权限的错误</li><li>调用存储引擎接口进行执行查询或其他操作</li><li>最终将查询结果集返回给客户端，语句即执行完成</li></ol><p>简述：</p><ul><li>解析器知道了你想做什么</li><li>优化器知道该怎么做最合适</li><li>执行器去执行</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T <span class="keyword">where</span> ID<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line">ERROR <span class="number">1142</span> (<span class="number">42000</span>): <span class="keyword">SELECT</span> command denied <span class="keyword">to</span> <span class="keyword">User</span> <span class="string">&#x27;b&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="string">&#x27;T&#x27;</span></span><br></pre></td></tr></table></figure><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义（创建表的时候可以执行该表对应的存储迎引擎，如果不指定那么默认使用InnoDB），去使用这个引擎提供的接口。</p><p>比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：</p><ol><li>调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；</li><li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li><li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li></ol><p>至此，这个语句就执行完成了。</p><p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p><h3 id="1-3-存储引擎层"><a href="#1-3-存储引擎层" class="headerlink" title="1.3 存储引擎层"></a>1.3 存储引擎层</h3><p>存储引擎层负责 MySQL 中数据的存储与提取，服务器中的查询执行引擎通过 API 与存储引擎进行通信，通过接口屏蔽了不同存储引擎之间的差异。</p><p>MySQL 采用插件式的存储引擎。MySQL 为我们提供了许多存储引擎，每种存储引擎有不同的特点。我们可以根据不同的业务特点，选择最适合的存储引擎。如果对于存储引擎的性能不满意，可以通过修改源码来得到自己想要达到的性能。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><ul><li>MySQL 采用插件式的存储引擎。</li><li>存储引擎是针对于表的而不是针对库的（一个库中不同表可以使用不同的存储引擎），服务器通过 API 与存储引擎进行通信，用来屏蔽不同存储引擎之间的差异。</li><li>不管表采用什么样的存储引擎，都会在数据区，产生对应的一个 的一个 frm 文件（表结构定义描述文件）</li></ul><h3 id="1-4-物理存储层"><a href="#1-4-物理存储层" class="headerlink" title="1.4 物理存储层"></a>1.4 物理存储层</h3><p>存储引擎底部是物理存储层，是文件的物理存储层（磁盘），包括二进制（BinLog）日志、数据文件、错误日志、慢查询日志、全日志、redo&#x2F;Undo 日志（事务）等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据目录*/</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%datadir%&#x27;</span></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> databases;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sys                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><ul><li>mysql：MySQL系统自带的核心库，存储MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，运行过程中产生日志信息，一些帮助信息及其时区信息。</li><li>information_schema：保存着MySQL服务器维护的其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、那些列、哪些索引。</li><li>performance_schema：保存MySQL运行过程中的状态信息，监控服务器的各类性能指标。</li><li>sys：通过视图的形式把performance_schema和information_schema结合起来。</li></ul><h2 id="2、-SQL运行机制"><a href="#2、-SQL运行机制" class="headerlink" title="2、 SQL运行机制"></a>2、 SQL运行机制</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011325215.png" alt="image-20250217011325215"></p><p>流程描述：</p><ol><li>通过客户端&#x2F;服务器通信协议与 MySQL 建立连接。</li><li>查询缓存，如果开启了 Query Cache 且在查询缓存过程中查询到完全相同的 SQL 语句，则将查询结果直接返回给客户端；如果没有开启Query Cache 或没有查询到完全相同的 SQL 语句则会由解析器经过词法分析，语法分析后生成解析树。</li><li>预处理器生成新的解析树，主要工作是处理解析器无法解决的语义，检查权限等，生成新的解析树。</li><li>查询优化器生成执行计划。</li><li>查询执行引擎执行 SQL 语句，此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的 API 接口与底层存储引擎缓存或者物理文件的交互情况，得到查询结果。</li><li>由MySQL Server 过滤后将查询结果缓存并返回给客户端。若开启了 Query Cache，这时也会将SQL 语句和结果完整地保存到 Query Cache 中，以后若有相同的 SQL 语句执行则直接返回结果。</li></ol><h3 id="2-1-C-S通信协议"><a href="#2-1-C-S通信协议" class="headerlink" title="2.1 C&#x2F;S通信协议"></a>2.1 C&#x2F;S通信协议</h3><p>建立连接（Connectors&amp;Connection Pool），通过客户端&#x2F;服务器通信协议与MySQL建立连接。MySQL 客户端与服务端的通信方式是 “ 半双工 ”。对于每一个 MySQL 的连接，时刻都有一个线程状态来标识这个连接正在做什么。</p><p>通讯机制：</p><ul><li>全双工：任意时刻，客户端和服务器既可以发送数据，也可以接收数据。</li><li>半双工：在任一时刻，要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。</li><li>单工</li></ul><p>MySQL客户端&#x2F;服务端通信协议是“半双工”的，一旦一端开始发送消息，另一端要接收完整个消息才能响应它，所以我们无法也无须将一个消息切成小块独立发送，也没有办法进行流量控制。</p><p>客户端用一个单独的数据包将查询请求发送给服务器，所以当查询语句很长的时候，需要设置max_allowed_packet参数。但是需要注意的是，如果查询实在是太大，服务端会拒绝接收更多数据并抛出异常。</p><h3 id="2-2-查询缓存"><a href="#2-2-查询缓存" class="headerlink" title="2.2 查询缓存"></a>2.2 查询缓存</h3><p><strong>从MySQL 5.7.20起，查询缓存已被弃用，并在MySQL 8.0中删除。</strong></p><p>在解析一个查询语句前，如果查询缓存是打开的，那么MySQL会检查这个查询语句是否命中查询缓存中的数据（命中率）。如果当前查询恰好命中查询缓存，在检查一次用户权限后直接返回缓存中的结果。这种情况下，查询不会被解析，也不会生成执行计划，更不会执行。</p><p>MySQL将缓存存放在一个引用表（类似于HashMap的数据结构），通过一个哈希值索引（针对于客户端描述信息以及SQL语句），这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中</p><h4 id="查询缓存的优缺点"><a href="#查询缓存的优缺点" class="headerlink" title="查询缓存的优缺点"></a><strong>查询缓存的优缺点</strong></h4><p><strong>优点：</strong><br>Query Cache的查询，发生在MySQL接收到客户端的查询请求、查询权限验证之后和查询SQL解析之前。</p><p>也就是说，当MySQL接收到客户端的查询SQL之后，仅仅只需要对其进行相应的权限验证之后，就会通过Query Cache来查找结果，甚至都不需要经过Optimizer模块进行执行计划的分析优化，更不需要发生任何存储引擎的交互。</p><p>由于Query Cache是基于内存的，直接从内存中返回相应的查询结果，因此减少了大量的磁盘I&#x2F;O和CPU计算，导致效率非常高。</p><p><strong>缺点：</strong></p><ul><li>MySQL会对每条接收到的SELECT类型的查询进行Hash计算，然后查找这个查询的缓存结果是否存在。虽然Hash计算和查找的效率已经足够高了，一条查询语句所带来的开销可以忽略，但一旦涉及到高并发，有成千上万条查询语句时，Hash计算和查找所带来的开销就必须重视了。 </li><li>Query Cache的失效问题。如果表的变更比较频繁，则会造成Query Cache的失效率非常高。表的变更不仅仅指表中的数据发生变化，还包括表结构或者索引的任何变化。 </li><li>查询语句不同，但查询结果相同的查询都会被缓存，这样便会造成内存资源的过度消耗。查询语句的字符大小写、空格或者注释的不同，Query Cache都会认为是不同的查询（因为他们的Hash值会不同）。 </li><li>相关系统变量设置不合理会造成大量的内存碎片，这样便会导致Query Cache频繁清理内存。</li></ul><h4 id="架构级缓存解决方案："><a href="#架构级缓存解决方案：" class="headerlink" title="架构级缓存解决方案："></a><strong>架构级缓存解决方案：</strong></h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011331491.png" alt="image-20250217011331491" style="zoom:80%;" /><h3 id="2-3-语法解析和预处理"><a href="#2-3-语法解析和预处理" class="headerlink" title="2.3 语法解析和预处理"></a>2.3 语法解析和预处理</h3><p>MySQL通过关键字将SQL语句进行解析，并生成一颗对应的解析树。</p><p>这个过程解析器主要通过语法规则来验证和解析。比如SQL中是否使用了错误的关键字或者关键字的顺序是否正确等等。预处理则会根据MySQL规则进一步检查解析树是否合法。比如检查要查询的数据表和数据列是否存在等。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011345743.png" alt="image-20250217011345743" style="zoom:80%;" /><h3 id="2-4-查询优化器"><a href="#2-4-查询优化器" class="headerlink" title="2.4 查询优化器"></a>2.4 查询优化器</h3><p>根据解析树生成最优的执行计划。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011404327.png" alt="image-20250217011404327" style="zoom:80%;" /><ol><li>逻辑查询优化：</li></ol><ul><li>对SQL语句做一些等价交换、对条件表达式进行等价谓词重写、条件顺序的调整、条件简化、视图重写、子查询、连接查询优化。</li></ul><ol><li>物理查询优化</li></ol><ul><li>CBO：Cost-Based Optimizer，基于代价的优化，根据模型计算出各个可能的执行计划的代价，选择代价最小的一个，它会利用数据库里面的统计信息来做判断，动态。</li><li>RBO：Rule-Based Optimizer，基于规则的优化，主要基于一些预置的规则，对查询进行优化。</li></ul><h3 id="2-5-查询执行引擎"><a href="#2-5-查询执行引擎" class="headerlink" title="2.5 查询执行引擎"></a>2.5 查询执行引擎</h3><p>查询执行引擎负责执行 SQL 语句（选择对应的存储引擎去执行），此时查询执行引擎会根据 SQL 语句中表的存储引擎类型，以及对应的API接口与底层存储引擎缓存或者物理文件的交互，得到查询结果并返回给客户端。</p><p>若开启用查询缓存，这时会将SQL 语句和结果完整地保存到查询缓存中，以后若有相同的 SQL 语句执行则直接返回结果。</p><ul><li>如果开启了查询缓存，先将查询结果做缓存操作</li><li>返回结果过多，采用增量模式返回</li></ul><h3 id="2-6-流程总结"><a href="#2-6-流程总结" class="headerlink" title="2.6 流程总结"></a>2.6 流程总结</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011418725.png" alt="image-20250217011418725"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250217011432243.png" alt="image-20250217011432243"></p><h4 id="连接流程："><a href="#连接流程：" class="headerlink" title="连接流程："></a><strong>连接流程：</strong></h4><ol><li>客户端发起一条Query请求，监听客户端的‘连接管理模块’接收请求</li><li>将请求转发到‘连接进&#x2F;线程模块’</li><li>调用‘用户模块’来进行授权检查</li><li>通过检查后，‘连接进&#x2F;线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接，如果失败则创建一个新的连接请求。</li></ol><h4 id="处理："><a href="#处理：" class="headerlink" title="处理："></a><strong>处理：</strong></h4><ol><li>先查询缓存，检查Query语句是否完全匹配，接着再检查是否具有权限，都成功则直接取数据返回</li><li>上一步有失败则转交给‘命令解析器’，经过词法分析，语法分析后生成解析树</li><li>接下来是预处理阶段，处理解析器无法解决的语义，检查权限等，生成新的解析树</li><li>再转交给对应的模块处理</li><li>如果是SELECT查询还会经由‘查询优化器’做大量的优化，生成执行计划</li><li>模块收到请求后，通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限</li><li>有则调用‘表管理模块’，先是查看table cache中是否存在，有则直接对应的表和获取锁，否则重新打开表文件</li><li>根据表的meta数据，获取表的存储引擎类型等信息，通过接口调用对应的存储引擎处理</li><li>上述过程中产生数据变化的时候，若打开日志功能，则会记录到相应二进制日志文件中</li></ol><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a><strong>结果：</strong></h4><ol><li>Query请求完成后，将结果集返回给‘连接进&#x2F;线程模块’</li><li>返回的也可以是相应的状态标识，如成功或失败等</li><li>‘连接进&#x2F;线程模块’进行后续的清理工作，并继续等待请求或断开与客户端的连接</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理 -- 索引及查询优化类</title>
      <link href="/2024/11/10/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E7%B4%A2%E5%BC%95%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%B1%BB/"/>
      <url>/2024/11/10/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E7%B4%A2%E5%BC%95%E5%8F%8A%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-索引原理"><a href="#一、-索引原理" class="headerlink" title="一、 索引原理"></a>一、 索引原理</h1><h2 id="1、-索引概述"><a href="#1、-索引概述" class="headerlink" title="1、 索引概述"></a>1、 索引概述</h2><p>MySQL官方对索引定义：索引是MySQL存储引擎用于快速查找记录的一种数据结构。</p><p>简单理解为： 索引是 排好序的数据结构，帮助我们快速的查询数据库表中的数据。</p><p>索引是一种特殊的数据文件 ：</p><p>MyISAM存储引擎：数据文件和索引文件是分开的。索引文件中保存的是数据记录的地址。</p><p>InnoDB存储引擎：表数据本身就是按照B+Tree组织的索引结构。.ibd文件 就是数据+索引存储文件。索引是一种数据结构 </p><p>索引是一个独立的、物理的数据结构，它是由一个表中的一个字段或者多个字段的值组合成的集合。</p><p>MySQL中，默认使用的是B+Tree结构管理索引。</p><h2 id="2、索引底层数据结构"><a href="#2、索引底层数据结构" class="headerlink" title="2、索引底层数据结构"></a>2、索引底层数据结构</h2><p>InnoDB 底层采用 B+ 数来存储和组织数据， 其他类型 数据结构问题如下：</p><ul><li>二叉查找树<ul><li>在存储有序数据的时候，最终排列结构会形成一个单向链表，对于读取链表尾部的数据时，效率会很低。</li></ul></li><li>AVL 树 &#x2F; 红黑树<ul><li>一个节点最多分裂出两个子节点，树的高度太高，导致IO次数过多</li><li>节点里面只保存一个关键字，每次操作获取的目标数据太少</li></ul></li><li>B 树<ul><li>B-Tree中每个节点不仅包含数据的key值，还有data数据。当data数据较大的时候，会导致每个节点存储的key值减少了，就会导致B树的层数变高。增加查询的I&#x2F;O 次数。</li></ul></li></ul><h3 id="B-树特点"><a href="#B-树特点" class="headerlink" title="B+ 树特点"></a>B+ 树特点</h3><ul><li>所有数据存储在叶子节点，叶子节点形成有序链表，支持范围查询和顺序访问。</li><li>非叶子节点仅存储索引信息，不保存数据，查询效率稳定。</li><li>树的高度较低，减少磁盘I&#x2F;O操作。</li><li><strong>适用场景</strong>：<ul><li>范围查询（如<code>BETWEEN</code>、<code>&gt;</code>、<code>&lt;</code>）。</li><li>频繁的插入和删除操作。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1313648-20210722094807990-431801600.png" alt="img"></p><h2 id="3、-MySQL-索引核心概念"><a href="#3、-MySQL-索引核心概念" class="headerlink" title="3、 MySQL 索引核心概念"></a>3、 MySQL 索引核心概念</h2><p>以下是关于聚簇索引与非聚簇索引、回表查询与覆盖索引、联合索引与最左前缀法则的总结归纳：</p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><ul><li><strong>聚簇索引（Clustered Index）</strong><ul><li><strong>定义</strong>：聚簇索引决定了数据在物理存储上的顺序。表中的数据行存储顺序与索引的顺序一致。</li><li><strong>特点</strong>：<ul><li>每张表只能有一个聚簇索引。</li><li>数据行存储在索引的叶子节点中，因此查询效率高，尤其是范围查询。</li><li>插入、更新和删除操作可能较慢，因为数据行的物理位置可能需要调整。</li><li>适用于主键或唯一性约束的字段。</li></ul></li><li><strong>适用场景</strong>：适合频繁查询的字段，尤其是范围查询（如 <code>SELECT * FROM table WHERE id BETWEEN 100 AND 200</code>）。</li></ul></li><li><strong>非聚簇索引（Non-Clustered Index）</strong><ul><li><strong>定义</strong>：非聚簇索引与数据行的存储顺序无关。索引存储的是指向数据行的指针。</li><li><strong>特点</strong>：<ul><li>一张表可以有多个非聚簇索引。</li><li>索引的叶子节点存储的是指向数据行的指针，而非数据本身。</li><li>查询时可能需要回表查询（即先通过索引找到指针，再通过指针找到数据行）。</li><li>对数据行的物理存储顺序无影响，因此插入、更新和删除操作相对高效。</li></ul></li><li><strong>适用场景</strong>：适合用于精确查询的字段（如 <code>SELECT * FROM table WHERE column = &#39;value&#39;</code>），尤其是当查询字段不频繁用于范围查询时。</li></ul></li></ul><h3 id="回表查询与覆盖索引"><a href="#回表查询与覆盖索引" class="headerlink" title="回表查询与覆盖索引"></a>回表查询与覆盖索引</h3><ul><li><strong>回表查询（Index Backing）</strong><ul><li><strong>定义</strong>：当查询需要的数据不在索引中时，数据库引擎会先通过索引找到数据行的指针，再通过指针访问实际的数据表，获取所需数据。</li><li><strong>特点</strong>：<ul><li>额外的I&#x2F;O操作，性能开销较大。</li><li>通常发生在非聚簇索引查询中，因为非聚簇索引的叶子节点不包含完整的数据行。</li></ul></li><li><strong>优化建议</strong>：尽量减少回表查询，可以通过优化索引设计或调整查询语句来避免。</li></ul></li><li><strong>覆盖索引（Covering Index）</strong><ul><li><strong>定义</strong>：如果查询所需的所有字段都包含在索引中，数据库可以直接通过索引获取数据，而无需回表查询。</li><li><strong>特点</strong>：<ul><li>提高查询效率，减少I&#x2F;O操作。</li><li>索引的叶子节点包含查询所需的所有字段。</li></ul></li><li><strong>适用场景</strong>：适用于查询字段较少且可以通过索引完全覆盖的场景（如 <code>SELECT column1, column2 FROM table WHERE column1 = &#39;value&#39;</code>，其中 <code>column1</code> 和 <code>column2</code> 都在索引中）。</li></ul></li></ul><h3 id="联合索引与最左前缀法则"><a href="#联合索引与最左前缀法则" class="headerlink" title="联合索引与最左前缀法则"></a>联合索引与最左前缀法则</h3><ul><li><strong>联合索引（Composite Index）</strong><ul><li><strong>定义</strong>：联合索引是基于多个字段创建的索引，索引的顺序按照字段的定义顺序排列。</li><li><strong>特点</strong>：<ul><li>提高多字段查询的效率。</li><li>索引的顺序很重要，查询时必须按照索引的顺序使用字段。</li><li>可以部分使用联合索引（即使用索引的前缀字段）。</li></ul></li><li><strong>适用场景</strong>：适用于多字段联合查询（如 <code>SELECT * FROM table WHERE column1 = &#39;value1&#39; AND column2 = &#39;value2&#39;</code>）。</li></ul></li><li><strong>最左前缀法则（Left-Most Prefix Rule）</strong><ul><li><strong>定义</strong>：在联合索引中，查询条件必须从索引的最左边字段开始匹配，才能有效利用索引。</li><li><strong>特点</strong>：<ul><li>如果查询条件跳过了索引的最左边字段，则索引可能无法被有效利用。</li><li>索引的字段顺序对查询性能影响很大。</li></ul></li><li><strong>示例</strong>：<ul><li>索引为 <code>(column1, column2, column3)</code>：<ul><li>查询条件为 <code>WHERE column1 = &#39;value1&#39; AND column2 = &#39;value2&#39;</code> 可以有效利用索引。</li><li>查询条件为 <code>WHERE column2 = &#39;value2&#39; AND column3 = &#39;value3&#39;</code> 则无法有效利用索引。</li></ul></li></ul></li><li><strong>优化建议</strong>：在设计联合索引时，应根据查询频率和字段的过滤性合理安排字段顺序。</li></ul></li></ul><h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><ul><li><strong>定义</strong>：前缀索引是基于字符串字段的前缀创建的索引，而不是整个字段。它通常用于长字符串字段，以减少索引大小。</li><li><strong>特点</strong>：<ul><li>可以显著减少索引的大小，节省存储空间。</li><li>但可能会降低索引的唯一性，增加查询的复杂性。</li></ul></li><li><strong>应用场景</strong>：适用于长字符串字段（如用户名、URL等），尤其是当字段值较长且前缀重复性较低时。</li><li><strong>注意事项</strong>：需要合理选择前缀长度，以平衡索引大小和查询性能。</li></ul><h1 id="二、优化分析"><a href="#二、优化分析" class="headerlink" title="二、优化分析"></a>二、优化分析</h1><h2 id="1、-Explain-指令"><a href="#1、-Explain-指令" class="headerlink" title="1、 Explain 指令"></a>1、 Explain 指令</h2><p>MySQL 的 <code>EXPLAIN</code> 指令是优化 SQL 查询的重要工具，它可以帮助你分析查询的执行计划，理解查询是如何被优化器处理的。以下是 <code>EXPLAIN</code> 的详细梳理：</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>在 SQL 查询前添加 <code>EXPLAIN</code> 或 <code>EXPLAIN FORMAT=JSON</code>（更详细）即可查看执行计划：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure><h3 id="输出字段解析"><a href="#输出字段解析" class="headerlink" title="输出字段解析"></a>输出字段解析</h3><p><code>EXPLAIN</code> 输出的关键字段及其含义：</p><h4 id="1-id"><a href="#1-id" class="headerlink" title="1. id"></a><strong>1. <code>id</code></strong></h4><ul><li><strong>作用</strong>：查询中 SELECT 子句的执行顺序。</li><li><strong>规则</strong>：<ul><li>相同 <code>id</code> 表示同一执行层级（如普通查询）。</li><li><code>id</code> 递增表示嵌套查询（如子查询），值越大优先级越高。</li></ul></li></ul><h4 id="2-select-type"><a href="#2-select-type" class="headerlink" title="2. select_type"></a><strong>2. <code>select_type</code></strong></h4><ul><li><strong>作用</strong>：查询类型。</li><li><strong>常见值</strong>：<ul><li><code>SIMPLE</code>：简单查询（无子查询或 UNION）。</li><li><code>PRIMARY</code>：外层主查询。</li><li><code>SUBQUERY</code>：子查询中的第一个 SELECT。</li><li><code>DERIVED</code>：派生表（FROM 子句中的子查询）。</li><li><code>UNION</code>：UNION 中的第二个或后续查询。</li><li><code>UNION RESULT</code>：UNION 的结果。</li></ul></li></ul><h4 id="3-table"><a href="#3-table" class="headerlink" title="3. table"></a><strong>3. <code>table</code></strong></h4><ul><li><strong>作用</strong>：当前行操作的表名（可能是别名或派生表名如 <code>&lt;derivedN&gt;</code>）。</li></ul><h4 id="4-partitions"><a href="#4-partitions" class="headerlink" title="4. partitions"></a><strong>4. <code>partitions</code></strong></h4><ul><li><strong>作用</strong>：查询匹配到的分区（若表未分区则为 <code>NULL</code>）。</li></ul><h4 id="5-type"><a href="#5-type" class="headerlink" title="5. type"></a><strong>5. <code>type</code></strong></h4><ul><li><strong>作用</strong>：访问数据的方式（性能从优到劣排序）：<ul><li><code>system</code>：表只有一行（系统表）。</li><li><code>const</code>：通过主键或唯一索引直接找到一行（如 <code>WHERE id = 1</code>）。</li><li><code>eq_ref</code>：唯一索引关联（如 <code>JOIN</code> 中使用主键）。</li><li><code>ref</code>：非唯一索引查找（返回多个行）。</li><li><code>range</code>：索引范围扫描（如 <code>BETWEEN</code>、<code>IN</code>）。</li><li><code>index</code>：全索引扫描（遍历索引树）。</li><li><code>ALL</code>：全表扫描（需优化）。</li></ul></li></ul><h4 id="6-possible-keys"><a href="#6-possible-keys" class="headerlink" title="6. possible_keys"></a><strong>6. <code>possible_keys</code></strong></h4><ul><li><strong>作用</strong>：可能用到的索引（实际可能未使用）。</li></ul><h4 id="7-key"><a href="#7-key" class="headerlink" title="7. key"></a><strong>7. <code>key</code></strong></h4><ul><li><strong>作用</strong>：实际使用的索引（若为 <code>NULL</code> 表示未用索引）。</li></ul><h4 id="8-key-len"><a href="#8-key-len" class="headerlink" title="8. key_len"></a><strong>8. <code>key_len</code></strong></h4><ul><li><strong>作用</strong>：使用的索引长度（单位字节），可用于判断联合索引的使用情况。</li></ul><h4 id="9-ref"><a href="#9-ref" class="headerlink" title="9. ref"></a><strong>9. <code>ref</code></strong></h4><ul><li><strong>作用</strong>：显示索引的哪一列被使用（如 <code>const</code> 或列名）。</li></ul><h4 id="10-rows"><a href="#10-rows" class="headerlink" title="10. rows"></a><strong>10. <code>rows</code></strong></h4><ul><li><strong>作用</strong>：预估需要扫描的行数（越小越好）。</li></ul><h4 id="11-filtered"><a href="#11-filtered" class="headerlink" title="11. filtered"></a><strong>11. <code>filtered</code></strong></h4><ul><li><strong>作用</strong>：查询条件过滤后剩余行的百分比（仅限 MySQL 5.7+）。</li></ul><h4 id="12-Extra"><a href="#12-Extra" class="headerlink" title="12. Extra"></a><strong>12. <code>Extra</code></strong></h4><ul><li><strong>作用</strong>：额外信息（常见值）：<ul><li><code>Using index</code>：覆盖索引（无需回表）。</li><li><code>Using where</code>：WHERE 过滤行。</li><li><code>Using temporary</code>：使用临时表（常见于排序或分组）。</li><li><code>Using filesort</code>：需要额外排序（需优化）。</li><li><code>Using join buffer</code>：使用连接缓存（嵌套循环连接）。</li></ul></li></ul><h3 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h3><p>通过 <code>EXPLAIN</code> 分析后，可采取以下优化策略：</p><ol><li><strong>避免全表扫描（<code>type=ALL</code>）</strong>：为 WHERE 条件中的列添加索引。</li><li><strong>优化索引使用</strong>：<ul><li>确保索引覆盖查询字段（减少回表）。</li><li>避免索引失效（如对索引列使用函数、类型转换）。</li></ul></li><li><strong>减少 <code>rows</code> 值</strong>：通过更精确的查询条件减少扫描行数。</li><li>**消除 <code>Using filesort</code> 或 <code>Using temporary</code>**：优化 <code>ORDER BY</code>&#x2F;<code>GROUP BY</code>，使用索引排序。</li><li><strong>关注 <code>Extra</code> 字段</strong>：优先解决 <code>Using filesort</code> 或 <code>Using temporary</code>。</li></ol><h3 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders </span><br><span class="line"><span class="keyword">WHERE</span> user_id <span class="operator">=</span> <span class="number">100</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> order_date;</span><br></pre></td></tr></table></figure><p>假设输出：</p><ul><li><code>type=ref</code>（使用非唯一索引 <code>user_id</code>）</li><li><code>key=user_id</code></li><li><code>Extra=Using filesort</code>（需要额外排序）</li></ul><p><strong>优化</strong>：为 <code>(user_id, order_date)</code> 创建联合索引，消除文件排序。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><code>EXPLAIN</code> 结果是基于统计信息的估算，可能与实际执行有差异。</li><li>使用 <code>EXPLAIN ANALYZE</code>（MySQL 8.0+）可获取实际执行数据。</li><li>分区表、子查询和复杂 JOIN 可能需要更深入分析。</li></ul><p>通过 <code>EXPLAIN</code>，可以快速定位查询瓶颈并针对性优化，是 SQL 性能调优的必备工具。</p><h2 id="2、-索引下推"><a href="#2、-索引下推" class="headerlink" title="2、 索引下推"></a>2、 索引下推</h2><ul><li>索引下推：MySQL5.6引入的，用于查询优化。可以在索引遍历的过程中，对索引中包含的字段先做判断，不符合条件的记录过滤，作用就是减少回表的次数。 </li><li>如下图所示，没有使用索引下推，回表4次</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216225916890.png" alt="image-20250216225916890"></p><ul><li>用索引下推，回表2次</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216225931021.png" alt="image-20250216225931021"></p><h2 id="3、-主键选型"><a href="#3、-主键选型" class="headerlink" title="3、 主键选型"></a>3、 主键选型</h2><p>选择合适的主键是数据库设计中的一个重要环节，它直接影响到数据的完整性、查询性能和系统的可扩展性。以下是一些关于主键选择的建议：</p><h3 id="理解主键的作用"><a href="#理解主键的作用" class="headerlink" title="理解主键的作用"></a>理解主键的作用</h3><p>主键的主要作用是唯一标识表中的每一行数据。它必须满足以下条件：</p><ul><li><strong>唯一性</strong>：主键值不能重复。</li><li><strong>非空性</strong>：主键值不能为空（<code>NOT NULL</code>）。</li><li><strong>稳定性</strong>：主键值在表的生命周期内不应更改。</li></ul><h3 id="常见的主键类型及优缺点"><a href="#常见的主键类型及优缺点" class="headerlink" title="常见的主键类型及优缺点"></a>常见的主键类型及优缺点</h3><h4 id="（1）自然主键（Natural-Key）"><a href="#（1）自然主键（Natural-Key）" class="headerlink" title="（1）自然主键（Natural Key）"></a>（1）<strong>自然主键（Natural Key）</strong></h4><ul><li><strong>定义</strong>：使用数据本身的属性作为主键，如身份证号、用户名、邮箱等。</li><li><strong>优点</strong>：<ul><li>语义化强，易于理解和维护。</li><li>减少冗余，避免额外的字段存储。</li></ul></li><li><strong>缺点</strong>：<ul><li>可能不够稳定（如用户可能更换邮箱）。</li><li>可能导致索引膨胀（如身份证号等长字符串）。</li><li>查询性能可能较低（尤其是长字符串作为主键）。</li></ul></li><li><strong>适用场景</strong>：当自然键稳定且唯一性有保障时，如银行账户号、商品条码等。</li></ul><h4 id="（2）代理主键（Surrogate-Key）"><a href="#（2）代理主键（Surrogate-Key）" class="headerlink" title="（2）代理主键（Surrogate Key）"></a>（2）<strong>代理主键（Surrogate Key）</strong></h4><ul><li><strong>定义</strong>：使用数据库自动生成的值作为主键，通常是整数（如自增ID）。</li><li><strong>优点</strong>：<ul><li>稳定且唯一，不会因业务逻辑变化而改变。</li><li>索引效率高（整数占用空间小，查询速度快）。</li><li>与业务逻辑解耦，便于扩展。</li></ul></li><li><strong>缺点</strong>：<ul><li>缺乏语义化，需要额外字段存储业务标识。</li><li>需要额外维护外键关系。</li></ul></li><li><strong>适用场景</strong>：大多数需要高性能和高扩展性的场景，尤其是业务逻辑复杂或数据频繁更新的系统。</li></ul><h3 id="主键选择的具体建议"><a href="#主键选择的具体建议" class="headerlink" title="主键选择的具体建议"></a>主键选择的具体建议</h3><h4 id="（1）优先选择代理主键（自增ID）"><a href="#（1）优先选择代理主键（自增ID）" class="headerlink" title="（1）优先选择代理主键（自增ID）"></a>（1）<strong>优先选择代理主键（自增ID）</strong></h4><ul><li><p><strong>理由</strong>：</p><ul><li><strong>性能优势</strong>：整数类型的自增ID占用空间小，索引效率高，适合频繁的增删改查操作。</li><li><strong>稳定性</strong>：自增ID不会因业务逻辑变化而更改，适合需要高扩展性的系统。</li><li><strong>通用性</strong>：适用于大多数场景，尤其是业务逻辑复杂或数据量较大的系统。</li></ul></li><li><p><strong>示例</strong>：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    username <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> (username),</span><br><span class="line">    <span class="keyword">UNIQUE</span> (email)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）使用自然主键时需谨慎"><a href="#（2）使用自然主键时需谨慎" class="headerlink" title="（2）使用自然主键时需谨慎"></a>（2）<strong>使用自然主键时需谨慎</strong></h4><ul><li><p><strong>适用条件</strong>：</p><ul><li>自然主键必须是<strong>唯一且稳定</strong>的，且不会因业务逻辑变化而更改。</li><li>自然主键的字段类型应尽量短（如短字符串或数字）。</li></ul></li><li><p><strong>示例</strong>：</p><ul><li><strong>适用场景</strong>：商品表中使用商品条码（如<code>SKU</code>）作为主键。</li></ul><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    sku <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong>不适用场景</strong>：用户表中使用邮箱作为主键（邮箱可能更改）。</li></ul></li></ul><h4 id="（3）避免使用复合主键"><a href="#（3）避免使用复合主键" class="headerlink" title="（3）避免使用复合主键"></a>（3）<strong>避免使用复合主键</strong></h4><ul><li><p><strong>理由</strong>：</p><ul><li>复合主键（联合主键）由多个字段组成，增加了索引的复杂性和查询成本。</li><li>复合主键的唯一性依赖于多个字段，维护成本较高。</li></ul></li><li><p><strong>替代方案</strong>：使用代理主键，并通过唯一约束（<code>UNIQUE</code>）来保证字段组合的唯一性。</p></li><li><p><strong>示例</strong>：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    order_date <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> (user_id, order_date)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）考虑业务需求和数据特性"><a href="#（4）考虑业务需求和数据特性" class="headerlink" title="（4）考虑业务需求和数据特性"></a>（4）<strong>考虑业务需求和数据特性</strong></h4><ul><li><strong>唯一性</strong>：确保主键字段在业务逻辑中是唯一的。</li><li><strong>稳定性</strong>：主键字段不应因业务逻辑变化而更改。</li><li><strong>性能</strong>：尽量选择短字段（如整数或短字符串）作为主键，避免长字符串（如UUID）。</li><li><strong>扩展性</strong>：如果系统可能扩展到分布式架构，考虑使用全局唯一标识符（如UUID）作为主键，但需注意性能影响。</li></ul><h4 id="（5）特殊场景的主键选择"><a href="#（5）特殊场景的主键选择" class="headerlink" title="（5）特殊场景的主键选择"></a>（5）<strong>特殊场景的主键选择</strong></h4><ul><li><p><strong>分布式系统</strong>：如果系统需要分布式部署，建议使用全局唯一标识符（如UUID或自定义的分布式ID生成策略）。</p><ul><li><strong>优点</strong>：避免主键冲突，支持分布式扩展。</li><li><strong>缺点</strong>：UUID长度较长，索引性能略低于整数。</li></ul></li><li><p><strong>示例</strong>：</p><p>sql复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> distributed_table (</span><br><span class="line">    id <span class="type">CHAR</span>(<span class="number">36</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    data <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>优先选择代理主键（自增ID）</strong>，因为它简单、高效且稳定。</li><li><strong>谨慎使用自然主键</strong>，确保其唯一性和稳定性。</li><li><strong>避免使用复合主键</strong>，改用唯一约束来保证字段组合的唯一性。</li><li><strong>根据业务需求和数据特性选择合适的主键类型</strong>，并在分布式系统中考虑全局唯一标识符。</li><li><strong>性能优先</strong>：在大多数情况下，主键的性能和稳定性比语义化更重要。</li></ul><p>通过合理选择主键，可以提高数据库的性能、可维护性和可扩展性。</p><h2 id="4、索引失效问题梳理"><a href="#4、索引失效问题梳理" class="headerlink" title="4、索引失效问题梳理"></a>4、索引失效问题梳理</h2><h3 id="查询条件问题"><a href="#查询条件问题" class="headerlink" title="查询条件问题"></a>查询条件问题</h3><ul><li><strong>使用函数或表达式</strong> —— 在索引列上使用函数（如 <code>YEAR()</code>、<code>LEFT()</code>）或表达式会导致索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE YEAR(birthdate) = 1990;</code></li><li><strong>原因</strong>：数据库无法直接对函数结果使用索引。</li><li><strong>优化</strong>：改写为范围查询，如 <code>birthdate &gt;= &#39;1990-01-01&#39; AND birthdate &lt; &#39;1991-01-01&#39;</code>。</li></ul></li><li><strong>使用 <code>OR</code> 条件</strong> —— 如果 <code>OR</code> 连接的条件中有一个未使用索引，可能会导致索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE age = 30 OR name = &#39;John&#39;;</code></li><li><strong>优化</strong>：使用 <code>UNION</code> 替代 <code>OR</code>，分别查询后合并结果。</li></ul></li><li><strong>使用 <code>LIKE</code> 通配符开头</strong> —— 当 <code>LIKE</code> 查询以通配符（如 <code>%</code> 或 <code>_</code>）开头时，索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE name LIKE &#39;%John&#39;;</code></li><li><strong>优化</strong>：尽量将通配符放在查询条件的末尾。</li></ul></li><li><strong>数据类型不匹配</strong> —— 查询条件的数据类型与索引列类型不一致时，可能导致隐式类型转换，从而索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE salary = &#39;30000&#39;;</code>（<code>salary</code> 是 <code>INT</code> 类型）</li><li><strong>优化</strong>：确保查询条件的数据类型与索引列一致。</li></ul></li><li><strong>范围查询阻断</strong> —— 在联合索引中，范围查询会阻断后续列的索引使用。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE age BETWEEN 30 AND 40 AND name = &#39;John&#39;;</code></li><li><strong>优化</strong>：调整查询条件顺序，确保范围查询在最后。</li></ul></li></ul><h3 id="索引结构问题"><a href="#索引结构问题" class="headerlink" title="索引结构问题"></a>索引结构问题</h3><ul><li><strong>联合索引未遵循最左前缀原则</strong> —— 查询条件未按联合索引的列顺序使用时，索引可能失效。<ul><li><strong>示例</strong>：<code>CREATE INDEX idx_name_age ON employees (name, age);</code><br>查询：<code>SELECT * FROM employees WHERE age = 30 AND name = &#39;John&#39;;</code></li><li><strong>优化</strong>：调整查询条件顺序，或重新设计联合索引。</li></ul></li><li><strong>索引列参与计算</strong> —— 索引列在查询条件中参与计算时，索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE age + 10 &gt; 40;</code></li><li><strong>优化</strong>：改写为直接使用索引列，如 <code>age &gt; 30</code>。</li></ul></li></ul><h3 id="特殊查询语句问题"><a href="#特殊查询语句问题" class="headerlink" title="特殊查询语句问题"></a>特殊查询语句问题</h3><ul><li><strong>使用 <code>NOT</code>、<code>IS NULL</code> 或 <code>IS NOT NULL</code></strong> —— 这些操作符可能导致索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE NOT age = 30;</code></li><li><strong>优化</strong>：尽量避免使用这些操作符，或通过其他方式重写查询。</li></ul></li><li><strong>使用 <code>DISTINCT</code> 或 <code>GROUP BY</code></strong> —— 这些操作可能导致索引无法完全利用。<ul><li><strong>示例</strong>：<code>SELECT DISTINCT name FROM employees WHERE age = 30;</code></li><li><strong>优化</strong>：确保查询条件能够充分利用索引。</li></ul></li><li><strong>使用 <code>LIMIT</code> 时未明确排序</strong> —— 如果查询包含 <code>LIMIT</code> 但未使用排序索引，索引可能失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE age = 30 LIMIT 10;</code></li><li><strong>优化</strong>：添加 <code>ORDER BY</code> 条件。</li></ul></li></ul><h3 id="连接查询问题"><a href="#连接查询问题" class="headerlink" title="连接查询问题"></a>连接查询问题</h3><ul><li><strong>连接条件未使用索引</strong> —— 在 <code>JOIN</code> 查询中，连接条件（<code>ON</code> 子句）未涉及索引时，索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees e JOIN departments d ON e.department_id = d.id;</code></li><li><strong>优化</strong>：确保连接条件涉及的列已建立索引。</li></ul></li></ul><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ul><li><strong>查询条件未使用索引列</strong> —— 查询条件未涉及索引列时，数据库会直接执行全表扫描。<ul><li><strong>优化</strong>：为需要频繁查询的列创建索引。</li></ul></li><li><strong>隐式类型转换</strong> —— 查询中对列进行隐式类型转换，可能导致索引失效。<ul><li><strong>优化</strong>：确保查询条件的数据类型与索引列一致。</li></ul></li><li><strong>字符串拼接或连接运算</strong> —— 对索引列进行拼接或连接运算时，索引失效。<ul><li><strong>示例</strong>：<code>SELECT * FROM employees WHERE CONCAT(first_name, &#39; &#39;, last_name) = &#39;John Doe&#39;;</code></li><li><strong>优化</strong>：避免对索引列进行复杂运算。</li></ul></li></ul><h2 id="1-4-慢查询日志分析"><a href="#1-4-慢查询日志分析" class="headerlink" title="1.4 慢查询日志分析"></a>1.4 慢查询日志分析</h2><h2 id="1-5-JOIN优化"><a href="#1-5-JOIN优化" class="headerlink" title="1.5 JOIN优化"></a>1.5 JOIN优化</h2><p>JOIN使用总结：</p><ol><li><strong>永远用小的结果集去驱动大的结果集（本质就是减少外层循环的数据数量）。</strong></li><li><strong>应该为匹配的条件 增加索引（减少内层表的循环匹配次数）。</strong></li><li><strong>增加 join buffer的大小（一次缓存的越多，内层表扫描的次数就越少）</strong></li><li><strong>减少不必要的字段查询（字段越少，join buffe所缓存的数据就越多)。</strong></li></ol><h3 id="1-5-4-in和exists函数"><a href="#1-5-4-in和exists函数" class="headerlink" title="1.5.4 in和exists函数"></a>1.5.4 in和exists函数</h3><h2 id="1-6-order-by与group-by优化"><a href="#1-6-order-by与group-by优化" class="headerlink" title="1.6 order by与group by优化"></a>1.6 order by与group by优化</h2><h2 id="1-7-MySQL查询成本计算"><a href="#1-7-MySQL查询成本计算" class="headerlink" title="1.7 MySQL查询成本计算"></a>1.7 MySQL查询成本计算</h2><h3 id="1-7-1-什么是成本？"><a href="#1-7-1-什么是成本？" class="headerlink" title="1.7.1 什么是成本？"></a>1.7.1 什么是成本？</h3><p>在MySQL中，一条查询语句的执行成本实际上是由两部分构成的：</p><ul><li><p><strong>I&#x2F;O 成本</strong> </p></li><li><p>MyISAM 和 InnoDB都需要将数据和素银存储到磁盘，当进行查询时，就需要把数据或者索引加载到内存中。从磁盘到内存这个加载过程，损耗的时间，我们称之为 <strong>I&#x2F;O成本</strong>。</p></li><li><p><strong>CPU成本</strong> </p></li><li><p>读取记录的时候，需要检测记录是否满足对应的 搜索条件、对结果集进行排序等等操作发生的损耗都称之为 CPU成本。</p></li><li><p>成本常数 </p></li><li><p><strong>I&#x2F;O成本常数：1.0</strong> ，MySQL规定读取一个页面花费的成本默认是1.0</p></li><li><p><strong>CPU成本常数：0.2</strong>，读取以及检测一条记录是否符合搜索条件的成本，默认是0.2</p></li></ul><h3 id="1-7-2-单表查询成本"><a href="#1-7-2-单表查询成本" class="headerlink" title="1.7.2 单表查询成本"></a>1.7.2 单表查询成本</h3><p>MySQL中找出成本最低方案的过程，大致如下</p><ol><li>根据搜索条件，找出所有可能使用的索引。</li><li>计算全表扫描的代价。</li><li>计算使用不同索引，执行查询的代价。</li><li>对比各种执行方案的代价，找出成本最低的那个。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理 -- 事务及锁机制</title>
      <link href="/2024/11/10/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/11/10/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E4%BA%8B%E5%8A%A1%E5%92%8C%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、事务特性"><a href="#一、事务特性" class="headerlink" title="一、事务特性"></a>一、事务特性</h1><p>首先看看什么是事务？事务具有哪些特性？</p><p>简单来说，事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做，要么全不做，是一个不可分割的工作单元。</p><p>一个逻辑工作单元要成为事务，在关系型数据库管理系统中，必须满足 4 个特性。</p><p>数据库事务的特性包括以下四个方面，简称 ACID：</p><ul><li>原子性（Atomicity）、</li><li>一致性（Consistency）、</li><li>隔离性（Isolation）和</li><li>持久性（Durabilily）</li></ul><h2 id="1、-原子性"><a href="#1、-原子性" class="headerlink" title="1、 原子性"></a>1、 原子性</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。</p><h3 id="实现原理：undo-log"><a href="#实现原理：undo-log" class="headerlink" title="实现原理：undo log"></a>实现原理：undo log</h3><ul><li>实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。</li><li><code>InnoDB</code> 实现回滚，靠的是<code>undo log</code>：<ul><li>当事务对数据库进行修改时，InnoDB会生成对应的undo log；</li><li>如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。</li></ul></li><li>undo log属于逻辑日志，它记录的是sql执行相关的信息。<ul><li>当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：<ul><li>对于每个insert，回滚时会执行delete；</li><li>对于每个delete，回滚时会执行insert；</li><li>对于每个update，回滚时会执行一个相反的update，把数据改回去</li></ul></li></ul></li></ul><h2 id="2、-持久性"><a href="#2、-持久性" class="headerlink" title="2、 持久性"></a>2、 持久性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>持久性（Durability）确保一旦事务被提交，其对数据库中数据的修改就是永久性的。即使在数据库发生故障（如宕机、掉电或意外重启）的情况下，这些修改也不会丢失，数据库能够恢复到事务提交后的状态。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>在InnoDB存储引擎中，持久性是通过多种机制和技术来实现的，主要包括 <strong>redo log</strong> 和 <strong>double write buffer</strong></p><h4 id="重做日志（redo-log）"><a href="#重做日志（redo-log）" class="headerlink" title="重做日志（redo log）"></a><strong>重做日志（redo log）</strong></h4><ol><li>InnoDB存储引擎使用重做日志来保证事务的持久性。</li><li>当事务被提交时，InnoDB会将该事务的所有操作记录到重做日志中（WAL机制：WAL要求所有对数据的修改在写入数据文件之前，必须先写入日志文件）。这些日志包含了修改数据的详细信息，修改的位置等。</li><li>重做日志被设计为循环写入的，分为多个日志文件。当一个日志文件写满后，会切换到下一个日志文件继续写入。</li><li>这些日志会被持久化到磁盘上，确保在数据库发生故障时能够恢复数据。</li><li>在数据库恢复过程中，重做日志被用来重新执行事务的操作，将数据库恢复到事务提交后的状态。</li></ol><h4 id="双写缓冲（double-write-buffer）"><a href="#双写缓冲（double-write-buffer）" class="headerlink" title="双写缓冲（double write buffer）"></a><strong>双写缓冲（double write buffer）</strong></h4><ol><li>双写缓冲是InnoDB用来保证数据页完整性的技术。</li><li>在修改数据页之前，InnoDB会先将数据页的原始内容写入到一个双写缓冲区中。</li><li>接着，InnoDB会将修改后的数据页写入到其实际位置。</li><li>如果在写入过程中发生故障，InnoDB可以使用双写缓冲区中的原始数据页来恢复数据，确保数据页的完整性。</li><li>这意味着即使在系统故障导致数据页部分写入的情况下，InnoDB也能通过双写缓冲来恢复数据页，避免数据损坏。</li></ol><p><strong>为什么需要Doublewrite Buffer？</strong></p><blockquote><p> Linux文件系统页（OS Page）的大小默认是4KB。而MySQL的页（Page）大小默认是16KB。MySQL程序是跑在Linux操作系统上的，理所当然要跟操作系统交互，所以MySQL中一页数据刷到磁盘，要写4个文件系统里的页。但是，由于磁盘操作不是原子的，如果在写页的过程中发生系统崩溃或电源故障，就可能导致页的部分写入，即只有页的一部分被写入磁盘，而其他部分仍然是旧的或损坏的数据。 </p></blockquote><p>InnoDB的redo日志虽然可以用来恢复数据，但它记录的是对页的物理更改（如“将页的偏移量XXX处的值更改为YYY”），而不是页的完整内容。因此，如果页发生了部分写入，redo日志可能无法完全恢复该页，因为它依赖于页的原始内容来应用这些更改。</p><p><strong>Doublewrite Buffer的工作原理</strong></p><p> 为了解决这个问题，InnoDB引入了Doublewrite Buffer。Doublewrite Buffer是一个特殊的区域，它分为内存部分和磁盘部分。</p><p><strong>内存部分</strong>：Doublewrite Buffer在内存中维护了一个缓冲区，用于暂存即将写入磁盘的数据页。</p><p> <strong>磁盘部分</strong>：Doublewrite Buffer在磁盘上有一个固定的区域，用于存储从内存中刷新出来的数据页。</p><p>当InnoDB需要将一个修改后的数据页从内存刷新到磁盘时，它会执行以下步骤：</p><ol><li>页数据先通过memcpy函数拷贝至内存中的Doublewrite Buffer中。</li><li>Doublewrite Buffer的内存里的数据页，会fsync刷到Doublewrite Buffer的磁盘上，分两次写入磁盘共享表空间中(连续存储，顺序写，性能很高)，每次写1MB。</li><li>Doublewrite Buffer的内存里的数据页，再刷到数据磁盘存储.ibd文件上（离散写）。</li></ol><p>如果在第1步和第3步之间发生系统崩溃，InnoDB可以在重启后从Doublewrite Buffer中恢复数据页。因为Doublewrite Buffer中存储的是数据页的完整内容，所以InnoDB可以使用它来重建任何发生部分写入的数据页。</p><p>Doublewrite Buffer是InnoDB存储引擎用来保证数据完整性的一个重要机制。它通过先将数据页写入一个安全的缓冲区，然后再写入最终的目标位置，来防止部分页写入导致的数据损坏。这种设计虽然增加了一些写操作的开销，但大大提高了数据库的可靠性和恢复能力。</p><p>除了重做日志和双写缓冲，InnoDB还使用其他技术来增强持久性，如撤销日志（undo log）用于回滚未提交的事务，以及使用事务日志序列号（Log Sequence Number, LSN）来追踪日志的写入位置等。</p><p>综上所述，MySQL通过重做日志、双写缓冲以及其他辅助技术来实现事务的持久性。这些机制共同工作，确保了在各种故障场景下数据的可靠性和恢复能力。</p><h2 id="3、-隔离性"><a href="#3、-隔离性" class="headerlink" title="3、 隔离性"></a>3、 隔离性</h2><p>隔离性：当多个事务并发访问数据库中的同一数据时，所表现出来的相互关系。</p><ul><li>隔离性，指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对其他的并发事务是隔离的。</li><li>锁和多版本控制就符合隔离性。</li></ul><p>InnoDB 支持的隔离性有 4 种，隔离性从低到高分别为：读未提交、读提交、可重复读、可串行化。后面再详细讲。</p><h2 id="4、-一致性"><a href="#4、-一致性" class="headerlink" title="4、 一致性"></a>4、 一致性</h2><p>一致性：事务开始之前和事务结束之后，数据库的完整性限制未被破坏。</p><ul><li>一致性其实包括两部分内容，分别是约束一致性和数据一致性。</li><li>约束一致性：数据库中创建表结构时所指定的外键、唯一索引等约束。</li><li>数据一致性：是一个综合性的规定，或者说是一个把握全局的规定。因为它是由原子性、持久性、隔离性共同保证的结果，而不是单单依赖于某一种技术。</li></ul><p>一致性可以归纳为数据的完整性。</p><p>根据前文可知，数据的完整性是通过其他三个特性来保证的，包括原子性、隔离性、持久性，而这三个特性，又是通过 Redo&#x2F;Undo 来保证的，正所谓：合久必分，分久必合，三足鼎力，三分归晋，数据库也是，<strong>为了保证数据的完整性，提出来三个特性</strong>，这三个特性又是由同一个技术来实现的，所以理解 Redo&#x2F;Undo 才能理解数据库的本质。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215308180.png"></p><p>如上图所示，逻辑上的一致性，包括唯一索引、外键约束、check 约束，这属于业务逻辑范畴，这里就不做赘述了。</p><p>事务特性技术图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215305902.png" alt="image-20250216215305902"></p><h1 id="二、事务隔离"><a href="#二、事务隔离" class="headerlink" title="二、事务隔离"></a>二、事务隔离</h1><p>##1、 并发问题</p><p>在数据库执行中，多个并发执行的事务如果涉及到同一份数据的读写就容易出现数据不一致的情况，不一致的异常现象有以下几种。</p><ul><li><strong>脏读，是指一个事务中访问到了另外一个事务未提交的数据。</strong> <ul><li>例如事务 T1 中修改的数据（张三–&gt;李四）项在尚未提交的情况下被其他事务（T2）读取到，如果 T1 进行回滚操作，则 T2 刚刚读取到的数据实际并不存在。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215254134.png" alt="image-20250216215254134"></p><ul><li><strong>不可重复读，是指一个事务读取同一条记录 2 次，得到的结果不一致。</strong> <ul><li>例如事务 T1 第一次读取数据（张三），接下来 T2 对其中的数据进行了更新或者删除（李四），并且 Commit 成功。这时候 T1 再次读取这些数据，那么会得到 T2 修改后的数据，发现数据已经变更，这样 T1 在一个事务中的两次读取，返回的结果集会不一致。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215250580.png" alt="image-20250216215250580"></p><ul><li><strong>幻读，是指一个事务读取 2 次，得到的记录条数不一致。</strong> <ul><li>例如事务 T1 查询获得一个结果集，T2 插入新的数据，T2 Commit 成功后，T1 再次执行同样的查询，此时得到的结果集记录数不同。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215247625.png" alt="image-20250216215247625"></p><p>脏读、不可重复读和幻读有以下的包含关系，如果发生了脏读，那么幻读和不可重复读都有可能出现。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215244601.png" alt="image-20250216215244601"></p><h2 id="2、-隔离级别"><a href="#2、-隔离级别" class="headerlink" title="2、 隔离级别"></a>2、 隔离级别</h2><p>SQL 标准根据三种不一致的异常现象，将隔离性定义为四个隔离级别（Isolation Level），隔离级别和数据库的性能呈反比(安全性和执行速度)，隔离级别越低，数据库性能越高；而隔离级别越高，数据库性能越差，具体如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216215240025.png" alt="image-20250216215240025"></p><p>按隔离水平高低排序，读未提交 &lt; 读已提交 &lt; 可重复度 &lt; 串行化。</p><h3 id="Read-uncommitted-读未提交"><a href="#Read-uncommitted-读未提交" class="headerlink" title="Read uncommitted 读未提交"></a>Read uncommitted 读未提交</h3><p>在该级别下，一个事务对数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据进行读，不会出现更新丢失，但会出现脏读、不可重复读的情况。</p><p>它能读到一个事务的中间过程，违背了 ACID 特性，存在脏读的问题，所以基本不会用到，可以忽略。</p><h3 id="Read-committed-读已提交"><a href="#Read-committed-读已提交" class="headerlink" title="Read committed 读已提交"></a>Read committed 读已提交</h3><p>在该级别下，未提交的写事务不允许其他事务访问该行，不会出现脏读，但是读取数据的事务允许其他事务访问该行数据，因此会出现不可重复读的情况。</p><ul><li><p>A事务正在写，不允许其他事务访问</p></li><li><p>A事务正在读，允许其他事务写</p></li></ul><h3 id="Repeatable-read-可重复读"><a href="#Repeatable-read-可重复读" class="headerlink" title="Repeatable read 可重复读"></a>Repeatable read 可重复读</h3><ul><li><p>可能出现幻读</p></li><li><p>在该级别下，在同一个事务内的查询都是和事务开始时刻一致的，保证对同一字段的多次读取结果都相同，除非数据是被本身事务自己所修改，不会出现同一事务读到两次不同数据的情况。因为没有约束其他事务的新增Insert操作，所以 SQL 标准中可重复读级别会出现幻读。</p></li><li><p>A事务正在读，不允许其他事务写，但是允许事务事务读。</p></li></ul><ul><li>值得一提的是，可重复读是 MySQL InnoDB 引擎的默认隔离级别，但是在 MySQL 额外添加了间隙锁（Gap Lock），可以防止幻读。是目前被使用得最多的一种级别，在这种级别下有一定概率会发生死锁、低并发等问题。</li></ul><h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>该级别要求所有事务都必须串行执行（无论读写操作都是串行），可以避免各种并发引起的问题，效率也最低。可串行化，这种实现方式，其实已经并不是多版本了，又回到了单版本的状态，因为它所有的实现都是通过锁来实现的。</p><p>对不同隔离级别的解释，其实是为了保持数据库事务中的隔离性（Isolation），目标是使并发事务的执行效果与串行一致，隔离级别的提升带来的是并发能力的下降，两者是负相关的关系。</p><h2 id="3、并发事务控制"><a href="#3、并发事务控制" class="headerlink" title="3、并发事务控制"></a>3、并发事务控制</h2><h3 id="单版本控制-锁"><a href="#单版本控制-锁" class="headerlink" title="单版本控制-锁"></a>单版本控制-锁</h3><p>先来看锁，锁用独占的方式来保证在只有一个版本的情况下事务之间相互隔离，所以锁可以理解为单版本控制。</p><p>在 MySQL 事务中，锁的实现与隔离级别有关系，在 RR（Repeatable Read）隔离级别下，MySQL 为了解决幻读的问题，以牺牲并行度为代价，通过 Gap 锁来防止数据的写入，而这种锁，因为其并行度不够，冲突很多，经常会引起死锁。</p><p>现在流行的 Row 模式可以避免很多冲突甚至死锁问题，所以推荐默认使用 Row + RC（Read Committed）模式的隔离级别，可以很大程度上提高数据库的读写并行度。</p><h3 id="多版本控制-MVCC"><a href="#多版本控制-MVCC" class="headerlink" title="多版本控制-MVCC"></a>多版本控制-MVCC</h3><p>多版本控制也叫作 MVCC，是指在数据库中，为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性来保证事务能看到自己应该看到的数据版本。</p><p>那个多版本是如何生成的呢？每一次对数据库的修改，都会在 Undo 日志中记录当前修改记录的事务号及修改前数据状态的存储地址（即 ROLL_PTR），以便在必要的时候可以回滚到老的数据版本。例如，一个读事务查询到当前记录，而最新的事务还未提交，根据原子性，读事务看不到最新数据，但可以去回滚段中找到老版本的数据，这样就生成了多个版本。</p><p>多版本控制很巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。</p><h2 id="4、锁机制"><a href="#4、锁机制" class="headerlink" title="4、锁机制"></a>4、锁机制</h2><h3 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h3><p>在 MySQL 中有三种级别的锁：页(Page)级锁、表级锁、行级锁。</p><ol><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 会发生在：MyISAM、memory、InnoDB、BDB 等存储引擎中。 </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。会发生在：InnoDB 存储引擎。 </li><li>页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。会发生在：BDB 存储引擎。</li></ol><p>三种级别的锁分别对应存储引擎关系如下图所示。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38665288/1698824554306-0a016669-ff9d-4b1e-ae8d-4aa8f7888500.png" alt="img"></p><p>在InnoDB 存储引擎中，锁分为行锁和表锁，其中<strong>行锁</strong>包括两种锁：</p><ul><li><p>共享锁（S）：读锁，允许持有锁的事务读取行，多个事务可以一起读，共享锁之间不互斥，共享锁会阻塞排它锁。 </p></li><li><p>事务A获得共享锁，事务B可以同时获得共享锁  from Table where col1 &#x3D; 1</p></li><li><p>事务A获得共享锁，事务B如果是个写操作，阻塞等待锁</p></li><li><p>排他锁（X）：写锁，允许获得排他锁的事务更新或者删除数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。 </p></li><li><p>如果要对某一行进行写操作，首先要先获得排它锁</p></li><li><p>如果对id&#x3D;5这一行获得X锁，此时自该行无法加X锁和S锁</p></li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的<strong>意向锁（Intention Locks）</strong>，这两种意向锁都是表锁。表锁又分为三种：</p><ul><li>意向共享锁（<code>IS</code>）：事务计划给数据行加行共享锁（S），事务在给一个数据行加共享锁前必须先取得该表的 <code>IS</code>锁。 </li><li>意向排他锁（<code>IX</code>）：事务计划给数据行加行排他锁（X），事务在给一个数据行加排他锁前必须先取得该表的 <code>IX</code>锁。 </li><li>自增锁（<code>AUTO-INC Locks</code>）：特殊表锁，自增长计数器通过该“锁”来获得子增长计数器最大的计数值。</li></ul><p>InnoDB 锁关系矩阵如下图所示，其中：+ 表示兼容，- 表示不兼容。</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/38665288/1698824587369-16e7c891-f349-4c47-81ad-0a0eda2a2a11.png" alt="img"></p><p>从操作的性能可分为<strong>乐观锁</strong>和<strong>悲观锁</strong>。</p><ol><li>乐观锁：一般实现方式是对记录数据版本进行比对，在数据更新的时候才会进行冲突检测，如果发现冲突了，则提示错误信息。</li><li>悲观锁：在对一条数据修改的时候，为了避免同时被其他人修改，在修改数据之前先锁定，再修改的控制方式。</li><li><strong>共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴</strong>。</li></ol><h3 id="InnoDB-自增锁"><a href="#InnoDB-自增锁" class="headerlink" title="InnoDB 自增锁"></a>InnoDB 自增锁</h3><p>在 MySQL InnoDB 存储引擎中，我们在设计表结构的时候，通常会建议添加一列作为自增主键。这里就会涉及一个特殊的锁：自增锁（即：AUTO-INC Locks），它属于表锁的一种，在 INSERT 结束后立即释放。我们可以执行 show engine innodb status 来查看自增锁的状态信息。</p><p>理解自增锁是一个接口，实现的形式有多种。</p><p>在自增锁的使用过程中，有一个核心参数，需要关注，即 innodb_autoinc_lock_mode,它有0、1、2 三个值。保持默认值就行。具体的含义可以参考官方文档，这里不再赘述，如下图所示。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image (3).png" alt="image (3)" style="zoom:67%;" /><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB 行锁是通过对索引数据页上的记录（record）加锁实现的，主要实现算法有 3 种：</p><ul><li>Record Lock：单个行记录的锁（锁数据，不锁 Gap）。（记录锁，RC、RR隔离级别都支持）</li><li>Gap Lock：间隙锁，锁定一个范围，不包括记录本身（不锁数据，仅仅锁数据前面的Gap）。（范围锁，RR隔离级别支持）</li><li>Next-key Lock：同时锁住数据，并且锁住数据前面的 Gap。（记录锁+范围锁，RR隔离级别支持）</li></ul><h3 id="加锁行为分析"><a href="#加锁行为分析" class="headerlink" title="加锁行为分析"></a>加锁行为分析</h3><p>我们以 RR 为例，主要是从四个场景分析。</p><ul><li>主键 + RR。 </li><li>唯一键 + RR。 </li><li>非唯一键 + RR。 </li><li>无索引 + RR。</li></ul><h4 id="（1）第一种情况：主键-RR"><a href="#（1）第一种情况：主键-RR" class="headerlink" title="（1）第一种情况：主键 + RR"></a>（1）第一种情况：主键 + RR</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216220542867.png" alt="image-20250216220542867" style="zoom:67%;" /><ul><li>假设条件是：<ul><li>update t1 set name&#x3D;‘XX’ where id&#x3D;10</li><li>id 为主键索引。</li></ul></li><li>加锁行为：仅在 id&#x3D;10 的主键索引记录上加 X锁。</li></ul><h4 id="（2）第二种情况：唯一键-RR"><a href="#（2）第二种情况：唯一键-RR" class="headerlink" title="（2）第二种情况：唯一键 + RR"></a>（2）第二种情况：唯一键 + RR</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216220536931.png" alt="image-20250216220536931" style="zoom:85%;" /><ul><li><p>假设条件是：</p><ul><li><p>update t1 set name&#x3D;‘XX’ where id&#x3D;10。</p></li><li><p>id 为唯一索引。</p></li></ul></li><li><p>加锁行为：</p><ul><li><p>先在唯一索引 id 上加 id&#x3D;10 的 X 锁。</p></li><li><p>再在 id&#x3D;10 的主键索引记录上加 X 锁。</p></li></ul></li></ul><h4 id="（3）第三种情况：非唯一键-RR"><a href="#（3）第三种情况：非唯一键-RR" class="headerlink" title="（3）第三种情况：非唯一键 + RR"></a>（3）第三种情况：非唯一键 + RR</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216220530566.png" alt="image-20250216220530566"></p><ul><li><p>假设条件是：</p><ul><li><p>update t1 set name&#x3D;‘XX’ where id&#x3D;10。</p></li><li><p>id 为非唯一索引。</p></li></ul></li><li><p>加锁行为：</p><ul><li><p>先通过 id&#x3D;10 在 key(id) 上定位到第一个满足的记录，对该记录加 X 锁，而且要在 (6,c)~(10,b) 之间加上 Gap lock，为了防止幻读。然后在主键索引 name 上加对应记录的X 锁； </p></li><li><p>再通过 id&#x3D;10 在 key(id) 上定位到第二个满足的记录，对该记录加 X 锁，而且要在(10,b)~(10,d)之间加上 Gap lock，为了防止幻读。然后在主键索引 name 上加对应记录的X 锁； </p></li><li><p>最后直到 id&#x3D;11 发现没有满足的记录了，此时不需要加 X 锁，但要再加一个 Gap lock： (10,d)~(11,f)。</p></li></ul></li></ul><h4 id="（4）第四种情况：无索引-RR"><a href="#（4）第四种情况：无索引-RR" class="headerlink" title="（4）第四种情况：无索引 + RR"></a>（4）第四种情况：无索引 + RR</h4><ul><li><p>假设条件是：</p><ul><li><p>update t1 set name&#x3D;‘XX’ where id&#x3D;10。</p></li><li><p>id 列无索引。</p></li></ul></li><li><p>加锁行为：</p><ul><li>加上表锁</li></ul></li></ul><h2 id="5、-MVCC原理"><a href="#5、-MVCC原理" class="headerlink" title="5、 MVCC原理"></a>5、 MVCC原理</h2><p>Multi-Version Concurrency Control 多版本并发控制。MySQL InnoDB 存储引擎，实现的是基于多版本的并发控制协议——MVCC，而不是基于锁的并发控制。</p><p>MVCC 最大的好处是读不加锁，读写不冲突。在读多写少的 OLTP（On-Line Transaction Processing）应用中，读写不冲突是非常重要的，极大的提高了系统的并发性能，这也是为什么现阶段几乎所有的 RDBMS（Relational Database Management System），都支持 MVCC 的原因。</p><p>常规的服务分类：</p><ul><li>读服务：电商搜索、查看订单，缓存、索引库、数据库</li><li>写服务：先插入缓存系统然后再异步写入到数据，直接写入数据库</li><li>扣减服务：update，秒杀服务</li></ul><h3 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h3><p>在 MVCC 并发控制中，读操作可以分为两类: 快照读（Snapshot Read）与当前读 （Current Read）。</p><ul><li>快照读：读取的是记录的可见版本（有可能是历史版本），不用加锁。</li><li>当前读：读取的是记录的最新版本，并且当前读返回的记录，都会加锁，保证其他事务不会再并发修改这条记录。</li></ul><p>注意：MVCC 只在 Read Commited 和 Repeatable Read 两种隔离级别下工作。</p><p>如何区分快照读和当前读呢？ 可以简单的理解为：</p><ul><li>快照读：简单的 select 操作，属于快照读，不需要加锁。</li><li>当前读：特殊的读操作，插入&#x2F;更新&#x2F;删除操作，属于当前读，需要加锁。</li></ul><h3 id="MVCC-多版本实现"><a href="#MVCC-多版本实现" class="headerlink" title="MVCC 多版本实现"></a>MVCC 多版本实现</h3><p>举例：事务对某行记录更新的过程。<br>假设 F1～F6 是表中字段的名字，1～6 是其对应的数据。后面三个隐含字段分别对应该行的隐含ID、事务号和回滚指针，如下图所示。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216221239226.png" alt="image-20250216221239226"></p><ul><li>隐含 ID（DB_ROW_ID），6 个字节，当由 InnoDB 自动产生聚集索引时，聚集索引包括这个 DB_ROW_ID 的值。</li><li>事务号（DB_TRX_ID），6 个字节，标记了最新更新这条行记录的 Transaction ID，每处理一个事务，其值自动 +1。</li><li>回滚指针（DB_ROLL_PT），7 个字节，指向当前记录项的 Rollback Segment 的 Undo log记录，通过这个指针才能查找之前版本的数据。</li></ul><p>具体的更新过程，简单描述如下：</p><p>首先，假如这条数据是刚 INSERT 的，可以认为 ID 为 1，其他两个字段为空。</p><p>然后，当事务 1 更改该行的数据值时，会进行如下操作，如下图所示。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216221244085.png" alt="image-20250216221244085"></p><ul><li>用排他锁锁定该行；记录 Redo log； </li><li>把该行修改前的值复制到 Undo log，即图中下面的行； </li><li>修改当前行的值，填写事务编号，使回滚指针指向 Undo log 中修改前的行。</li></ul><p>接下来，与事务 1 相同，此时 Undo log 中有两行记录，并且通过回滚指针连在一起。因此，如果 Undo log 一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在 InnoDB 中存在 purge 线程，它会查询那些比现在最老的活动事务还早的 Undo log，并删除它们，从而保证 Undo log 文件不会无限增长，如下图所示。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216221248459.png" alt="image-20250216221248459"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 知识点梳理 -- 存储引擎相关</title>
      <link href="/2024/11/09/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB/"/>
      <url>/2024/11/09/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86--%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的<strong>存储机制</strong>、<strong>索引技巧</strong>、<strong>锁定水平</strong>等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎，MySql的核心就是插件式存储引擎。</p><p>Mysql中不同的表可以指定不同的存储引擎，也就是说一套Mysql服务器可以同时使用N种不同的存储引擎。</p><p>InnoDB 事务型数据库的首选，支持事务安全表（ACID），支持行锁定和外键。</p><p>MySQL 5.5.5 之后，InnoDB 作为默认存储引擎。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 查看系统所支持的引擎类型 */</span></span><br><span class="line"><span class="keyword">SHOW</span> ENGINES;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> INFORMATION_SCHEMA.ENGINES;</span><br></pre></td></tr></table></figure><h2 id="1、-功能对比"><a href="#1、-功能对比" class="headerlink" title="1、 功能对比"></a>1、 功能对比</h2><p>不同的存储引擎都有各自的特点，以适应不同的需求，如表所示。为了做出选择，首先要考虑每一个存储引擎提供了哪些不同的功能。</p><table><thead><tr><th>特点</th><th>Myisam</th><th>BDB</th><th>Memory</th><th>InnoDB</th><th>Archive</th></tr></thead><tbody><tr><td>存储限制</td><td>没有</td><td>没有</td><td>有</td><td>64TB</td><td>没有</td></tr><tr><td>事务安全</td><td></td><td>支持</td><td></td><td>支持</td><td></td></tr><tr><td>锁机制</td><td>表锁</td><td>页锁</td><td>表锁</td><td>行锁</td><td>行锁</td></tr><tr><td>B树索引</td><td>支持</td><td>支持</td><td>支持</td><td>支持</td><td></td></tr><tr><td>哈希索引</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>全文索引</td><td>支持</td><td></td><td></td><td></td><td></td></tr><tr><td>集群索引</td><td></td><td></td><td></td><td>支持</td><td></td></tr><tr><td>数据缓存</td><td></td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>索引缓存</td><td>支持</td><td></td><td>支持</td><td>支持</td><td></td></tr><tr><td>数据可压缩</td><td>支持</td><td></td><td></td><td></td><td>支持</td></tr><tr><td>空间使用</td><td>低</td><td>低</td><td>N&#x2F;A</td><td>高</td><td>非常低</td></tr><tr><td>内存使用</td><td>低</td><td>低</td><td>中等</td><td>高</td><td>低</td></tr><tr><td>批量插入的速度</td><td>高</td><td>高</td><td>高</td><td>低</td><td>非常高</td></tr><tr><td>支持外键</td><td></td><td></td><td></td><td>支持</td><td></td></tr></tbody></table><p><strong>MyISAM</strong>：默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一</p><p><strong>InnoDB</strong>：用于事务处理应用程序，具有众多特性，包括ACID事务支持。</p><p><strong>Memory</strong>：将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。</p><p>使用下面的语句可以修改数据库临时的默认存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> default_storage_engine<span class="operator">=</span><span class="string">&#x27;存储引擎名&#x27;</span></span><br></pre></td></tr></table></figure><p>例如，将 MySQL 数据库的临时默认存储引擎修改为 MyISAM，输入的 SQL 语句和运行结果如图所示。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216143805181.png" alt="image-20250216143805181"></p><p>此时，可以发现 MySQL 的默认存储引擎已经变成了 MyISAM。但是当再次重启客户端时，默认存储引擎仍然是 InnoDB。</p><h2 id="2、-InnoDB-存储引擎简介"><a href="#2、-InnoDB-存储引擎简介" class="headerlink" title="2、 InnoDB 存储引擎简介"></a>2、 InnoDB 存储引擎简介</h2><p><code>InnoDB</code>是一款通用存储引擎，平衡了高可靠性和高性能。</p><ul><li>高可靠性：任何时候可以保证数据是不丢失的</li><li>高性能：数据读取（查询、检索）和数据变更效率高、RT短（Response Time，服务响应时间）</li><li>通常性能和可靠性是相悖的，磁盘的效率是远远低于内存的。</li></ul><p>在MySQL 8.0中，<code>InnoDB</code>是默认的MySQL存储引擎。除非配置了不同的默认存储引擎，否则在没有<code>ENGINE</code>子句的情况下发布<code>CREATE TABLE</code>语句会创建InnoDB表。</p><p><strong>主要优势：</strong></p><ul><li>其DML操作遵循ACID模型（事务模型），其事务具有提交、回滚和崩溃恢复功能（InnoDB redo、Undo日志），以保护用户数据。</li><li>行级锁定和甲骨文风格的一致读取提高了多用户并发性和性能。</li><li><code>InnoDB</code>表在磁盘上排列数据，以根据主键优化查询。每个<code>InnoDB</code>表都有一个名为聚类索引的主键索引，该索引组织数据以最小化主键查找的I&#x2F;O。</li><li>为了保持数据完整性，<code>InnoDB</code>支持<code>FOREIGN KEY</code>约束。使用外键，会检查插入、更新和删除，以确保它们不会导致相关表之间的不一致。</li></ul><h3 id="2-1-InnoDB-架构"><a href="#2-1-InnoDB-架构" class="headerlink" title="2.1    InnoDB 架构"></a>2.1    InnoDB 架构</h3><p>InnoDB架构包括内存和磁盘结构。</p><p>内存结构包括缓冲池、自适应哈希索引、写缓冲区和日志缓冲区。</p><p>磁盘结构包括系统表空间、独立表空间、通用表空间、撤销表空间、临时表空间、重做日志和双写缓冲文件。</p><p>![image (1)](<a href="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image">https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image</a> (1).png)</p><h1 id="二、-InnoDB-存储引擎的内存结构"><a href="#二、-InnoDB-存储引擎的内存结构" class="headerlink" title="二、 InnoDB 存储引擎的内存结构"></a>二、 InnoDB 存储引擎的内存结构</h1><p>从MySQL5.5版本开始，默认使用的就是InnoDB存储引擎，它擅长处理事务，具有自动崩溃恢复的特性，使用非常广泛。</p><p>InnoDB存储引擎架构主要由两部分组成，<strong>内存结构</strong> 和 <strong>磁盘结构</strong>。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216020752601.png" alt="image-20250216020752601" style="zoom:80%;" /><p>InnoDB存储引擎的内存结构由4部分组成：</p><ol><li><strong>Buffer Pool:</strong> 缓冲池，作用就是用来缓存表数据和索引数据，减少磁盘IO操作，提升效率。</li><li><strong>Change Buffer</strong>：写缓冲区，是针对二级索引页（辅助索引）的更新优化措施。</li><li><strong>Log Buffer</strong>：日志缓冲区，用来缓存写入磁盘上log文件（Redo、Undo）的数据,日志缓冲区的内容会定期的刷新到磁盘Log文件中。主要作用是：用来优化每次更新操作之后都要写入redo log产生的磁盘IO的。</li><li><strong>Adaptive Hash Index</strong>： 自适应Hash索引。InnoDB不支持手动创建哈希索引的，但是InnoDB会进行自调优，如果判断建立 自适应哈希索引能够提升查询效率，InnoDB就会在自己的内存中创建相关的Hash索引。自适应指的是不需要人工手动干预，InnoDB会根据自己的需求去创建 自适应Hash索引。</li></ol><h2 id="1、-Buffer-Pool"><a href="#1、-Buffer-Pool" class="headerlink" title="1、 Buffer Pool"></a>1、 Buffer Pool</h2><h3 id="Buffer-Pool-概述"><a href="#Buffer-Pool-概述" class="headerlink" title="Buffer Pool 概述"></a>Buffer Pool 概述</h3><ul><li><p><strong>作用</strong>： Buffer Pool ， 也即缓冲池，用来<strong>缓存表数据和索引数据的，减少磁盘IO</strong>。</p></li><li><p><strong>组成</strong>： Buffer Pool有 <strong>缓存数据页（Page）</strong> 和 对缓存数据页进行描述的 **控制块 ** 组成。</p><ul><li><p><strong>缓存数据页Page</strong>：InnoDB以页为单位，对数据进行划分，以页Page作为磁盘和内存交互的基本单位，一个页大小默认 16KB。</p><ul><li>Buffer Pool 除了缓存了 索引页和数据页，还包括了undo页，自适应哈希索引，插入缓存页，锁信息。</li></ul></li><li><p><strong>控制块</strong>：控制块中存储着对应的缓存页所属的表空间信息，数据页编号，控制块所对应的缓存页在BufferPool中的地址信息。</p></li></ul></li><li><p>BufferPool的默认的大小128M，以Page页为单位，Page页16KB，控制块一般为数据页的5%，大概是800字节。</p></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216020804515.png" alt="image-20250216020804515" style="zoom: 67%;" /><ul><li>Q: 如何判断一个页是否在BP中存储？<ul><li>在MySQL中有一个Hash表数据结构，它使用表空间号 + 数据页编号，作为一个key，value是缓存页对应的控制块。当我们需要访问某个页的数据时，先从Hash表中根据表空间号+页号，查看是否有对应的缓存页。<br>如果有，则直接使用。<br>如果没有，就会从free链表中选出一个空闲的缓存页，把磁盘中的对应的页加载到该缓存页的位置。</li></ul></li></ul><h3 id="Buffer-Pool-对-Page-页管理机制"><a href="#Buffer-Pool-对-Page-页管理机制" class="headerlink" title="Buffer Pool 对 Page 页管理机制"></a>Buffer Pool 对 Page 页管理机制</h3><ul><li><strong>Page页分类</strong>：在BP的底层采用的是链表数据结构管理Page。Page根据状态可以分为3中类型：</li></ul><ul><li><p><strong>free Page</strong>： 空闲Page，未被使用的Page。</p></li><li><p><strong>clean Page</strong>：被使用的Page，但是数据没有修改过。</p></li><li><p><strong>dirty Page</strong>：脏页，被使用过的Page，并且数据被修改了，缓存页中的数据与磁盘的数据不一致的。</p></li></ul><p>上面说的三种Page类型，InnoDB采用三种链表结构进行维护和管理。</p><ul><li><strong>free list ：</strong>表示空闲缓冲区，管理free Page</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216020814954.png" alt="image-20250216020814954"></p><ul><li><strong>flush list:</strong>  表示的是需要刷新到磁盘的缓冲区，管理dirty page，内部page是按照修改时间排序。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216020825306.png" alt="image-20250216020825306"></p><ul><li><strong>lru list</strong> :表示正在使用的缓冲区，管理clean page和dirty page，该缓冲区以 midpoint 为基点，前面的链表称为new 列表区，存放经常被访问的数据，占63%，后面的链表称为old列表区，存放的是使用较少的数据占37%。</li></ul><p>注意：脏页在 flush 链表和 LRU 链表中都存在，但是两者互不影响，LRU 链表负责管理 page 的可用性和释放，而 flush list 负责管理脏页的刷盘操作。</p><h4 id="Q-MySQL中为什么没有采用传统的LRU算法？"><a href="#Q-MySQL中为什么没有采用传统的LRU算法？" class="headerlink" title="Q: MySQL中为什么没有采用传统的LRU算法？"></a>Q: MySQL中为什么没有采用传统的LRU算法？</h4><p><strong>普通的LRU算法</strong>：LRU （最近最少使用），就是末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰。</p><p><strong>普通LRU链表的缺点</strong>：</p><ul><li><strong>Buffer Pool污染</strong>：当某一个SQL，扫描了大量数据时，就有可能把BP中所有页都替换出去，导致大量的热数据被淘汰，这些热数据再次被访问时候，就会产生大量的磁盘IO，MySQL性能就会下降，这个过程被称为<strong>Buffer Pool污染</strong>。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021110833.png" alt="image-20250216021110833"></p><ul><li><strong>预读失效</strong> —— MySQL中存在预读机制，很多预读的页会被放在LRU链表的头部，如果没有使用到预读页，就会导致很多尾部的缓存页被淘汰，这就是预读失效。</li></ul><h4 id="Q：-MySQL中对于LRU算法进行了哪些优化？"><a href="#Q：-MySQL中对于LRU算法进行了哪些优化？" class="headerlink" title="Q： MySQL中对于LRU算法进行了哪些优化？"></a>Q： MySQL中对于LRU算法进行了哪些优化？</h4><p>改进型LRU算法：链表分为new和old两个区域，加入元素时并不是从表头插入，而是从midpoint位置插入。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021119612.png" alt="image-20250216021119612"></p><p>冷数据区的数据页什么时候被转到热数据区？</p><p>1）如何数据页在LRU链表中存在时间超过1s,就将其移动到链表的头部（链表指的是整个LRU链表）</p><p>2）如果该数据页在LRU链表中存在的时间短于1s.位置不变。</p><p>3）只有同时满足 【被访问】与【在old区域停留超过1s】两个条件，才会被插入到热数据区的头部。这样就解决了BP污染问题。</p><h2 id="2、-change-Buffer"><a href="#2、-change-Buffer" class="headerlink" title="2、 change Buffer"></a>2、 change Buffer</h2><p>Chnage Buffer，又称写缓冲区、变更&#x2F;更改缓冲区。</p><p>更改缓冲区是一种特殊的数据结构，当<code>辅助索引/次要索引（非唯一索引）</code>页面不在<code>缓冲池</code>中时，它会缓存对这些页面的更改。当页面通过其他读取操作加载到缓冲池时，缓冲更改可能由<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>操作（DML）而合并。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216155459307.png" alt="image-20250216155459307"></p><p><strong>Change Buffer更新机制：</strong></p><p>情况1: 对于唯一索引来说，需要将数据页读入内存，判断到没有冲突，插入这个值，语句执行结束；</p><p>情况2: 对于普通索引来说，则是将更新记录在 Change Buffer，流程如下:</p><ol><li>更新一条记录时，该记录在BufferPool存在，直接在BufferPool修改，一次内存操作。</li><li>如果该记录在Buffer Pool不存在（没有命中），在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 Change Buffer 中不用再去磁盘查询数据，避免一次磁盘IO。</li><li>当下次查询记录时，会将数据页读入内存，然后执行Buffer Pool中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性</li></ol><p>![image (2)](<a href="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image">https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image</a> (2).png)</p><p><strong>什么情况下进行merge?</strong></p><p>​1) 访问这个数据页会出发merge。</p><p>​2）系统有后台线程，定期merge。</p><p>​3）在数据库正常关闭的过程中，也会执行merge.</p><p><strong>为什么 ChangeBuffer 仅适用于非唯一二级索引页？</strong></p><p>【ANS】： 如果索引设置了唯一性，在进行修改时，InnoDB就必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。会直接将记录查询到Buffer Pool中，然后在缓冲池中修改，不会在CB中操作。</p><h2 id="3、-Log-Buffer"><a href="#3、-Log-Buffer" class="headerlink" title="3、 Log Buffer"></a>3、 Log Buffer</h2><p>Log Buffer：日志缓冲区，用来保存要写入磁盘上log（Redo&#x2F;undo）文件的数据,日志缓冲区的内容定期的刷新到磁盘Log文件中。</p><p>Log Buffer作用：用来优化每次更新操作之后都要写入 redo log而产生的磁盘IO过多的问题。日志缓冲区满时自动将数据刷新到磁盘，当遇到BLOB或者多行更新的大事务操作时，增加日志缓冲区可以节省磁盘IO。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021219758.png" alt="image-20250216021219758"></p><p><strong>innodb_log_buffer_size参数说明：</strong></p><p><code>innodb_log_buffer_size</code>变量定义日志缓冲区大小由，默认大小为16MB。日志缓冲区的内容定期刷新到磁盘。</p><ul><li>日志缓冲区使事务能够运行，而无需在事务提交之前将重做（Redo）日志数据写入磁盘。</li><li>如果有更新、插入或删除许多行的事务，增加日志缓冲区的大小将保存磁盘I&#x2F;O。</li></ul><p><code>innodb_flush_log_at_trx_commit</code>变量控制日志刷新频率，默认为1</p><ul><li>0 ： 每隔1秒写日志文件和刷盘操作，最多丢失1秒数据</li><li>1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作</li><li>2：事务提交，立刻写日志文件，每隔1秒钟进行刷盘操作</li></ul><h2 id="4、-Adaptive-Hash-Index"><a href="#4、-Adaptive-Hash-Index" class="headerlink" title="4、 Adaptive Hash Index"></a>4、 Adaptive Hash Index</h2><p>InnoDB存储引擎会监控对表上索引页（二级索引，非主键的索引）的查询，自动建立合适的Hash索引，提升数据页的访问效率。</p><p>特点：</p><ul><li>哈希索引，查询消耗O(1)，高效</li><li>降低对二级索引树的频繁访问</li><li>自适应（不用开发者自己去维护，由InnoDB引擎去维护）</li></ul><p>缺点：</p><ul><li>Hash自适应索引会占用Buffer Pool</li><li>只适合与等值查询 </li><li>范围查询不可以</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216143143931.png" alt="image-20250216143143931"></p><p>Adaptive Hash Index，是配合 Buffer Pool 工作的一个功能，使得MySQL的性能更加<strong>接近于</strong>内存服务器。</p><p>用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表索引的查找，如果观察到建立哈希索引可以带来速度的提升，则建立哈希索引，所以称之为自适应。InnoDB存储引擎会自动根据访问的频率和模式来为某些页建立哈希索引。</p><p>自适应散列索引使<code>InnoDB</code>能够在具有适当组合工作负载和缓冲池充足内存的系统上运行更像内存数据库（接近于Redis），而不会牺牲事务功能或可靠性。自适应哈希索引由<code>innodb_adaptive_Hash_index</code>变量启用，或在服务器启动时由<code>--skip-innodb-adaptive-Hash-index</code>关闭。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_adaptive_Hash_index%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="三、InnoDB-存储结构"><a href="#三、InnoDB-存储结构" class="headerlink" title="三、InnoDB 存储结构"></a>三、InnoDB 存储结构</h1><p>InnoDB磁盘主要包含Tablespaces、Doublewrite Buffer、Redo Log和Undo Log等。</p><h2 id="1、-表空间"><a href="#1、-表空间" class="headerlink" title="1、 表空间"></a>1、 表空间</h2><p>从 InnoDB存储引擎的逻辑存储结构看,所有数据都被逻辑地存放在一个空间中，称之为表空间( tablespace)。表空间又由段(segment)、区( extent)、页(page)组成。页在一些文档中有时也称为块( block)。</p><p>空间表示一本书，段表示书中的章节，区表示每章节的小节，页表示书的每一页，行就是每页的每行数据。表空间里有多个段，一个段包含256个区，一个区包含64个页，一个页为16K。</p><p>InnoDB存储引擎的逻辑存储结构大致如图所示。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/3a8ef2d5f9c714fdb3dfb2eaad2d859d.png" alt="在这里插入图片描述" style="zoom:75%;" /><p>在innodb存储引擎中数据是按照表空间来组织存储的。表空间是表空间文件是实际存在的物理文件。</p><p><strong>当我们创建一个表之后，在磁盘上会有对应的表名称.ibd的磁盘文件，这个文件就是这张表的表空间物理文件。</strong></p><h3 id="1-1-系统表空间"><a href="#1-1-系统表空间" class="headerlink" title="1.1    系统表空间"></a>1.1    系统表空间</h3><p><strong>系统表空间组成</strong>：</p><ul><li><strong>数据字典</strong>：其中包含了表结构、数据库名或者表名，字段的类型、视图、索引、表字段信息、MYSQL的版本等信息。</li><li><strong>双写缓冲区</strong>：用于保证写入磁盘时页数据的完整性，防止发生写失效问题。</li><li><strong>修改缓冲区</strong>：内存中change Buffer对应的持久化的区域，为了保证数据的完整性。</li><li><strong>回滚日志（Undo Log）</strong>：记录数据修改前的状态的，逻辑日志。主要用来实现事务回滚，实现多版本并发控制。</li></ul><h3 id="1-2-独立表空间"><a href="#1-2-独立表空间" class="headerlink" title="1.2    独立表空间"></a>1.2    独立表空间</h3><p>每个表都有自己独立的表空间，每个表的数据和索引都会存在自己的表空间中。</p><p>独立表空间的作用：可以实现单表在不同数据库中的移动。独立表空间的空间可以回收（在执行删除或者清空操作后，存储空间会还给操作系统）。</p><h3 id="1-3-其他表空间"><a href="#1-3-其他表空间" class="headerlink" title="1.3    其他表空间"></a>1.3    其他表空间</h3><h4 id="通用表空间（General-Tablespace）"><a href="#通用表空间（General-Tablespace）" class="headerlink" title="通用表空间（General Tablespace）"></a><strong>通用表空间（General Tablespace）</strong></h4><ul><li>多个表可以共享一个表空间文件。</li><li>可以通过 <code>CREATE TABLESPACE</code> 语句创建，并指定存储路径。</li></ul><h4 id="Undo-表空间（Undo-Tablespace）"><a href="#Undo-表空间（Undo-Tablespace）" class="headerlink" title="Undo 表空间（Undo Tablespace）"></a><strong>Undo 表空间（Undo Tablespace）</strong></h4><ul><li>专门用于存储事务回滚所需的数据。</li><li>现代 MySQL 版本中，Undo 表空间独立于系统表空间。</li></ul><h4 id="临时表空间（Temporary-Tablespace）"><a href="#临时表空间（Temporary-Tablespace）" class="headerlink" title="临时表空间（Temporary Tablespace）"></a><strong>临时表空间（Temporary Tablespace）</strong></h4><ul><li>用于存储临时表和排序操作的数据。</li></ul><h2 id="2、-双写缓冲区（Doublewrite-Buffer）"><a href="#2、-双写缓冲区（Doublewrite-Buffer）" class="headerlink" title="2、 双写缓冲区（Doublewrite Buffer）"></a>2、 双写缓冲区（Doublewrite Buffer）</h2><ul><li><p>作用： Doublewrite Buffer是MySQL数据库中InnoDB存储引擎的一种机制，用于解决部分<strong>写失效</strong>的问题，提高数据完整性和可靠</p></li><li><p>结构： Doublewrite Buffer是内存+磁盘的结构，包括内存结构和磁盘结构两个部分。</p><ul><li><p>在内存结构中，DWB 由128个页（Page）构成，大小是2MB。<br>这些页在内存中以 DWB 的形式存在。</p></li><li><p>在磁盘结构中，DWB 在系统表空间上是128个页（2个区，extend1和extend2），大小也是2MB。<br>这些页在磁盘上以Doublewrite File的形式存在。</p></li></ul></li></ul><p>Doublewrite Buffer的原理是在将数据页写到数据文件之前，先将它们写入Doublewrite Buffer的共享表空间内。</p><p>在完成写入Doublewrite Buffer后，再将数据页写入到数据文件的适当位置。</p><p>这种方式可以确保数据的一致性和完整性，因为在写入过程中发生意外崩溃时，可以从Doublewrite Buffer中找到完好的数据页副本用于恢复。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/0dd42f330707104ac3dbd89df94a130c.png" alt="img"></p><h2 id="3、RedoLog"><a href="#3、RedoLog" class="headerlink" title="3、RedoLog"></a>3、RedoLog</h2><h3 id="3-1-WAL-策略"><a href="#3-1-WAL-策略" class="headerlink" title="3.1    WAL 策略"></a>3.1    WAL 策略</h3><p>WAL 的全称是 Write-Ahead Logging，中文称预写式日志（写前日志），是一种数据安全写入机制。就是先写日志，然后再写入磁盘，这样既能提高性能又可以保证数据的安全性，MySQL中的Redo Log就是采用WAL机制。</p><p><strong>写后日志</strong>：先将数据写入到磁盘，然后将数据写入到日志，这种策略不适合MySQL中使用，适合的场景是内存型数据库的备份。比如Redis 的AOF的持久化策略（记录操作命令），宕机恢复进行AOF日志的回放，该方式本质上就是写入日志。</p><p><strong>为什么使用WAL ?</strong></p><p>磁盘的写（使用SQL语句执行编辑操作）操作是随机IO，比较耗性能，所以如果把每一次的更新操作都先写入Log中，那么就成了顺序写操作（效率远远高于随机IO），实际更新操作由后台线程再根据Log异步写入。这样对于Client端，延迟就降低了。并且，由于顺序写入大概率是在一个磁盘块内，这样产生的IO次数也大大降低。所以WAL的核心在于<strong>将随机写转变为了顺序写</strong>，降低了客户端的延迟，提升了吞吐量。</p><h4 id="Redo-Log-基本概念"><a href="#Redo-Log-基本概念" class="headerlink" title="Redo Log 基本概念"></a>Redo Log 基本概念</h4><p>InnoDB引擎对数据的更新，是先将更新记录写入Redo Log日志，然后会在系统空闲的时候或者是按照设定的更新策略再将日志中的内容更新到磁盘之中。这就是所谓的预写式技术（Write Ahead logging）。这种技术可以大大减少IO操作的频率，提升数据刷新的效率。</p><p>Redo Log：被称作重做日志，包括两部分</p><ul><li>一个是内存中的日志缓冲： <code>Redo Log buffer</code>，</li><li>另一个是磁盘上的日志文件： <code>Redo Log file</code> 。</li></ul><p>默认情况下，重做日志在磁盘上由两个名为<code>ib_logfile0</code>和<code>ib_logfile1</code>的文件物理表示。</p><p>MySQL 每执行一条 DML 语句，先将记录写入 Redo Log Buffer ( Redo日志记录的是事务对数据库做了哪些修改 ) 。后续某个时间点再一次性将多个操作记录写到 Redo Log File（磁盘） 。当故障发生致使内存数据丢失后，InnoDB会在重启时，经过重放 Redo，将Page恢复到崩溃之前的状态 <strong>通过Redo Log可以实现事务的持久性 。</strong></p><h4 id="Redo-Log-落盘流程："><a href="#Redo-Log-落盘流程：" class="headerlink" title="Redo Log 落盘流程："></a>Redo Log 落盘流程：</h4><p>将内存中的数据页持久化到磁盘,需要下面的两个流程来完成 :</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216195438878.png" alt="image-20250216195438878"></p><p>当进行数据页的修改操作时: <strong>首先修改在缓冲池中的页，然后再以一定的频率刷新到磁盘上</strong>。</p><p>Redo Log Buffer刷新到 Redo Log File ，下面三种情况刷新：</p><ul><li>Master Thread每一秒将重做日志缓冲刷新到重做日志文件</li><li>每个事务（Commit）提交时会将重做日志缓冲刷新到重做日志文件</li><li>当重做日志缓冲池剩余空间小于1&#x2F;2时，重做日志刷新到重做日志文件</li></ul><p>补充上述三种情况第二种，触发写磁盘过程由参数innodb_flush_log_at_trx_commit控制，表示提交(commit)操作时，处理重做日志的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_flush_log_at_trx_commit%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>参数innodb_flush_log_at_trx_commit有效值有0、1、2</p><ul><li><p>0：表示当提交事务时，并不将事务的重做日志写入磁盘上日志文件，而是等待主线程每秒刷新。 </p></li><li><p>1：表示在执行commit时将重做日志缓冲同步写到磁盘（数据安全性有保障，MySQL Server），即伴有fsync的调用 </p></li><li><p>fsync函数式Linux系统的写入磁盘的函数</p></li><li><p>兼顾了效率和安全性</p></li><li><p>2：表示将重做日志异步写到磁盘，即写到文件系统的缓存中，不保证commit时肯定会写入重做日志文件。</p></li></ul><p>0，当数据库发生宕机时，部分日志未刷新到磁盘，因此会丢失最后一段时间的事务。<br>2，当操作系统宕机时，重启数据库后会丢失未从文件系统缓存刷新到重做日志文件那部分事务。</p><h4 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h4><p>硬盘上存储的 redo log 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 redo log 日志文件组可以记录<code>4G</code>的内容。</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/10.png" alt="img" style="zoom:80%;" /><p>在这个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ul><li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li><li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 redo log 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p><p>每次 MySQL 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 redo log 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 redo log 记录。</p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 redo log 记录，MySQL 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/12.png" alt="img" style="zoom:80%;" /><h4 id="Q：-事务还没有提交的时候，-redo-log能不能够被持久化到磁盘？"><a href="#Q：-事务还没有提交的时候，-redo-log能不能够被持久化到磁盘？" class="headerlink" title="Q： 事务还没有提交的时候， redo log能不能够被持久化到磁盘？"></a>Q： 事务还没有提交的时候， redo log能不能够被持久化到磁盘？</h4><p>A： 有可能，因为 redo Log Buffer 是共享的，有可能刚好其他线程触发了刷盘</p><h2 id="4、-Undo-Log"><a href="#4、-Undo-Log" class="headerlink" title="4、 Undo Log"></a>4、 Undo Log</h2><h4 id="Undo-Log-基本概念"><a href="#Undo-Log-基本概念" class="headerlink" title="Undo Log 基本概念"></a>Undo Log 基本概念</h4><p>顾名思义，undo log是一种用于撤销回退的日志，在事务没提交之前，MySQL会先记录更新前的数据到 undo log日志文件里面，当事务回滚时或者数据库崩溃时，可以利用 undo log来进行回退。</p><h4 id="Undo-Log-作用"><a href="#Undo-Log-作用" class="headerlink" title="Undo Log 作用"></a>Undo Log 作用</h4><ul><li><p><strong>提供回滚操作（undo log实现事务的原子性）</strong> </p><ul><li>redo log记录的是物理日志，undolog记录的是逻辑日志，当delete一条记录时，Undo log中会记录一条对应insert。当执行一个update操作时，记录一条相反的update</li></ul></li><li><p><strong>提供多版本并发控制（MVCC）undo log帮助实现MVCC</strong> </p><ul><li>多版本并发控制：当去读取某一行被其他事务锁定的数据时，可以从Undolog中分析出当前行记录以前版本，从而让用户能够读取当前事务操作之前的数据，这种读操作也被称为【快照读】。</li></ul></li></ul><h4 id="Undo-Log-存储机制："><a href="#Undo-Log-存储机制：" class="headerlink" title="Undo Log 存储机制："></a>Undo Log 存储机制：</h4><p>在 InnoDB 存储引擎中，undo log是采用分段(segment)的方式进行存储的。</p><p>rollback segment称为回滚段，每个回滚段中有1024个undo log segment。</p><p>在MySQL5.5之前，只支持1个rollback segment，也就是只能记录1024个undo操作。</p><p>在MySQL5.5之后，可以支持128个rollback segment，分别从resg slot0 - resg slot127，每一个resg slot，也就是每一个回滚段，内部由1024个undo segment 组成，即总共可以记录128 * 1024个undo操作。</p><p>下面以一张图来说明undo log日志里面到底存了哪些信息？</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/5a59f812d80bc20de9fcf3e1ce9fed85.png" alt="img"></p><p>如上图，可以看到，undo log日志里面不仅存放着数据更新前的记录，还记录着RowID、事务ID、回滚指针。其中事务ID每次递增，回滚指针第一次如果是insert语句的话，回滚指针为NULL，第二次update之后的undo log的回滚指针就会指向刚刚那一条undo log日志，依次类推，就会形成一条undo log的回滚链，方便找到该条记录的历史版本</p><h4 id="Undo-Log-工作原理"><a href="#Undo-Log-工作原理" class="headerlink" title="Undo Log 工作原理"></a>Undo Log 工作原理</h4><p>在更新数据之前，MySQL会提前生成undo log日志，当事务提交的时候，并不会立即删除undo log，因为后面可能需要进行回滚操作，要执行回滚（rollback）操作时，从缓存中读取数据。undo log日志的删除是通过通过后台purge线程进行回收处理的。</p><p>同样，通过一张图来理解undo log的工作原理。<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/fe82df2b520ff875d847a234ebaaa6ee.png" alt="img"></p><p>如上图：</p><ul><li>事务A执行update操作，此时事务还没提交，会将数据进行备份到对应的undo buffer，然后由undo buffer持久化到磁盘中的undo log文件中，此时undo log保存了未提交之前的操作日志，接着将操作的数据，也就是Teacher表的数据持久保存到InnoDB的数据文件IBD。</li><li>此时事务B进行查询操作，直接从undo buffer缓存中进行读取，这时事务A还没提交事务，如果要回滚（rollback）事务，是不读磁盘的，先直接从undo buffer缓存读取。</li></ul><h4 id="Undo-Log-类型"><a href="#Undo-Log-类型" class="headerlink" title="Undo Log 类型"></a>Undo Log 类型</h4><p>InnoDB存储引擎中Undo log分为两种：</p><ol><li>insert Undo log：因为insert操作的记录只对当前记录本身可见，对其他事务不可见，所以该log日志可以在事务提交之后直接删除。</li><li>update undo log：包含delete和update操作产生的undo日志。这类日志可能需要保证MVCC机制,因此就不能再事务提交时就进行删除，提交事务时放入Undo log链表中，等待后天线程进行最后的删除。</li></ol><h2 id="5、binlog"><a href="#5、binlog" class="headerlink" title="5、binlog"></a>5、binlog</h2><p>redo log是物理日志，记录的是“在某个数据页做了什么修改”，属于Innodb存储引擎。</p><p>而binlog日志是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server层。所有的存储引擎只要发生了数据更新，都会产生binlog日志。</p><h4 id="binlog日志的作用"><a href="#binlog日志的作用" class="headerlink" title="binlog日志的作用"></a>binlog日志的作用</h4><p>可以说MySQL数据库的数据备份、主备、主主、住从都离不开binlog，需要依赖binlog来同步数据，保证数据一致性。</p><p>binlog会记录所有涉及更新数据的逻辑规则，并且按顺序写。</p><h4 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h4><p>binlog日志有三种格式，可以通过binlog_format参数设置，有以下三种：</p><ul><li>statement</li><li>row</li><li>mixed</li></ul><p>设置 statement 记录的内容是SQL语句原文，比如执行一条<code>update T set update_time = now() where id = 1</code>，记录内容如下：<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758797" alt="img"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题<code>update_time = now()</code>这里会获取到当前系统问题，直接执行会导致与原库数据不一致。</p><p>为了解决这种问题，我们需要将<code>binlog_format</code>设置成<code>row</code>，记录的不再是简单的<code>SQL</code>语句了，还包含了操作的具体数据，记录内容如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758798" alt="img"></p><p><code>row</code>格式记录的内容看不到详细信息，通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time = now()</code>变成了具体的时间，条件后面的<code>@1、@2</code>都是该行数据第1个~2个字段的原始值（假设这张表只有2个字段）。</p><p>设置成<code>row</code>带来的好处就是同步数据的一致性，通常情况都设置成<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。但是这种格式需要大量的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以又有了一种折中方案，设置为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否会引起数据不一致，如果是就用<code>row</code>格式，否则就用<code>statement</code>格式。</p><h4 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h4><p><code>binlog</code>的写入时机为事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候再把<code>binlog cache</code>写到<code>binlog</code>文件中（实际先会写入<code>page cache</code>，然后再由<code>fsync</code>写入<code>binlog</code>文件）。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为<code>binlog cache</code>。可以通过<code>binlog_cache_size</code>参数控制单线程<code>binlog_cache</code>大小，如果存储内容超过了这个参数，就要暂存到磁盘。</p><p><code>binlog</code>日志刷盘流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758799" alt="img"></p><ul><li>上图的<code>write</code>，是指把日志写入到文件系统的<code>page cache</code>，并没有把数据持久化硬盘，所以速度比较快。</li><li>上图的<code> fsync</code>才是将数据库持久化到硬盘的操作。</li></ul><p><code>write</code>和<code>fsync</code>的时机可以由参数<code>sync_binlog</code>控制，可以配置成<code>0、1、N(N&gt;1)</code>。</p><ul><li>设置成0时：表示每次提交事务都只会<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</li><li>设置成1时：表示每次提交事务都会执行<code>fsync</code>，就和<code>redo log</code>日志刷盘流程一样。</li><li>设置成N时：表示每次提交事务都会<code>write</code>，但是积累<code>N</code>个事务后才<code>fsync</code>。</li></ul><p>设置为0时如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758800" alt="img"></p><p>从上图可知，<code>sync_bilog = 0</code>设置成<code>0</code>，只把日志写入<code>page cache</code>虽然性能得到了提高，但是事务提交了<code>fsync</code>的时候宕机了，可能造成<code>binlog</code>日志的丢失。</p><p>设置为2时如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758801" alt="img"></p><p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p><p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志</p><h4 id="Q：为什么崩溃恢复不使用binlog？"><a href="#Q：为什么崩溃恢复不使用binlog？" class="headerlink" title="Q：为什么崩溃恢复不使用binlog？"></a><strong>Q：为什么崩溃恢复不使用binlog？</strong></h4><p>1）恢复机制：MySQL可以根据redo日志中的各种信息，来确定恢复的起点和终点。</p><p>2）binlog主要用于人工恢复数据，redo log是MySQL自己使用，用于保证在数据库崩溃时的事务持久性。</p><p>当数据库崩溃后，想要恢复未刷盘但已经写入redo log和binlog的数据到内存时，binlog是无法恢复，<strong>虽然binlog拥有全量的数据，但是没有一个标识，能够让InnoDB判断哪些数据已经写入表（写入到磁盘），哪些数据还没有</strong>。</p><p>比如，binlog记录了两条日志</p><ul><li>记录1：给ID&#x3D;2 这一行的c字段+1.</li><li>记录2：给ID&#x3D;2 这一行的c字段+1.</li></ul><p>在记录1入表之后，记录2还没有入表时，数据库挂了。重启后，如果只是通过binlog无法判断两条记录哪条已经写入磁盘了，哪条没写，不管是两条都恢复至内存，还是都不恢复，对于id&#x3D;2的这行数据来说，都不对。</p><p>但是如果有了redolog 就不一样，<strong>只要刷入磁盘的数据，都会从redolog抹除掉。数据库重启之后，直接把redolog中的数据都恢复到内存就可以了</strong>。</p><h2 id="6、-两阶段提交"><a href="#6、-两阶段提交" class="headerlink" title="6、 两阶段提交"></a>6、 两阶段提交</h2><h3 id="6-1-定义与作用"><a href="#6-1-定义与作用" class="headerlink" title="6.1 定义与作用"></a>6.1 定义与作用</h3><p>两阶段提交（Two-Phase Commit，2PC）是 InnoDB 存储引擎用来保证事务持久性和一致性的机制。它主要用于处理跨存储引擎的事务，特别是在涉及 InnoDB 的 redo log（重做日志）和 MySQL Server 层的 binlog（二进制日志）时。两阶段提交确保了事务在两个日志系统中要么都成功，要么都失败，从而避免数据不一致。</p><h3 id="6-2-两阶段提交的流程"><a href="#6-2-两阶段提交的流程" class="headerlink" title="6.2 两阶段提交的流程"></a>6.2 两阶段提交的流程</h3><p>两阶段提交分为两个阶段：<strong>Prepare 阶段</strong>和 <strong>Commit 阶段</strong>。</p><h4 id="（1）Prepare-阶段"><a href="#（1）Prepare-阶段" class="headerlink" title="（1）Prepare 阶段"></a>（1）Prepare 阶段</h4><ul><li>InnoDB 将事务的变更记录到 redo log 中，并将事务状态标记为“准备（Prepared）”。</li><li>此时，InnoDB 会向 MySQL Server 层发送请求，准备写入 binlog，但不会立即提交。</li><li>redo log 中记录事务的 XID（事务标识符），以便后续识别和处理。</li></ul><h4 id="（2）Commit-阶段"><a href="#（2）Commit-阶段" class="headerlink" title="（2）Commit 阶段"></a>（2）Commit 阶段</h4><ul><li>MySQL Server 层将事务信息写入 binlog，并确保其持久化到磁盘。</li><li>一旦 binlog 写入成功，InnoDB 会将 redo log 中的事务状态标记为“已提交（Committed）”，并释放事务持有的锁。</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1460000041758802" alt="img" style="zoom: 50%;" /><h3 id="6-3-异常情况及处理机制"><a href="#6-3-异常情况及处理机制" class="headerlink" title="6.3 异常情况及处理机制"></a>6.3 异常情况及处理机制</h3><p>在两阶段提交过程中，可能会出现崩溃或故障。InnoDB 通过以下机制处理这些异常情况，以保障数据一致性：</p><h4 id="（1）崩溃发生在-Prepare-阶段之后、Commit-阶段之前"><a href="#（1）崩溃发生在-Prepare-阶段之后、Commit-阶段之前" class="headerlink" title="（1）崩溃发生在 Prepare 阶段之后、Commit 阶段之前"></a>（1）崩溃发生在 Prepare 阶段之后、Commit 阶段之前</h4><ul><li>如果 MySQL 在 Prepare 阶段完成后崩溃，重启时会检查 redo log 和 binlog。</li><li>如果发现某个事务在 redo log 中处于“准备”状态，但在 binlog 中没有记录，则认为该事务提交失败，InnoDB 会自动回滚该事务。</li></ul><h4 id="（2）崩溃发生在-Commit-阶段之后"><a href="#（2）崩溃发生在-Commit-阶段之后" class="headerlink" title="（2）崩溃发生在 Commit 阶段之后"></a>（2）崩溃发生在 Commit 阶段之后</h4><ul><li>如果事务已经提交（redo log 和 binlog 都已写入成功），但 MySQL 在此之后崩溃，重启时会根据 redo log 和 binlog 的记录，将事务的变更应用到数据库中。</li><li>这种情况下，InnoDB 通过重放 redo log 中的记录，确保事务的持久性。</li></ul><h4 id="（3）依赖-Redo-Log-和-Undo-Log"><a href="#（3）依赖-Redo-Log-和-Undo-Log" class="headerlink" title="（3）依赖 Redo Log 和 Undo Log"></a>（3）依赖 Redo Log 和 Undo Log</h4><ul><li>如果在崩溃恢复过程中发现某些页面损坏，InnoDB 会依赖 redo log 进行修复。</li><li>对于未提交的事务，InnoDB 会通过 undo log 进行回滚，确保数据库处于一致状态</li></ul><h2 id="7、-其他"><a href="#7、-其他" class="headerlink" title="7、 其他"></a>7、 其他</h2><h3 id="7-1-page页的结构"><a href="#7-1-page页的结构" class="headerlink" title="7.1    page页的结构"></a>7.1    page页的结构</h3><p>Page页是InnoDB存储的最基本单位，磁盘与内存之间进行数据交互时以页（Page）为单位。</p><p>Page页分为多种类型：数据页、undo页、索引页、系统页等等</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021847718.png" alt="image-20250216021847718"></p><p><strong>页结构整体可以分为三部分：</strong></p><ul><li>通用部分（文件头、文件尾）。</li><li>存储记录的空间</li><li>数据目录</li></ul><p>数据页中行记录是按照主键值由小到大顺序的穿成一个单链表。</p><p>单链表的链表头是最小记录，表尾是最大记录。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021852737.png" alt="image-20250216021852737" style="zoom:67%;" /><p>为了快速的定位到指定的行记录，通过Page directory实现目录的功能，有了目录之后，使用二分查找法快速的定位到所需的记录。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021858603.png" alt="image-20250216021858603" style="zoom:67%;" /><h3 id="行溢出机制介绍"><a href="#行溢出机制介绍" class="headerlink" title="行溢出机制介绍"></a>行溢出机制介绍</h3><h4 id="什么是行溢出"><a href="#什么是行溢出" class="headerlink" title="什么是行溢出"></a>什么是行溢出</h4><ul><li>如果某些字段的信息过长，无法存储在B树的节点中，这时候会被单独分配空间，此时这个页被称为溢出页，这种现象就被称为行溢出。</li><li>Page  &#x3D; 16KB 16384字节，一个varchar类型列最多可以存储 65532个字节，一个页就无法存储这个varchar类型的列。如果一个表有这样一个大字段，一个页就无法存储一条完整的记录，这时候就会发生行溢出，多出的数据就在溢出页中。</li></ul><h4 id="行溢出机制"><a href="#行溢出机制" class="headerlink" title="行溢出机制"></a>行溢出机制</h4><ul><li>当发生行溢出的时候，数据页只保存前768个字节的前缀数据，以及溢出页地址，指向行溢出页。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250216021916889.png" alt="image-20250216021916889"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
            <tag> InnoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVCC 机制介绍</title>
      <link href="/2024/11/08/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20MVCC%20%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/08/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/MySQL%20MVCC%20%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="MVCC-原理详细解释"><a href="#MVCC-原理详细解释" class="headerlink" title="MVCC 原理详细解释"></a>MVCC 原理详细解释</h2><p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种数据库并发控制技术，旨在提高读写并发性能，避免传统锁机制导致的阻塞问题。其核心思想是为数据维护多个版本，使得读操作无需阻塞写操作，写操作也无需阻塞读操作。</p><h3 id="1-核心机制"><a href="#1-核心机制" class="headerlink" title="1. 核心机制"></a>1. 核心机制</h3><ul><li><strong>数据版本化</strong>：每条数据记录包含多个版本，每个版本关联两个隐藏字段：<ul><li><strong>创建版本号（DB_TRX_ID）</strong>：记录插入或最后一次更新该数据的事务ID。</li><li><strong>删除版本号（DB_ROLL_PTR）</strong>：指向旧版本数据的指针（通过Undo Log实现），用于回滚或版本链追溯。</li></ul></li><li><strong>事务ID</strong>：每个事务启动时分配唯一递增的ID（或时间戳），用于标记数据的可见性。</li></ul><h3 id="2-版本链与Undo-Log"><a href="#2-版本链与Undo-Log" class="headerlink" title="2. 版本链与Undo Log"></a>2. 版本链与Undo Log</h3><ul><li><strong>版本链</strong>：每条记录的修改会生成新版本，旧版本通过<code>DB_ROLL_PTR</code>形成链表。例如：<ul><li>事务T1插入记录R，版本为R1（DB_TRX_ID&#x3D;T1）。</li><li>事务T2更新R为R2（DB_TRX_ID&#x3D;T2，DB_ROLL_PTR→R1）。</li><li>事务T3删除R2，标记删除版本号&#x3D;T3。</li></ul></li><li><strong>Undo Log</strong>：存储旧版本数据，支持回滚和一致性读。通过版本链回溯到特定事务可见的版本。</li></ul><h3 id="3-可见性判断（Read-View）"><a href="#3-可见性判断（Read-View）" class="headerlink" title="3. 可见性判断（Read View）"></a>3. 可见性判断（Read View）</h3><p>事务启动时生成<strong>Read View</strong>，包含：</p><ul><li><code>creator_trx_id</code>：当前事务ID。</li><li><code>m_ids</code>：活跃（未提交）事务ID集合。</li><li><code>min_trx_id</code>：活跃事务中最小ID。</li><li><code>max_trx_id</code>：下一个将分配的事务ID。</li></ul><p>判断数据版本是否可见的规则：</p><ol><li>如果数据版本的<code>DB_TRX_ID &lt; min_trx_id</code>：该版本在事务启动前已提交，<strong>可见</strong>。</li><li>如果<code>DB_TRX_ID ≥ max_trx_id</code>：该版本在事务启动后生成，<strong>不可见</strong>。</li><li>如果<code>min_trx_id ≤ DB_TRX_ID &lt; max_trx_id</code>：<ul><li><code>DB_TRX_ID</code>在<code>m_ids</code>中：生成该版本的事务未提交，<strong>不可见</strong>。</li><li>否则：事务已提交，<strong>可见</strong>。</li></ul></li><li>若当前事务自身修改了数据（<code>DB_TRX_ID = creator_trx_id</code>），总是可见。</li></ol><h3 id="4-隔离级别与MVCC行为"><a href="#4-隔离级别与MVCC行为" class="headerlink" title="4. 隔离级别与MVCC行为"></a>4. 隔离级别与MVCC行为</h3><ul><li><strong>读未提交（Read Uncommitted）</strong>：直接读取最新数据，不依赖MVCC。</li><li><strong>读已提交（Read Committed）</strong>：每次读生成新Read View，看到最新提交的数据。</li><li><strong>可重复读（Repeatable Read）</strong>：事务首次读时生成Read View，后续读沿用该视图，保证一致性快照。</li><li><strong>串行化（Serializable）</strong>：退化为锁机制，不使用MVCC。</li></ul><hr><h2 id="MVCC-对幻读问题的解决分析"><a href="#MVCC-对幻读问题的解决分析" class="headerlink" title="MVCC 对幻读问题的解决分析"></a>MVCC 对幻读问题的解决分析</h2><h3 id="1-幻读的定义"><a href="#1-幻读的定义" class="headerlink" title="1. 幻读的定义"></a>1. 幻读的定义</h3><ul><li><strong>现象</strong>：同一事务中多次范围查询，结果集数量因其他事务插入&#x2F;删除而改变。</li><li><strong>与不可重复读的区别</strong>：不可重复读针对同一行数据的修改，幻读针对新增&#x2F;删除的行。</li></ul><h3 id="2-MVCC-如何缓解幻读"><a href="#2-MVCC-如何缓解幻读" class="headerlink" title="2. MVCC 如何缓解幻读"></a>2. MVCC 如何缓解幻读</h3><ul><li><p><strong>快照读（Snapshot Read）</strong>：</p><ul><li>在可重复读级别下，事务首次读生成快照，后续读沿用该快照。</li><li><strong>新插入的数据</strong>：若其他事务在快照生成后提交插入操作，因其<code>DB_TRX_ID &gt; max_trx_id</code>，对当前事务不可见。</li><li><strong>结果</strong>：同一事务内多次范围查询结果一致，避免幻读。</li></ul></li><li><p><strong>当前读（Current Read）</strong>：</p><ul><li>使用<code>SELECT ... FOR UPDATE</code>或<code>LOCK IN SHARE MODE</code>时，InnoDB会对扫描的索引范围加<strong>间隙锁（Gap Lock）</strong>，阻止其他事务插入数据到间隙中。</li><li><strong>结果</strong>：彻底杜绝幻读。</li></ul></li></ul><h3 id="3-不同数据库的实现差异"><a href="#3-不同数据库的实现差异" class="headerlink" title="3. 不同数据库的实现差异"></a>3. 不同数据库的实现差异</h3><ul><li><strong>MySQL InnoDB</strong>：<ul><li>可重复读级别下，通过MVCC快照读+间隙锁的混合机制，<strong>完全解决幻读</strong>。</li><li>快照读依赖MVCC，当前读依赖间隙锁。</li></ul></li><li><strong>PostgreSQL</strong>：<ul><li>可重复读级别仅依赖MVCC，可能出现幻读（需升级到串行化隔离级别解决）。</li></ul></li><li><strong>理论标准</strong>：<ul><li>SQL标准中，可重复读允许幻读，但MySQL&#x2F;InnoDB通过增强实现避免了这一点。</li></ul></li></ul><h3 id="4-示例分析"><a href="#4-示例分析" class="headerlink" title="4. 示例分析"></a>4. 示例分析</h3><ul><li><strong>场景</strong>：<ul><li>事务A查询<code>age &gt; 30</code>，得到2条记录。</li><li>事务B插入<code>age=35</code>并提交。</li><li>事务A再次查询<code>age &gt; 30</code>。</li></ul></li><li><strong>MVCC结果</strong>：<ul><li>若事务A为快照读：看不到事务B的插入，无幻读。</li><li>若事务A为当前读（如<code>SELECT ... FOR UPDATE</code>）：间隙锁阻止事务B插入，无幻读。</li></ul></li></ul><h3 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h3><ul><li><strong>MVCC单独作用</strong>：在快照读下可避免幻读，但对当前读无效。</li><li><strong>完整解决方案</strong>：需结合锁机制（如InnoDB的间隙锁）。因此，严格来说，<strong>MVCC本身不彻底解决幻读</strong>，而是与锁协同工作实现。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC通过多版本和Read View机制实现高效读写并发，在可重复读级别下避免快照读的幻读。但彻底解决幻读需依赖锁机制，如InnoDB的间隙锁。不同数据库的实现策略导致对幻读的处理存在差异。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD 简介</title>
      <link href="/2024/10/27/%E6%9E%B6%E6%9E%84/DDD%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/10/27/%E6%9E%B6%E6%9E%84/DDD%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="领域驱动设计（DDD）深度解析：从战略设计到战术落地"><a href="#领域驱动设计（DDD）深度解析：从战略设计到战术落地" class="headerlink" title="领域驱动设计（DDD）深度解析：从战略设计到战术落地"></a>领域驱动设计（DDD）深度解析：从战略设计到战术落地</h3><hr><h4 id="一、为什么需要DDD？"><a href="#一、为什么需要DDD？" class="headerlink" title="一、为什么需要DDD？"></a>一、为什么需要DDD？</h4><p>在传统软件开发中，<strong>业务逻辑与技术实现的高度耦合</strong>常导致系统难以维护。MVC架构容易退化为”贫血模型”，业务规则散落在Service层，领域知识逐渐丢失。而DDD通过<strong>以领域为中心的设计哲学</strong>，提供了一套应对复杂业务系统的完整方法论。</p><hr><h4 id="二、DDD核心思想"><a href="#二、DDD核心思想" class="headerlink" title="二、DDD核心思想"></a>二、DDD核心思想</h4><ol><li><p><strong>领域为王</strong><br>一切设计围绕业务领域展开，技术实现为领域服务</p></li><li><p><strong>统一语言</strong><br>开发团队与业务专家使用一致的术语表（Ubiquitous Language）</p></li><li><p><strong>分治策略</strong><br>通过限界上下文（Bounded Context）划分复杂系统</p></li></ol><hr><h3 id="三、战略设计：划分战场"><a href="#三、战略设计：划分战场" class="headerlink" title="三、战略设计：划分战场"></a>三、战略设计：划分战场</h3><ol><li><p><strong>子域划分</strong></p><ul><li><strong>核心域</strong>：业务核心竞争力（如电商的订单系统）</li><li><strong>支撑域</strong>：辅助核心业务（如物流跟踪）</li><li><strong>通用域</strong>：通用解决方案（如支付模块）</li></ul></li><li><p><strong>限界上下文</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[订单上下文]           [库存上下文]</span><br><span class="line">- 订单聚合根          - 库存条目</span><br><span class="line">- 订单项值对象        - 仓库实体</span><br><span class="line">- 订单状态机          - 库存锁定服务</span><br></pre></td></tr></table></figure></li><li><p><strong>上下文映射</strong></p><ul><li>合作关系（Partnership）</li><li>客户&#x2F;供应商（Customer&#x2F;Supplier）</li><li>防腐层（Anticorruption Layer）</li></ul></li></ol><hr><h3 id="四、战术设计：构建领域模型"><a href="#四、战术设计：构建领域模型" class="headerlink" title="四、战术设计：构建领域模型"></a>四、战术设计：构建领域模型</h3><table><thead><tr><th>构建块</th><th>核心特征</th><th>示例</th></tr></thead><tbody><tr><td><strong>实体</strong></td><td>唯一标识+生命周期</td><td>User(userId)</td></tr><tr><td><strong>值对象</strong></td><td>不可变+无标识</td><td>Money(amount,currency)</td></tr><tr><td><strong>聚合根</strong></td><td>一致性边界</td><td>Order(orderId)</td></tr><tr><td><strong>领域服务</strong></td><td>无状态操作</td><td>TransferService</td></tr><tr><td><strong>领域事件</strong></td><td>记录领域状态变化</td><td>OrderShippedEvent</td></tr></tbody></table><p><strong>聚合设计原则</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderId id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(Product product, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(items.size() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleException</span>(<span class="string">&quot;Max items exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items.add(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(product, quantity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、架构实现模式"><a href="#五、架构实现模式" class="headerlink" title="五、架构实现模式"></a>五、架构实现模式</h3><ol><li><p><strong>分层架构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│  User Interface │</span><br><span class="line">├─────────────┤</span><br><span class="line">│ Application  │</span><br><span class="line">│   Service    │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   Domain     │</span><br><span class="line">├─────────────┤</span><br><span class="line">│ Infrastructure │</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure></li><li><p><strong>CQRS模式</strong></p><ul><li>命令端：领域模型处理业务逻辑</li><li>查询端：优化后的读模型直接返回DTO</li></ul></li><li><p><strong>事件溯源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, events</span>):</span><br><span class="line">        self.balance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">            self.apply(event)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.apply(DepositEvent(amount))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(event, DepositEvent):</span><br><span class="line">            self.balance += event.amount</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="六、实践建议"><a href="#六、实践建议" class="headerlink" title="六、实践建议"></a>六、实践建议</h4><ol><li><p><strong>实施步骤</strong></p><ul><li>事件风暴工作坊 → 领域模型 → 限界上下文 → 微服务划分</li></ul></li><li><p><strong>技术选型</strong></p><ul><li>框架：Axon Framework, DDDLib</li><li>存储：EventStoreDB, MongoDB</li></ul></li><li><p><strong>常见陷阱</strong></p><ul><li>过度设计聚合边界</li><li>忽略领域事件的消息可靠性</li><li>将DDD与微服务强制绑定</li></ul></li></ol><hr><h4 id="七、何时使用DDD？"><a href="#七、何时使用DDD？" class="headerlink" title="七、何时使用DDD？"></a>七、何时使用DDD？</h4><ul><li>✅ 业务规则复杂多变的系统（保险、金融）</li><li>✅ 需要长期演进的战略级项目</li><li>❌ 简单CRUD管理系统</li><li>❌ 交付周期极短的MVP项目</li></ul><hr><p>通过DDD，我们不仅是在构建软件，更是在构建对业务领域的深刻认知。这种设计思想需要持续的精益实践，但当复杂业务遇上DDD，就像给迷宫装上了导航系统——虽然不能消除所有曲折，却能始终指引正确的方向。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
            <tag> DDD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构演进</title>
      <link href="/2024/10/24/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2024/10/24/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><ul><li><strong>硬件限制</strong>：在20世纪70年代末期到80年代初，计算机科学经历了从大型机向微型机的转变。当时的微型计算机系统通常具有16位寻址能力、不足5MHz时钟频率的处理器和128KB左右的内存地址空间。这样的硬件限制直接妨碍了单台计算机上信息系统软件的最大规模，因此需要多台计算机共同协作来支撑同一套软件系统的运行。</li><li><strong>突破算力限制</strong>：为了突破硬件算力的限制，各个高校、研究机构、软硬件厂商开始探索使用多台计算机共同协作来支撑同一套软件系统运行的可行性。</li><li><strong>计算机应用的扩展</strong>：计算机逐渐从科研设备转变为商业企业的生产设备，甚至是面向家庭、个人用户的娱乐设备，这要求计算机能够处理更大规模的信息系统软件</li></ul><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ol><li><strong>网络运算架构（NCA）</strong>：惠普公司提出的网络运算架构是未来远程服务调用的雏形 （RPC）。</li><li><strong>分布式文件系统（AFS）</strong>：卡内基·梅隆大学提出的AFS文件系统是日后分布式文件系统的最早实现。</li><li><strong>Kerberos协议</strong>：麻省理工学院提出的Kerberos协议是服务认证和访问控制的基础性协议，是分布式服务安全性的重要支撑，目前仍被用于实现包括Windows和MacOS在内众多操作系统的登录、认证功能。</li><li><strong>分布式运算环境（DCE）</strong>：开放软件基金会（OSF）制订了名为“分布式运算环境”的软件架构公约，包括了一整套完整的分布式服务组件的规范与实现，如DCE&#x2F;RPC、DCE&#x2F;DFS等。</li></ol><p>这些技术、概念对Unix系统后续的发展，乃至对今天计算机科学的诸多领域都产生了巨大而深远的影响，直接牵引了后续软件架构演化进程。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><ul><li>诸如 服务发现、负载均衡、熔断、隔离、降级、序列化、传输协议、认证和授权 、分布式数据一致性 等后续分布式&#x2F;微服务 时代老生常谈的话题，其实在这时候都已经开始了大量探索</li><li><strong>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</strong></li></ul><h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><h3 id="演进前提"><a href="#演进前提" class="headerlink" title="演进前提"></a>演进前提</h3><ol><li><strong>硬件性能的提升</strong>：随着摩尔定律的生效，微型计算机的性能以每两年增长一倍的速度提升，使得单台或少数几台计算机即可作为服务器来支撑大型信息系统运作，这使得单体架构成为可能。</li></ol><h3 id="演进原因"><a href="#演进原因" class="headerlink" title="演进原因"></a>演进原因</h3><h4 id="分布式（在当时条件下）存在的问题"><a href="#分布式（在当时条件下）存在的问题" class="headerlink" title="分布式（在当时条件下）存在的问题"></a>分布式（在当时条件下）存在的问题</h4><ol><li><p><strong>分布式架构的复杂性</strong>：原始分布式架构虽然提出了很多技术和概念，但其复杂性高，包括服务发现、负载均衡、网络分区、超时处理、序列化协议、传输协议、认证授权等一系列问题，这些问题使得分布式架构难以管理和维护。</p></li><li><p><strong>对透明分布式操作的追求</strong>：Unix设计哲学强调接口与实现的简单性，比系统的其他属性更为重要。原始分布式架构追求如同本地调用一般简单透明的分布式系统，但实际中这种透明性难以实现，导致了许多问题。</p></li></ol><h4 id="单体系统的优势"><a href="#单体系统的优势" class="headerlink" title="单体系统的优势"></a>单体系统的优势</h4><ol><li><p><strong>开发简单</strong>：单体架构中所有功能单元紧密集成，使得应用开发相对简单。</p></li><li><p><strong>易于部署</strong>：单体应用通常只需要将打包好的应用拷贝到服务器上，部署过程简单明了。</p></li><li><p><strong>测试直观</strong>：由于所有组件都在同一个应用中，测试过程相对简单直观。</p></li><li><p><strong>易于大规模更改</strong>：在单体架构中，对应用程序进行大规模更改相对容易。</p></li><li><p><strong>横向扩展容易</strong>：单体架构可以通过在负载均衡器后端运行多个应用副本来轻松实现应用扩展。</p></li></ol><h3 id="单体系统的劣势"><a href="#单体系统的劣势" class="headerlink" title="单体系统的劣势"></a>单体系统的劣势</h3><ol><li><p><strong>复杂度问题</strong>：随着业务的拓展和功能的增多，单体应用变得越来越复杂，维护和升级成为挑战。</p></li><li><p><strong>扩展局限</strong>：单体架构很难进行水平扩展，当某个模块需要单独扩展时，整个系统都需要扩展，成本高昂。</p></li><li><p><strong>部署困难</strong>：频繁的部署需求使得单体架构在每次更新时都需要重新部署整个应用，增加了风险和工作量。</p></li><li><p><strong>技术迭代困难</strong>：在单体架构下引入新技术和工具，或进行架构优化，通常意味着大规模的改动和可能的风险。</p></li><li><p><strong>可靠性差</strong>：单体应用中任何一部分代码出现缺陷，如内存泄漏或线程爆炸，都将影响整个程序的正常运作。</p></li><li><p><strong>难以技术异构</strong>：单体架构中各模块通常需要使用相同的技术栈，限制了技术多样性。</p></li></ol><p><strong>综上所述，原始分布式时代向单体系统时代的演进是为了解决分布式架构的复杂性和管理难题，而单体系统虽然简化了开发和部署流程，但也带来了新的挑战，特别是在系统规模扩大和需求变化时。</strong></p><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><h3 id="演进原因-1"><a href="#演进原因-1" class="headerlink" title="演进原因"></a>演进原因</h3><p>单体架构向分层架构演进的主要原因是为了解决以下几个问题：</p><ol><li><p><strong>易于开发与维护</strong>：随着业务的发展，单体应用变得越来越复杂，难以维护。分层架构通过将系统拆分成具有独立职责的多个层次，简化了系统设计，使得团队成员可以专注于特定层次的开发。</p></li><li><p><strong>提高代码的复用性和系统的横向扩展能力</strong>：分层架构允许在不同系统或模块中重用相同的代码，尤其是在数据访问层。</p></li><li><p><strong>应对高并发系统设计</strong>：分层架构支持高并发和向分布式方向发展，对网站支持高并发至关重要。</p></li></ol><h3 id="分层架构优势"><a href="#分层架构优势" class="headerlink" title="分层架构优势"></a>分层架构优势</h3><p>分层架构相对于单体架构的优势包括：</p><ol><li><p><strong>高内聚低耦合</strong>：每个层次都有明确的职责，内聚度高，层与层之间的耦合度低，提高了系统的可维护性和可扩展性。</p></li><li><p><strong>易于测试</strong>：由于每一层都有明确的职责，可以对每一层进行单独的测试，简化了测试工作。</p></li><li><p><strong>可重用性和灵活性</strong>：分层架构提高了代码的可重用性，如果在某一层引入了改变，只需要修改那一层的代码，而不会影响到其他层，这大大增加了系统的灵活性。</p></li></ol><h3 id="分层架构不足"><a href="#分层架构不足" class="headerlink" title="分层架构不足"></a>分层架构不足</h3><p>然而，分层架构也引入了新的挑战和不足：</p><ol><li><p><strong>性能问题</strong>：分层架构可能会引入额外的性能开销，因为一个请求可能需要穿越多层才能得到处理，这可能会导致延迟。</p></li><li><p><strong>过度复杂化</strong>：如果过度使用分层架构，可能会导致系统过于复杂，管理和维护这些层变得困难。</p></li><li><p><strong>架构设计之初没有严格的层级和边界设计</strong>：如果层与层之间只是物理代码的隔离，逻辑上却严重耦合，会导致架构设计的初衷无法实现。</p></li><li><p><strong>有层级设计，但每层的职责设计难以支撑业务演进</strong>：如果某一层没有承担起它该有的责任，其他层只能把这个责任担起来，从而引入不必要的问题。</p></li><li><p><strong>开发团队的认知水平和协作水平低下</strong>：软件开发是一个团队协作共同创作的过程，如果在每个阶段都完全依靠每个个体的能力，软件的架构和质量取决于团队内最差的个体的能力和认知水平。</p></li></ol><p>综上所述，分层架构通过将复杂的系统分解为更小、更易于管理的部分，提高了系统的可维护性和可扩展性，但也带来了性能和复杂性方面的挑战。</p><h2 id="SOA-架构"><a href="#SOA-架构" class="headerlink" title="SOA 架构"></a>SOA 架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SOA (Service-oriented architecture，面相服务的软件架构)是一种软件设计方法 或 大型服务架构设计思想，</p><p>SOA 侧重于构建和维护一系列的大型服务系统的基本组件， 这些基本组件可以相互调用，且相互松耦合，每一个组件可以完整的覆盖一个子模块，或子业务的各项基本功能。</p><p>在完成 基础组件搭建后， 可以快速的将业务进行编排、组合来实现具体的或不断变化业务。</p><p>在SOA中，重点是模块化、可重用性和互操作性——当业务将复杂的应用程序分解成更小、更易于管理的构建块时，结果是更大的灵活性和可伸缩性。</p><h3 id="主要技术概念"><a href="#主要技术概念" class="headerlink" title="主要技术概念"></a>主要技术概念</h3><p>SOA 软件设计指导原则： 包括服务的 封装性、</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP详解</title>
      <link href="/2024/09/16/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20AOP%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/16/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20AOP%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-AOP——Spring-中面向切面编程"><a href="#Spring-AOP——Spring-中面向切面编程" class="headerlink" title="Spring AOP——Spring 中面向切面编程"></a>Spring AOP——Spring 中面向切面编程</h1><h2 id="一、AOP概述"><a href="#一、AOP概述" class="headerlink" title="一、AOP概述"></a>一、AOP概述</h2><h3 id="1-1-什么是-AOP"><a href="#1-1-什么是-AOP" class="headerlink" title="1.1 什么是 AOP"></a>1.1 什么是 AOP</h3><p>AOP （Aspect Orient Programming）,直译过来就是 面向切面编程。AOP 是一种编程思想，是面向对象编程（OOP）的一种补充。面向对象编程将程序抽象成各个层次的对象，而面向切面编程是将程序抽象成各个切面。<br>从《Spring实战（第4版）》图书中扒了一张图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225344641-152289598.png" alt="img"></p><p>从该图可以很形象地看出，所谓切面，相当于应用对象间的横切点，我们可以将其单独抽象为单独的模块。</p><h3 id="1-2-为什么需要-AOP"><a href="#1-2-为什么需要-AOP" class="headerlink" title="1.2 为什么需要 AOP"></a>1.2 为什么需要 AOP</h3><p>想象下面的场景，开发中在多个模块间有某段重复的代码，我们通常是怎么处理的？显然，没有人会靠“复制粘贴”吧。在传统的面向过程编程中，我们也会将这段代码，抽象成一个方法，然后在需要的地方分别调用这个方法，这样当这段代码需要修改时，我们只需要改变这个方法就可以了。然而需求总是变化的，有一天，新增了一个需求，需要再多出做修改，我们需要再抽象出一个方法，然后再在需要的地方分别调用这个方法，又或者我们不需要这个方法了，我们还是得删除掉每一处调用该方法的地方。实际上涉及到多个地方具有相同的修改的问题我们都可以通过 AOP 来解决。</p><h3 id="1-3-AOP-实现分类"><a href="#1-3-AOP-实现分类" class="headerlink" title="1.3 AOP 实现分类"></a>1.3 AOP 实现分类</h3><p>AOP 要达到的效果是，保证开发者不修改源代码的前提下，去为系统中的业务组件添加某种通用功能。AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码，看到这其实应该明白了，AOP 其实就是前面一篇文章讲的代理模式的典型应用。<br>按照 AOP 框架修改源代码的时机，可以将其分为两类：</p><ul><li>静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ。</li><li>动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。</li></ul><p>下面给出常用 AOP 实现比较</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225400887-1590896890.png" alt="img"></p><h2 id="二、AOP-术语"><a href="#二、AOP-术语" class="headerlink" title="二、AOP 术语"></a>二、AOP 术语</h2><p>AOP 领域中的特性术语：</p><ul><li><strong>通知（Advice）</strong>: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。</li><li><strong>连接点（join point）</strong>: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。</li><li><strong>切点（PointCut）</strong>: 可以插入增强处理的连接点。</li><li><strong>切面（Aspect）</strong>: 切面是通知和切点的结合。</li><li><strong>引入（Introduction）</strong>：引入允许我们向现有的类添加新的方法或者属性。</li><li><strong>织入（Weaving）</strong>: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。</li></ul><p>概念看起来总是有点懵，并且上述术语，不同的参考书籍上翻译还不一样，所以需要慢慢在应用中理解。</p><h2 id="三、初步认识-Spring-AOP"><a href="#三、初步认识-Spring-AOP" class="headerlink" title="三、初步认识 Spring AOP"></a>三、初步认识 Spring AOP</h2><h3 id="3-1-Spring-AOP-的特点"><a href="#3-1-Spring-AOP-的特点" class="headerlink" title="3.1 Spring AOP 的特点"></a>3.1 Spring AOP 的特点</h3><p>AOP 框架有很多种，1.3节中介绍了 AOP 框架的实现方式有可能不同， Spring 中的 AOP 是通过动态代理实现的。不同的 AOP 框架支持的连接点也有所区别，例如，AspectJ 和 JBoss,除了支持方法切点，它们还支持字段和构造器的连接点。而 Spring AOP 不能拦截对对象字段的修改，也不支持构造器连接点,我们无法在 Bean 创建时应用通知。</p><h3 id="3-2-Spring-AOP-的简单例子"><a href="#3-2-Spring-AOP-的简单例子" class="headerlink" title="3.2 Spring AOP 的简单例子"></a>3.2 Spring AOP 的简单例子</h3><p>下面先上代码，对着代码说比较好说，看下面这个例子：<br>这个例子是基于gradle创建的，首先 build.gradle 文件添加依赖：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="built_in">compile</span> <span class="string">&#x27;org.springframework:spring-context:5.0.6.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建一个接口 IBuy.java</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IBuy</span> &#123;</span><br><span class="line">    <span class="function">String <span class="title">buy</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Boy 和 Gril 两个类分别实现了这个接口：<br>Boy.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">sharpcj</span>.<span class="property">aopdemo</span>.<span class="property">test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">buy</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;男孩买了一个游戏机&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;游戏机&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Girl.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">sharpcj</span>.<span class="property">aopdemo</span>.<span class="property">test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">buy</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">&quot;女孩买了一件漂亮的衣服&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;衣服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件, AppConfig.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.sharpcj.aopdemo.test1.IBuy.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类， AppTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Boy;</span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Girl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;boy&quot;</span>,Boy.class);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> (Girl) context.getBean(<span class="string">&quot;girl&quot;</span>);</span><br><span class="line">        boy.buy();</span><br><span class="line">        girl.buy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225425832-1733905596.png" alt="img"></p><p>这里运用SpringIOC里的自动部署。现在需求改变了，我们需要在男孩和女孩的 buy 方法之前，需要打印出“男孩女孩都买了自己喜欢的东西”。用 Spring AOP 来实现这个需求只需下面几个步骤：<br>1、 <strong>既然用到 Spring AOP, 首先在 <code>build.gralde</code> 文件中引入相关依赖：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="built_in">compile</span> <span class="string">&#x27;org.springframework:spring-context:5.0.6.RELEASE&#x27;</span></span><br><span class="line">    <span class="built_in">compile</span> <span class="string">&#x27;org.springframework:spring-aspects:5.0.6.RELEASE&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 <strong>定义一个切面类，BuyAspectJ.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;男孩女孩都买自己喜欢的东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类，我们使用了注解 <code>@Component</code> 表明它将作为一个Spring Bean 被装配，使用注解 <code>@Aspect</code> 表示它是一个切面。<br>类中只有一个方法 <code>haha</code> 我们使用 <code>@Before</code> 这个注解，表示他将在方法执行之前执行。关于这个注解后文再作解释。<br>参数<code>(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</code> 声明了切点，表明在该切面的切点是<code>com.sharpcj.aopdemo.test1.Ibuy</code>这个接口中的<code>buy</code>方法。至于为什么这么写，下文再解释。<br>3、 <strong>在配置文件中启用AOP切面功能</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.sharpcj.aopdemo.test1.IBuy.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在配置文件类增加了<code>@EnableAspectJAutoProxy</code>注解，启用了 AOP 功能，参数<code>proxyTargetClass</code>的值设为了 true 。默认值是 false，两者的区别下文再解释。<br>OK，下面只需测试代码,运行结果如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225446321-1741506938.png" alt="img"></p><p>我们看到，结果与我们需求一致，我们并没有修改 Boy 和 Girl 类的 Buy 方法，也没有修改测试类的代码，几乎是完全无侵入式地实现了需求。这就是 AOP 的“神奇”之处。</p><h2 id="四、通过注解配置-Spring-AOP"><a href="#四、通过注解配置-Spring-AOP" class="headerlink" title="四、通过注解配置 Spring AOP"></a>四、通过注解配置 Spring AOP</h2><h3 id="4-1-通过注解声明切点指示器"><a href="#4-1-通过注解声明切点指示器" class="headerlink" title="4.1 通过注解声明切点指示器"></a>4.1 通过注解声明切点指示器</h3><p>Spring AOP 所支持的 AspectJ 切点指示器</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225507103-314276426.png" alt="img"></p><p>在spring中尝试使用AspectJ其他指示器时，将会抛出IllegalArgumentException异常。</p><p>当我们查看上面展示的这些spring支持的指示器时，注意只有execution指示器是唯一的执行匹配，而其他的指示器都是用于限制匹配的。这说明execution指示器是我们在编写切点定义时最主要使用的指示器，在此基础上，我们使用其他指示器来限制所匹配的切点。</p><p>下图的切点表达式表示当Instrument的play方法执行时会触发通知。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225530124-1714809272.png" alt="img"></p><p>我们使用execution指示器选择Instrument的play方法，方法表达式以 <code>*</code> 号开始，标识我们不关心方法的返回值类型。然后我们指定了全限定类名和方法名。对于方法参数列表，我们使用 <code>..</code> 标识切点选择任意的play方法，无论该方法的入参是什么。<br>多个匹配之间我们可以使用链接符 <code>&amp;&amp;</code>、<code>||</code>、<code>！</code>来表示 “且”、“或”、“非”的关系。但是在使用 XML 文件配置时，这些符号有特殊的含义，所以我们使用 “and”、“or”、“not”来表示。</p><p>举例：<br>限定该切点仅匹配的包是 <code>com.sharpcj.aopdemo.test1</code>,可以使用<br><code>execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;&amp; within(com.sharpcj.aopdemo.test1.*)</code><br>在切点中选择 bean,可以使用<br><code>execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;&amp; bean(girl)</code><br>修改 BuyAspectJ.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..)) &amp;&amp; within(com.sharpcj.aopdemo.test1.*) &amp;&amp; bean(girl)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hehe</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;男孩女孩都买自己喜欢的东西&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，切面只会对 <code>Girl.java</code> 这个类生效，执行结果：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225548745-1785519580.png" alt="img"></p><p>细心的你，可能发现了，切面中的方法名，已经被我悄悄地从<code>haha</code>改成了<code>hehe</code>，丝毫没有影响结果，说明方法名没有影响。和 Spring IOC 中用 java 配置文件装配 Bean 时，用<code>@Bean</code> 注解修饰的方法名一样，没有影响。</p><h3 id="4-2-通过注解声明-5-种通知类型"><a href="#4-2-通过注解声明-5-种通知类型" class="headerlink" title="4.2 通过注解声明 5 种通知类型"></a>4.2 通过注解声明 5 种通知类型</h3><p>Spring AOP 中有 5 中通知类型，分别如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225613898-1522094074.png" alt="img"></p><p>下面修改切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hehe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xixi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Around aaa ...&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;Around bbb ...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了方便看效果,我们测试类中，只要 Boy 类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Boy;</span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Girl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;boy&quot;</span>,Boy.class);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> (Girl) context.getBean(<span class="string">&quot;girl&quot;</span>);</span><br><span class="line">        boy.buy();</span><br><span class="line">        <span class="comment">// girl.buy();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225633682-474468038.png" alt="img"></p><p>结果显而易见。指的注意的是 <code>@Around</code> 修饰的环绕通知类型，是将整个目标方法封装起来了，在使用时，我们传入了 <code>ProceedingJoinPoint</code> 类型的参数，这个对象是必须要有的，并且需要调用 <code>ProceedingJoinPoint</code> 的 <code>proceed()</code> 方法。 如果没有调用 该方法，执行结果为 ：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Around aaa ...</span><br><span class="line">Around bbb ...</span><br><span class="line">After ...</span><br><span class="line">AfterReturning ...</span><br></pre></td></tr></table></figure><p>可见，如果不调用该对象的 proceed() 方法，表示原目标方法被阻塞调用，当然也有可能你的实际需求就是这样。</p><h3 id="4-3-通过注解声明切点表达式"><a href="#4-3-通过注解声明切点表达式" class="headerlink" title="4.3 通过注解声明切点表达式"></a>4.3 通过注解声明切点表达式</h3><p>如你看到的，上面我们写的多个通知使用了相同的切点表达式，对于像这样频繁出现的相同的表达式，我们可以使用 <code>@Pointcut</code>注解声明切点表达式，然后使用表达式，修改代码如下：<br>BuyAspectJ.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hehe</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">haha</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xixi</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxx</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Around aaa ...&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;Around bbb ...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果没有变化。<br>这里，我们使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>声明了一个切点表达式，该方法 point 的内容并不重要，方法名也不重要，实际上它只是作为一个标识，供通知使用。</p><h3 id="4-4-通过注解处理通知中的参数"><a href="#4-4-通过注解处理通知中的参数" class="headerlink" title="4.4 通过注解处理通知中的参数"></a>4.4 通过注解处理通知中的参数</h3><p>上面的例子，我们要进行增强处理的目标方法没有参数，下面我们来说说有参数的情况，并且在增强处理中使用该参数。<br>下面我们给接口增加一个参数，表示购买所花的金钱。通过AOP 增强处理，如果女孩买衣服超过了 68 元，就可以赠送一双袜子。<br>更改代码如下：<br>IBuy.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    String <span class="title function_">buy</span><span class="params">(<span class="type">double</span> price)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Girl.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">sharpcj</span>.<span class="property">aopdemo</span>.<span class="property">test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">buy</span>(<span class="params">double price</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="title class_">String</span>.<span class="title function_">format</span>(<span class="string">&quot;女孩花了%s元买了一件漂亮的衣服&quot;</span>, price));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;衣服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Boy.java</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.<span class="property">sharpcj</span>.<span class="property">aopdemo</span>.<span class="property">test1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.<span class="property">springframework</span>.<span class="property">stereotype</span>.<span class="property">Component</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">String</span> <span class="title function_">buy</span>(<span class="params">double price</span>) &#123;</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="title class_">String</span>.<span class="title function_">format</span>(<span class="string">&quot;男孩花了%s元买了一个游戏机&quot;</span>, price));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;游戏机&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看 BuyAspectJ 类，我们将之前的通知都注释掉。用一个环绕通知来实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line"><span class="meta">    @Pointcut(<span class="params"><span class="string">&quot;execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))&quot;</span></span>)</span></span><br><span class="line">    public void point()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Before(<span class="params"><span class="string">&quot;point()&quot;</span></span>)</span></span><br><span class="line">    public void hehe() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @After(<span class="params"><span class="string">&quot;point()&quot;</span></span>)</span></span><br><span class="line">    public void haha() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @AfterReturning(<span class="params"><span class="string">&quot;point()&quot;</span></span>)</span></span><br><span class="line">    public void xixi() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;AfterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Around(<span class="params"><span class="string">&quot;point()&quot;</span></span>)</span></span><br><span class="line">    public void xxx(ProceedingJoinPoint pj) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Around aaa ...&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.out.println(<span class="string">&quot;Around bbb ...&quot;</span>);</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @Pointcut(<span class="params"><span class="string">&quot;execution(String com.sharpcj.aopdemo.test1.IBuy.buy(double)) &amp;&amp; args(price) &amp;&amp; bean(girl)&quot;</span></span>)</span></span><br><span class="line">    public void gif(double price) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">    @Around(<span class="params"><span class="string">&quot;gif(price)&quot;</span></span>)</span></span><br><span class="line">    public String hehe(ProceedingJoinPoint pj, double price)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pj.proceed();</span><br><span class="line">            <span class="keyword">if</span> (price &gt; <span class="number">68</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;女孩买衣服超过了68元，赠送一双袜子&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;衣服和袜子&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;衣服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文提到，当不关心方法返回值的时候，我们在编写切点指示器的时候使用了 <code>*</code> ， 当不关心方法参数的时候，我们使用了 <code>..</code>。现在如果我们需要传入参数，并且有返回值的时候，则需要使用对应的类型。在编写通知的时候，我们也需要声明对应的返回值类型和参数类型。</p><p>测试类：AppTest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Boy;</span><br><span class="line"><span class="keyword">import</span> com.sharpcj.aopdemo.test1.Girl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(AppConfig.class);</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;boy&quot;</span>,Boy.class);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> (Girl) context.getBean(<span class="string">&quot;girl&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">boyBought</span> <span class="operator">=</span> boy.buy(<span class="number">35</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">girlBought</span> <span class="operator">=</span> girl.buy(<span class="number">99.8</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;男孩买到了：&quot;</span> + boyBought);</span><br><span class="line">        System.out.println(<span class="string">&quot;女孩买到了：&quot;</span> + girlBought);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225709155-1683416178.png" alt="img"></p><p>可以看到，我们成功通过 AOP 实现了需求，并将结果打印了出来。</p><h3 id="4-5-通过注解配置织入的方式"><a href="#4-5-通过注解配置织入的方式" class="headerlink" title="4.5 通过注解配置织入的方式"></a>4.5 通过注解配置织入的方式</h3><p>前面还有一个遗留问题，在配置文件中，我们用注解 <code>@EnableAspectJAutoProxy()</code> 启用Spring AOP 的时候，我们给参数 <code>proxyTargetClass</code> 赋值为 <code>true</code>,如果我们不写参数，默认为 false。这个时候运行程序，程序抛出异常</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225724860-1448694025.png" alt="img"></p><p>这是一个强制类型转换异常。为什么会抛出这个异常呢？或许已经能够想到，这跟Spring AOP 动态代理的机制有关，这个 <code>proxyTargetClass</code> 参数决定了代理的机制。当这个参数为 false 时，<br>通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常。<br>反之，<code>proxyTargetClass</code> 为 <code>true</code>，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被<code>final</code>修饰时，无法进行织入。<br>测试一下，我们将 <code>proxyTargetClass</code> 参数设为 <code>true</code>，同时将 Girl.java 的 Buy 方法用 <code>final</code> 修饰：<br>AppConfig.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.sharpcj.aopdemo.test1.IBuy.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Girl.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">IBuy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">buy</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;女孩花了%s元买了一件漂亮的衣服&quot;</span>, price));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;衣服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时运行结果：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529225755992-1036671637.png" alt="img"></p><p>可以看到，我们的切面并没有织入生效。</p><h2 id="五、通过-XML-配置文件声明切面"><a href="#五、通过-XML-配置文件声明切面" class="headerlink" title="五、通过 XML 配置文件声明切面"></a>五、通过 XML 配置文件声明切面</h2><p>前面的示例中，我们已经展示了如何通过注解配置去声明切面，下面我们看看如何在 XML 文件中声明切面。下面先列出 XML 中声明 AOP 的常用元素：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/758949-20190529232014979-1838628294.png" alt="img"></p><p>我们依然可以使用 <code>&lt;aop:aspectj-autoproxy&gt;</code> 元素，他能够自动代理AspectJ注解的通知类。</p><h3 id="5-1-XML-配置文件中切点指示器"><a href="#5-1-XML-配置文件中切点指示器" class="headerlink" title="5.1 XML 配置文件中切点指示器"></a>5.1 XML 配置文件中切点指示器</h3><p>在XML配置文件中，切点指示器表达式与通过注解配置的写法基本一致，区别前面有提到，即XML文件中需要使用 “and”、“or”、“not”来表示 “且”、“或”、“非”的关系。</p><h3 id="5-2-XML-文件配置-AOP-实例"><a href="#5-2-XML-文件配置-AOP-实例" class="headerlink" title="5.2 XML 文件配置 AOP 实例"></a>5.2 XML 文件配置 AOP 实例</h3><p>下面我们不使用任何注解改造上面的例子：<br>BuyAspectJ.java</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.sharpcj.aopdemo.test2;</span><br><span class="line"></span><br><span class="line">import org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BuyAspectJ</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hehe</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;before ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">haha</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;After ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xixi</span>()</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">&quot;AfterReturning ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span>(<span class="params">ProceedingJoinPoint pj</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;Around aaa ...&quot;</span>);</span><br><span class="line">            pj.proceed();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">&quot;Around bbb ...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Resource 目录下新建一个配置文件 aopdemo.xml ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Boy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;girl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyAspectJ&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;qiemian&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;buyAspectJ&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;</span> <span class="attr">method</span>=<span class="string">&quot;hehe&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;</span> <span class="attr">method</span>=<span class="string">&quot;haha&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;</span> <span class="attr">method</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;</span> <span class="attr">method</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里分别定义了一个切面，里面包含四种类型的通知。<br>测试文件中，使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;aopdemo.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>来获取 ApplicationContext，其它代码不变。</p><h3 id="5-3-XML-文件配置声明切点"><a href="#5-3-XML-文件配置声明切点" class="headerlink" title="5.3 XML 文件配置声明切点"></a>5.3 XML 文件配置声明切点</h3><p>对于频繁重复使用的切点表达式，我们也可以声明成切点。<br>配置文件如下：aopdemo.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Boy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;girl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyAspectJ&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.sharpcj.aopdemo.test2.IBuy.buy(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;qiemian&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;buyAspectJ&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">method</span>=<span class="string">&quot;hehe&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">method</span>=<span class="string">&quot;haha&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">method</span>=<span class="string">&quot;xixi&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">method</span>=<span class="string">&quot;xxx&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-4-XML文件配置为通知传递参数"><a href="#5-4-XML文件配置为通知传递参数" class="headerlink" title="5.4 XML文件配置为通知传递参数"></a>5.4 XML文件配置为通知传递参数</h3><p>BuyAspectJ.java</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sharpcj.aopdemo.test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyAspectJ</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String hehe(ProceedingJoinPoint pj, double price)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pj.proceed();</span><br><span class="line">            <span class="keyword">if</span> (price &gt; <span class="number">68</span>) &#123;</span><br><span class="line">                System.<span class="keyword">out</span>.println(<span class="string">&quot;女孩买衣服超过了68元，赠送一双袜子&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;衣服和袜子&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;衣服&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>aopdemo.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;boy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Boy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;girl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.Girl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;buyAspectJ&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.sharpcj.aopdemo.test2.BuyAspectJ&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(String com.sharpcj.aopdemo.test2.IBuy.buy(double)) and args(price) and bean(girl)&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;qiemian&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;buyAspectJ&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;apoint&quot;</span> <span class="attr">method</span>=<span class="string">&quot;hehe&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-5-Xml-文件配置织入的方式"><a href="#5-5-Xml-文件配置织入的方式" class="headerlink" title="5.5 Xml 文件配置织入的方式"></a>5.5 Xml 文件配置织入的方式</h3><p>同注解配置类似,<br>CGlib 代理方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:<span class="keyword">config</span> proxy-target-<span class="keyword">class</span>=<span class="string">&quot;true&quot;</span>&gt; &lt;/aop:<span class="keyword">config</span>&gt;</span><br></pre></td></tr></table></figure><p>JDK 代理方式：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:<span class="keyword">config</span> proxy-target-<span class="keyword">class</span>=<span class="string">&quot;false&quot;</span>&gt; &lt;/aop:<span class="keyword">config</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>本文简单记录了 AOP 的编程思想，然后介绍了 Spring 中 AOP 的相关概念，以及通过注解方式和XML配置文件两种方式使用 Spring AOP进行编程。 相比于 AspectJ 的面向切面编程，Spring AOP 也有一些局限性，但是已经可以解决开发中的绝大多数问题了，如果确实遇到了 Spring AOP 解决不了的场景，我们依然可以在 Spring 中使用 AspectJ 来解决。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 后处理器概要总结</title>
      <link href="/2024/09/15/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A6%81%E6%80%BB%E7%BB%93/"/>
      <url>/2024/09/15/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8%E6%A6%82%E8%A6%81%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-后处理器总结"><a href="#Spring-后处理器总结" class="headerlink" title="Spring 后处理器总结"></a>Spring 后处理器总结</h1><p>Spring 后处理器（Post-Processor）是框架扩展机制的核心组件，分为 <strong>Bean 后处理器</strong>和<strong>容器后处理器</strong>两类，通过干预 Bean 生命周期和容器行为实现高阶功能。以下是技术总结：</p><h2 id="1、-Bean-后处理器-BeanPostProcessor"><a href="#1、-Bean-后处理器-BeanPostProcessor" class="headerlink" title="1、 Bean 后处理器 (BeanPostProcessor)"></a>1、 Bean 后处理器 (<code>BeanPostProcessor</code>)</h2><p><strong>作用阶段</strong>：Bean 初始化前后（<code>afterPropertiesSet</code>&#x2F;<code>init-method</code> 前后）<br><strong>核心方法</strong>：</p><ul><li><code>postProcessBeforeInitialization(Object bean, String beanName)</code></li><li><code>postProcessAfterInitialization(Object bean, String beanName)</code></li></ul><p><strong>常见实现及用途</strong>：</p><ol><li><strong><code>AutowiredAnnotationBeanPostProcessor</code></strong><ul><li>处理 <code>@Autowired</code>、<code>@Value</code>、<code>@Inject</code> 注解，完成依赖注入。</li><li><strong>底层机制</strong>：通过 <code>MergedBeanDefinitionPostProcessor</code> 解析元数据，生成 <code>InjectionMetadata</code> 注入元信息。</li></ul></li><li><strong><code>CommonAnnotationBeanPostProcessor</code></strong><ul><li>处理 <code>@PostConstruct</code>、<code>@PreDestroy</code>、<code>@Resource</code> 注解。</li><li><strong>原理</strong>：利用 <code>InitDestroyAnnotationBeanPostProcessor</code> 基类实现生命周期回调。</li></ul></li><li><strong><code>PersistenceAnnotationBeanPostProcessor</code></strong><ul><li>支持 JPA 注解（如 <code>@PersistenceContext</code>、<code>@PersistenceUnit</code>）。</li></ul></li><li>**<code>AbstractAutoProxyCreator</code>**（AOP 核心）<ul><li>基于 <code>BeanPostProcessor</code> 实现动态代理（JDK&#x2F;CGLIB）。</li><li><strong>子类</strong>：<code>AnnotationAwareAspectJAutoProxyCreator</code>（处理 <code>@Aspect</code> 切面）。</li></ul></li></ol><h2 id="2、-容器后处理器-BeanFactoryPostProcessor"><a href="#2、-容器后处理器-BeanFactoryPostProcessor" class="headerlink" title="2、 容器后处理器 (BeanFactoryPostProcessor)"></a>2、 容器后处理器 (<code>BeanFactoryPostProcessor</code>)</h2><p><strong>作用阶段</strong>：容器启动时，<strong>Bean 定义加载完成后、实例化前</strong><br><strong>核心方法</strong>：<code>postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)</code></p><p><strong>关键实现</strong>：</p><ol><li><strong><code>PropertySourcesPlaceholderConfigurer</code></strong><ul><li>解析 <code>$&#123;...&#125;</code> 占位符，替换为 <code>Environment</code> 或 <code>.properties</code> 中的值。</li><li><strong>替代方案</strong>：Spring Boot 中通过 <code>@PropertySource</code> 或 <code>application.yml</code> 自动处理。</li></ul></li><li><strong><code>ConfigurationClassPostProcessor</code></strong><ul><li>解析 <code>@Configuration</code> 类，处理 <code>@ComponentScan</code>、<code>@Import</code>、<code>@Bean</code> 等注解。</li><li><strong>底层</strong>：调用 <code>ConfigurationClassParser</code> 生成 <code>BeanDefinition</code>。</li></ul></li><li><strong><code>CustomAutowireConfigurer</code></strong><ul><li>自定义限定符（<code>@Qualifier</code> 扩展），例如结合自定义注解实现按条件注入。</li></ul></li></ol><h2 id="3、-Bean-定义注册后处理器-BeanDefinitionRegistryPostProcessor"><a href="#3、-Bean-定义注册后处理器-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3、 Bean 定义注册后处理器 (BeanDefinitionRegistryPostProcessor)"></a>3、 Bean 定义注册后处理器 (<code>BeanDefinitionRegistryPostProcessor</code>)</h2><p>**扩展自 <code>BeanFactoryPostProcessor</code>**，允许直接操作 <code>BeanDefinitionRegistry</code><br><strong>核心方法</strong>：<code>postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)</code><br><strong>典型用例</strong>：</p><ul><li>**<code>ConfigurationClassPostProcessor</code>**（同上）</li><li><strong>动态注册 Bean</strong>：通过编程方式向容器添加新的 <code>BeanDefinition</code>（如根据条件生成 Bean）。</li></ul><h2 id="4、-其他扩展点"><a href="#4、-其他扩展点" class="headerlink" title="4、 其他扩展点"></a>4、 其他扩展点</h2><ol><li><strong><code>MergedBeanDefinitionPostProcessor</code></strong><ul><li>在 Bean 合并定义阶段修改元数据（如 <code>@Autowired</code> 字段解析）。</li></ul></li><li><strong><code>DestructionAwareBeanPostProcessor</code></strong><ul><li>拦截 Bean 销毁逻辑（<code>@PreDestroy</code> 的底层支持）。</li></ul></li><li><strong><code>EventListenerMethodProcessor</code></strong><ul><li>解析 <code>@EventListener</code> 方法，将其注册为应用事件监听器。</li></ul></li></ol><h2 id="5、-执行顺序与优先级"><a href="#5、-执行顺序与优先级" class="headerlink" title="5、 执行顺序与优先级"></a>5、 执行顺序与优先级</h2><ol><li><code>BeanDefinitionRegistryPostProcessor</code> → <code>BeanFactoryPostProcessor</code></li><li><code>PriorityOrdered</code> → <code>Ordered</code> → 无优先级接口（通过 <code>@Order</code> 或 <code>Ordered</code> 实现控制）。</li></ol><h2 id="6、-实战场景"><a href="#6、-实战场景" class="headerlink" title="6、 实战场景"></a>6、 实战场景</h2><ul><li><strong>自定义后处理器</strong>：实现动态代理（如日志增强）、条件化 Bean 注入。</li><li><strong>框架整合</strong>：MyBatis 通过 <code>MapperScannerConfigurer</code>（<code>BeanDefinitionRegistryPostProcessor</code> 实现）扫描 Mapper 接口。</li><li><strong>性能优化</strong>：避免在 <code>BeanPostProcessor</code> 中执行耗时操作，防止启动瓶颈。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 事务详解</title>
      <link href="/2024/09/15/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/15/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20%E4%BA%8B%E5%8A%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-事务详解"><a href="#Spring-事务详解" class="headerlink" title="Spring 事务详解"></a>Spring 事务详解</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>相信大家应该都能背上面这句话了，下面我结合我们日常的真实开发来谈一谈。</p><p>我们系统的每个业务方法可能包括了多个原子性的数据库操作，比如下面的 <code>savePerson()</code> 方法中就有两个原子性的数据库操作。这些原子性的数据库操作是有依赖的，它们要么都执行，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">savePerson</span><span class="params">()</span> &#123;</span><br><span class="line">    personDao.save(person);</span><br><span class="line">    personDetailDao.save(personDetail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要格外注意的是：<strong>事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 <code>innodb</code>引擎。但是，如果把数据库引擎变为 <code>myisam</code>，那么程序也就不再支持事务了！</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：</p><blockquote><ol><li>将小明的余额减少 1000 元。</li><li>将小红的余额增加 1000 元。</li></ol></blockquote><p>万一在这两个操作之间突然出现错误比如银行系统崩溃或者网络故障，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250304003052531.png" alt="image-20250304003052531"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrdersService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrdersDao</span><span class="params">(AccountDao accountDao)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.accountDao = accountDao;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Transactional(propagation = Propagation.REQUIRED,</span></span><br><span class="line"><span class="meta">                isolation = Isolation.DEFAULT, readOnly = false, timeout = -1)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accountMoney</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//小红账户多1000</span></span><br><span class="line">    accountDao.addMoney(<span class="number">1000</span>,xiaohong);</span><br><span class="line">    <span class="comment">//模拟突然出现的异常，比如银行中可能为突然停电等等</span></span><br><span class="line">    <span class="comment">//如果没有配置事务管理的话会造成，小红账户多了1000而小明账户没有少钱</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//小王账户少1000</span></span><br><span class="line">    accountDao.reduceMoney(<span class="number">1000</span>,xiaoming);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务特性回顾"><a href="#事务特性回顾" class="headerlink" title="事务特性回顾"></a>事务特性回顾</h3><ul><li><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><h2 id="Spring-事务实现方式"><a href="#Spring-事务实现方式" class="headerlink" title="Spring 事务实现方式"></a>Spring 事务实现方式</h2><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><p>通过 <code>TransactionTemplate</code>或者<code>TransactionManager</code>手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</p><p>使用<code>TransactionTemplate</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// ....  业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>TransactionManager</code> 进行编程式事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ....  业务代码</span></span><br><span class="line">        transactionManager.commit(status);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">transactionManager.rollback(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）。</p><p>使用 <code>@Transactional</code>注解进行事务管理的示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> aMethod &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">C</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">    b.bMethod();</span><br><span class="line">    c.cMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-事务管理接口介绍"><a href="#Spring-事务管理接口介绍" class="headerlink" title="Spring 事务管理接口介绍"></a>Spring 事务管理接口介绍</h2><p>Spring 框架中，事务管理相关最重要的 3 个接口如下：</p><ul><li><code>PlatformTransactionManager</code>：（平台）事务管理器，Spring 事务策略的核心。</li><li><code>TransactionDefinition</code>：事务定义信息(事务隔离级别、传播行为、超时、只读、回滚规则)。</li><li><code>TransactionStatus</code>：事务运行状态。</li></ul><p>我们可以把 <code>PlatformTransactionManager</code> 接口可以被看作是事务上层的管理者，而 <code>TransactionDefinition</code> 和 <code>TransactionStatus</code> 这两个接口可以看作是事务的描述。</p><p><code>PlatformTransactionManager</code> 会根据 <code>TransactionDefinition</code> 的定义比如事务超时时间、隔离级别、传播行为等来进行事务管理 ，而 <code>TransactionStatus</code> 接口则提供了一些方法来获取事务相应的状态比如是否新事务、是否可以回滚等等。</p><h3 id="PlatformTransactionManager-事务管理接口"><a href="#PlatformTransactionManager-事务管理接口" class="headerlink" title="PlatformTransactionManager:事务管理接口"></a>PlatformTransactionManager:事务管理接口</h3><p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。Spring 事务管理器的接口是：<code>PlatformTransactionManager</code> 。</p><p>通过这个接口，Spring 为各个平台如：JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p><p><code>PlatformTransactionManager</code> 接口的具体实现如下:<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/PlatformTransactionManager-Sss6sitn.png" alt="img"></p><p><code>PlatformTransactionManager</code>接口中定义了三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> &#123;</span><br><span class="line">    <span class="comment">//获得事务</span></span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里多插一嘴。为什么要定义或者说抽象出来<code>PlatformTransactionManager</code>这个接口呢？</strong></p><p>主要是因为要将事务管理行为抽象出来，然后不同的平台去实现它，这样我们可以保证提供给外部的行为不变，方便我们扩展。</p><p>事务管理器接口 <strong><code>PlatformTransactionManager</code></strong> 通过 <strong><code>getTransaction(TransactionDefinition definition)</code></strong> 方法来得到一个事务，这个方法里面的参数是 <strong><code>TransactionDefinition</code></strong> 类 ，这个类就定义了一些基本的事务属性。</p><h3 id="TransactionDefinition-事务属性"><a href="#TransactionDefinition-事务属性" class="headerlink" title="TransactionDefinition:事务属性"></a>TransactionDefinition:事务属性</h3><p><strong>什么是事务属性呢？</strong> 事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。</p><p>事务属性包含了 5 个方面：</p><ul><li>隔离级别</li><li>传播行为</li><li>回滚规则</li><li>是否只读</li><li>事务超时</li></ul><p><code>TransactionDefinition</code> 接口中定义了 5 个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回事务的传播行为，默认值为 REQUIRED。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//返回事务的隔离级别，默认值是 DEFAULT</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 返回是否为只读事务，默认值为 false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TransactionStatus-事务状态"><a href="#TransactionStatus-事务状态" class="headerlink" title="TransactionStatus:事务状态"></a>TransactionStatus:事务状态</h3><p><code>TransactionStatus</code>接口用来记录事务的状态 该接口定义了一组方法,用来获取或判断事务的相应状态信息。</p><p><code>PlatformTransactionManager.getTransaction(…)</code>方法返回一个 <code>TransactionStatus</code> 对象。</p><p><strong>TransactionStatus 接口内容如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNewTransaction</span><span class="params">()</span>; <span class="comment">// 是否是新的事务</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>; <span class="comment">// 是否有恢复点</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setRollbackOnly</span><span class="params">()</span>;  <span class="comment">// 设置为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isRollbackOnly</span><span class="params">()</span>; <span class="comment">// 是否为只回滚</span></span><br><span class="line">    <span class="type">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务属性详解"><a href="#事务属性详解" class="headerlink" title="事务属性详解"></a>事务属性详解</h2><p>实际业务开发中，大家一般都是使用 <code>@Transactional</code> 注解来开启事务，很多人并不清楚这个注解里面的参数是什么意思，有什么用。为了更好的在项目中使用事务管理，强烈推荐好好阅读一下下面的内容。</p><h3 id="7-个事务传播行为"><a href="#7-个事务传播行为" class="headerlink" title="7 个事务传播行为"></a>7 个事务传播行为</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><ul><li><strong>PROPAGATION_REQUIRED</strong> – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</li><li><strong>PROPAGATION_SUPPORTS</strong> – 支持当前事务，如果当前没有事务，就以非事务方式执行。</li><li><strong>PROPAGATION_MANDATORY</strong> – 支持当前事务，如果当前没有事务，就抛出异常。</li><li><strong>PROPAGATION_REQUIRES_NEW</strong> – 新建事务，如果当前存在事务，把当前事务挂起。</li><li><strong>PROPAGATION_NOT_SUPPORTED</strong> – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li><strong>PROPAGATION_NEVER</strong> – 以非事务方式执行，如果当前存在事务，则抛出异常。</li><li><strong>PROPAGATION_NESTED</strong> – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</li></ul><h3 id="5-个隔离级别"><a href="#5-个隔离级别" class="headerlink" title="5 个隔离级别"></a>5 个隔离级别</h3><h4 id="ISOLATION-DEFAULT"><a href="#ISOLATION-DEFAULT" class="headerlink" title="ISOLATION_DEFAULT"></a><strong>ISOLATION_DEFAULT</strong></h4><p>这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.</p><p>另外四个与JDBC的隔离级别相对应；</p><h4 id="ISOLATION-READ-UNCOMMITTED"><a href="#ISOLATION-READ-UNCOMMITTED" class="headerlink" title="ISOLATION_READ_UNCOMMITTED"></a>ISOLATION_READ_UNCOMMITTED</h4><p>这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。<br>这种隔离级别会产生脏读，不可重复读和幻像读。</p><h4 id="ISOLATION-READ-COMMITTED"><a href="#ISOLATION-READ-COMMITTED" class="headerlink" title="ISOLATION_READ_COMMITTED"></a>ISOLATION_READ_COMMITTED</h4><p>保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<br>这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。</p><h4 id="ISOLATION-REPEATABLE-READ"><a href="#ISOLATION-REPEATABLE-READ" class="headerlink" title="ISOLATION_REPEATABLE_READ"></a>ISOLATION_REPEATABLE_READ</h4><p>这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。<br>它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p><h4 id="ISOLATION-SERIALIZABLE"><a href="#ISOLATION-SERIALIZABLE" class="headerlink" title="ISOLATION_SERIALIZABLE"></a>ISOLATION_SERIALIZABLE</h4><p>这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。<br>除了防止脏读，不可重复读外，还避免了幻像读。</p><h3 id="事务超时时间"><a href="#事务超时时间" class="headerlink" title="事务超时时间"></a>事务超时时间</h3><p>所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 <code>TransactionDefinition</code> 中以 int 的值来表示超时时间，其单位是秒，默认值为-1，这表示事务的超时时间取决于底层事务系统或者没有超时时间</p><h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><ul><li><p><strong>默认回滚规则</strong></p><ul><li>默认情况下，Spring 事务会在运行时异常（<code>RuntimeException</code>）时自动回滚，而在受检查的异常（<code>Exception</code>）时则不会</li></ul></li><li><p><strong>自定义回滚规则</strong></p><ul><li><p>可以通过 <code>@Transactional</code> 注解的 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性自定义回滚规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="事务只读属性"><a href="#事务只读属性" class="headerlink" title="事务只读属性"></a>事务只读属性</h3><p>这里的只读是对开发者的提示，并不意味着你标注只读就真的不能写更新语句。实际上你更新，出错后回滚等功能都还是正常的。甚至该标注也支持 SUPPORTS 传播规则，说明即使没有开启事务也无妨。</p><p>我们可以看原文注释</p><blockquote><p>This just serves as a hint for the actual transaction subsystem; it will not necessarily cause failure of write access attempts.A transaction manager which cannot interpret the read-only hint will not throw an exception when asked for a read-only transaction.return<br>这只是作为实际事务子系统的提示，它不一定会导致写访问尝试失败。不能理解只读提示的事务管理器在请求只读事务时也不会抛出异常</p></blockquote><h2 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h2><h3 id="异常类型不匹配"><a href="#异常类型不匹配" class="headerlink" title="异常类型不匹配"></a>异常类型不匹配</h3><ul><li><p>默认情况下，Spring 事务仅对 <code>RuntimeException</code> 和 <code>Error</code> 类型的异常进行回滚。</p></li><li><p>如果抛出的是其他类型的异常（如 <code>Exception</code> 或自定义异常），事务不会自动回滚。</p></li><li><p><strong>解决方案</strong>：在 <code>@Transactional</code> 注解中明确指定回滚异常类型，例如：</p><p>java复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="异常被捕获"><a href="#异常被捕获" class="headerlink" title="异常被捕获"></a>异常被捕获</h3><ul><li>如果事务方法内部捕获了异常，而没有重新抛出，Spring 事务管理器无法感知异常，事务不会回滚。</li><li><strong>解决方案</strong>：在捕获异常后，重新抛出异常，或者直接让异常向上抛出。</li></ul><h3 id="方法内部直接调用"><a href="#方法内部直接调用" class="headerlink" title="方法内部直接调用"></a>方法内部直接调用</h3><ul><li>在同一个类中，事务方法被内部其他方法调用时，事务不会生效。</li><li><strong>原因</strong>：Spring 事务是通过动态代理实现的，只有通过代理调用的方法才会被事务管理器拦截。</li><li><strong>解决方案</strong>：避免在同一个类内部直接调用事务方法，或者通过代理对象调用。</li></ul><h3 id="方法修饰符非-public"><a href="#方法修饰符非-public" class="headerlink" title="方法修饰符非 public"></a>方法修饰符非 public</h3><ul><li><code>@Transactional</code> 注解只能作用于 <code>public</code> 方法上。</li><li>如果方法被 <code>private</code> 或 <code>protected</code> 修饰，事务不会生效。</li><li><strong>解决方案</strong>：将方法的访问修饰符改为 <code>public</code>。</li></ul><h3 id="使用了错误的事务传播机制"><a href="#使用了错误的事务传播机制" class="headerlink" title="使用了错误的事务传播机制"></a>使用了错误的事务传播机制</h3><ul><li>如果错误地设置了事务传播行为（如 <code>Propagation.NEVER</code>），事务可能不会按预期执行。</li><li><strong>解决方案</strong>：根据业务需求选择正确的事务传播行为。</li></ul><h3 id="当前类没有被-Spring-容器托管"><a href="#当前类没有被-Spring-容器托管" class="headerlink" title="当前类没有被 Spring 容器托管"></a>当前类没有被 Spring 容器托管</h3><ul><li>如果类没有被 Spring 管理（例如缺少 <code>@Service</code> 或 <code>@Component</code> 注解），事务注解不会生效。</li><li><strong>解决方案</strong>：确保类被 Spring 容器管理。</li></ul><h3 id="数据库不支持事务"><a href="#数据库不支持事务" class="headerlink" title="数据库不支持事务"></a>数据库不支持事务</h3><ul><li>如果底层数据库不支持事务（如某些数据库引擎），Spring 事务也会失效。</li><li><strong>解决方案</strong>：确保使用的数据库支持事务。</li></ul><h3 id="多线程调用"><a href="#多线程调用" class="headerlink" title="多线程调用"></a>多线程调用</h3><ul><li>在多线程环境下，事务可能失效。</li><li><strong>原因</strong>：Spring 事务是基于线程绑定的，多线程环境下可能导致事务上下文不一致。</li><li><strong>解决方案</strong>：尽量避免在事务方法中启动新线程，或者使用分布式事务解决方案。</li></ul><h3 id="未配置事务管理器"><a href="#未配置事务管理器" class="headerlink" title="未配置事务管理器"></a>未配置事务管理器</h3><ul><li>如果项目中没有正确配置事务管理器，事务注解不会生效。</li><li><strong>解决方案</strong>：确保在 Spring 配置中正确配置了事务管理器。</li></ul><h3 id="事务注解被覆盖"><a href="#事务注解被覆盖" class="headerlink" title="事务注解被覆盖"></a>事务注解被覆盖</h3><ul><li>在继承或重写方法时，可能会覆盖事务注解的行为。</li><li><strong>解决方案</strong>：确保父类和子类的事务注解配置一致，或者避免在子类中覆盖父类的事务方法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器核心设计总结</title>
      <link href="/2024/09/14/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20IOC%20%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%20/"/>
      <url>/2024/09/14/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20IOC%20%E5%AE%B9%E5%99%A8%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93%20/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IOC-容器启动流程概述及核心机制关联"><a href="#Spring-IOC-容器启动流程概述及核心机制关联" class="headerlink" title="Spring IOC 容器启动流程概述及核心机制关联"></a>Spring IOC 容器启动流程概述及核心机制关联</h1><h2 id="一、顶层流程概述"><a href="#一、顶层流程概述" class="headerlink" title="一、顶层流程概述"></a>一、顶层流程概述</h2><p>Spring IOC 容器启动的核心流程可概括为以下步骤：</p><ol><li><strong>容器初始化</strong>：创建 <code>BeanFactory</code>（默认 <code>DefaultListableBeanFactory</code>）和 <code>ApplicationContext</code>（如 <code>AnnotationConfigApplicationContext</code>）。</li><li><strong>配置加载</strong>：读取配置文件（XML&#x2F;注解&#x2F;Java Config）并解析为 <code>BeanDefinition</code>。</li><li><strong>Bean定义注册</strong>：将 <code>BeanDefinition</code> 注册到 <code>BeanFactory</code> 的 <code>BeanDefinitionRegistry</code>。</li><li><strong>扩展点处理</strong>：调用 <code>BeanFactoryPostProcessor</code> 修改或增强 <code>BeanDefinition</code>。</li><li><strong>Bean实例化</strong>：通过反射或工厂方法创建 Bean 实例，处理依赖注入（DI）和自动装配。</li><li><strong>生命周期回调</strong>：执行初始化方法（如 <code>@PostConstruct</code>、<code>InitializingBean</code>）。</li><li><strong>容器就绪</strong>：完成所有单例 Bean 的预实例化，发布 <code>ContextRefreshedEvent</code> 事件。</li></ol><h2 id="二、核心流程拓展与底层机制"><a href="#二、核心流程拓展与底层机制" class="headerlink" title="二、核心流程拓展与底层机制"></a>二、核心流程拓展与底层机制</h2><h3 id="1-容器初始化与配置加载"><a href="#1-容器初始化与配置加载" class="headerlink" title="1. 容器初始化与配置加载"></a><strong>1. 容器初始化与配置加载</strong></h3><ul><li><p><strong><code>ApplicationContext</code> vs <code>BeanFactory</code></strong><br><code>ApplicationContext</code> 是高级容器，继承 <code>BeanFactory</code> 并整合了资源加载、事件发布、AOP 等功能。启动时自动调用 <code>refresh()</code> 方法触发完整流程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 示例：AnnotationConfigApplicationContext 初始化</span><br><span class="line">ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);</span><br></pre></td></tr></table></figure></li><li><p><strong><code>BeanDefinition</code> 加载与注册</strong></p><ul><li><strong>解析器</strong>：如 <code>ClassPathBeanDefinitionScanner</code>（扫描 <code>@Component</code>）或 <code>XmlBeanDefinitionReader</code>（解析 XML）。</li><li><strong>注册</strong>：<code>BeanDefinition</code> 存储于 <code>BeanFactory</code> 的 <code>beanDefinitionMap</code>，包含 Bean 的元数据（类名、作用域、属性等）。</li></ul></li></ul><h3 id="2-扩展点：BeanFactoryPostProcessor"><a href="#2-扩展点：BeanFactoryPostProcessor" class="headerlink" title="2. 扩展点：BeanFactoryPostProcessor"></a><strong>2. 扩展点：BeanFactoryPostProcessor</strong></h3><ul><li><strong>作用阶段</strong>：在 <code>BeanDefinition</code> 注册后、Bean 实例化前执行。</li><li><strong>典型应用</strong>：<ul><li><code>PropertySourcesPlaceholderConfigurer</code>：解析 <code>$&#123;&#125;</code> 占位符。</li><li><code>ConfigurationClassPostProcessor</code>：处理 <code>@Configuration</code> 类，解析 <code>@Bean</code> 方法。</li></ul></li></ul><h3 id="3-Bean-实例化与依赖注入"><a href="#3-Bean-实例化与依赖注入" class="headerlink" title="3. Bean 实例化与依赖注入"></a><strong>3. Bean 实例化与依赖注入</strong></h3><h4 id="实例化策略："><a href="#实例化策略：" class="headerlink" title="实例化策略："></a><strong>实例化策略</strong>：</h4><ul><li>通过反射调用构造函数或工厂方法。</li></ul><h4 id="自动装配（Autowiring）："><a href="#自动装配（Autowiring）：" class="headerlink" title="自动装配（Autowiring）："></a><strong>自动装配（Autowiring）</strong>：</h4><ul><li><strong>模式</strong>：<code>byType</code>、<code>byName</code>、<code>constructor</code>。</li><li><strong>注解驱动</strong>：<code>@Autowired</code>（按类型）、<code>@Resource</code>（按名称）等。</li></ul><h4 id="三级缓存解决循环依赖："><a href="#三级缓存解决循环依赖：" class="headerlink" title="三级缓存解决循环依赖："></a><strong>三级缓存解决循环依赖</strong>：</h4><ul><li><p><strong>一级缓存（<code>singletonObjects</code>）</strong></p><ul><li><strong>作用</strong>：存储完全初始化完成的单例Bean实例。</li><li><strong>数据结构</strong>：<code>ConcurrentHashMap&lt;String, Object&gt;</code>。</li><li><strong>说明</strong>：当Bean完成所有依赖注入和初始化后，会被放入一级缓存，供其他Bean引用。</li></ul></li><li><p><strong>二级缓存（<code>earlySingletonObjects</code>）</strong></p><ul><li><strong>作用</strong>：存储早期暴露的单例Bean实例，即已实例化但尚未完全初始化的Bean。</li><li><strong>数据结构</strong>：<code>ConcurrentHashMap&lt;String, Object&gt;</code>。</li><li><strong>说明</strong>：在Bean初始化过程中，如果需要提前暴露Bean以解决循环依赖，Spring会将Bean放入二级缓存。</li></ul></li><li><p><strong>三级缓存（<code>singletonFactories</code>）</strong></p><ul><li><strong>作用</strong>：存储创建Bean实例的工厂对象（<code>ObjectFactory</code>），用于延迟创建代理对象。</li><li><strong>数据结构</strong>：<code>ConcurrentHashMap&lt;String, ObjectFactory&lt;?&gt;&gt;</code>。</li><li><strong>说明</strong>：当Bean需要进行AOP代理时，Spring会将<code>ObjectFactory</code>放入三级缓存。通过<code>ObjectFactory</code>，Spring可以在需要时动态创建Bean的代理实例。</li></ul></li></ul><h5 id="【Q】-为什么需要三级缓存"><a href="#【Q】-为什么需要三级缓存" class="headerlink" title="【Q】 为什么需要三级缓存"></a><strong>【Q】 为什么需要三级缓存</strong></h5><blockquote><p>理论上，两级缓存（一级缓存 + 二级缓存）可以解决循环依赖问题，但无法灵活处理代理对象的创建。</p><p>三级缓存通过引入<code>ObjectFactory</code>，提供了更灵活的解决方案，能够同时处理循环依赖和AOP代理</p></blockquote><h3 id="4-生命周期管理"><a href="#4-生命周期管理" class="headerlink" title="4. 生命周期管理"></a><strong>4. 生命周期管理</strong></h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/0fc09f32cde5336385817e3d3113b9b3.jpeg" alt="img"></p><ol><li><strong>实例化</strong>：<ul><li>Spring容器通过反射创建Bean实例。</li></ul></li><li><strong>依赖注入</strong>：<ul><li>调用<code>setBeanFactory</code>方法（若Bean实现了<code>BeanFactoryAware</code>接口）。</li><li>调用<code>setApplicationContext</code>方法（若Bean实现了<code>ApplicationContextAware</code>接口）。</li><li>调用<code>setBeanName</code>方法（若Bean实现了<code>BeanNameAware</code>接口）。</li><li>注入依赖（通过构造器注入或setter注入）。</li></ul></li><li><strong>BeanPostProcessor前置处理</strong>：<ul><li>调用<code>postProcessBeforeInitialization</code>方法（若Bean实现了<code>BeanPostProcessor</code>接口）。</li></ul></li><li><strong>初始化</strong>：<ul><li>调用<code>afterPropertiesSet</code>方法（若Bean实现了<code>InitializingBean</code>接口）。</li><li>调用<code>@PostConstruct</code>注解的方法（若存在）。</li></ul></li><li><strong>BeanPostProcessor后置处理</strong>：<ul><li>调用<code>postProcessAfterInitialization</code>方法（若Bean实现了<code>BeanPostProcessor</code>接口）。</li></ul></li><li><strong>使用</strong>：<ul><li>Bean被应用程序使用。</li></ul></li><li><strong>销毁</strong>：<ul><li>调用<code>@PreDestroy</code>注解的方法（若存在）。</li><li>调用<code>destroy</code>方法（若Bean实现了<code>DisposableBean</code>接口）。</li><li>调用<code>destroy</code>方法（如果在Bean定义中配置了<code>destroy-method</code>属性）。</li></ul></li></ol><h3 id="5-条件装配（Conditional）"><a href="#5-条件装配（Conditional）" class="headerlink" title="5. 条件装配（Conditional）"></a><strong>5. 条件装配（Conditional）</strong></h3><ul><li><strong><code>@Conditional</code> 注解</strong>：根据条件动态注册 Bean。</li><li><strong>实现机制</strong>：<ul><li>通过 <code>Condition</code> 接口的 <code>matches()</code> 方法判断条件是否满足。</li><li>应用场景：Profile（<code>@Profile</code>）、条件化配置（如根据类是否存在启用功能）。</li></ul></li></ul><h3 id="6-事件机制"><a href="#6-事件机制" class="headerlink" title="6. 事件机制"></a><strong>6. 事件机制</strong></h3><ul><li>**<code>ApplicationEvent</code> 与 <code>ApplicationListener</code>**：<ul><li>内置事件：<code>ContextRefreshedEvent</code>（容器刷新完成）、<code>ContextClosedEvent</code>（容器关闭）。</li><li>自定义事件：继承 <code>ApplicationEvent</code>，通过 <code>ApplicationContext#publishEvent()</code> 发布。</li></ul></li></ul><h2 id="三、流程与机制的关联性"><a href="#三、流程与机制的关联性" class="headerlink" title="三、流程与机制的关联性"></a>三、流程与机制的关联性</h2><ul><li><strong>设计目标</strong>：IOC 容器通过分层处理（配置解析 → 定义增强 → 实例化 → 依赖注入 → 生命周期）实现解耦与扩展。</li><li><strong>扩展性</strong>：<ul><li><strong>后处理器</strong>（<code>BeanFactoryPostProcessor</code>、<code>BeanPostProcessor</code>）提供“插拔式”扩展能力。</li><li><strong>三级缓存</strong>在保证单例唯一性的同时，解决循环依赖问题。</li></ul></li><li><strong>灵活性</strong>：<ul><li><strong>条件装配</strong>允许动态控制 Bean 的注册。</li><li><strong>事件机制</strong>支持容器状态变化的监听与响应。</li></ul></li></ul><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>Spring IOC 容器的启动流程通过分层设计与扩展点机制，将配置加载、Bean 管理、依赖注入等职责解耦。核心机制（如三级缓存、后处理器）在解决循环依赖、支持 AOP 等场景中发挥关键作用，而条件装配和事件机制进一步增强了容器的灵活性和可观测性。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC 容器启动源码分析</title>
      <link href="/2024/09/14/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20IOC%20%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81/"/>
      <url>/2024/09/14/%E6%A1%86%E6%9E%B6/Spring%20Family/Spring%20IOC%20%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-IOC-容器启动源码分析"><a href="#Spring-IOC-容器启动源码分析" class="headerlink" title="Spring IOC 容器启动源码分析"></a>Spring IOC 容器启动源码分析</h1><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>话不多说， 直接从代码着手</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.leon.funddatahouse&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们基于注解的方式</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">annotationConfigApplicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(Config.class);</span><br><span class="line">        <span class="comment">// 如果基于XML文件配置，则也可以如下：</span></span><br><span class="line">        <span class="comment">// ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(&quot;spring-context.xml&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在构造方法中，总共做了3件事情。这三件事情包括了整个Spring容器启动的所有过程！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.调用默认构造方法，进行容器环境的准备</span></span><br><span class="line">    <span class="built_in">this</span>();</span><br><span class="line">    <span class="comment">// 2.基于配置类注册相关信息</span></span><br><span class="line">    register(componentClasses);</span><br><span class="line">    <span class="comment">// 3.刷新整个容器</span></span><br><span class="line">    refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1.实例化容器中的reader. 后面会详细解析</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 2.实例化容器中的scanner.后面会详细解析</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>乍看一眼，这个无参构造方法做了两件事情，其实不然。它实际上等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotationConfigApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 1.调用父类构造方法</span></span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="comment">// 2.实例化容器中的reader. 后面会详细解析</span></span><br><span class="line">    <span class="built_in">this</span>.reader = <span class="keyword">new</span> <span class="title class_">AnnotatedBeanDefinitionReader</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">// 3.实例化容器中的scanner.后面会详细解析</span></span><br><span class="line">    <span class="built_in">this</span>.scanner = <span class="keyword">new</span> <span class="title class_">ClassPathBeanDefinitionScanner</span>(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一点很关键, 如果没有意识到<strong>这里隐形调用了父类构造方法</strong>的话, 那么接下来的路没法走, 因为在父类构造器中做了一件大事情:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在父类的构造方法中, 创建了容器中的BeanFactory.至此,容器中有了第一个程序创建的属性:beanFactory</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">GenericApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化容器的beanFactory，类型为DefaultListableBeanFactory</span></span><br><span class="line">    <span class="built_in">this</span>.beanFactory = <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>reader最主要的目的是用于辅助注册BeanDefinition，其具体的使用后文在介绍，这里我们只需知道它包含了哪些东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参registry就是容器本身。因为通过上面的UML类图可以发现,容器间接继承了BeanDefinitionRegistry</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// getOrCreateEnvironment() 方法最主要是获取环境。实际类型其实默认的就是StandardEnvironment类。这里的环境包括两方面：</span></span><br><span class="line">    <span class="comment">// 1.systemEnvironment：操作系统环境。这样，Spring就可以获取到操作系统、CPU核心数等操作系统本身的数据。</span></span><br><span class="line">    <span class="comment">// 2.systemProperties：JVM的环境变量。这样，Spring就可以获取到JVM的基础数据，比如我们在启动参数中手动设置的环境变量等。</span></span><br><span class="line">    <span class="built_in">this</span>(registry, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<strong>this()</strong> 调用了reader内部另一个构造方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AnnotatedBeanDefinitionReader</span><span class="params">(BeanDefinitionRegistry registry, Environment environment)</span> &#123;</span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    Assert.notNull(environment, <span class="string">&quot;Environment must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置registry，已经知道它的就是容器本身:AnnotationConfigApplicationContext</span></span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="comment">// 创建条件处理器</span></span><br><span class="line">    <span class="built_in">this</span>.conditionEvaluator = <span class="keyword">new</span> <span class="title class_">ConditionEvaluator</span>(registry, environment, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 非常关键！ 提前往容器中注册一些必要的后置处理器</span></span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造方法很重要, 因为它涉及到 spring 容器当中的两个重要成员: <strong>条件解析器</strong>和 <strong>后置处理器</strong>!</p><h4 id="实例化条件解析器"><a href="#实例化条件解析器" class="headerlink" title="实例化条件解析器"></a>实例化条件解析器</h4><p>熟悉Spring的人一定都知道或用过<code>@ConditionalOnBean</code> &#x2F; <code>@ConditionalOnClass</code> 等条件注解.而这些条件注解的解析就是<code>ConditionEvaluator</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConditionEvaluator</span><span class="params">(<span class="meta">@Nullable</span> BeanDefinitionRegistry registry,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 实际上是委托给内部类ConditionContextImpl</span></span><br><span class="line">    <span class="built_in">this</span>.context = <span class="keyword">new</span> <span class="title class_">ConditionContextImpl</span>(registry, environment, resourceLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ------------分割线------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部的ConditionContextImpl构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConditionContextImpl</span><span class="params">(<span class="meta">@Nullable</span> BeanDefinitionRegistry registry,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line">    <span class="comment">// 再说一遍，registry的实际类型就是 AnnotationConfigApplicationCont</span></span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="comment">// 获取beanFactory，我们也知道了beanFactory其实就是 ConfigurableListableBeanFactory</span></span><br><span class="line">    <span class="built_in">this</span>.beanFactory = deduceBeanFactory(registry);</span><br><span class="line">    <span class="comment">// 从容器中获取environment，前面介绍过，容器中的environment的封装类是 StandardEnvironment</span></span><br><span class="line">    <span class="built_in">this</span>.environment = (environment != <span class="literal">null</span> ? environment : deduceEnvironment(registry));</span><br><span class="line">    <span class="comment">// 资源加载器. 通过UML类图可以发现,resourceLoader就是容器, 因为容器间接继承了ResourceLoader</span></span><br><span class="line">    <span class="built_in">this</span>.resourceLoader = (resourceLoader != <span class="literal">null</span> ? resourceLoader : deduceResourceLoader(registry));</span><br><span class="line">    <span class="comment">// 类加载器. 实际上就是获取beanFactory的类加载器。理应如此，容器当中的类加载器肯定要一致才行</span></span><br><span class="line">    <span class="built_in">this</span>.classLoader = deduceClassLoader(resourceLoader, <span class="built_in">this</span>.beanFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面在解析<code>BeanDefinition</code>时我们还会遇到<code>ConditionEvaluator</code>, 其具体源码解析会用专门的文章来解析,本篇文章我们只需要知道它的作用即可</p><h4 id="注册一部分后置处理器"><a href="#注册一部分后置处理器" class="headerlink" title="注册一部分后置处理器"></a>注册一部分后置处理器</h4><p><code>ConditionEvaluator</code>初始化完成之后，接下来就特别重要了，因为在这里将提前注入一些后置处理器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 空壳方法，实际委托给重载的方法</span></span><br><span class="line">    registerAnnotationConfigProcessors(registry, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重载的方法如下(<strong>高能预警</strong>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title function_">registerAnnotationConfigProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取容器中的beanFactory，通过前面的解析，我们知道，这里一定会获取到。因此将进入if分支</span></span><br><span class="line">    <span class="type">DefaultListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 此时beanFactory的属性dependencyComparator为null，因为初始化过程中，内部成员变量如果没有默认值，则默认为null，</span></span><br><span class="line">        <span class="comment">// 所以如果第一次进来, 这里的判断一定成立，对dependencyComparator进行设置。</span></span><br><span class="line">        <span class="comment">// AnnotationAwareOrderComparator继承了OrderComparator,</span></span><br><span class="line">        <span class="comment">// 因此可以对实现了Ordered接口、打上@Order或者@Priority注解的类进行排序。</span></span><br><span class="line">        <span class="comment">// 也就是说，在这里设置beanFactory中的orderComparator，以支持解析bean的排序功能。</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// beanFactory初始化时，默认为SimpleAutowireCandidateResolver，因此第一次进来时这里的判断也一定成立。</span></span><br><span class="line">        <span class="comment">// ContextAnnotationAutowireCandidateResolver最主要的作用就是支持@Lazy注解的类的处理。</span></span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> <span class="title class_">ContextAnnotationAutowireCandidateResolver</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个bdh容器，用于盛放接下来将解析出来的后置处理器的bd。</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 容器在第一次初始化时，内部一个bd都没有的。</span></span><br><span class="line">    <span class="comment">// 也就是说，从这里开始，容器将第一次装载bd，而这里的这些bd都是spring自带的后置处理器。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册ConfigurationClassPostProcessor后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册AutowiredAnnotationBeanPostProcessor后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册CommonAnnotationBeanPostProcessor后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册PersistenceAnnotationBeanPostProcessor后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                    AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(</span><br><span class="line">                    <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册EventListenerMethodProcessor后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并注册DefaultEventListenerFactory后置处理器 的bd</span></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        <span class="type">RootBeanDefinition</span> <span class="variable">def</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首次出现了 BeanDefinition 这个类. Spring 的 BeanDefinition 相当于Java的Class</p><p>通过该方法之后, beanFactory中就存在了 5 个后处理器的bd：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250303224136667.png" alt="image-20250303224136667"></p><p>后处理器是 IOC 的核心组件之一， 掌握了 Spring 的后置处理器， 整个 Spring 至少就掌握了 10%!<br>但是在这里先不展开后置处理器(太多了)，本篇文章的主线是容器启动过程。</p><h4 id="reader初始化过程小结"><a href="#reader初始化过程小结" class="headerlink" title="reader初始化过程小结"></a><code>reader</code>初始化过程小结</h4><p>到这里reader部分的初始化终于完成了。总结一下，reader的初始化主要干了这些事情：<br> 1.创建并设置容器当中的Environment属性。即默认为StandardEnvironment类。<br> 2.创建并设置容器当中的条件解析器,即 <code>ConditionEvaluator</code>，其内部实际委托给内部类 <code>ConditionContextImpl</code>。</p><h3 id="实例化-Scanner"><a href="#实例化-Scanner" class="headerlink" title="实例化 Scanner"></a>实例化 <code>Scanner</code></h3><p>解析完reader之后，继续解析scanner。这里的scanner的实际类型是ClassPathBeanDefinitionScanner。它最主要的目的就是扫描类路径下所有的class文件能否解析为bd。 其最终调用的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">// 1.委托给内部的另一个构造方法</span></span><br><span class="line">    <span class="built_in">this</span>(registry, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------分割线-------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters)</span> &#123;</span><br><span class="line"><span class="comment">// 2.又委托给内部的另一个构造方法 </span></span><br><span class="line">    <span class="comment">// 从上面的入参可以知道 入参的registry实际就是容器本身, 并使用默认的filter.这个filter干什么的,下面会解析</span></span><br><span class="line">    <span class="built_in">this</span>(registry, useDefaultFilters, getOrCreateEnvironment(registry));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------分割线-------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">        Environment environment)</span> &#123;</span><br><span class="line">    <span class="comment">// 3.又委托给内部的另一个构造方法 </span></span><br><span class="line">    <span class="built_in">this</span>(registry, useDefaultFilters, environment,</span><br><span class="line">            (registry <span class="keyword">instanceof</span> ResourceLoader ? (ResourceLoader) registry : <span class="literal">null</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------分割线-------------------------</span></span><br><span class="line"><span class="comment">// 4. 终于见到了庐山真面目</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathBeanDefinitionScanner</span><span class="params">(BeanDefinitionRegistry registry, <span class="type">boolean</span> useDefaultFilters,</span></span><br><span class="line"><span class="params">        Environment environment, <span class="meta">@Nullable</span> ResourceLoader resourceLoader)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(registry, <span class="string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);</span><br><span class="line">    <span class="comment">// 再说一遍, registry就是容器!</span></span><br><span class="line">    <span class="built_in">this</span>.registry = registry;</span><br><span class="line">    <span class="comment">// 重要!!! 是否包括默认过滤器。从上面的入参可以知道, 这里的useDefaultFilters = true，因此会进入if分支</span></span><br><span class="line">    <span class="keyword">if</span> (useDefaultFilters) &#123;</span><br><span class="line">        registerDefaultFilters();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置环境变量</span></span><br><span class="line">    setEnvironment(environment);</span><br><span class="line">    <span class="comment">// 设置资源加载器</span></span><br><span class="line">    setResourceLoader(resourceLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="registerDefaultFilters"><a href="#registerDefaultFilters" class="headerlink" title="registerDefaultFilters()"></a><code>registerDefaultFilters()</code></h4><p>从最终的构造方法我们知道, Scanner在扫描的过程中,会使用过滤策略,并且使用了默认的过滤策略.默认策略就是以下这个方法解析.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerDefaultFilters</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 扫描@Component注解的类</span></span><br><span class="line">    <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(Component.class));</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> ClassPathScanningCandidateComponentProvider.class.getClassLoader();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描所有@ManageBean的类</span></span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">                ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 扫描所有@Named的类</span></span><br><span class="line">        <span class="built_in">this</span>.includeFilters.add(<span class="keyword">new</span> <span class="title class_">AnnotationTypeFilter</span>(</span><br><span class="line">                ((Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;) ClassUtils.forName(<span class="string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="literal">false</span>));</span><br><span class="line">        logger.trace(<span class="string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的一个知识点:<strong>@ManageBean和@Named的作用和@Component是一样的</strong>。只是我们通常习惯使用**@Component**。</p></blockquote><p>为什么这里没有添加默认扫描<code>@Service</code>、<code>@Repository</code>、<code>@Controller</code>呢？原因很简单，这些注解都间接继承了<code>@Component</code>了。<br> 到这里，<code>scanner</code>解析完毕，它做的最主要的事情就是添加默认的过滤器策略以便在后续中可以扫描出<code>@Component</code>注解的类。</p><h2 id="register-方法解析"><a href="#register-方法解析" class="headerlink" title="register()方法解析"></a>register()方法解析</h2><p>无参构造方法解析完毕之后，接下来，构造方法将进行执行第二个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从我们的例子中, 这里的componentClasses就是我们传进来的Config.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    Assert.notEmpty(componentClasses, <span class="string">&quot;At least one component class must be specified&quot;</span>);</span><br><span class="line">    <span class="comment">// 实际上是委托给AnnotatedBeanDefinitionReader类来注册</span></span><br><span class="line">    <span class="built_in">this</span>.reader.register(componentClasses);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------分割线-------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt;... componentClasses)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; componentClass : componentClasses) &#123;</span><br><span class="line">    <span class="comment">// 委托给内部的registerBean方法</span></span><br><span class="line">        registerBean(componentClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ------------------------分割线-------------------------</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBean</span><span class="params">(Class&lt;?&gt; beanClass)</span> &#123;</span><br><span class="line"><span class="comment">// 终于见到庐山真面目! 委托给内部的doRegisterBean()方法</span></span><br><span class="line">    doRegisterBean(beanClass, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doRegisterBean-源码解析"><a href="#doRegisterBean-源码解析" class="headerlink" title="doRegisterBean()源码解析"></a>doRegisterBean()源码解析</h3><p>doRegisterBean()的源码十分重要, 因为在Spring当中, 所有的Bean都是通过该方法注入到容器当中的!源码如下(<strong>高能预警</strong>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">doRegisterBean</span><span class="params">(Class&lt;T&gt; beanClass, <span class="meta">@Nullable</span> String name,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> Class&lt;? extends Annotation&gt;[] qualifiers, <span class="meta">@Nullable</span> Supplier&lt;T&gt; supplier,</span></span><br><span class="line"><span class="params">        <span class="meta">@Nullable</span> BeanDefinitionCustomizer[] customizers)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据类生成一个beanDefinition, 具体类型是AnnotatedGenericBeanDefinition</span></span><br><span class="line">    <span class="comment">// 在当前场景中，beanClass就是传入的Config.class</span></span><br><span class="line">    <span class="type">AnnotatedGenericBeanDefinition</span> <span class="variable">abd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotatedGenericBeanDefinition</span>(beanClass);</span><br><span class="line">    <span class="comment">// 根据之前reader当中的条件解析器来判断当前的配置类当中是否有条件相关的注解，如果有，则进一步判断是否需要暂时跳过注册。</span></span><br><span class="line">    <span class="comment">// 还记得上文当中Scanner初始化过程中的条件解析器不? 它就是在这里起作用的!</span></span><br><span class="line">    <span class="comment">// 在当前场景中，由于Config类并没有配置任何conditional，因此这里不需要跳过注册</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.conditionEvaluator.shouldSkip(abd.getMetadata())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Supplier函数</span></span><br><span class="line">    <span class="comment">// 在当前场景中，supplier为null</span></span><br><span class="line">    abd.setInstanceSupplier(supplier);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析bd的ScopeMetadata。在reader初始化时，scopeMetadataResolver就默认初始化为AnnotationScopeMetadataResolver类型了</span></span><br><span class="line">    <span class="comment">// 这里主要是解析类上是否有@Scope注解，如果有，则解析:scopeName和proxyNode</span></span><br><span class="line">    <span class="comment">// scopeName（作用域范围：单例or原型？）</span></span><br><span class="line">    <span class="comment">// proxyNode（代理模式：JDK or Cglib?）</span></span><br><span class="line">    <span class="comment">// @Scope也是非常重要的一个点!! 但在这里不展开讲解，将单独章节进行讲解</span></span><br><span class="line">    <span class="comment">// 在当前场景中，Config没有@Scope注解，因此这里的config将默认为单例，且不采取代理技术。</span></span><br><span class="line">    <span class="type">ScopeMetadata</span> <span class="variable">scopeMetadata</span> <span class="operator">=</span> <span class="built_in">this</span>.scopeMetadataResolver.resolveScopeMetadata(abd);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置beanDefinition的作用域</span></span><br><span class="line">    <span class="comment">// 当前场景中为singleton</span></span><br><span class="line">    abd.setScope(scopeMetadata.getScopeName());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成bean的名字</span></span><br><span class="line">    <span class="comment">// 在reader初始化时，默认的beanName生成器为AnnotationBeanNameGenerator。</span></span><br><span class="line">    <span class="comment">// 如果有需要的话，我们自己也可以继承BeanNameGenerator来自定义beanName生成器。一般情况下，用默认的就可以了。</span></span><br><span class="line">    <span class="comment">// 默认的beanName生成策略就是类名首字母小写。</span></span><br><span class="line">    <span class="comment">// 在当前场景中，Config类的beanName就为：config</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> (name != <span class="literal">null</span> ? name : <span class="built_in">this</span>.beanNameGenerator.generateBeanName(abd, <span class="built_in">this</span>.registry));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要！！ 处理公共的注解，比如@Lazy、@Order、@Priority、@DependsOn。</span></span><br><span class="line">    <span class="comment">// 这些注解的作用很简单，这里不展开细说。</span></span><br><span class="line">    <span class="comment">// 在当前场景下，Config类没有这些注解。</span></span><br><span class="line">    AnnotationConfigUtils.processCommonDefinitionAnnotations(abd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有其他限定注解，则进行设置</span></span><br><span class="line">    <span class="comment">// 当前场景中, Config类显然是没有的</span></span><br><span class="line">    <span class="keyword">if</span> (qualifiers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; qualifier : qualifiers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Primary.class == qualifier) &#123;</span><br><span class="line">                abd.setPrimary(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Lazy.class == qualifier) &#123;</span><br><span class="line">                abd.setLazyInit(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                abd.addQualifier(<span class="keyword">new</span> <span class="title class_">AutowireCandidateQualifier</span>(qualifier));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanDefinitionCustomizer的作用就是回调处理beanDefinition</span></span><br><span class="line">    <span class="comment">// 当前场景中,不需要回调处理</span></span><br><span class="line">    <span class="keyword">if</span> (customizers != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionCustomizer customizer : customizers) &#123;</span><br><span class="line">            customizer.customize(abd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将beanDefinition和beanName封装成bdh</span></span><br><span class="line">    <span class="type">BeanDefinitionHolder</span> <span class="variable">definitionHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(abd, beanName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重要！！！ 这里将根据scopeMetadata来判断beanDefinition是否需要进行代理。如果需要，则生成代理类的beanDefinition并赋值给bdh！</span></span><br><span class="line">    <span class="comment">// 本场景中，不需要进行代理，因此bdh没有改变。</span></span><br><span class="line">    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册bdh所代表的的beanDefinition</span></span><br><span class="line">    <span class="comment">// 本场景中,就是注册Config类所代表的的bd. 注册成功后,工厂中就包含了7个bd了(别忘了前面注册的6个后置处理器的bd)</span></span><br><span class="line">    BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, <span class="built_in">this</span>.registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250303225157172.png" alt="image-20250303225157172"></p><h3 id="registerBeanDefinition"><a href="#registerBeanDefinition" class="headerlink" title="registerBeanDefinition()"></a><code>registerBeanDefinition()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinition</span><span class="params">(BeanDefinitionHolder definitionHolder, </span></span><br><span class="line"><span class="params">                                          BeanDefinitionRegistry registry)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先根据主名进行 beanDefinition 注册</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> definitionHolder.getBeanName();</span><br><span class="line">    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再注册别名 </span></span><br><span class="line">    String[] aliases = definitionHolder.getAliases();</span><br><span class="line">    <span class="keyword">if</span> (aliases != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">            registry.registerAlias(beanName, alias);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Refresh-方法解析"><a href="#Refresh-方法解析" class="headerlink" title="Refresh() 方法解析"></a><code>Refresh()</code> 方法解析</h2><p>构造方法中, 前面两步已经做了很多事情了, 但这些事情都是准备工作. 比起refresh()而言, 还是小巫见大巫. 在refresh()方法中,包含着各后置处理的作用 &#x2F; 调用时机; Bean的诞生过程; 循环依赖如何解决以及Spring的其他组件使用等. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// refresh()本身是一个聚合方法, 具体的功能都委托给了各个子方法.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 1.在刷新容器之前,做一些基础的处理. 不难</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// 2. 获取刷新后的beanFactory.注意:这里并不是要把当前的beanFactory全部刷新,只是刷新部分数据.不然之前的准备工作岂不是白做了. 不难</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"><span class="comment">// 3. 准备BeanFactory. 重要!!!</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 空方法 Spring后版本可能会用</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line">            <span class="comment">// 5. 调用后置处理器 重要!!!</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 6. 注册后置处理的Bean到容器当中 重要!!!</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line">            <span class="comment">// 7. 初始化MessageSource并将其bean注入到容器中</span></span><br><span class="line">            initMessageSource();</span><br><span class="line">            <span class="comment">// 8. 初始化事件多播器并将其bean注入到容器中</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line">            <span class="comment">// 9. 在特定上下文子类中初始化其他特殊bean. 当前是空方法, Spring后续版本可能会用</span></span><br><span class="line">            onRefresh();</span><br><span class="line">            <span class="comment">// 10. 注册监听器到容器中</span></span><br><span class="line">            registerListeners();</span><br><span class="line">            <span class="comment">// 11. 实例化所有剩余的bean(非延迟)到容器中 重要!!!</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">            <span class="comment">// 12. 最后, 发布容器刷新完成事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">           <span class="comment">// 异常情况下, 销毁容器中所有的bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 清除一些不必要的缓存</span></span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh()"></a><code>prepareRefresh()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 设置激活状态,启动时间</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化资源必要的资源. 目前是空方法. Spring后续版本可能会启用.</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验系统环境/JVM环境当中的必要参数</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储预刷新的ApplicationListeners. 实际上就是一个empty set</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.earlyApplicationListeners == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.earlyApplicationListeners = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(<span class="built_in">this</span>.applicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="built_in">this</span>.applicationListeners.addAll(<span class="built_in">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许收集早期的ApplicationEvent，一旦多播器可用，便会发布. 实际上这里也是一个empty set</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory()"></a><code>prepareBeanFactory()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置beanFactory的类加载器. 实际上,这里的类加载器和前文中所提到的类加载器是一样的.</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    <span class="comment">// 设置beanFactory当中的表达式语言解析器. 比如@Value中的表达式就是这里设置的解析器来解析的.</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    <span class="comment">// 设置beanFactory当中的属性编辑器.比如在配置文件中配置了一个&quot;2020-01-01&quot;的日期类型字符串,</span></span><br><span class="line">    <span class="comment">// 正常情况下,Spring无法解析为Date类型,因此可以通过自定义属性编辑器的方式来转换.这就是属性编辑器的作用.</span></span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重要!!! 这里添加了一个ApplicationContextAwareProcessor到BeanFactory的BeanPostProcessors中.</span></span><br><span class="line">    <span class="comment">// 注意,这里只是添加到后置处理列表,并没有将其解析为beanDefinition,更没有解析为bean注入到容器当中.具体解析时机,后面会提到.</span></span><br><span class="line">    <span class="comment">// 到这里, BeanFactory中的BeanPostProcessors中迎来了第1个后置处理器.(注意,并没有添加到BeanDefinitionMap中)</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略实现了这些接口的类的解析和注入.</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里提前注册已解析的依赖,目的是用于自动装配使用.</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="built_in">this</span>);</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// BeanPostProcessors中迎来了第2个 processor</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次进来显然不包含,因此不会进入if分支</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将environment实例注入到单例容器中, 到这里,容器迎来了第1个单例!</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将systemProperties实例注入到单例容器中, 到这里,容器迎来了第2个单例!</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将systemEnvironment实例注入到单例容器中, 到这里,容器迎来了第3个单例!</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepareBeanFactory()方法很有意义,因为它在整个容器启动过程中,第一次添加了后置处理器到列表中,第一次添加了单例到容器中.</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors()"></a><code>invokeBeanFactoryPostProcessors()</code></h3><p>这个方法及其重要,因为它调用了后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 首先获取容器中的BeanFactoryPostProcessors. 注意这里不是获取BeanPostProcessors.</span></span><br><span class="line">    <span class="comment">// 因此第一次这里获取到BeanFactoryPostProcessors列表肯定是空</span></span><br><span class="line">    <span class="comment">// 委托给invokeBeanFactoryPostProcessors方法</span></span><br><span class="line">    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span></span><br><span class="line">    <span class="comment">// (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.getTempClassLoader() == <span class="literal">null</span> &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>委托的方法如下(高能预警):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法很复杂~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span></span><br><span class="line">    Set&lt;String&gt; processedBeans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先,判断是不是BeanDefinitionRegistry类型, 从BeanFactoryUML类图中可以看出. 显然是的,因此进入到if分支</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory <span class="keyword">instanceof</span> BeanDefinitionRegistry) &#123;</span><br><span class="line">        <span class="type">BeanDefinitionRegistry</span> <span class="variable">registry</span> <span class="operator">=</span> (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">        <span class="comment">// 注意, 这里会先初始化两个列表</span></span><br><span class="line">        <span class="comment">// 一个用于盛放BeanFactoryPostProcessor类型的后置处理器</span></span><br><span class="line">        <span class="comment">// 一个用于盛放BeanDefinitionRegistryPostProcessor类型的后置处理器</span></span><br><span class="line">        <span class="comment">// 值得注意的是, BeanDefinitionRegistryPostProcessor实际上是继承了BeanFactoryPostProcessor</span></span><br><span class="line">        <span class="comment">// 那么为什么这里要用两个容器分别盛放呢??? 原因在于, Spring的初始化过程中,后置处理器的执行顺序有要求. 这里我们不展开详细讨论,会专门拿一篇文章出来解说后置处理器.</span></span><br><span class="line">        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 因为beanFactoryPostProcessors为空,因此for循环直接跳出.</span></span><br><span class="line">        <span class="keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line">            <span class="keyword">if</span> (postProcessor <span class="keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line">                <span class="type">BeanDefinitionRegistryPostProcessor</span> <span class="variable">registryProcessor</span> <span class="operator">=</span></span><br><span class="line">                        (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line">                registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line">                registryProcessors.add(registryProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                regularPostProcessors.add(postProcessor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再初始化一个BeanDefinitionRegistryPostProcessor容器列表. 注意区别与之前的registryProcessors!</span></span><br><span class="line">        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先，调用实现PriorityOrdered的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        <span class="comment">// 从容器中获取BeanDefinitionRegistryPostProcessor的beanNameList,</span></span><br><span class="line">        <span class="comment">// 从上文中可以得知,容器中只有ConfigurationClassPostProcessor是BeanDefinitionRegistryPostProcessor类型的.</span></span><br><span class="line">        <span class="comment">// 因此,postProcessorNames只有1个值</span></span><br><span class="line">        String[] postProcessorNames =</span><br><span class="line">                beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// ConfigurationClassPostProcessor实现了PriorityOrdered接口, 因此这里进入到if分支.</span></span><br><span class="line">            <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="comment">// 获取BeanDefinitionRegistryPostProcessor的bean并放入到currentRegistryProcessors</span></span><br><span class="line">                <span class="comment">// 上文中我们得知,当前的容器中只有3个bean, 这里通过getBean方法只会,容器将会添加第4个bean.</span></span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                <span class="comment">// 添加到processedBeans中</span></span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对currentRegistryProcessors进行排序.</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 将currentRegistryProcessors全部添加到registryProcessors中</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 调用BeanDefinitionRegistryPostProcessor的独有方法:postProcessBeanDefinitionRegistry()</span></span><br><span class="line">        <span class="comment">// 从上文解析得知,实际上这里只会调用ConfigurationClassPostProcessor的postProcessBeanDefinitionRegistry()</span></span><br><span class="line">        <span class="comment">// 在这里面便提现了ConfigurationClassPostProcessor的价值!!! 它是通过一个parser对象解析@Configuration注解的类的.</span></span><br><span class="line">        <span class="comment">// 本例中, 就是解析Config.class类,而在Config.class上有@ComponentScan注解,因此会通过scanner扫描该包下的所有@Component注解的类并解析成BeanDefinition添加到BeanFactory的beanDefinitionMap中.</span></span><br><span class="line">        <span class="comment">// 到这里,便知道,Spring就是在这里完成了@Configuration类的解析和bean的初步扫描!</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// 调用完成后, 将currentRegistryProcessors清空,以便后续再次使用.</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来，调用实现Ordered的BeanDefinitionRegistryPostProcessors</span></span><br><span class="line">        <span class="comment">// 同样的,显示获取BeanDefinitionRegistryPostProcessor的所有postProcessorNames,</span></span><br><span class="line">        <span class="comment">// 通过上文得知, 实际上只有1个</span></span><br><span class="line">        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="comment">// 判断是否实现了Ordered接口. 显然ConfigurationClassPostProcessor没有实现Ordered接口,因此不会进入if分支</span></span><br><span class="line">            <span class="keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                processedBeans.add(ppName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序, 从上文得知, 这里会排个寂寞~~因为当前的currentRegistryProcessors为空</span></span><br><span class="line">        sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">        <span class="comment">// 同样地,寂寞~~</span></span><br><span class="line">        registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">        <span class="comment">// 寂寞~~</span></span><br><span class="line">        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">        <span class="comment">// 再寂寞~~</span></span><br><span class="line">        currentRegistryProcessors.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后，调用所有其他BeanDefinitionRegistryPostProcessor，通过while循环保证会全部调用完</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reiterate</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (reiterate) &#123;</span><br><span class="line">            reiterate = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 获取BeanDefinitionRegistryPostProcessor的所有postProcessorNames, 同样的只有1个~~</span></span><br><span class="line">            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">            <span class="comment">// 由于在上文中processedBeans已经添加了ConfigurationClassPostProcessor了,因此必然包含啊</span></span><br><span class="line">                <span class="comment">// 所以这里不会进入到if分支.</span></span><br><span class="line">                <span class="keyword">if</span> (!processedBeans.contains(ppName)) &#123;</span><br><span class="line">                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line">                    processedBeans.add(ppName);</span><br><span class="line">                    reiterate = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line">            registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line">            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line">            currentRegistryProcessors.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在，调用到目前为止已处理的所有处理器的postProcessBeanFactory回调</span></span><br><span class="line">        <span class="comment">// 上文中, 都是调用的BeanDefinitionRegistryPostProcessor当中的特有的方法,</span></span><br><span class="line">        <span class="comment">// 这里将会调用BeanFactoryPostProcessor中的方法了.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line">        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Invoke factory processors registered with the context instance.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过以上解析, BeanDefinitionRegistryPostProcessor类型的后置处理器就执行完了.</span></span><br><span class="line">    <span class="comment">// 接下来,将执行BeanFactoryPostProcessor类型的后置处理器.有了上面的铺垫之后,接下来就会好受很多.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先,从容器中获取BeanFactoryPostProcessor类型的后置处理器名称.</span></span><br><span class="line">    <span class="comment">// 这里实际上会获取到2个: ConfigurationClassPostProcessor和EventListenerPostProcessor</span></span><br><span class="line">    String[] postProcessorNames =</span><br><span class="line">            beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要先执行实现了priority的, 再执行实现了Ordered的, 最后执行非ordered的, 因此这里是初始化了3个List</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">    <span class="comment">// 如果processedBeans包含了, 说明已经调用过了,不需要再执行.</span></span><br><span class="line">        <span class="comment">// 再我们这个场景中,</span></span><br><span class="line">        <span class="comment">// 很显然, ConfigurationClassPostProcessor是已经执行过了, 因此将会跳过</span></span><br><span class="line">        <span class="comment">// 而EventListenerPostProcessor没有执行过,因此不会跳过</span></span><br><span class="line">        <span class="keyword">if</span> (processedBeans.contains(ppName)) &#123;</span><br><span class="line">            <span class="comment">// skip - already processed in first phase above</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">        <span class="comment">// 如果实现了PriorityOrdered, 则添加到priorityOrderedPostProcessors中</span></span><br><span class="line">            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">        <span class="comment">// 如果实现了Ordered, 则添加到orderedPostProcessorNames中</span></span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则, 添加到nonOrderedPostProcessorNames</span></span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，调用实现PriorityOrdered的BeanFactoryPostProcessors</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来，调用实现Ordered的BeanFactoryPostProcessors</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，调用所有其他BeanFactoryPostProcessors</span></span><br><span class="line">    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">    &#125;</span><br><span class="line">    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空不必要的元数据缓存</span></span><br><span class="line">    beanFactory.clearMetadataCache();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeBeanFactoryPostProcessors()</code>方法到这里执行完毕, 初看之时, 我头皮着实麻了一下,但是静下心来梳理了以便之后, 又感叹于Spring复杂且精妙.<br> 这个方法整体上是执行实现了<code>BeanFactoryPostProcessor</code>的后置处理器的. 在Spring内部中使用了<code>BeanDefinitionRegistryPostProcessor</code>来作为框架辅助运行, 它的执行优先级也是最高的.  整个<code>BeanFactoryPostProcessor</code>组件 的执行优先级如下:</p><ul><li>最高: 实现了PriorityOrdered接口的 BeanDefinitionRegistryPostProcessor</li><li>再次: 实现了Ordered接口的 BeanDefinitionRegistryPostProcessor</li><li>再次: 普通的BeanDefinitionRegistryPostProcessor</li><li>再次: 实现了PriorityOrdered接口的 BeanFactoryPostProcessor</li><li>再次: 实现了Ordered接口的BeanFactoryPostProcessor</li><li>最低: 普通的BeanFactoryPostProcessor</li></ul><blockquote><p>在实际应用中最高优先级执行的便是实现PriorityOrdered的ConfigurationClassPostProcessor类. 因为它真的很重要,因此必须优先级最高.<br> 知道了这个优先级之后, 我们便可以通过实现BeanFactoryPostProcessor或者BeanDefinitionRegistryPostProcessor来插足Spring的生命周期了. 当然了, BeanFactoryPostProcessor或者BeanDefinitionRegistryPostProcessor其实是Spring内部使用的, 开发人员在非特殊情况下应该避免直接使用, Spring为我们提供了优先级更低的BeanPostProcessor</p></blockquote><p>讲解完<code>BeanFactoryPostProcessor</code>后,继续~~</p><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors()"></a><code>registerBeanPostProcessors()</code></h3><p>这个方法主要是注册<code>BeanPostProcessor</code>的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="comment">// 委托</span></span><br><span class="line">    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是委托给registerBeanPostProcessors()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">registerBeanPostProcessors</span><span class="params">(</span></span><br><span class="line"><span class="params">        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前所有的PostProcessor的名称</span></span><br><span class="line">    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">beanProcessorTargetCount</span> <span class="operator">=</span> beanFactory.getBeanPostProcessorCount() + <span class="number">1</span> + postProcessorNames.length;</span><br><span class="line">    <span class="comment">// 添加一个checker</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">BeanPostProcessorChecker</span>(beanFactory, beanProcessorTargetCount));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同样的道理, 优先级最高的是实现了PriorityOrdered, 然后是实现了Ordered,最后是普通的BeanPostProcessor.</span></span><br><span class="line">    <span class="comment">// 将这些注册到BeanFactory的BeanPostProcessors列表中.</span></span><br><span class="line">    </span><br><span class="line">    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;BeanPostProcessor&gt; internalPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; orderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; nonOrderedPostProcessorNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String ppName : postProcessorNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">            <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">            priorityOrderedPostProcessors.add(pp);</span><br><span class="line">            <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">                internalPostProcessors.add(pp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">            orderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First, register the BeanPostProcessors that implement PriorityOrdered.</span></span><br><span class="line">    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Next, register the BeanPostProcessors that implement Ordered.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; orderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(orderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        orderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now, register all regular BeanPostProcessors.</span></span><br><span class="line">    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nonOrderedPostProcessorNames.size());</span><br><span class="line">    <span class="keyword">for</span> (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">        <span class="type">BeanPostProcessor</span> <span class="variable">pp</span> <span class="operator">=</span> beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">        nonOrderedPostProcessors.add(pp);</span><br><span class="line">        <span class="keyword">if</span> (pp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            internalPostProcessors.add(pp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, re-register all internal BeanPostProcessors.</span></span><br><span class="line">    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line"></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(applicationContext));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerBeanPostProcessors()的主要目的就是注册程序当中的BeanPostProcessor到容器中,并且通过getBean方法,将这些BeanPostProcessor的bean注入到容器当中去. 而真正的调用则是在注入bean的过程中调用的.</p><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization()"></a><code>finishBeanFactoryInitialization()</code></h3><p>该方法将会实例化所有剩余的（非延迟初始化）单例. 也就是说, 经过了前面所有的步骤之后, 终于要开始解析并注入我们程序代码当中定义的bean了,无论是通过注解的方式还是JavaConfig的方式还是配置的方式.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">java 代码解读复制代码<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最关键的就是这个方法, 它会实例化所有剩余的（非延迟初始化）单例!!!</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh()"></a><code>finishRefresh()</code></h3><p>该方法做一些结尾的工作, 主要是发布容器刷新成功事件.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">java 代码解读复制代码<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finishRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Clear context-level resource caches (such as ASM metadata from scanning).</span></span><br><span class="line">    clearResourceCaches();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize lifecycle processor for this context.</span></span><br><span class="line">    initLifecycleProcessor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate refresh to lifecycle processor first.</span></span><br><span class="line">    getLifecycleProcessor().onRefresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布容器刷新成功事件</span></span><br><span class="line">    publishEvent(<span class="keyword">new</span> <span class="title class_">ContextRefreshedEvent</span>(<span class="built_in">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Participate in LiveBeansView MBean, if active.</span></span><br><span class="line">    LiveBeansView.registerApplicationContext(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="refresh-小结"><a href="#refresh-小结" class="headerlink" title="refresh() 小结"></a><code>refresh()</code> 小结</h3><p>整个refresh过程几乎设计到了Spring core的所有东西. 比如后置处理的解析&#x2F;注册&#x2F;调用, bean的解析&#x2F;自动装配&#x2F;循环依赖等.</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熔断、降级、限流</title>
      <link href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%20%E4%B8%8E%20%E9%99%8D%E7%BA%A7/"/>
      <url>/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%20%E4%B8%8E%20%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="一、熔断（Circuit-Breaker）"><a href="#一、熔断（Circuit-Breaker）" class="headerlink" title="一、熔断（Circuit Breaker）"></a>一、熔断（Circuit Breaker）</h2><h3 id="1-1-熔断机制概述"><a href="#1-1-熔断机制概述" class="headerlink" title="1.1 熔断机制概述"></a>1.1 熔断机制概述</h3><p>熔断机制是一种保护机制，类似于电路中的保险丝。当某个服务调用失败次数或响应时间超过预设阈值时，熔断器会自动“断开”，直接返回错误，避免故障进一步扩散。熔断器通常有三种状态：</p><ul><li><strong>关闭状态（Closed）</strong>：正常请求通过，未检测到故障。</li><li><strong>打开状态（Open）</strong>：熔断器触发，所有请求立即失败。</li><li><strong>半开状态（Half-Open）</strong>：部分请求尝试重新连接目标服务，验证其是否恢复。</li></ul><h3 id="1-2-熔断策略"><a href="#1-2-熔断策略" class="headerlink" title="1.2 熔断策略"></a>1.2 熔断策略</h3><p>熔断策略通常包括以下几种：</p><ul><li><strong>失败率阈值</strong>：当服务调用失败率达到预设阈值时触发熔断。</li><li><strong>慢调用比例</strong>：当服务响应时间超过预设阈值的比例过高时触发熔断。</li><li><strong>超时时间</strong>：熔断后设置超时时间，等待服务恢复正常。</li></ul><h3 id="1-3-熔断实现与技术选型"><a href="#1-3-熔断实现与技术选型" class="headerlink" title="1.3 熔断实现与技术选型"></a>1.3 熔断实现与技术选型</h3><ul><li><strong>Hystrix</strong>：Netflix 开源的熔断库，支持熔断、降级和限流功能。虽然已停止维护，但其在遗留系统中仍有广泛应用。</li><li><strong>Resilience4j</strong>：轻量级的熔断库，专为响应式编程和 Java 8+ 设计，支持基于访问数量和时间的滑动窗口统计。</li><li><strong>Sentinel</strong>：阿里巴巴开源的限流、熔断和降级组件，支持多种框架集成，功能丰富。</li></ul><h3 id="1-4-使用场景"><a href="#1-4-使用场景" class="headerlink" title="1.4 使用场景"></a>1.4 使用场景</h3><ul><li><strong>高并发场景</strong>：如秒杀、抢购等场景，服务容易因过载而响应超时，触发熔断可以有效保护系统。</li><li><strong>依赖外部服务的场景</strong>：当系统依赖第三方服务时，如果第三方服务不可用，熔断能够防止大量请求堆积。</li><li><strong>网络不稳定场景</strong>：在跨地域调用或弱网环境中，熔断可以避免由于网络问题导致的级联故障。</li></ul><h1 id="二、限流（Rate-Limiting）"><a href="#二、限流（Rate-Limiting）" class="headerlink" title="二、限流（Rate Limiting）"></a>二、限流（Rate Limiting）</h1><p>在高并发的微服务架构中，限流是一种关键的技术手段，用于保护系统免受过载，确保服务的稳定性。本文将深入探讨限流的原理、常见算法、实现方法以及应用场景，帮助读者全面理解限流技术。</p><h2 id="1、-限流的原理与重要性"><a href="#1、-限流的原理与重要性" class="headerlink" title="1、 限流的原理与重要性"></a>1、 限流的原理与重要性</h2><p>限流的核心目的是控制请求的速率，防止系统因突发流量或恶意攻击而崩溃。通过限制请求的频率，限流可以有效缓解系统压力，确保服务在高负载下仍能稳定运行。限流不仅保护了系统资源，还提升了用户体验，避免因系统过载导致的长时间等待或服务不可用。</p><h2 id="2、常见的限流算法"><a href="#2、常见的限流算法" class="headerlink" title="2、常见的限流算法"></a>2、常见的限流算法</h2><h3 id="2-1-固定窗口算法"><a href="#2-1-固定窗口算法" class="headerlink" title="2.1 固定窗口算法"></a>2.1 固定窗口算法</h3><p>固定窗口算法是最简单的限流算法，将时间划分为固定长度的窗口，统计窗口内的请求数。如果请求数超过阈值，则拒绝后续请求。它的优点是实现简单，但存在窗口边界问题，可能导致突发流量超过阈值。</p><p><strong>实现示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 请求阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">1000</span>; <span class="comment">// 窗口大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">trafficMonitoring</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime();</span><br><span class="line">        <span class="keyword">if</span> (nowTime &lt; time + interval) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> max &gt; count;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            time = nowTime; <span class="comment">// 开启新的窗口</span></span><br><span class="line">            count = <span class="number">1</span>; <span class="comment">// 初始化计数器</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-滑动窗口算法"><a href="#2-2-滑动窗口算法" class="headerlink" title="2.2 滑动窗口算法"></a>2.2 滑动窗口算法</h3><p>滑动窗口算法是固定窗口的改进版，通过将时间窗口细分为多个小窗口，解决了固定窗口的边界问题。它能够更精准地控制流量，适用于高精度限流场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindow</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> windowSize; <span class="comment">// 窗口大小（毫秒）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxRequests; <span class="comment">// 最大请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;Long&gt; requestTimes; <span class="comment">// 存储请求时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindow</span><span class="params">(<span class="type">int</span> windowSize, <span class="type">int</span> maxRequests)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.windowSize = windowSize;</span><br><span class="line">        <span class="built_in">this</span>.maxRequests = maxRequests;</span><br><span class="line">        <span class="built_in">this</span>.requestTimes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">allowRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 移除窗口外的请求</span></span><br><span class="line">        <span class="keyword">while</span> (!requestTimes.isEmpty() &amp;&amp; now - requestTimes.peek() &gt; windowSize) &#123;</span><br><span class="line">            requestTimes.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否超过最大请求数</span></span><br><span class="line">        <span class="keyword">if</span> (requestTimes.size() &lt; maxRequests) &#123;</span><br><span class="line">            requestTimes.add(now);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-漏桶算法-（没有任何价值）"><a href="#2-3-漏桶算法-（没有任何价值）" class="headerlink" title="2.3 漏桶算法 （没有任何价值）"></a>2.3 漏桶算法 （没有任何价值）</h3><p>漏桶算法以固定速率处理请求，无论请求的到达速率如何。它适合需要严格平滑流量的场景，如支付系统。漏桶算法的优点是实现简单，输出流量绝对平滑，但无法应对突发流量。</p><ul><li>漏桶算法 一般认为区别于 令牌桶的地方在于 流量整形，也即任务按恒定速率处理， 要做到这一点，必须将任务执行交给专门的线程池处理，然后还要设定定时任务，从 列表中 提取 “任务” 交由 线程池处理， 这种行为个人认为相当迷惑， 线程池本身也可以提供池子的作用，而且直接提交任务到线程池，可以再前面任务完成后自动执行 后续请求， 个人感觉 除非真正有那种 流量 “恶意” 整形 的场景，否则漏桶算法没有任何意义， 用令牌桶和固定窗口或者线程池来限流都比漏桶要来的合理<ul><li>固定窗口可以流量整形， 并且应对小窗口内的流量不均衡</li></ul></li></ul><h3 id="2-4-令牌桶算法"><a href="#2-4-令牌桶算法" class="headerlink" title="2.4 令牌桶算法"></a>2.4 令牌桶算法</h3><p>令牌桶算法以固定速率向桶中添加令牌，请求需要获取令牌才能通过。它允许一定程度的突发流量，适合如秒杀等场景。令牌桶算法的优点是用户体验较好，但实现相对复杂。</p><p><strong>实现示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> capacity; <span class="comment">// 桶的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> refillRate; <span class="comment">// 令牌的填充速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">tokens</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(); <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">lastRefillTime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucket</span><span class="params">(<span class="type">long</span> capacity, <span class="type">long</span> refillRate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.refillRate = refillRate;</span><br><span class="line">        <span class="built_in">this</span>.tokens.set(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">acquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">elapsedTime</span> <span class="operator">=</span> now - lastRefillTime.getAndSet(now);</span><br><span class="line">        <span class="type">long</span> <span class="variable">newTokens</span> <span class="operator">=</span> (elapsedTime / <span class="number">1000</span>) * refillRate;</span><br><span class="line">        tokens.addAndGet(Math.min(newTokens, capacity - tokens.get()));</span><br><span class="line">        <span class="keyword">return</span> tokens.getAndDecrement() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、-限流的实现方法"><a href="#3、-限流的实现方法" class="headerlink" title="3、 限流的实现方法"></a>3、 限流的实现方法</h2><h3 id="3-1-基于本地内存的限流"><a href="#3-1-基于本地内存的限流" class="headerlink" title="3.1 基于本地内存的限流"></a>3.1 基于本地内存的限流</h3><p>使用本地内存实现限流是最简单的方式，适用于单机环境。例如，可以使用 <code>AtomicInteger</code> 或 <code>Semaphore</code> 来控制请求速率。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitingFilter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_REQUESTS_PER_SECOND</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(MAX_REQUESTS_PER_SECOND);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">allowRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> semaphore.tryAcquire();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-基于-Redis-的分布式限流"><a href="#3-2-基于-Redis-的分布式限流" class="headerlink" title="3.2 基于 Redis 的分布式限流"></a>3.2 基于 Redis 的分布式限流</h3><p>在分布式系统中，可以使用 Redis 实现限流。Redis 的高性能和原子操作特性使其成为理想的限流工具。例如，可以使用 Redis 的 <code>INCR</code> 和 <code>EXPIRE</code> 命令实现固定窗口限流。</p><p><strong>示例代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAllowed</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;rate_limit:&quot;</span> + userId;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentWindow</span> <span class="operator">=</span> System.currentTimeMillis() / <span class="number">1000</span> / WINDOW_SIZE;</span><br><span class="line">    <span class="type">String</span> <span class="variable">windowKey</span> <span class="operator">=</span> key + <span class="string">&quot;:&quot;</span> + currentWindow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (jedis.exists(windowKey)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.parseInt(jedis.get(windowKey)) &lt; LIMIT) &#123;</span><br><span class="line">            jedis.incr(windowKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jedis.setex(windowKey, WINDOW_SIZE, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-使用第三方库"><a href="#3-3-使用第三方库" class="headerlink" title="3.3 使用第三方库"></a>3.3 使用第三方库</h3><p>许多第三方库提供了限流功能，例如 <code>Bucket4j</code> 和 <code>Guava RateLimiter</code>。这些库封装了复杂的限流逻辑，简化了开发工作。</p><p><strong>示例代码（Guava RateLimiter）</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimiterExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>); <span class="comment">// 每秒 10 个令牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleRequest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rateLimiter.tryAcquire()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Request processed.&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Request rejected.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、-限流的应用场景"><a href="#4、-限流的应用场景" class="headerlink" title="4、 限流的应用场景"></a>4、 限流的应用场景</h2><h3 id="4-1-防止系统过载"><a href="#4-1-防止系统过载" class="headerlink" title="4.1 防止系统过载"></a>4.1 防止系统过载</h3><p>在高并发场景下，如秒杀、抢购等，限流可以防止系统因突发流量而崩溃。</p><h3 id="4-2-保护后端服务"><a href="#4-2-保护后端服务" class="headerlink" title="4.2 保护后端服务"></a>4.2 保护后端服务</h3><p>对于依赖外部服务的系统，限流可以防止因外部服务不可用而导致的级联故障。</p><h3 id="4-3-限制用户行为"><a href="#4-3-限制用户行为" class="headerlink" title="4.3 限制用户行为"></a>4.3 限制用户行为</h3><p>在网站中，限流可以限制用户访问频率，防止恶意攻击。</p><h2 id="5、-总结"><a href="#5、-总结" class="headerlink" title="5、 总结"></a>5、 总结</h2><p>限流是微服务架构中保障系统稳定性的关键技术。通过合理选择限流算法和实现方式，可以有效防止系统过载，提升用户体验。在技术选型上，可以根据具体需求选择本地内存、Redis 或第三方库实现限流。希望本文能帮助读者更好地理解和应用限流技术，提升系统的稳定性和可靠性。</p><hr><h2 id="三、降级（Degradation）"><a href="#三、降级（Degradation）" class="headerlink" title="三、降级（Degradation）"></a>三、降级（Degradation）</h2><h3 id="3-1-降级机制概述"><a href="#3-1-降级机制概述" class="headerlink" title="3.1 降级机制概述"></a>3.1 降级机制概述</h3><p>降级是指当某个服务出现异常时，系统暂时提供有限的功能或返回预设的默认值，以保证核心业务的正常运转。降级策略通常包括：</p><ul><li><strong>超时降级</strong>：当服务响应时间超过预设阈值时，返回默认值或缓存数据。</li><li><strong>失败次数降级</strong>：当服务调用失败次数超过阈值时，返回默认值。</li><li><strong>故障降级</strong>：当远程服务不可用时，返回默认值或缓存数据。</li><li><strong>限流降级</strong>：当请求量超过系统承受能力时，返回排队页面或错误提示。</li></ul><h3 id="3-2-自动恢复"><a href="#3-2-自动恢复" class="headerlink" title="3.2 自动恢复"></a>3.2 自动恢复</h3><p>与熔断类似，降级也需要考虑自动恢复。在降级后，系统需要通过监控和预警机制，及时发现服务是否恢复正常，并动态调整降级策略。</p><h3 id="3-3-技术选型"><a href="#3-3-技术选型" class="headerlink" title="3.3 技术选型"></a>3.3 技术选型</h3><ul><li><strong>Sentinel</strong>：支持基于错误率、慢调用比例等指标触发降级，并提供自动恢复机制。</li><li><strong>自定义降级逻辑</strong>：在业务代码中通过异常处理和逻辑判断实现降级。</li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><strong>非核心功能的场景</strong>：对于一些非核心功能（如推荐系统、评论系统等），可以通过降级保证主业务流程不受影响。</li><li><strong>资源有限的场景</strong>：当系统资源（如内存、线程池）不足时，可以对某些业务进行降级以节省资源。</li><li><strong>系统升级场景</strong>：在系统升级过程中，部分服务可能暂时不可用，通过降级返回默认值，可以减少对用户的影响。</li></ul><hr><h2 id="四、总结：熔断、限流与降级的综合应用"><a href="#四、总结：熔断、限流与降级的综合应用" class="headerlink" title="四、总结：熔断、限流与降级的综合应用"></a>四、总结：熔断、限流与降级的综合应用</h2><p>熔断、限流和降级是微服务架构中保障系统稳定性和高可用性的关键策略。它们通过不同的机制和作用，共同实现系统在高负载或服务异常时的稳定性。在实际项目中，熔断和降级往往需要配合使用，例如：</p><ul><li><strong>熔断</strong>：当库存服务响应超时时，触发熔断保护订单服务不受影响。</li><li><strong>降级</strong>：当推荐服务不可用时，返回默认的推荐商品，保证用户体验。</li></ul><p>通过合理配置熔断阈值、降级策略和限流算法，可以有效防止系统雪崩，保护系统的核心功能。在技术选型上，Sentinel 是目前最成熟、功能最强大的分布式限流、熔断、降级组件，适合大规模分布式系统。对于轻量级应用，Resilience4j 和 Guava RateLimiter 也是不错的选择。</p>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理注册与发现</title>
      <link href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
      <url>/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>在微服务架构中，服务实例的数量和位置可能会动态变化。例如，新的服务实例可能会随时启动，旧的服务实例可能会因为故障而停止。<strong>服务注册与发现机制的作用就是让服务能够动态地加入和离开系统，并且让其他服务能够快速找到并调用它们。</strong></p><p><strong>服务注册</strong> ：服务提供者将自己的信息（如服务名称、IP 地址、端口号等）注册到一个中央注册中心的过程。</p><p>注册中心可以是一个数据库、一个专门的服务注册服务器，或者一个分布式存储系统。服务提供者在启动时会将自己的信息发送给注册中心，注册中心会存储这些信息以便其他服务能够查询。</p><p><strong>服务发现</strong> ：服务消费者通过注册中心（NameServer）查询服务提供者信息的过程。</p><p>当服务消费者需要调用某个服务时，它会向注册中心发送请求，注册中心会返回当前可用的服务提供者列表。服务消费者可以根据这些信息选择一个服务提供者进行调用。</p><h2 id="二、服务注册与发现的实现方式"><a href="#二、服务注册与发现的实现方式" class="headerlink" title="二、服务注册与发现的实现方式"></a>二、服务注册与发现的实现方式</h2><h3 id="1、客户端发现模式"><a href="#1、客户端发现模式" class="headerlink" title="1、客户端发现模式"></a>1、客户端发现模式</h3><p>客户端发现模式是指服务消费者直接从注册中心获取服务实例列表，并根据负载均衡策略选择服务实例进行调用。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>灵活性高</strong>：客户端可以根据实时的服务状态和负载情况动态选择服务实例。</li><li><strong>去中心化</strong>：每个客户端独立进行负载均衡决策，减少了对中心负载均衡器的依赖。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>客户端复杂度增加</strong>：客户端需要实现服务发现和负载均衡逻辑，增加了代码复杂度。</li><li><strong>性能开销</strong>：客户端需要定期从注册中心获取服务实例列表，增加了网络开销。</li></ul><h4 id="典型实现"><a href="#典型实现" class="headerlink" title="典型实现"></a>典型实现</h4><ul><li><strong>Netflix Eureka + Ribbon</strong><ul><li><strong>Eureka</strong>：作为服务注册中心，存储服务实例的元数据信息。</li><li><strong>Ribbon</strong>：作为客户端负载均衡器，从 Eureka 获取服务实例列表，并根据负载均衡算法选择服务实例。</li></ul></li></ul><h3 id="2、-服务端发现模式"><a href="#2、-服务端发现模式" class="headerlink" title="2、 服务端发现模式"></a>2、 服务端发现模式</h3><p>服务端发现模式是指客户端将请求发送到一个负载均衡器，负载均衡器从注册中心获取服务实例列表，并根据负载均衡策略选择服务实例进行转发。</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>客户端简化</strong>：客户端逻辑简单，只需要进行基本的 DNS 解析获取负载均衡器的地址。</li><li><strong>集中管理</strong>：负载均衡器统一管理服务发现和负载均衡逻辑，易于维护和扩展。</li><li><strong>高可用性</strong>：负载均衡器可以实现高可用性部署，提高系统的整体可靠性。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>单点故障风险</strong>：负载均衡器可能成为单点故障点，需要通过集群部署等方式解决。</li><li><strong>性能瓶颈</strong>：所有请求都需要经过负载均衡器，可能会成为性能瓶颈。</li><li><strong>配置复杂</strong>：负载均衡器的配置和管理相对复杂，需要一定的运维经验。</li></ul><h4 id="典型实现-1"><a href="#典型实现-1" class="headerlink" title="典型实现"></a>典型实现</h4><ul><li><strong>Kubernetes</strong><ul><li><strong>服务注册与发现</strong>：由 kubelet 负责将 Pod 的状态注册到 Kubernetes API Server。</li><li><strong>负载均衡</strong>：kube-proxy 作为负载均衡器，根据 API Server 中的服务实例信息进行流量转发。</li></ul></li><li><strong>Nginx + Consul</strong><ul><li><strong>Consul</strong>：作为服务注册中心，存储服务实例信息。</li><li><strong>Nginx</strong>：通过 Consul 的 API 动态获取服务实例列表，并进行负载均衡。</li></ul></li></ul><h2 id="三、服务注册与发现的常见组件"><a href="#三、服务注册与发现的常见组件" class="headerlink" title="三、服务注册与发现的常见组件"></a>三、服务注册与发现的常见组件</h2><h3 id="1、-Eureka"><a href="#1、-Eureka" class="headerlink" title="1、 Eureka"></a>1、 Eureka</h3><p>由 Netflix 开发的服务发现框架，基于 RESTful API 提供服务注册和发现功能。</p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>集成简单</strong>：与 Spring Cloud 集成良好，提供完整的客户端和服务器端实现。</li><li><strong>自我保护机制</strong>：在网络分区等异常情况下，自动保护服务实例，避免误删。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>适用性有限</strong>：更适合大规模分布式系统，小型或中型系统可能过于复杂。</li><li><strong>潜在风险</strong>：自我保护机制可能导致服务消费者调用到不可用的服务实例。</li></ul><h3 id="2、-Consul"><a href="#2、-Consul" class="headerlink" title="2、 Consul"></a>2、 Consul</h3><p>由 HashiCorp 开发的服务网格解决方案，提供服务发现、配置管理、健康检查等功能。</p><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>功能强大</strong>：支持多种功能，如配置管理、健康检查等。</li><li><strong>协议支持广泛</strong>：支持 HTTP、DNS 和 gRPC 等多种协议，易于集成。</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>配置复杂</strong>：部署和配置相对复杂，需要一定的运维经验。</li><li><strong>性能瓶颈</strong>：在大规模集群中，性能可能受到一定影响。</li></ul><h3 id="3、-Zookeeper"><a href="#3、-Zookeeper" class="headerlink" title="3、 Zookeeper"></a>3、 Zookeeper</h3><p>由 Apache 开发的分布式协调服务，提供高性能、高可用的分布式存储。</p><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>性能高</strong>：支持大规模分布式系统，性能优异。</li><li><strong>可靠性高</strong>：临时节点机制自动删除不可用的服务实例，保证服务列表的准确性。</li></ul><h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>学习曲线陡峭</strong>：需要一定的分布式系统知识才能理解和使用。</li><li><strong>故障恢复复杂</strong>：集群故障恢复机制复杂，可能导致数据丢失或服务不可用。</li></ul><h2 id="四、服务注册与发现的高可用与性能优化"><a href="#四、服务注册与发现的高可用与性能优化" class="headerlink" title="四、服务注册与发现的高可用与性能优化"></a>四、服务注册与发现的高可用与性能优化</h2><h3 id="1、-高可用"><a href="#1、-高可用" class="headerlink" title="1、 高可用"></a>1、 高可用</h3><ul><li><strong>注册中心集群部署</strong>：通过部署多个实例并进行相互注册，避免单点故障。</li><li><strong>服务实例冗余</strong>：增加服务实例数量，采用容器化等方式提高可用性。</li><li><strong>断路器机制</strong>：使用 Hystrix 等工具防止因调用不可用服务导致自身不可用。</li></ul><h3 id="2、-性能优化"><a href="#2、-性能优化" class="headerlink" title="2、 性能优化"></a>2、 性能优化</h3><ul><li><strong>缓存机制</strong>：在客户端缓存服务实例列表，减少对注册中心的访问频率。</li><li><strong>高效通信协议</strong>：使用 gRPC 等高性能通信协议，提高服务调用效率。</li><li><strong>负载均衡策略优化</strong>：根据实际业务场景动态调整负载均衡策略，如权重分配、动态调整权重等。</li></ul><h2 id="五、注册中心设计-经典问题"><a href="#五、注册中心设计-经典问题" class="headerlink" title="五、注册中心设计 经典问题"></a>五、注册中心设计 经典问题</h2><p>【核心概括】  CAP、及时感知Server变化、高性能（高并发、低延迟）</p><h3 id="1-及时感知服务实例变化"><a href="#1-及时感知服务实例变化" class="headerlink" title="1.  及时感知服务实例变化"></a>1.  <strong>及时感知服务实例变化</strong></h3><ul><li><strong>问题</strong>：服务实例可能动态变化（如扩缩容、故障转移），注册中心需要实时更新服务实例的状态。</li><li><strong>解决方案</strong>：<ul><li>扩容： 主动注册（自检后注册）</li><li>故障或宕机： <ul><li>实现心跳机制和服务实例的健康检查，确保注册中心能及时发现并更新服务实例的状态。</li><li>调用端上报 —— 如何避免部分节点导致的误报</li><li>服务端宕机前上报</li></ul></li></ul></li></ul><h3 id="2-高可用"><a href="#2-高可用" class="headerlink" title="2. 高可用"></a>2. <strong>高可用</strong></h3><ul><li><strong>问题</strong>：注册中心本身可能成为单点故障，影响整个系统的可用性。</li><li><strong>解决方案</strong>：采用<strong>集群部署</strong>，通过<strong>分布式一致性算法</strong>（如Raft、ZAB）确保注册中心的高可用性和数据一致性。</li></ul><h3 id="3-性能优化"><a href="#3-性能优化" class="headerlink" title="3. 性能优化"></a>3. <strong>性能优化</strong></h3><ul><li><strong>问题</strong>：随着服务实例数量增加，注册中心的性能可能成为瓶颈。</li><li><strong>解决方案</strong>：优化数据结构和查询算法，减少存储和检索服务实例信息的延迟。</li></ul><h3 id="4-网络分区与一致性"><a href="#4-网络分区与一致性" class="headerlink" title="4. 网络分区与一致性"></a>4. <strong>网络分区与一致性</strong></h3><ul><li><strong>问题</strong>：网络分区可能导致注册中心数据不一致 —— 脑裂问题</li><li><strong>解决方案</strong>：根据 CAP 定理，平衡一致性与可用性，采用合适的分布式一致性协议。</li></ul><h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><ul><li><p><strong>跨平台和跨语言支持</strong></p><ul><li><strong>解决方案</strong>：提供多种语言的客户端SDK，并确保注册中心的接口协议（如HTTP、gRPC）具有良好的跨语言支持。</li></ul></li><li><p><strong>监控与日志</strong></p><ul><li><strong>解决方案</strong>：实现详细的监控和日志记录功能，支持实时告警和问题追溯。</li></ul></li></ul><ul><li><strong>配置管理</strong> （服务实例的配置信息需要动态更新，且要支持不同环境下的配置）<ul><li><strong>解决方案</strong>：集成动态配置管理系统（如Spring Cloud Config、Apollo），支持配置的实时更新。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理概述</title>
      <link href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="服务治理概述"><a href="#服务治理概述" class="headerlink" title="服务治理概述"></a>服务治理概述</h1><p><strong>服务治理</strong>是微服务架构中的核心概念，旨在确保分布式系统中各个服务的稳定性、可靠性和可维护性。它涵盖了从服务发现到故障恢复的多个方面。以下是服务治理的主要方面：</p><hr><h3 id="1-服务发现与注册"><a href="#1-服务发现与注册" class="headerlink" title="1. 服务发现与注册"></a>1. <strong>服务发现与注册</strong></h3><ul><li><strong>定义</strong>：服务实例启动时向注册中心注册自己的信息（如IP、端口、服务名），其他服务通过注册中心发现目标服务。</li><li><strong>常见工具</strong>：<ul><li><strong>Consul</strong>：支持服务发现、健康检查、KV存储。</li><li><strong>Eureka</strong>：Netflix开源的注册中心，适合Spring Cloud生态。</li><li><strong>Zookeeper</strong>：分布式协调服务，支持服务注册与发现。</li><li><strong>Nacos</strong>：阿里巴巴开源的注册中心，支持服务发现和配置管理。</li></ul></li><li><strong>关键点</strong>：<ul><li>服务动态上下线。</li><li>服务信息的实时更新。</li></ul></li></ul><hr><h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. <strong>负载均衡</strong></h3><ul><li><strong>定义</strong>：将请求均匀分发到多个服务实例，以提高系统的吞吐量和可用性。</li><li><strong>负载均衡策略</strong>：<ul><li>轮询（Round Robin）。</li><li>加权轮询（Weighted Round Robin）。</li><li>最小连接数（Least Connections）。</li><li>一致性哈希（Consistent Hashing）。</li></ul></li><li><strong>实现方式</strong>：<ul><li>客户端负载均衡（如Ribbon）。</li><li>服务端负载均衡（如Nginx、HAProxy）。</li></ul></li></ul><hr><h3 id="3-服务容错与熔断"><a href="#3-服务容错与熔断" class="headerlink" title="3. 服务容错与熔断"></a>3. <strong>服务容错与熔断</strong></h3><ul><li><strong>定义</strong>：在服务出现故障时，防止故障扩散，保证系统的稳定性。</li><li><strong>常见机制</strong>：<ul><li><strong>熔断器（Circuit Breaker）</strong>：当服务失败率达到阈值时，熔断器会暂时停止调用该服务。</li><li><strong>降级（Fallback）</strong>：在服务不可用时，返回默认值或执行备用逻辑。</li><li><strong>重试（Retry）</strong>：在服务调用失败时，自动重试。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Hystrix</strong>：Netflix开源的熔断器实现。</li><li><strong>Resilience4j</strong>：轻量级的容错库。</li><li><strong>Sentinel</strong>：阿里巴巴开源的流量控制和熔断工具。</li></ul></li></ul><hr><h3 id="4-流量控制与限流"><a href="#4-流量控制与限流" class="headerlink" title="4. 流量控制与限流"></a>4. <strong>流量控制与限流</strong></h3><ul><li><strong>定义</strong>：通过限制服务的请求量，防止系统过载。</li><li><strong>限流算法</strong>：<ul><li>计数器算法。</li><li>滑动窗口算法。</li><li>令牌桶算法。</li><li>漏桶算法。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Sentinel</strong>：支持流量控制、熔断降级。</li><li><strong>Nginx</strong>：通过配置实现限流。</li><li><strong>Redis</strong>：利用Redis实现分布式限流。</li></ul></li></ul><hr><h3 id="5-配置管理"><a href="#5-配置管理" class="headerlink" title="5. 配置管理"></a>5. <strong>配置管理</strong></h3><ul><li><strong>定义</strong>：集中管理服务的配置信息，支持动态更新。</li><li><strong>常见工具</strong>：<ul><li><strong>Spring Cloud Config</strong>：基于Git的配置管理。</li><li><strong>Nacos</strong>：支持配置管理和服务发现。</li><li><strong>Apollo</strong>：携程开源的配置中心。</li></ul></li><li><strong>关键点</strong>：<ul><li>配置的动态更新。</li><li>配置的版本管理。</li></ul></li></ul><hr><h3 id="6-服务监控与告警"><a href="#6-服务监控与告警" class="headerlink" title="6. 服务监控与告警"></a>6. <strong>服务监控与告警</strong></h3><ul><li><strong>定义</strong>：实时监控服务的运行状态，及时发现和处理问题。</li><li><strong>监控指标</strong>：<ul><li>请求量、响应时间、错误率。</li><li>CPU、内存、磁盘等资源使用情况。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Prometheus</strong>：开源的监控系统。</li><li><strong>Grafana</strong>：可视化监控数据。</li><li><strong>ELK Stack</strong>：用于日志收集和分析。</li><li><strong>SkyWalking</strong>：分布式追踪系统。</li></ul></li></ul><hr><h3 id="7-日志管理"><a href="#7-日志管理" class="headerlink" title="7. 日志管理"></a>7. <strong>日志管理</strong></h3><ul><li><strong>定义</strong>：集中收集、存储和分析服务的日志。</li><li><strong>常见工具</strong>：<ul><li><strong>ELK Stack</strong>：Elasticsearch、Logstash、Kibana。</li><li><strong>Fluentd</strong>：日志收集工具。</li><li><strong>Splunk</strong>：商业日志管理工具。</li></ul></li><li><strong>关键点</strong>：<ul><li>日志的标准化。</li><li>日志的实时分析。</li></ul></li></ul><hr><h3 id="8-分布式追踪"><a href="#8-分布式追踪" class="headerlink" title="8. 分布式追踪"></a>8. <strong>分布式追踪</strong></h3><ul><li><strong>定义</strong>：跟踪请求在分布式系统中的调用链路，帮助定位问题。</li><li><strong>常见工具</strong>：<ul><li><strong>Zipkin</strong>：开源的分布式追踪系统。</li><li><strong>Jaeger</strong>：支持高并发的分布式追踪。</li><li><strong>SkyWalking</strong>：APM工具，支持分布式追踪和性能监控。</li></ul></li><li><strong>关键点</strong>：<ul><li>调用链路的可视化。</li><li>性能瓶颈的分析。</li></ul></li></ul><hr><h3 id="9-服务安全"><a href="#9-服务安全" class="headerlink" title="9. 服务安全"></a>9. <strong>服务安全</strong></h3><ul><li><strong>定义</strong>：保护服务免受未授权访问和攻击。</li><li><strong>常见措施</strong>：<ul><li>身份认证（如OAuth2、JWT）。</li><li>权限控制（如RBAC）。</li><li>数据加密（如HTTPS、TLS）。</li><li>防止常见攻击（如SQL注入、XSS）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Spring Security</strong>：Java生态的安全框架。</li><li><strong>Keycloak</strong>：开源的身份和访问管理工具。</li></ul></li></ul><hr><h3 id="10-服务版本管理"><a href="#10-服务版本管理" class="headerlink" title="10. 服务版本管理"></a>10. <strong>服务版本管理</strong></h3><ul><li><strong>定义</strong>：管理服务的不同版本，支持灰度发布和回滚。</li><li><strong>常见策略</strong>：<ul><li>蓝绿部署。</li><li>金丝雀发布。</li><li>版本路由（如通过HTTP头或参数区分版本）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Kubernetes</strong>：支持蓝绿部署和金丝雀发布。</li><li><strong>Istio</strong>：服务网格，支持流量管理。</li></ul></li></ul><hr><h3 id="11-服务依赖管理"><a href="#11-服务依赖管理" class="headerlink" title="11. 服务依赖管理"></a>11. <strong>服务依赖管理</strong></h3><ul><li><strong>定义</strong>：管理服务之间的依赖关系，避免循环依赖和单点故障。</li><li><strong>常见措施</strong>：<ul><li>依赖隔离（如线程池隔离）。</li><li>依赖降级（如关闭非核心服务）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Hystrix</strong>：支持依赖隔离和降级。</li><li><strong>Sentinel</strong>：支持依赖流量控制。</li></ul></li></ul><hr><h3 id="12-服务编排与调度"><a href="#12-服务编排与调度" class="headerlink" title="12. 服务编排与调度"></a>12. <strong>服务编排与调度</strong></h3><ul><li><strong>定义</strong>：在容器化环境中，管理服务的部署和调度。</li><li><strong>常见工具</strong>：<ul><li><strong>Kubernetes</strong>：容器编排工具。</li><li><strong>Docker Swarm</strong>：轻量级的容器编排工具。</li></ul></li><li><strong>关键点</strong>：<ul><li>服务的自动扩缩容。</li><li>资源调度和优化。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>服务治理是微服务架构中不可或缺的一部分，涵盖了从服务注册发现到监控告警的多个方面。通过合理的服务治理，可以显著提高系统的稳定性、可维护性和可扩展性。在实际项目中，通常需要结合具体需求选择合适的工具和策略。</p>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡概述</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡常见面试题解析"><a href="#负载均衡常见面试题解析" class="headerlink" title="负载均衡常见面试题解析"></a>负载均衡常见面试题解析</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1-什么是负载均衡？为什么需要它？"><a href="#1-什么是负载均衡？为什么需要它？" class="headerlink" title="1. 什么是负载均衡？为什么需要它？"></a>1. 什么是负载均衡？为什么需要它？</h3><p><strong>答案</strong>：<br>负载均衡是一种将网络请求或计算任务<strong>动态分配</strong>到多个服务器（或资源）的技术，目标是：</p><ul><li><strong>提高系统吞吐量</strong>：避免单个服务器过载。</li><li><strong>增强可用性</strong>：通过故障转移（Failover）避免单点故障。</li><li><strong>优化资源利用率</strong>：合理分配请求，减少资源浪费。</li></ul><h3 id="2-四层负载均衡-vs-七层负载均衡的区别？"><a href="#2-四层负载均衡-vs-七层负载均衡的区别？" class="headerlink" title="2. 四层负载均衡 vs. 七层负载均衡的区别？"></a>2. 四层负载均衡 vs. 七层负载均衡的区别？</h3><p><strong>答案</strong>：  </p><ul><li><strong>四层（L4）</strong>：基于内核态的TCP&#x2F;IP协议栈，通过修改IP&#x2F;TCP头信息实现转发（如DNAT）。性能高（可达到百万级QPS），但无法理解HTTP报文。典型工具：LVS（Linux Virtual Server）。</li><li><strong>七层（L7）</strong>：工作在用户态，解析HTTP&#x2F;HTTPS头部，支持按URL、Cookie等路由。性能较低（通常十万级QPS），但灵活性极强。典型工具：Nginx、Envoy。<br><strong>性能优化</strong>：LVS使用IPVS内核模块避免数据拷贝；Nginx通过epoll多路复用和非阻塞I&#x2F;O提升并发能力。<br><strong>关键区别</strong>：L7能识别应用协议，支持更复杂的路由策略（如按URL分发），但延迟略高。</li></ul><h3 id="3-负载均衡的实现方式有哪些"><a href="#3-负载均衡的实现方式有哪些" class="headerlink" title="3. 负载均衡的实现方式有哪些"></a>3. 负载均衡的实现方式有哪些</h3><p><strong>答案：</strong></p><ul><li><p>代理模式（proxy model）<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250209002825710.png" alt="image-20250209002825710"></p></li><li><p>客户端负载均衡（Balancing-aware Client）</p><ul><li><p>集成式 —— 负载均衡策略解析 与 服务调用发起  动作由同一进程处理</p></li><li><p>拓展式 —— LB 从消费进程移动出来</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250209003310225.png" alt="image-20250209003310225"></p></li></ul></li></ul><hr><h2 id="二、负载均衡算法"><a href="#二、负载均衡算法" class="headerlink" title="二、负载均衡算法"></a>二、负载均衡算法</h2><h3 id="1-常见的负载均衡算法有哪些？"><a href="#1-常见的负载均衡算法有哪些？" class="headerlink" title="1. 常见的负载均衡算法有哪些？"></a>1. 常见的负载均衡算法有哪些？</h3><p><strong>答案</strong>：  </p><ul><li><strong>轮询（Round Robin）</strong>：依次分配请求，适合服务器性能相近的场景。  </li><li><strong>加权轮询（Weighted Round Robin）</strong>：根据服务器权重分配，权重高的处理更多请求。  </li><li><strong>最少连接（Least Connections）</strong>：将请求分发给当前连接数最少的服务器。  </li><li><strong>IP哈希（IP Hash）</strong>：根据客户端IP计算哈希值，固定分配到某台服务器，适合需要会话保持的场景。  </li><li><strong>响应时间加权（Response Time）</strong>：优先选择响应时间短的服务器。</li></ul><h3 id="2-一致性哈希（Consistent-Hashing）解决了什么问题？"><a href="#2-一致性哈希（Consistent-Hashing）解决了什么问题？" class="headerlink" title="2. 一致性哈希（Consistent Hashing）解决了什么问题？"></a>2. 一致性哈希（Consistent Hashing）解决了什么问题？</h3><p><strong>答案</strong>：<br>传统哈希算法在服务器增减时会导致大量请求重新映射，引发缓存雪崩。一致性哈希通过环形哈希空间，仅影响相邻节点，<strong>减少重新映射的比例</strong>，适用于分布式缓存和动态扩缩容场景。</p><hr><h2 id="三、云原生与Kubernetes中的负载均衡"><a href="#三、云原生与Kubernetes中的负载均衡" class="headerlink" title="三、云原生与Kubernetes中的负载均衡"></a>三、云原生与Kubernetes中的负载均衡</h2><h3 id="1-Kubernetes-Service的负载均衡机制"><a href="#1-Kubernetes-Service的负载均衡机制" class="headerlink" title="1. Kubernetes Service的负载均衡机制"></a>1. Kubernetes Service的负载均衡机制</h3><p><strong>核心组件</strong>：</p><ul><li><strong>kube-proxy</strong>：维护节点上的iptables&#x2F;IPVS规则，实现ClusterIP的负载均衡。</li><li><strong>Ingress Controller</strong>：七层负载均衡器（如Nginx Ingress），支持基于Host&#x2F;Path的路由。<br><strong>流量路径</strong>：<br>用户请求 → Ingress (L7) → Service (L4) → Pod</li></ul><h3 id="2-Service-Mesh中的负载均衡（以Istio为例）"><a href="#2-Service-Mesh中的负载均衡（以Istio为例）" class="headerlink" title="2. Service Mesh中的负载均衡（以Istio为例）"></a>2. Service Mesh中的负载均衡（以Istio为例）</h3><p><strong>架构革新</strong>：</p><ul><li><strong>Sidecar模式</strong>：每个Pod部署Envoy代理，实现细粒度流量控制。</li><li><strong>高级策略</strong>：<ul><li>金丝雀发布：按百分比分配流量到新版本。</li><li>熔断与重试：基于响应状态的自动故障隔离。<br><strong>配置示例（Istio VirtualService）</strong>：</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - reviews</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v1</span><br><span class="line">      weight: 90</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v2</span><br><span class="line">      weight: 10</span><br></pre></td></tr></table></figure><hr><h2 id="四、实践与工具"><a href="#四、实践与工具" class="headerlink" title="四、实践与工具"></a>四、实践与工具</h2><h3 id="1-如何用Nginx实现简单的负载均衡？"><a href="#1-如何用Nginx实现简单的负载均衡？" class="headerlink" title="1. 如何用Nginx实现简单的负载均衡？"></a>1. 如何用Nginx实现简单的负载均衡？</h3><p><strong>示例配置</strong>：  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.101:8080</span> weight=<span class="number">3</span>;  <span class="comment"># 加权轮询</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.102:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.103:8080</span> backup;    <span class="comment"># 备用服务器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-什么是健康检查（Health-Check）？"><a href="#2-什么是健康检查（Health-Check）？" class="headerlink" title="2. 什么是健康检查（Health Check）？"></a>2. 什么是健康检查（Health Check）？</h3><p><strong>答案</strong>：<br>负载均衡器定期检测后端服务器的状态（如HTTP 200响应），自动剔除故障节点。分为：</p><ul><li><strong>主动检查</strong>：定时发送探测请求（如每10秒一次）。</li><li><strong>被动检查</strong>：根据请求失败率判断（如连续3次超时标记为不可用）。</li></ul><hr><h2 id="四、高频面试问题"><a href="#四、高频面试问题" class="headerlink" title="四、高频面试问题"></a>四、高频面试问题</h2><h3 id="1-如何实现会话保持（Session-Persistence）？"><a href="#1-如何实现会话保持（Session-Persistence）？" class="headerlink" title="1. 如何实现会话保持（Session Persistence）？"></a>1. 如何实现会话保持（Session Persistence）？</h3><p><strong>答案</strong>：  </p><ul><li><strong>Cookie插入</strong>：负载均衡器注入Cookie记录服务器信息（如AWS ALB的<code>AWSALB</code>）。  </li><li><strong>Redis集中存储</strong>：将Session数据存储在外部缓存，解耦服务器。  </li><li><strong>IP哈希</strong>：同一IP的请求固定到同一服务器（可能导致负载不均）。</li></ul><h3 id="2-负载均衡器本身如何避免成为单点故障？"><a href="#2-负载均衡器本身如何避免成为单点故障？" class="headerlink" title="2. 负载均衡器本身如何避免成为单点故障？"></a>2. 负载均衡器本身如何避免成为单点故障？</h3><p><strong>答案</strong>：  </p><ul><li><strong>集群化部署</strong>：使用主备（Active-Standby）或双活模式（Active-Active）。  </li><li><strong>DNS轮询</strong>：通过DNS将域名解析到多个负载均衡器IP。  </li><li><strong>云服务多可用区</strong>：在AWS、阿里云等平台跨可用区部署。</li></ul><h3 id="3-什么是SSL终结（SSL-Termination）？"><a href="#3-什么是SSL终结（SSL-Termination）？" class="headerlink" title="3. 什么是SSL终结（SSL Termination）？"></a>3. 什么是SSL终结（SSL Termination）？</h3><p><strong>答案</strong>：<br>负载均衡器负责解密HTTPS请求，将明文HTTP请求转发给后端服务器。<strong>优点</strong>是减少后端服务器的计算压力，但需确保内网传输安全（如使用VPC隔离）。</p><hr><h2 id="五、进阶场景"><a href="#五、进阶场景" class="headerlink" title="五、进阶场景"></a>五、进阶场景</h2><h3 id="1-如何处理突发流量？"><a href="#1-如何处理突发流量？" class="headerlink" title="1. 如何处理突发流量？"></a>1. 如何处理突发流量？</h3><p><strong>策略</strong>：  </p><ul><li><strong>自动扩缩容（Auto Scaling）</strong>：根据CPU&#x2F;连接数动态增减服务器。  </li><li><strong>限流与降级</strong>：通过令牌桶或漏桶算法限制请求速率。  </li><li><strong>队列缓冲</strong>：使用消息队列（如Kafka）异步处理请求。</li></ul><h3 id="2-如何实现跨地域负载均衡？"><a href="#2-如何实现跨地域负载均衡？" class="headerlink" title="2. 如何实现跨地域负载均衡？"></a>2. 如何实现跨地域负载均衡？</h3><p><strong>方案</strong>：  </p><ul><li><strong>DNS全局负载均衡（GSLB）</strong>：根据用户地理位置返回最近的IP。  </li><li><strong>Anycast网络</strong>：同一IP在多个地域广播，路由选择最短路径（如Cloudflare）。</li></ul><hr><h2 id="六、面试实战问题"><a href="#六、面试实战问题" class="headerlink" title="六、面试实战问题"></a>六、面试实战问题</h2><ul><li><strong>问题</strong>：某电商大促时，部分服务器CPU飙升，负载均衡如何应对？  </li><li><strong>回答</strong>：结合健康检查快速剔除故障节点，启用自动扩缩容添加新实例，同时配合限流（如Nginx的<code>limit_req</code>）保护后端服务。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>负载均衡不仅要求掌握算法和工具，还需理解其在高可用、扩展性、安全性中的角色。面试中需结合具体场景（如微服务、云原生）展现技术深度。建议动手实践Nginx&#x2F;HAProxy配置，并阅读云厂商（如AWS、阿里云）的负载均衡文档以补充实战经验。</p>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HaProxy 配置详解</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy-配置详解与综合示例"><a href="#HAProxy-配置详解与综合示例" class="headerlink" title="HAProxy 配置详解与综合示例"></a>HAProxy 配置详解与综合示例</h1><h2 id="一、配置文件结构解析"><a href="#一、配置文件结构解析" class="headerlink" title="一、配置文件结构解析"></a>一、配置文件结构解析</h2><p>HAProxy配置文件由5个主要部分组成，优先级从高到低：</p><ol><li><strong>global</strong>：全局系统参数</li><li><strong>defaults</strong>：默认参数模板</li><li><strong>frontend</strong>：客户端连接入口</li><li><strong>backend</strong>：服务端集群配置</li><li><strong>listen</strong>：frontend+backend组合声明</li></ol><h2 id="二、核心配置指令详解"><a href="#二、核心配置指令详解" class="headerlink" title="二、核心配置指令详解"></a>二、核心配置指令详解</h2><h3 id="2-1-全局配置（Global）"><a href="#2-1-全局配置（Global）" class="headerlink" title="2.1 全局配置（Global）"></a>2.1 全局配置（Global）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log 127.0.0.1 local0 info    # 日志服务器配置</span><br><span class="line">    maxconn 100000               # 最大并发连接数</span><br><span class="line">    user haproxy                 # 运行用户</span><br><span class="line">    group haproxy                # 运行组</span><br><span class="line">    nbthread 4                   # 工作线程数（建议等于CPU核心）</span><br><span class="line">    stats socket /var/run/haproxy.sock mode 660 level admin # 管理接口</span><br><span class="line">    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256 # SSL加密套件</span><br><span class="line">    tune.ssl.default-dh-param 2048      # DH参数长度</span><br></pre></td></tr></table></figure><h3 id="2-2-默认配置（Defaults）"><a href="#2-2-默认配置（Defaults）" class="headerlink" title="2.2 默认配置（Defaults）"></a>2.2 默认配置（Defaults）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">    mode http                    # 默认代理模式（http/tcp）</span><br><span class="line">    timeout connect 5s           # 后端连接超时</span><br><span class="line">    timeout client 30s           # 客户端空闲超时</span><br><span class="line">    timeout server 30s           # 服务端响应超时</span><br><span class="line">    option httplog               # 详细HTTP日志</span><br><span class="line">    option dontlognull           # 忽略空连接日志</span><br><span class="line">    option redispatch            # 故障节点重试</span><br><span class="line">    retries 3                    # 最大重试次数</span><br></pre></td></tr></table></figure><h3 id="2-3-前端配置（Frontend）"><a href="#2-3-前端配置（Frontend）" class="headerlink" title="2.3 前端配置（Frontend）"></a>2.3 前端配置（Frontend）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">frontend web-in</span><br><span class="line">    bind *:80</span><br><span class="line">    bind *:443 ssl crt /etc/ssl/certs/example.com.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line">    # 访问控制列表</span><br><span class="line">    acl is_static path_end -i .jpg .css .js</span><br><span class="line">    acl is_api path_beg /api/</span><br><span class="line">    acl is_admin path_beg /admin</span><br><span class="line">    </span><br><span class="line">    # 流量分割</span><br><span class="line">    use_backend static_servers if is_static</span><br><span class="line">    use_backend api_cluster if is_api</span><br><span class="line">    use_backend admin_servers if is_admin</span><br><span class="line">    default_backend web_servers</span><br><span class="line">    </span><br><span class="line">    # 安全防护</span><br><span class="line">    http-request deny if &#123; src_get_gpc0(web-in) gt 10 &#125; # 请求频率限制</span><br><span class="line">    stick-table type ip size 1m expire 10m store gpc0   # 会话追踪表</span><br></pre></td></tr></table></figure><h3 id="2-4-后端配置（Backend）"><a href="#2-4-后端配置（Backend）" class="headerlink" title="2.4 后端配置（Backend）"></a>2.4 后端配置（Backend）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">backend web_servers</span><br><span class="line">    balance leastconn            # 最少连接算法</span><br><span class="line">    cookie SERVERID insert indirect nocache # 会话保持</span><br><span class="line">    </span><br><span class="line">    server web1 192.168.1.101:80 check maxconn 500 cookie s1</span><br><span class="line">    server web2 192.168.1.102:80 check maxconn 500 cookie s2</span><br><span class="line">    server backup 192.168.1.103:80 check backup</span><br><span class="line">    </span><br><span class="line">    # 健康检查配置</span><br><span class="line">    option httpchk GET /health</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    default-server inter 5s fall 3 rise 2</span><br></pre></td></tr></table></figure><h3 id="2-5-监控界面（Stats）"><a href="#2-5-监控界面（Stats）" class="headerlink" title="2.5 监控界面（Stats）"></a>2.5 监控界面（Stats）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen stats</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /haproxy?stats</span><br><span class="line">    stats realm &quot;HAProxy Stats&quot;</span><br><span class="line">    stats auth admin:SecureP@ssw0rd</span><br><span class="line">    stats refresh 10s</span><br><span class="line">    stats show-legends</span><br></pre></td></tr></table></figure><h2 id="三、综合配置示例"><a href="#三、综合配置示例" class="headerlink" title="三、综合配置示例"></a>三、综合配置示例</h2><h3 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h3><p>某电商平台需要部署HAProxy实现以下需求：</p><ol><li>同时支持HTTP和HTTPS访问</li><li>分离静态资源与动态请求</li><li>提供管理后台访问控制</li><li>实现灰度发布功能</li><li>监控与自动故障转移</li><li>防御CC攻击</li></ol><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log local0 info</span><br><span class="line">    maxconn 50000</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    nbthread 8</span><br><span class="line">    tune.ssl.default-dh-param 2048</span><br><span class="line">    stats socket /var/run/haproxy.sock mode 660 level admin</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode http</span><br><span class="line">    timeout connect 5s</span><br><span class="line">    timeout client 30s</span><br><span class="line">    timeout server 30s</span><br><span class="line">    option forwardfor</span><br><span class="line">    option httplog</span><br><span class="line">    option dontlognull</span><br><span class="line">    retries 3</span><br><span class="line"></span><br><span class="line">frontend main</span><br><span class="line">    bind *:80</span><br><span class="line">    bind *:443 ssl crt /etc/ssl/certs/ecommerce.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line">    # 访问控制规则</span><br><span class="line">    acl is_static path_end -i .jpg .css .js .png</span><br><span class="line">    acl is_api path_beg /api/</span><br><span class="line">    acl is_admin path_beg /admin</span><br><span class="line">    acl new_feature path_beg /v2</span><br><span class="line">    acl abusive_conn src_conn_rate gt 50</span><br><span class="line">    </span><br><span class="line">    # 安全策略</span><br><span class="line">    tcp-request connection reject if abusive_conn</span><br><span class="line">    http-request deny if &#123; path -m sub ..; url_dec -m len 1024 &#125;</span><br><span class="line">    </span><br><span class="line">    # 流量路由</span><br><span class="line">    use_backend static_servers if is_static</span><br><span class="line">    use_backend api_servers if is_api</span><br><span class="line">    use_backend admin_servers if is_admin</span><br><span class="line">    use_backend canary_servers if new_feature</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">backend web_servers</span><br><span class="line">    balance roundrobin</span><br><span class="line">    cookie SERVERID insert indirect</span><br><span class="line">    server web01 10.0.1.11:80 check cookie s1</span><br><span class="line">    server web02 10.0.1.12:80 check cookie s2</span><br><span class="line">    server web03 10.0.1.13:80 check cookie s3</span><br><span class="line"></span><br><span class="line">backend static_servers</span><br><span class="line">    balance source</span><br><span class="line">    server static01 10.0.2.21:80 check</span><br><span class="line">    server static02 10.0.2.22:80 check</span><br><span class="line"></span><br><span class="line">backend api_servers</span><br><span class="line">    balance leastconn</span><br><span class="line">    option httpclose</span><br><span class="line">    server api01 10.0.3.31:8080 check maxconn 1000</span><br><span class="line">    server api02 10.0.3.32:8080 check maxconn 1000</span><br><span class="line"></span><br><span class="line">backend admin_servers</span><br><span class="line">    acl valid_ip src 10.0.0.0/24</span><br><span class="line">    http-request deny unless valid_ip</span><br><span class="line">    server admin01 10.0.4.41:8080 check</span><br><span class="line"></span><br><span class="line">backend canary_servers</span><br><span class="line">    server canary01 10.0.5.51:80 check weight 10</span><br><span class="line">    server canary02 10.0.5.52:80 check weight 90</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /stats</span><br><span class="line">    stats auth admin:$&#123;STATS_PASSWORD&#125;</span><br><span class="line">    stats refresh 10s</span><br><span class="line">    stats admin if TRUE</span><br></pre></td></tr></table></figure><h3 id="配置解析与业务对应"><a href="#配置解析与业务对应" class="headerlink" title="配置解析与业务对应"></a>配置解析与业务对应</h3><ol><li><p><strong>SSL&#x2F;TLS配置</strong>：</p><ul><li>同时支持HTTP&#x2F;2和HTTP&#x2F;1.1</li><li>使用2048位DH参数增强安全性</li></ul></li><li><p><strong>流量分类</strong>：</p><ul><li>静态资源路由到专用服务器（CDN架构）</li><li>API请求采用最少连接算法</li><li>管理后台限制IP访问</li></ul></li><li><p><strong>灰度发布</strong>：</p><ul><li>通过路径&#x2F;v2访问新版服务</li><li>Canary服务器权重控制流量比例</li></ul></li><li><p><strong>安全防护</strong>：</p><ul><li>连接速率限制防御CC攻击</li><li>URL长度和路径检测防注入</li></ul></li><li><p><strong>会话保持</strong>：</p><ul><li>Cookie插入实现状态保持</li><li>源IP哈希保障静态资源缓存命中</li></ul></li><li><p><strong>监控管理</strong>：</p><ul><li>独立统计端口带权限控制</li><li>实时健康检查与自动切换</li></ul></li></ol><h2 id="四、配置验证与调优建议"><a href="#四、配置验证与调优建议" class="headerlink" title="四、配置验证与调优建议"></a>四、配置验证与调优建议</h2><ol><li><p><strong>语法检查</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -c -f /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure></li><li><p><strong>性能监控指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 <span class="string">&quot;echo &#x27;show info&#x27; | socat stdio /var/run/haproxy.sock&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>调优参数建议</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tune.bufsize 32768        # 增加缓冲区大小</span><br><span class="line">tune.http.cookielen 128   # 优化Cookie长度</span><br><span class="line">tune.http.maxhdr 100      # 扩展头部数量限制</span><br></pre></td></tr></table></figure></li><li><p><strong>动态调整命令示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disable server web_servers/web03&quot;</span> | socat stdio /var/run/haproxy.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看实时统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show stat&quot;</span> | socat stdio /var/run/haproxy.sock | column -t -s,</span><br></pre></td></tr></table></figure></li></ol><h2 id="五、典型问题解决方案"><a href="#五、典型问题解决方案" class="headerlink" title="五、典型问题解决方案"></a>五、典型问题解决方案</h2><ol><li><p><strong>TIME_WAIT过多</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune.idleclose on         # 启用延迟关闭</span><br><span class="line">option forceclose         # 强制关闭连接</span><br></pre></td></tr></table></figure></li><li><p><strong>内存持续增长</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune.maxrewrite 2048      # 限制缓冲区重写空间</span><br><span class="line">no option http-use-htx    # 禁用实验性HTTP引擎</span><br></pre></td></tr></table></figure></li><li><p><strong>SSL性能瓶颈</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl-engine openssl        # 启用硬件加速</span><br><span class="line">ssl-default-bind-options prefer-client-ciphers</span><br></pre></td></tr></table></figure></li></ol><p>通过以上配置示例和解析，可以快速构建适应高并发、高可用场景的负载均衡方案。实际部署时应根据具体业务需求调整参数，并通过持续监控优化系统表现。</p>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> HAProxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HaProxy 概述</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy深度指南：从配置实战到架构选型"><a href="#HAProxy深度指南：从配置实战到架构选型" class="headerlink" title="HAProxy深度指南：从配置实战到架构选型"></a>HAProxy深度指南：从配置实战到架构选型</h1><h2 id="一、核心概念解析"><a href="#一、核心概念解析" class="headerlink" title="一、核心概念解析"></a>一、核心概念解析</h2><h3 id="1-1-四层-vs-七层代理"><a href="#1-1-四层-vs-七层代理" class="headerlink" title="1.1 四层 vs 七层代理"></a>1.1 四层 vs 七层代理</h3><p>HAProxy同时支持L4(TCP)和L7(HTTP)代理，架构差异如下：</p><table><thead><tr><th>特性</th><th>L4代理</th><th>L7代理</th></tr></thead><tbody><tr><td>协议感知</td><td>无</td><td>有（HTTP解析）</td></tr><tr><td>会话保持</td><td>基于源IP</td><td>基于Cookie&#x2F;Header</td></tr><tr><td>健康检查</td><td>TCP端口检测</td><td>HTTP状态码验证</td></tr><tr><td>典型场景</td><td>数据库负载均衡</td><td>Web应用路由</td></tr></tbody></table><h3 id="1-2-核心组件"><a href="#1-2-核心组件" class="headerlink" title="1.2 核心组件"></a>1.2 核心组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frontend web-in           # 流量入口</span><br><span class="line">    bind *:80</span><br><span class="line">    acl is_api path_beg /api</span><br><span class="line">    use_backend api_cluster if is_api</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">backend web_servers       # 服务集群</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server web1 10.0.1.1:80 check</span><br><span class="line">    server web2 10.0.1.2:80 check</span><br><span class="line"></span><br><span class="line">listen stats              # 监控界面</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /haproxy?stats</span><br></pre></td></tr></table></figure><h2 id="二、配置引擎深度剖析"><a href="#二、配置引擎深度剖析" class="headerlink" title="二、配置引擎深度剖析"></a>二、配置引擎深度剖析</h2><h3 id="2-1-智能ACL系统"><a href="#2-1-智能ACL系统" class="headerlink" title="2.1 智能ACL系统"></a>2.1 智能ACL系统</h3><p>HAProxy的ACL（Access Control List）支持复杂条件组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acl valid_src src 192.168.0.0/24   # 源IP匹配</span><br><span class="line">acl is_post method POST             # HTTP方法</span><br><span class="line">acl json_content hdr_val(Content-Type) -i application/json</span><br><span class="line">acl high_load conn_rate gt 200      # 连接速率</span><br><span class="line"></span><br><span class="line"># 组合条件</span><br><span class="line">use_backend premium if valid_src is_post json_content !high_load</span><br></pre></td></tr></table></figure><h3 id="2-2-负载均衡算法"><a href="#2-2-负载均衡算法" class="headerlink" title="2.2 负载均衡算法"></a>2.2 负载均衡算法</h3><p>HAProxy支持10+种算法，常用算法对比：</p><table><thead><tr><th>算法</th><th>适用场景</th><th>实现复杂度</th><th>会话保持</th></tr></thead><tbody><tr><td>roundrobin</td><td>通用场景</td><td>O(1)</td><td>无</td></tr><tr><td>leastconn</td><td>长连接服务</td><td>O(n)</td><td>无</td></tr><tr><td>source</td><td>IP哈希</td><td>O(1)</td><td>强</td></tr><tr><td>uri</td><td>静态资源缓存</td><td>O(1)</td><td>强</td></tr><tr><td>hdr</td><td>定制头部路由</td><td>O(1)</td><td>强</td></tr></tbody></table><p>动态权重调整示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server web1 10.0.1.1:80 weight 100 check</span><br><span class="line">server web2 10.0.1.2:80 weight 50 check</span><br></pre></td></tr></table></figure><h2 id="三、高性能实现原理"><a href="#三、高性能实现原理" class="headerlink" title="三、高性能实现原理"></a>三、高性能实现原理</h2><h3 id="3-1-事件驱动架构"><a href="#3-1-事件驱动架构" class="headerlink" title="3.1 事件驱动架构"></a>3.1 事件驱动架构</h3><p>HAProxy采用单进程事件驱动模型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_poll_loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取活跃事件</span></span><br><span class="line">        <span class="type">int</span> n = poll(events, MAX_EVENTS, timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理I/O事件</span></span><br><span class="line">            <span class="keyword">if</span> (events[i].revents &amp; POLLIN)</span><br><span class="line">                process_read_event(events[i].fd);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (events[i].revents &amp; POLLOUT)</span><br><span class="line">                process_write_event(events[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理定时任务</span></span><br><span class="line">        process_expired_tasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-零拷贝优化"><a href="#3-2-零拷贝优化" class="headerlink" title="3.2 零拷贝优化"></a>3.2 零拷贝优化</h3><p>HAProxy通过<code>sendfile()</code>系统调用实现零拷贝数据传输：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send_data</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> buffer *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;file) &#123;</span><br><span class="line">        sendfile(fd, buf-&gt;file_fd, &amp;buf-&gt;file_offset, buf-&gt;file_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fd, buf-&gt;data, buf-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、企业级功能特性"><a href="#四、企业级功能特性" class="headerlink" title="四、企业级功能特性"></a>四、企业级功能特性</h2><h3 id="4-1-健康检查机制"><a href="#4-1-健康检查机制" class="headerlink" title="4.1 健康检查机制"></a>4.1 健康检查机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend db_cluster</span><br><span class="line">    option httpchk GET /health</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    server db1 10.0.2.1:3306 check inter 5s rise 2 fall 3</span><br><span class="line">    server db2 10.0.2.2:3306 check backup</span><br></pre></td></tr></table></figure><p>健康检查类型对比：</p><table><thead><tr><th>检查类型</th><th>协议层</th><th>开销</th><th>检测精度</th></tr></thead><tbody><tr><td>TCP Connect</td><td>L4</td><td>低</td><td>中</td></tr><tr><td>HTTP Expect</td><td>L7</td><td>中</td><td>高</td></tr><tr><td>SSL Hello</td><td>L4</td><td>低</td><td>低</td></tr><tr><td>MySQL Ping</td><td>L7</td><td>高</td><td>极高</td></tr></tbody></table><h3 id="4-2-动态配置"><a href="#4-2-动态配置" class="headerlink" title="4.2 动态配置"></a>4.2 动态配置</h3><p>通过Runtime API实现热更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disable server web_servers/web1&quot;</span> | socat stdio /var/run/haproxy.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流量统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show stat&quot;</span> | socat stdio /var/run/haproxy.sock | column -t -s,</span><br></pre></td></tr></table></figure><h2 id="五、横向技术对比"><a href="#五、横向技术对比" class="headerlink" title="五、横向技术对比"></a>五、横向技术对比</h2><h3 id="5-1-负载均衡器选型矩阵"><a href="#5-1-负载均衡器选型矩阵" class="headerlink" title="5.1 负载均衡器选型矩阵"></a>5.1 负载均衡器选型矩阵</h3><table><thead><tr><th>特性</th><th>HAProxy</th><th>Nginx</th><th>LVS</th><th>Traefik</th></tr></thead><tbody><tr><td>协议支持</td><td>L4&#x2F;L7</td><td>L4&#x2F;L7</td><td>L4</td><td>L4&#x2F;L7</td></tr><tr><td>最大并发连接</td><td>100万+</td><td>50万+</td><td>100万+</td><td>10万+</td></tr><tr><td>配置复杂度</td><td>中</td><td>低</td><td>高</td><td>低</td></tr><tr><td>动态配置</td><td>API支持</td><td>需Reload</td><td>不支持</td><td>自动发现</td></tr><tr><td>服务发现集成</td><td>有限</td><td>有限</td><td>无</td><td>原生支持</td></tr><tr><td>SSL Offloading</td><td>支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>典型延迟</td><td>0.2ms</td><td>0.5ms</td><td>0.1ms</td><td>1.2ms</td></tr></tbody></table><h3 id="5-2-性能基准测试"><a href="#5-2-性能基准测试" class="headerlink" title="5.2 性能基准测试"></a>5.2 性能基准测试</h3><p>测试环境：4核CPU&#x2F;8GB RAM，1000并发连接</p><table><thead><tr><th>工具</th><th>请求速率 (req&#x2F;s)</th><th>内存占用</th><th>长连接支持</th></tr></thead><tbody><tr><td>HAProxy 2.8</td><td>98,000</td><td>120MB</td><td>优秀</td></tr><tr><td>Nginx 1.25</td><td>75,000</td><td>220MB</td><td>良好</td></tr><tr><td>Envoy 1.28</td><td>82,000</td><td>350MB</td><td>优秀</td></tr><tr><td>Traefik 2.10</td><td>45,000</td><td>280MB</td><td>一般</td></tr></tbody></table><h2 id="六、安全加固实践"><a href="#六、安全加固实践" class="headerlink" title="六、安全加固实践"></a>六、安全加固实践</h2><h3 id="6-1-DDoS防护配置"><a href="#6-1-DDoS防护配置" class="headerlink" title="6.1 DDoS防护配置"></a>6.1 DDoS防护配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frontend http-in</span><br><span class="line">    # 连接速率限制</span><br><span class="line">    stick-table type ip size 1m expire 10s store conn_rate(3s)</span><br><span class="line">    tcp-request connection track-sc0 src</span><br><span class="line">    tcp-request connection reject if &#123; sc0_conn_rate gt 50 &#125;</span><br><span class="line">    </span><br><span class="line">    # 请求频率限制</span><br><span class="line">    acl abuse_requests req.rate ge 100</span><br><span class="line">    http-request deny if abuse_requests</span><br></pre></td></tr></table></figure><h3 id="6-2-SSL最佳实践"><a href="#6-2-SSL最佳实践" class="headerlink" title="6.2 SSL最佳实践"></a>6.2 SSL最佳实践</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind *:443 ssl crt /etc/ssl/certs/example.com.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line"># 启用TLS 1.3</span><br><span class="line">ssl-default-server-options no-sslv3 no-tlsv10 no-tlsv11 no-tlsv12</span><br><span class="line">ssl-server-options prefer-client-ciphers</span><br><span class="line">ssl-server-options no-tls-tickets</span><br></pre></td></tr></table></figure><h2 id="七、云原生集成"><a href="#七、云原生集成" class="headerlink" title="七、云原生集成"></a>七、云原生集成</h2><h3 id="7-1-Kubernetes-Ingress配置"><a href="#7-1-Kubernetes-Ingress配置" class="headerlink" title="7.1 Kubernetes Ingress配置"></a>7.1 Kubernetes Ingress配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">haproxy.org/ssl-redirect:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">haproxy.org/backend-config-snippet:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      balance leastconn</span></span><br><span class="line"><span class="string">      timeout server 30s</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">haproxy</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">app.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">web-service</span></span><br><span class="line">            <span class="attr">port:</span> </span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="7-2-Prometheus监控集成"><a href="#7-2-Prometheus监控集成" class="headerlink" title="7.2 Prometheus监控集成"></a>7.2 Prometheus监控集成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen stats</span><br><span class="line">    bind *:9101</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /metrics</span><br><span class="line">    stats show-legends</span><br><span class="line">    stats prometheus</span><br></pre></td></tr></table></figure><h2 id="八、调试与优化"><a href="#八、调试与优化" class="headerlink" title="八、调试与优化"></a>八、调试与优化</h2><h3 id="8-1-实时调试技巧"><a href="#8-1-实时调试技巧" class="headerlink" title="8.1 实时调试技巧"></a>8.1 实时调试技巧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取流量日志</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w haproxy.pcap port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态日志级别调整</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show info&quot;</span> | socat stdio /var/run/haproxy.sock | grep Debug</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;debug 2&quot;</span> | socat stdio /var/run/haproxy.sock</span><br></pre></td></tr></table></figure><h3 id="8-2-内核参数调优"><a href="#8-2-内核参数调优" class="headerlink" title="8.2 内核参数调优"></a>8.2 内核参数调优</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提升端口复用</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse=1</span><br><span class="line">sysctl -w net.ipv4.tcp_max_tw_buckets=2000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加文件描述符限制</span></span><br><span class="line">sysctl -w fs.file-max=1000000</span><br><span class="line"><span class="built_in">ulimit</span> -n 1000000</span><br></pre></td></tr></table></figure><h2 id="九、架构演进趋势"><a href="#九、架构演进趋势" class="headerlink" title="九、架构演进趋势"></a>九、架构演进趋势</h2><h3 id="9-1-eBPF加速"><a href="#9-1-eBPF加速" class="headerlink" title="9.1 eBPF加速"></a>9.1 eBPF加速</h3><p>HAProxy 2.8+支持eBPF实现高性能路由：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">    BPF_LDX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, offsetof(<span class="keyword">struct</span> __sk_buff, data)),</span><br><span class="line">    BPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_1, offsetof(<span class="keyword">struct</span> __sk_buff, data_end)),</span><br><span class="line">    <span class="comment">// 包解析逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-2-QUIC-HTTP3支持"><a href="#9-2-QUIC-HTTP3支持" class="headerlink" title="9.2 QUIC&#x2F;HTTP3支持"></a>9.2 QUIC&#x2F;HTTP3支持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frontend quic-in</span><br><span class="line">    bind :443 quic4</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">    # 启用HTTP/3</span><br><span class="line">    quic-force-retry on</span><br><span class="line">    quic-socket-owner listener</span><br></pre></td></tr></table></figure><h2 id="结语：负载均衡器的技术演进"><a href="#结语：负载均衡器的技术演进" class="headerlink" title="结语：负载均衡器的技术演进"></a>结语：负载均衡器的技术演进</h2><p>HAProxy凭借其卓越的性能、灵活的配置能力和企业级功能特性，在云原生时代持续保持技术竞争力。通过深入理解其架构原理和最佳实践，开发者可以构建出既具备高可用性，又能应对复杂业务场景的现代负载均衡体系。随着eBPF、QUIC等新技术的不断集成，HAProxy正在向更智能、更高效的下一代代理架构演进。</p>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S 服务注册、发现 与 负载均衡 原理解析</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/K8S%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/K8S%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="K8S-服务注册、发现-与-负载均衡-原理解析"><a href="#K8S-服务注册、发现-与-负载均衡-原理解析" class="headerlink" title="K8S 服务注册、发现 与 负载均衡 原理解析"></a>K8S 服务注册、发现 与 负载均衡 原理解析</h1><p>在 Kubernetes（K8S）集群中，服务注册、发现与负载均衡是确保微服务架构高效运行的核心机制。这些机制共同解决了分布式系统中服务实例动态变化、流量分配以及高可用性等问题。本文将系统、专业地解析这些机制的原理，并提供详细的配置示例，帮助读者深入理解 K8S 的工作方式。</p><h2 id="一、服务注册原理"><a href="#一、服务注册原理" class="headerlink" title="一、服务注册原理"></a>一、服务注册原理</h2><h3 id="1-1-服务注册的概念"><a href="#1-1-服务注册的概念" class="headerlink" title="1.1 服务注册的概念"></a>1.1 服务注册的概念</h3><p>服务注册是指将服务实例的相关信息（如 IP 地址、端口号等）记录到一个中心化的注册中心，以便其他服务能够发现并调用这些服务。在 K8S 中，服务注册主要通过 <strong>API Server</strong> 和 <strong>etcd</strong> 来实现。</p><h3 id="1-2-服务注册的流程"><a href="#1-2-服务注册的流程" class="headerlink" title="1.2 服务注册的流程"></a>1.2 服务注册的流程</h3><ul><li><strong>Pod 创建时注册</strong>：当一个新的 Pod 创建时，Kubelet 会将该 Pod 的信息（包括 IP 地址、端口号等）注册到 API Server。</li><li><strong>API Server 存储信息</strong>：API Server 接收到 Pod 信息后，将其存储到 etcd 中。</li><li><strong>Service 关联 Pod</strong>：Service 通过标签选择器（Label Selector）与 Pod 进行关联。当 Service 创建时，API Server 会根据标签选择器找到匹配的 Pod，并将这些 Pod 的信息存储在 Endpoints 资源中。</li></ul><h2 id="二、服务发现原理"><a href="#二、服务发现原理" class="headerlink" title="二、服务发现原理"></a>二、服务发现原理</h2><h3 id="2-1-服务发现的概念"><a href="#2-1-服务发现的概念" class="headerlink" title="2.1 服务发现的概念"></a>2.1 服务发现的概念</h3><p>服务发现是指客户端能够通过某种方式找到服务实例的地址信息，从而实现服务调用。K8S 提供了多种服务发现方式，主要包括 <strong>DNS</strong> 和 <strong>环境变量</strong>。</p><h3 id="2-2-服务发现的实现方式"><a href="#2-2-服务发现的实现方式" class="headerlink" title="2.2 服务发现的实现方式"></a>2.2 服务发现的实现方式</h3><ul><li><strong>DNS 服务发现</strong>：K8S 集群中内置了 DNS 服务（如 CoreDNS），每个 Service 都会被分配一个稳定的虚拟 IP（Cluster IP）。客户端可以通过 DNS 查询 Service 的名称，获取其 Cluster IP，进而访问后端的 Pod。</li><li><strong>环境变量</strong>：当 Pod 启动时，Kubelet 会为每个活跃的 Service 添加一组环境变量，包含服务的 IP 和端口信息。客户端可以通过这些环境变量直接访问服务。</li></ul><h3 id="2-3-Endpoints-的作用"><a href="#2-3-Endpoints-的作用" class="headerlink" title="2.3 Endpoints 的作用"></a>2.3 Endpoints 的作用</h3><p>Endpoints 资源对象存储了 Service 后端 Pod 的地址信息（包括 IP 地址和端口号）。当 Pod 的状态发生变化（如增加、删除或更新）时，Endpoints 会自动更新，确保 Service 能够找到正确的后端 Pod。</p><h2 id="三、负载均衡原理"><a href="#三、负载均衡原理" class="headerlink" title="三、负载均衡原理"></a>三、负载均衡原理</h2><h3 id="3-1-负载均衡的概念"><a href="#3-1-负载均衡的概念" class="headerlink" title="3.1 负载均衡的概念"></a>3.1 负载均衡的概念</h3><p>负载均衡是指将进入系统的请求分配到多个服务实例上，以实现资源的合理利用和服务的持续可用。K8S 的负载均衡机制可以确保流量均匀分配到后端的 Pod，提高系统的可用性和性能。</p><h3 id="3-2-负载均衡的实现方式"><a href="#3-2-负载均衡的实现方式" class="headerlink" title="3.2 负载均衡的实现方式"></a>3.2 负载均衡的实现方式</h3><ul><li><strong>Service 类型</strong>：K8S 提供了多种 Service 类型，包括 ClusterIP、NodePort、LoadBalancer 和 ExternalName。其中，ClusterIP 是默认类型，它会为 Service 分配一个仅在集群内部可访问的虚拟 IP。</li><li><strong>kube-proxy 的作用</strong>：kube-proxy 是 K8S 的网络代理组件，运行在每个节点上。它通过监听 API Server 的 Service 和 Endpoints 资源的变化，动态更新节点上的 iptables 或 IPVS 规则，从而实现负载均衡。</li><li><strong>负载均衡策略</strong>：K8S 支持多种负载均衡策略，包括轮询（Round Robin）、最少连接（Least Connections）和 IP 哈希（IP Hash）。这些策略可以根据实际需求进行配置。</li></ul><h3 id="3-3-负载均衡的工作机制"><a href="#3-3-负载均衡的工作机制" class="headerlink" title="3.3 负载均衡的工作机制"></a>3.3 负载均衡的工作机制</h3><p>当客户端请求到达 Service 的 Cluster IP 时，kube-proxy 会根据配置的负载均衡策略，将请求转发到相应的 Pod。如果某个 Pod 出现故障，kube-proxy 会自动将流量转移到其他健康的 Pod，确保服务的高可用性。</p><h2 id="四、实际应用中的注意事项"><a href="#四、实际应用中的注意事项" class="headerlink" title="四、实际应用中的注意事项"></a>四、实际应用中的注意事项</h2><h3 id="4-1-选择合适的-Service-类型"><a href="#4-1-选择合适的-Service-类型" class="headerlink" title="4.1 选择合适的 Service 类型"></a>4.1 选择合适的 Service 类型</h3><ul><li><strong>ClusterIP</strong>：适用于集群内部的服务访问，提供稳定的内部访问接口。</li><li><strong>NodePort</strong>：允许从集群外部通过节点的 IP 地址和指定端口访问服务，适用于简单的外部访问。</li><li><strong>LoadBalancer</strong>：通常与云服务提供商的负载均衡器结合使用，适用于需要高性能和高可用性的外部服务。</li><li><strong>ExternalName</strong>：将 Service 映射到一个外部名称（如域名），适用于需要将外部服务接入到 K8S 集群中的场景。</li></ul><h3 id="4-2-优化-kube-proxy-配置"><a href="#4-2-优化-kube-proxy-配置" class="headerlink" title="4.2 优化 kube-proxy 配置"></a>4.2 优化 kube-proxy 配置</h3><ul><li><p><strong>性能优化</strong>：可以通过调整 kube-proxy 的配置参数（如连接超时时间、最大连接数等）来优化负载均衡的性能。例如，可以通过以下配置文件调整 kube-proxy 的行为：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">&quot;iptables&quot;</span></span><br><span class="line"><span class="attr">iptables:</span></span><br><span class="line">  <span class="attr">masqueradeBit:</span> <span class="number">14</span></span><br><span class="line">  <span class="attr">masqueradeAll:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">syncPeriod:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line"><span class="attr">conntrack:</span></span><br><span class="line">  <span class="attr">maxPerCore:</span> <span class="number">32768</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">131072</span></span><br><span class="line">  <span class="attr">tcpEstablishedTimeout:</span> <span class="string">&quot;24h&quot;</span></span><br><span class="line">  <span class="attr">tcpCloseWaitTimeout:</span> <span class="string">&quot;1h&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>健康检查</strong>：启用 Pod 的健康检查（如 Liveness Probes 和 Readiness Probes），确保 kube-proxy 只将流量转发到健康的 Pod。</p></li></ul><h3 id="4-3-使用-Ingress-进行高级路由"><a href="#4-3-使用-Ingress-进行高级路由" class="headerlink" title="4.3 使用 Ingress 进行高级路由"></a>4.3 使用 Ingress 进行高级路由</h3><p>Ingress 是 K8S 中用于管理外部访问的资源，可以提供更复杂的路由规则和负载均衡策略。通过配置 Ingress，可以实现基于域名、路径等的路由转发，进一步优化服务的访问体验。以下是一个简单的 Ingress 配置示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/service1</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/service2</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="五、配置示例"><a href="#五、配置示例" class="headerlink" title="五、配置示例"></a>五、配置示例</h2><h3 id="5-1-创建一个简单的-Service"><a href="#5-1-创建一个简单的-Service" class="headerlink" title="5.1 创建一个简单的 Service"></a>5.1 创建一个简单的 Service</h3><p>以下是一个创建 <code>type: ClusterIP</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><h3 id="5-2-创建一个-NodePort-类型的-Service"><a href="#5-2-创建一个-NodePort-类型的-Service" class="headerlink" title="5.2 创建一个 NodePort 类型的 Service"></a>5.2 创建一个 NodePort 类型的 Service</h3><p>以下是一个创建 <code>type: NodePort</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30007</span></span><br></pre></td></tr></table></figure><h3 id="5-3-创建一个-LoadBalancer-类型的-Service"><a href="#5-3-创建一个-LoadBalancer-类型的-Service" class="headerlink" title="5.3 创建一个 LoadBalancer 类型的 Service"></a>5.3 创建一个 LoadBalancer 类型的 Service</h3><p>以下是一个创建 <code>type: LoadBalancer</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure><h2 id="六、-完整流程说明"><a href="#六、-完整流程说明" class="headerlink" title="六、 完整流程说明"></a>六、 完整流程说明</h2><p>在 Kubernetes 中，一个被调用方的 Pod 启动后关联到 Service，以及调用方 Pod 如何找到并调用该 Pod 的过程，是一个涉及多个组件协同工作的复杂流程。以下是全面详细的流程解析：</p><h3 id="1、被调用方-Pod-启动并关联到-Service-的"><a href="#1、被调用方-Pod-启动并关联到-Service-的" class="headerlink" title="1、被调用方 Pod 启动并关联到 Service 的"></a>1、被调用方 Pod 启动并关联到 Service 的</h3><h4 id="Pod-创建与启动"><a href="#Pod-创建与启动" class="headerlink" title="Pod 创建与启动"></a><strong>Pod 创建与启动</strong></h4><ul><li><p>用户通过 <code>kubectl</code> 或 Kubernetes API 创建一个 Pod，例如通过部署一个 Deployment：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-app-container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">my-app-image</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>Kubernetes 调度器（Scheduler）根据资源需求和调度策略将 Pod 分配到某个节点（Node）上，Kubelet 在该节点上启动 Pod。</p></li></ul><h4 id="Service-的创建与定义"><a href="#Service-的创建与定义" class="headerlink" title="Service 的创建与定义"></a><strong>Service 的创建与定义</strong></h4><ul><li><p>用户创建一个 Service 来暴露 Pod 提供的服务，例如创建一个 ClusterIP 类型的 Service：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>Kubernetes 控制平面（API Server）接收到 Service 的定义后，会为该 Service 分配一个内部虚拟 IP（ClusterIP），并将其存储在 etcd 中。</p></li></ul><h4 id="Endpoints-的自动发现与关联"><a href="#Endpoints-的自动发现与关联" class="headerlink" title="Endpoints 的自动发现与关联"></a><strong>Endpoints 的自动发现与关联</strong></h4><ul><li>当 Pod 启动并运行后，Kubernetes 的控制器管理器（Controller Manager）中的 Endpoint Controller 会持续监控 Pod 的状态和 Service 的定义。</li><li>Endpoint Controller 根据 Service 的标签选择器（Label Selector）找到匹配的 Pod，并将这些 Pod 的 IP 地址和端口号信息写入到对应的 Endpoints 资源中。</li><li>例如，如果 Service 的标签选择器是 <code>app: my-app</code>，那么所有带有 <code>app: my-app</code> 标签的 Pod 都会被关联到该 Service 的 Endpoints 中。</li></ul><h4 id="DNS-注册与解析"><a href="#DNS-注册与解析" class="headerlink" title="DNS 注册与解析"></a><strong>DNS 注册与解析</strong></h4><ul><li>Kubernetes 内置的 DNS 服务（如 CoreDNS）会自动将 Service 的名称注册到 DNS 中，使得 Service 可以通过名称进行解析。</li><li>当调用方 Pod 需要访问该 Service 时，它会通过 DNS 查询 Service 的名称，DNS 服务会返回 Service 的 ClusterIP。</li></ul><h3 id="2、调用方-Pod-如何找到并调用被调用方-Pod-的过程"><a href="#2、调用方-Pod-如何找到并调用被调用方-Pod-的过程" class="headerlink" title="2、调用方 Pod 如何找到并调用被调用方 Pod 的过程"></a>2、调用方 Pod 如何找到并调用被调用方 Pod 的过程</h3><ol><li><strong>DNS 查询与解析</strong><ul><li>调用方 Pod 通过 DNS 查询被调用方 Service 的名称，例如 <code>my-app-service</code>。</li><li>DNS 服务将 Service 的名称解析为对应的 ClusterIP，调用方 Pod 获得该 ClusterIP。</li></ul></li><li><strong>kube-proxy 的负载均衡</strong><ul><li>调用方 Pod 将请求发送到 Service 的 ClusterIP，该 ClusterIP 是一个虚拟 IP，由 kube-proxy 管理。</li><li>kube-proxy 运行在每个节点上，它维护着节点上的网络规则，当请求到达 ClusterIP 时，kube-proxy 会根据配置的负载均衡策略（如轮询、最少连接等）将请求转发到后端的某个 Pod。</li><li>kube-proxy 支持多种代理模式，如用户空间（User Space）、iptables 和 IPVS，这些模式在性能和灵活性上各有优劣。</li></ul></li><li><strong>请求转发与 Pod 通信</strong><ul><li>kube-proxy 根据 Endpoints 资源中记录的 Pod 列表，选择一个健康的 Pod，并将请求转发到该 Pod 的 IP 地址和端口号上。</li><li>被调用方 Pod 接收到请求后，处理请求并返回响应，响应数据通过相同的路径返回到调用方 Pod。</li></ul></li><li><strong>健康检查与动态更新</strong><ul><li>如果某个 Pod 出现故障（如容器崩溃或网络问题），Kubernetes 的健康检查机制（如 Liveness Probe 和 Readiness Probe）会检测到该 Pod 不可用。</li><li>Endpoint Controller 会自动将故障 Pod 从 Endpoints 资源中移除，kube-proxy 会更新其内部的转发规则，确保后续请求不会被转发到故障 Pod。</li><li>当新的 Pod 创建并加入 Service 时，Endpoint Controller 会将其添加到 Endpoints 资源中，kube-proxy 会动态更新转发规则，使其能够接收请求。</li></ul></li></ol><p>通过上述流程，Kubernetes 实现了 Pod 的动态注册、发现和负载均衡，确保了服务的高可用性和可扩展性。调用方 Pod 可以通过稳定的 Service 名称或 ClusterIP 访问后端的 Pod，而无需关心 Pod 的具体 IP 地址和数量变化。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>K8S 的服务注册、发现与负载均衡机制为微服务架构提供了强大的支持。通过合理配置 Service 类型、优化 kube-proxy 参数以及使用 Ingress 进行高级路由，可以实现高效、可靠的服务通信和流量管理。</p>]]></content>
      
      
      <categories>
          
          <category> 云原生 </category>
          
          <category> 服务治理 </category>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
            <tag> 云原生 </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX 进阶</title>
      <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="NGINX-进阶"><a href="#NGINX-进阶" class="headerlink" title="NGINX 进阶"></a>NGINX 进阶</h1><h2 id="一、NGINX架构设计核心"><a href="#一、NGINX架构设计核心" class="headerlink" title="一、NGINX架构设计核心"></a>一、NGINX架构设计核心</h2><h3 id="1-1-多进程模型"><a href="#1-1-多进程模型" class="headerlink" title="1.1 多进程模型"></a>1.1 多进程模型</h3><p>NGINX采用经典的主从多进程架构，包含1个Master进程和N个Worker进程（N通常等于CPU核心数），其中：</p><ul><li><p>Master 进程主要用来管理 Worker 进程，包含：</p><ul><li>接收来自外界的信号，向各 Worker 进程发送信号，</li><li>监控 Worker 进程的运行状态，当 Worker 进程异常退出后，会自动重新启动新的 Worker 进程。</li></ul></li><li><p>Worker 进程则负责处理基本的网络事件。</p><ul><li>多个 Worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</li><li>一个请求，只可能在一个 Worker 进程中处理，一个 Worker 进程，不可能处理其它进程的请求。</li></ul></li></ul><p>这种设计实现了：</p><ol><li><strong>热部署与零停机更新</strong>：通过<code>execve()</code>系统调用原子替换二进制文件</li><li><strong>异常隔离机制</strong>：Worker进程崩溃不会影响整体服务</li><li><strong>特权分离设计</strong>：Master进程以root身份运行，Worker以降权身份执行</li></ol><p>Nginx 的进程模型，可以由下图来表示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250208010821759.png" alt="image-20250208010821759" style="zoom:67%;" /><h4 id="1-1-1-热升级技术实现"><a href="#1-1-1-热升级技术实现" class="headerlink" title="1.1.1 热升级技术实现"></a>1.1.1 热升级技术实现</h4><p>零宕机升级流程：</p><ol><li>旧Master收到USR2信号，执行execve()加载新二进制</li><li>新旧Worker共存，旧Worker完成现有请求后退出</li><li>新Master通过进程间通信获取旧配置状态</li></ol><p>关键代码路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热升级处理</span></span><br><span class="line">ngx_exec_new_binary(cycle, argv) &#123;</span><br><span class="line">    ngx_write_channel(ngx_processes[s].channel[<span class="number">0</span>],</span><br><span class="line">                      &amp;ch, <span class="keyword">sizeof</span>(<span class="type">ngx_channel_t</span>), cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line">    execve(path, argv, environ);  <span class="comment">// 原子替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工程挑战</strong>：共享内存的版本兼容性管理。NGINX采用版本标记和回退机制确保平滑过渡。</p><h3 id="1-2-事件驱动架构"><a href="#1-2-事件驱动架构" class="headerlink" title="1.2 事件驱动架构"></a>1.2 事件驱动架构</h3><h4 id="1-2-1-Reactor模式实现"><a href="#1-2-1-Reactor模式实现" class="headerlink" title="1.2.1 Reactor模式实现"></a>1.2.1 Reactor模式实现</h4><p>NGINX采用主从Reactor变体：</p><ul><li>Main Reactor：负责Accept新连接（通过EPOLLEXCLUSIVE避免惊群）</li><li>Sub Reactor：Worker进程独立的事件循环处理I&#x2F;O</li></ul><p>事件处理核心逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理网络事件</span></span><br><span class="line">    (<span class="type">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理定时器事件</span></span><br><span class="line">    <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        ngx_event_expire_timers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理后延事件</span></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-Epoll深度优化"><a href="#1-2-2-Epoll深度优化" class="headerlink" title="1.2.2 Epoll深度优化"></a>1.2.2 Epoll深度优化</h4><p>NGINX对epoll的极致优化体现在：</p><ol><li><p><strong>事件触发模式</strong>：</p><ul><li>默认采用边沿触发（EPOLLET），减少事件通知次数</li><li>结合非阻塞I&#x2F;O实现完全异步处理</li></ul></li><li><p><strong>高效内存管理</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预分配事件对象</span></span><br><span class="line">event_list = ngx_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * nevents, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量处理事件</span></span><br><span class="line">nevents = epoll_wait(ep, event_list, nevents, timer);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nevents; i++) &#123;</span><br><span class="line">    <span class="comment">// 事件分发逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>时间精度控制</strong>：</p><ul><li>定时器红黑树实现O(log n)复杂度</li><li>时间缓存机制减少系统调用</li></ul></li></ol><p><strong>性能对比</strong>：</p><table><thead><tr><th align="left">连接数</th><th align="left">select</th><th align="left">poll</th><th align="left">epoll</th></tr></thead><tbody><tr><td align="left">1k</td><td align="left">2.1ms</td><td align="left">1.8ms</td><td align="left">0.3ms</td></tr><tr><td align="left">10k</td><td align="left">24ms</td><td align="left">22ms</td><td align="left">0.8ms</td></tr><tr><td align="left">100k</td><td align="left">内存溢出</td><td align="left">超时</td><td align="left">1.2ms</td></tr></tbody></table><h3 id="1-3-模块化设计体系"><a href="#1-3-模块化设计体系" class="headerlink" title="1.3 模块化设计体系"></a>1.3 模块化设计体系</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-a21dc54d422d860eb38cde7898003de8_1440w.jpg" alt="img"></p><p>NGINX采用<strong>层次化模块架构</strong>，各模块通过严格的接口规范进行通信。模块类型可分为：</p><ul><li><strong>核心模块</strong>：ngx_core_module（进程管理）、ngx_events_module（事件驱动）</li><li><strong>协议模块</strong>：ngx_http_module、ngx_stream_module</li><li><strong>功能模块</strong>：ngx_http_proxy_module、ngx_http_rewrite_module</li><li><strong>第三方模块</strong>：OpenResty生态的lua-nginx-module</li></ul><p>模块注册机制示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_str_t</span>             name;</span><br><span class="line">    <span class="type">void</span>               *(*create_conf)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="type">char</span>               *(*init_conf)(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *conf);</span><br><span class="line">&#125; <span class="type">ngx_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP模块注册示例</span></span><br><span class="line"><span class="type">ngx_module_t</span> ngx_http_core_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_core_module_ctx,    <span class="comment">/* 模块上下文 */</span></span><br><span class="line">    ngx_http_core_commands,       <span class="comment">/* 模块指令集 */</span></span><br><span class="line">    NGX_HTTP_MODULE,              <span class="comment">/* 模块类型 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-1-模块执行阶段"><a href="#1-3-1-模块执行阶段" class="headerlink" title="1.3.1  模块执行阶段"></a>1.3.1  模块执行阶段</h4><p>HTTP请求处理流程被划分为11个阶段（PHASE），模块通过挂载回调函数参与处理：</p><table><thead><tr><th>阶段顺序</th><th>阶段名称</th><th>典型模块</th></tr></thead><tbody><tr><td>1</td><td>POST_READ</td><td>realip模块</td></tr><tr><td>3</td><td>SERVER_REWRITE</td><td>rewrite模块</td></tr><tr><td>8</td><td>CONTENT</td><td>proxy_pass&#x2F;fastcgi</td></tr><tr><td>10</td><td>LOG</td><td>access_log</td></tr></tbody></table><p>阶段处理伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; NGX_HTTP_MAX_PHASE; phase++) &#123;</span><br><span class="line">    h = cmcf-&gt;phases[phase].handlers.elts;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cmcf-&gt;phases[phase].handlers.nelts; i++) &#123;</span><br><span class="line">        rc = h[i](r);  <span class="comment">// 执行阶段处理函数</span></span><br><span class="line">        <span class="keyword">if</span> (rc != NGX_OK) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计难点</strong>：模块执行顺序的确定性保障。NGINX通过显式定义模块优先级（NGX_MODULE_V1的index字段）解决依赖问题，确保关键模块（如rewrite）优先执行。</p><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-内存池设计"><a href="#2-1-内存池设计" class="headerlink" title="2.1 内存池设计"></a>2.1 内存池设计</h3><p>NGINX采用分级内存池管理机制：</p><ul><li>请求级内存池：4KB~16MB（根据<code>client_body_buffer_size</code>配置）</li><li>连接级内存池：固定256字节</li><li>全局内存池：使用slab分配器管理共享内存</li></ul><p>内存回收策略示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 共享内存配置示例</span><br><span class="line">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m </span><br><span class="line">                 inactive=60m use_temp_path=off max_size=1g;</span><br></pre></td></tr></table></figure><h3 id="2-2-内存对齐与性能优化"><a href="#2-2-内存对齐与性能优化" class="headerlink" title="2.2 内存对齐与性能优化"></a>2.2 内存对齐与性能优化</h3><p>NGINX通过<code>NGX_ALIGNMENT</code>宏实现严格的内存对齐（通常为16字节）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_ALIGNMENT   sizeof(unsigned long)    <span class="comment">/* platform word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br></pre></td></tr></table></figure><p>实测数据表明，严格对齐可提升内存访问效率达15%-20%。</p><h2 id="三、负载均衡算法实现内幕"><a href="#三、负载均衡算法实现内幕" class="headerlink" title="三、负载均衡算法实现内幕"></a>三、负载均衡算法实现内幕</h2><h3 id="3-1-一致性哈希的深度优化"><a href="#3-1-一致性哈希的深度优化" class="headerlink" title="3.1 一致性哈希的深度优化"></a>3.1 一致性哈希的深度优化</h3><p>NGINX在<code>ngx_http_upstream_hash_module</code>中实现了改进型一致性哈希：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟节点生成算法</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ngx_http_upstream_chash</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span> &#123;</span><br><span class="line">    u_char *name = r-&gt;upstream-&gt;hash.key.data;</span><br><span class="line">    <span class="type">uint32_t</span> hash = ngx_crc32_long(name, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟节点数=真实节点数*160</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">160</span>; i++) &#123;</span><br><span class="line">        point = hash * <span class="number">2862933555777941757ULL</span> + i;</span><br><span class="line">        <span class="comment">// 红黑树插入逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法通过虚拟节点数动态调整实现了：</p><ul><li>节点扩容时数据迁移量 &lt; 10%</li><li>请求分布标准差 &lt; 5%</li></ul><h3 id="3-2-动态权重调整算法"><a href="#3-2-动态权重调整算法" class="headerlink" title="3.2 动态权重调整算法"></a>3.2 动态权重调整算法</h3><p>在加权轮询（Weighted Round Robin）中，NGINX采用GCD（最大公约数）优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span> </span><br><span class="line"><span class="title function_">ngx_http_upstream_get_peer</span><span class="params">(<span class="type">ngx_peer_connection_t</span> *pc)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        peer = &amp;rrp-&gt;peers-&gt;peer[rrp-&gt;current];</span><br><span class="line">        <span class="comment">// 权重动态计算逻辑</span></span><br><span class="line">        best = current;</span><br><span class="line">        <span class="keyword">if</span> (peer-&gt;effective_weight &gt; best-&gt;effective_weight) &#123;</span><br><span class="line">            best = peer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、缓存系统的工程实践"><a href="#四、缓存系统的工程实践" class="headerlink" title="四、缓存系统的工程实践"></a>四、缓存系统的工程实践</h2><h3 id="4-1-缓存淘汰算法创新"><a href="#4-1-缓存淘汰算法创新" class="headerlink" title="4.1 缓存淘汰算法创新"></a>4.1 缓存淘汰算法创新</h3><p>NGINX采用LRU-K算法改进传统LRU：</p><table><thead><tr><th align="left">算法</th><th align="left">时间复杂度</th><th align="left">缓存命中率</th><th align="left">实现复杂度</th></tr></thead><tbody><tr><td align="left">LRU</td><td align="left">O(1)</td><td align="left">65%</td><td align="left">低</td></tr><tr><td align="left">LFU</td><td align="left">O(1)</td><td align="left">72%</td><td align="left">中</td></tr><tr><td align="left">LRU-2</td><td align="left">O(log n)</td><td align="left">85%</td><td align="left">高</td></tr><tr><td align="left">NGINX改进</td><td align="left">O(1)</td><td align="left">82%</td><td align="left">中</td></tr></tbody></table><h3 id="4-2-缓存锁的优化策略"><a href="#4-2-缓存锁的优化策略" class="headerlink" title="4.2 缓存锁的优化策略"></a>4.2 缓存锁的优化策略</h3><p>NGINX使用自旋锁+互斥锁的混合锁方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_shmtx_lock</span><span class="params">(<span class="type">ngx_shmtx_t</span> *mtx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_atomic_cmp_set(&amp;mtx-&gt;lock, <span class="number">0</span>, ngx_pid)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ngx_ncpu &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; mtx-&gt;spin; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ngx_cpu_pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入休眠等待</span></span><br><span class="line">        ngx_sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、性能调优实战指南"><a href="#五、性能调优实战指南" class="headerlink" title="五、性能调优实战指南"></a>五、性能调优实战指南</h2><h3 id="5-1-百万并发连接调优"><a href="#5-1-百万并发连接调优" class="headerlink" title="5.1 百万并发连接调优"></a>5.1 百万并发连接调优</h3><p>关键参数配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">worker_processes <span class="keyword">auto</span>;</span><br><span class="line">worker_rlimit_nofile <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">50000</span>;</span><br><span class="line">    use epoll;</span><br><span class="line">    multi_accept on;</span><br><span class="line">    epoll_events <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_requests <span class="number">1000</span>;</span><br><span class="line">    keepalive_timeout <span class="number">65</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-内核参数优化"><a href="#5-2-内核参数优化" class="headerlink" title="5.2 内核参数优化"></a>5.2 内核参数优化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大打开文件数</span></span><br><span class="line">sysctl -w fs.file-max=1000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP缓冲区设置</span></span><br><span class="line">sysctl -w net.ipv4.tcp_mem=<span class="string">&#x27;786432 2097152 3145728&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_rmem=<span class="string">&#x27;4096 87380 6291456&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=<span class="string">&#x27;4096 16384 4194304&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口复用</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse=1</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle=0</span><br></pre></td></tr></table></figure><h2 id="六、未来演进：从Web-Server到应用网络"><a href="#六、未来演进：从Web-Server到应用网络" class="headerlink" title="六、未来演进：从Web Server到应用网络"></a>六、未来演进：从Web Server到应用网络</h2><p>NGINX正在向云原生服务网格演进，最新版本已支持：</p><ul><li>QUIC&#x2F;HTTP3协议栈</li><li>WASM扩展支持</li><li>动态可编程配置（NJS）</li><li>服务网格数据平面集成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># WASM配置示例</span><br><span class="line">location /wasm &#123;</span><br><span class="line">    wasm &#123;</span><br><span class="line">        module hello_world /path/to/hello.wasm;</span><br><span class="line">        init_func _start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX 概述</title>
      <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="NGINX-简介"><a href="#NGINX-简介" class="headerlink" title="NGINX 简介"></a>NGINX 简介</h1><p>Nginx是一款高性能的开源HTTP服务器和反向代理服务器，同时也支持IMAP&#x2F;POP3代理服务器。它以其高性能、稳定性、丰富的功能和低资源消耗而闻名。以下是Nginx的一些基础知识，包括其架构、配置文件、主要模块和常见用途。</p><h3 id="1-Nginx-架构"><a href="#1-Nginx-架构" class="headerlink" title="1. Nginx 架构"></a>1. Nginx 架构</h3><h4 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h4><p>Nginx采用事件驱动的非阻塞I&#x2F;O模型，能够高效地处理大量并发连接。其架构主要包括以下几个部分：</p><ul><li><strong>主进程（Master Process）</strong>：负责管理和维护工作进程，处理日志文件的写入等。</li><li><strong>工作进程（Worker Processes）</strong>：实际处理客户端请求，每个工作进程可以处理多个连接。</li><li><strong>缓存管理</strong>：Nginx可以缓存静态文件和动态内容，提高响应速度。</li></ul><h4 id="1-2-事件驱动模型"><a href="#1-2-事件驱动模型" class="headerlink" title="1.2 事件驱动模型"></a>1.2 事件驱动模型</h4><p>Nginx 使用事件驱动模型来处理请求，这意味着它可以同时处理多个连接，而无需为每个连接创建一个线程或进程。这种模型使得Nginx在处理高并发请求时表现出色。</p><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><h4 id="2-1-配置文件结构"><a href="#2-1-配置文件结构" class="headerlink" title="2.1 配置文件结构"></a>2.1 配置文件结构</h4><p>Nginx的配置文件通常位于<code>/etc/nginx/nginx.conf</code>，或者在<code>/etc/nginx/sites-available/</code>和<code>/etc/nginx/sites-enabled/</code>目录中。配置文件由多个块组成，每个块定义了特定的配置指令。</p><ul><li><strong>全局块</strong>：定义全局配置，如用户、工作进程数等。</li><li><strong>http块</strong>：定义HTTP服务器相关配置，如虚拟主机、日志格式等。</li><li><strong>server块</strong>：定义虚拟主机，包括监听端口、域名等。</li><li><strong>location块</strong>：定义特定路径的处理规则，如静态文件服务、反向代理等。</li></ul><h4 id="2-2-示例配置"><a href="#2-2-示例配置" class="headerlink" title="2.2 示例配置"></a>2.2 示例配置</h4><p>nginx复制</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /api/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend-server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要模块"><a href="#3-主要模块" class="headerlink" title="3. 主要模块"></a>3. 主要模块</h3><h4 id="3-1-HTTP模块"><a href="#3-1-HTTP模块" class="headerlink" title="3.1 HTTP模块"></a>3.1 HTTP模块</h4><ul><li>**<code>ngx_http_core_module</code>**：核心模块，处理基本的HTTP请求和响应。</li><li>**<code>ngx_http_static_module</code>**：提供静态文件服务。</li><li>**<code>ngx_http_proxy_module</code>**：实现反向代理功能。</li><li>**<code>ngx_http_ssl_module</code>**：支持SSL&#x2F;TLS加密。</li></ul><h4 id="3-2-其他模块"><a href="#3-2-其他模块" class="headerlink" title="3.2 其他模块"></a>3.2 其他模块</h4><ul><li>**<code>ngx_http_gzip_module</code>**：支持响应内容的GZIP压缩。</li><li>**<code>ngx_http_rewrite_module</code>**：支持基于正则表达式的URL重写。</li><li>**<code>ngx_http_limit_req_module</code>**：限制请求速率，防止滥用。</li></ul><h3 id="4-常见用途"><a href="#4-常见用途" class="headerlink" title="4. 常见用途"></a>4. 常见用途</h3><h4 id="4-1-静态内容服务器"><a href="#4-1-静态内容服务器" class="headerlink" title="4.1 静态内容服务器"></a>4.1 静态内容服务器</h4><p>Nginx可以高效地提供静态文件服务，如HTML、CSS、JavaScript和图片文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-反向代理"><a href="#4-2-反向代理" class="headerlink" title="4.2 反向代理"></a>4.2 反向代理</h4><p>Nginx可以作为反向代理服务器，将请求转发到后端应用服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend-server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-负载均衡"><a href="#4-3-负载均衡" class="headerlink" title="4.3 负载均衡"></a>4.3 负载均衡</h4><p>Nginx可以将客户端请求分发到多个后端服务器，提高系统的可用性和性能。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选负载均衡策略：</p><ul><li>简单轮询 （Round Robin）</li><li>加权轮询 （Weighted Robin）</li><li>最少连接 </li><li>IP hash</li><li>基于响应时间的算法 （NGINX Plus 中提供）</li><li>随机算法</li><li>通用 HASH （一致性哈希）<ul><li><code>hash $remote_addr consistent</code></li><li><code>hash $request_uri consistent</code></li><li><code>hash $http_host consistent</code></li><li><code>hash $scheme consistent</code></li><li>组合，如：   <code>hash $remote_addr$request_uri consistent</code></li></ul></li></ul><h4 id="4-4-SSL-TLS终止"><a href="#4-4-SSL-TLS终止" class="headerlink" title="4.4 SSL&#x2F;TLS终止"></a>4.4 SSL&#x2F;TLS终止</h4><p>Nginx 可以处理 SSL&#x2F;TLS 加密，将加密流量解密后转发到后端服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/certificate.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/private.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><h4 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h4><p>Nginx可以缓存静态文件和动态内容，减少对后端服务器的请求，提高响应速度。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /data/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-GZIP压缩"><a href="#5-2-GZIP压缩" class="headerlink" title="5.2 GZIP压缩"></a>5.2 GZIP压缩</h4><p>Nginx可以对响应内容进行GZIP压缩，减少传输数据量，提高性能。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br></pre></td></tr></table></figure><h3 id="6-安全性"><a href="#6-安全性" class="headerlink" title="6. 安全性"></a>6. 安全性</h3><h4 id="6-1-SSL-TLS加密"><a href="#6-1-SSL-TLS加密" class="headerlink" title="6.1 SSL&#x2F;TLS加密"></a>6.1 SSL&#x2F;TLS加密</h4><p>Nginx支持SSL&#x2F;TLS加密，确保数据传输的安全性。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/certificate.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/private.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-防止DDoS攻击"><a href="#6-2-防止DDoS攻击" class="headerlink" title="6.2 防止DDoS攻击"></a>6.2 防止DDoS攻击</h4><p>Nginx可以通过限制请求速率来防止DDoS攻击。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=one burst=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Nginx是一款功能强大、性能卓越的HTTP服务器和反向代理服务器。通过合理配置和优化，Nginx可以满足多种应用场景，包括静态内容服务、反向代理、负载均衡和SSL&#x2F;TLS终止。掌握Nginx的基本知识和配置方法，可以帮助你更好地管理和优化你的Web服务。</p><h1 id="附-——-配置示例"><a href="#附-——-配置示例" class="headerlink" title="附 —— 配置示例"></a>附 —— 配置示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 定义 server1 集群的 upstream，使用最小连接数算法</span><br><span class="line">    upstream server1 &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.1:8080;  # 替换为 server1 集群的实际 IP 和端口</span><br><span class="line">        server 192.168.1.2:8080;</span><br><span class="line">        # 添加更多 server1 的节点</span><br><span class="line"></span><br><span class="line">        # 健康检查配置</span><br><span class="line">        health_check uri=/health match=healthy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 server2 集群的 upstream，使用轮询算法</span><br><span class="line">    upstream server2 &#123;</span><br><span class="line">        server 192.168.2.1:8080;  # 替换为 server2 集群的实际 IP 和端口</span><br><span class="line">        server 192.168.2.2:8080;</span><br><span class="line">        # 添加更多 server2 的节点</span><br><span class="line"></span><br><span class="line">        # 健康检查配置</span><br><span class="line">        health_check uri=/health match=healthy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义健康检查匹配规则</span><br><span class="line">    http_check &#123;</span><br><span class="line">        match healthy &#123;</span><br><span class="line">            status 200-299;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 server 块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">        # 强制重定向到 HTTPS</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 HTTPS server 块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">        # SSL 证书配置</span><br><span class="line">        ssl_certificate /path/to/your-domain.crt;  # 替换为你的 SSL 证书路径</span><br><span class="line">        ssl_certificate_key /path/to/your-domain.key;  # 替换为你的 SSL 私钥路径</span><br><span class="line"></span><br><span class="line">        # 配置 /location1 路径转发到 server1 集群</span><br><span class="line">        location /location1 &#123;</span><br><span class="line">            proxy_pass http://server1;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 配置 /location2 路径转发到 server2 集群</span><br><span class="line">        location /location2 &#123;</span><br><span class="line">            proxy_pass http://server2;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 服务治理 </category>
          
          <category> 负载均衡 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Pipeline</title>
      <link href="/2024/07/21/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Pipeline/"/>
      <url>/2024/07/21/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Pipeline/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty EventLoop</title>
      <link href="/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/EventLoop/"/>
      <url>/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/EventLoop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Channel</title>
      <link href="/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Channel/"/>
      <url>/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Channel/</url>
      
        <content type="html"><![CDATA[<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="Channel-简介"><a href="#Channel-简介" class="headerlink" title="Channel 简介"></a>Channel 简介</h2><p>在 Java NIO 中，Channel 即通道，是用来传输数据的一条“管道”，它与 Buffer 相辅相成；并且在 Java NIO 中，我们只能从 Channel 读取数据到 Buffer 中，或者从 Buffer 读取数据到 Channel 中</p><p>在 Netty 中同样有一个 Channel，该 <strong>Channel 是 Netty 的核心概念之一，它是 Netty 网络 IO 操作的抽象，即 Netty 网络通信的主体，由它来负责对端进行网络通信、注册、数据操作等一切 IO 相关的操作</strong>，其主要功能包括：</p><ol><li>网络 IO 的读写</li><li>客户端发起连接</li><li>关闭连接</li><li>网络连接的相关参数</li><li>绑定端口</li><li>Netty 框架相关操作，如获取 Channel 相关联的 EventLoop、pipeline 等。</li></ol><h3 id="为什么要重新设计"><a href="#为什么要重新设计" class="headerlink" title="为什么要重新设计"></a>为什么要重新设计</h3><ol><li>原生的 Channel 功能太少，不满足 Netty 的要求。</li><li>原生的 ServerSocketChannel 和 SocketChannel 是一个 SPI 接口，具体的实现由虚拟厂商来实现，直接通过原生 ServerSocketChannel 和 SocketChannel 来实现及满足 Netty 的要求，其工作量不亚于重新开发一个。</li><li>Netty 的 Channel 需要符合 Netty 的整体架构设计，他需要和 Netty 的整体架构耦合在一起，比如 IO 模型、基于元数据描述配置化的TCP参数等等，原生的 Channel 都不支持。</li><li>自定义的 Channel，灵活性更高，功能更加全面。</li></ol><h2 id="Channel-原理"><a href="#Channel-原理" class="headerlink" title="Channel 原理"></a>Channel 原理</h2><p>Channel 的核心原理如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206212000006.jpg" alt="img"></p><ol><li>客户端与服务端成功建立连接后，服务端会为该连接创建一个 Channel。</li><li>Channel 从 EventLoopGroup 中获取一个 EventLoop，Channel 注册到该 EventLoop 中，从此 Channel 就与该 EventLoop 绑定在一起了，在 Channel 整个生命周期内都只会与该 EventLoop 绑定在一起。</li><li>客户端发起的 IO 操作，在 Channel 中都将产生相对应的 Event，触发与该 Channel 绑定的 EventLoop 进行处理</li><li>如果是读写事件，执行线程调度 ChannelPipeline 来处理业务逻辑。ChannelPipeline 只负责 Handler 的编排，真正执行任务的是各个具体的 ChannelHandler。</li></ol><h2 id="Channel-的状态转换"><a href="#Channel-的状态转换" class="headerlink" title="Channel 的状态转换"></a>Channel 的状态转换</h2><p>Channel 从创建到消亡，他有四种状态，分别是：</p><ul><li><strong>打开状态（Open）：</strong><ul><li>Channel 处于打开状态时，表示它已经被创建，但尚未绑定到任何地址或连接到远端服务器。</li></ul></li><li><strong>活动状态（Active）</strong><ul><li>Channel 处于活动状态时，表示它已经成功绑定到本地地址或连接到远端服务器。</li><li>这个时候可以调用 <code>writeAndFlush()</code> 向对方发送数据了。</li></ul></li><li><strong>非活动状态（Inactive）</strong><ul><li>Channel 处于非活动状态时，表示它已经处于活动状态，但连接已经断开或由于其他原因不可用。</li><li>当连接被关闭或出现错误时，Channel 会进入非活动状态。</li><li>无法进行读取或写入操作，但可重新激活 Channel。</li></ul></li><li><strong>关闭状态（Closed）：</strong><ul><li>Channel 处于关闭状态时，表示它已经完全关闭，无法再进行任何操作。</li></ul></li></ul><p>Netty 提供了四个方法来判断 Channel 的状态：</p><ul><li><code>isOpen()</code>：检查 Channel 是否为 open 状态。</li><li><code>isRegistered()</code>：检查 Channel 是否为 registered 状态。</li><li><code>isActive()</code>：检查 Channel 是否为 active 状态。</li><li><code>isWritable()</code>：这个方法有误导性，它并不是判断当前 Channel 是否可写，实际上它是用来检测当前 Channel 的写操作是否可以立刻被 IO 线程处理，当该方法返回 false 时，任何写请求都会被阻塞，知道 I&#x2F;O 线程有能力能处理这些请</li></ul><h2 id="Channel-的-API"><a href="#Channel-的-API" class="headerlink" title="Channel 的 API"></a>Channel 的 API</h2><p>略</p><h2 id="Channel-的配置"><a href="#Channel-的配置" class="headerlink" title="Channel 的配置"></a>Channel 的配置</h2><p>在 Netty 中，每个 Channel 都有与之相对应的 ChannelConfig ， 可以通过调用 <code>config()</code> 来获取。ChannelConfig 是一个接口，每个特定的 Channel 都有具体的 ChannelConfig 实现类，例如：</p><ul><li>NioSocketChannel 的对应的配置类为 NioSocketChannelConfig。</li><li>NioServerSocketChannel 的对应的配置类为 NioServerSocketChannelConfig。</li></ul><h3 id="ChannelConfig-提供通用型配置"><a href="#ChannelConfig-提供通用型配置" class="headerlink" title="ChannelConfig 提供通用型配置"></a>ChannelConfig 提供通用型配置</h3><ul><li><code>ChannelOption.CONNECT_TIMEOUT_MILLIS</code>：连接超时时间，默认值30000毫秒即30秒。</li><li><code>ChannelOption.WRITE_SPIN_COUNT</code>：写操作的最大循环数，即一次写事件处理期间最多调用 <code>write()</code> 的次数。它有点儿像 Java 中的自旋锁。引入该参数的主要木的是为了避免一个 Channel 写入大量数据，对其他网络通道的读写处理带来延时。</li><li><code>ChannelOption.ALLOCATOR</code>：设置内存分配器。</li><li><code>ChannelOption.RCVBUF_ALLOCATOR</code>：对读事件设置内存分配器。</li><li><code>ChannelOption.AUTO_READ</code>：配置是否自动触发 <code>read()</code> ，默认为 True，程序不需要显示调用 <code>read()</code>。</li><li><code>ChannelOption.AUTO_CLOSE</code>：配置当写事件失败时，是否自动关闭 Channel，默认为 True。</li><li><code>ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</code>：设置写缓存区的高水位线。如果写缓存区中的数据超过该值， <code>Channel#isWritable()</code> 方法将返回 false。</li><li><code>ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</code>：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(<code>Channel#isWritable()</code>将再次返回true)。</li><li><code>ChannelOption.MESSAGE_SIZE_ESTIMATOR</code>：设置用于检测通道消息大小的检测器：MessageSizeEstimator。</li></ul><h3 id="NioSocketChannelConfig"><a href="#NioSocketChannelConfig" class="headerlink" title="NioSocketChannelConfig"></a>NioSocketChannelConfig</h3><p>NioSocketChannelConfig 在 ChannelConfig 的基础上增加了如下几个配置：</p><ul><li><code>ChannelOption.SO_KEEPALIVE</code>： 连接保持，默认为 False，我们可以将这个参数视为 TCP 的心跳机制。</li><li><code>ChannelOption.SO_REUSEADDR</code>：地址复用，默认值False。</li><li><code>ChannelOption.SO_LINGER</code>：关闭 Socket 的延迟时间，默认值  为 -1，表示禁用该功能</li><li><code>ChannelOption.TCP_NODELAY</code>：立即发送数据，默认值为 Ture。该值其实是设置 Nagle 算法的启用。关于 Nagle 算法我们后面再细说。</li><li><code>ChannelOption.SO_RCVBUF</code>：TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口。</li><li><code>ChannelOption.SO_SNDBUF</code>：TCP 数据发送缓冲区大小。该缓冲区即 TCP 发送滑动窗口。</li><li><code>ChannelOption.IP_TOS</code>：IP 参数，设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。</li><li><code>ChannelOption.ALLOW_HALF_CLOSURE</code>：一个连接的远端关闭时本地端是否关闭，默认值为False。</li></ul><h3 id="NioServerSocketChannelConfig"><a href="#NioServerSocketChannelConfig" class="headerlink" title="NioServerSocketChannelConfig"></a>NioServerSocketChannelConfig</h3><ul><li><code>ChannelOption.SO_REUSEADDR</code>：地址复用，默认值False。</li><li><code>ChannelOption.SO_RCVBUF</code>：TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口。</li><li><code>ChannelOption.SO_BACKLOG</code>：服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝</li></ul><h2 id="Channel-的使用方法"><a href="#Channel-的使用方法" class="headerlink" title="Channel 的使用方法"></a>Channel 的使用方法</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty ByteBuf</title>
      <link href="/2024/07/18/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/ByteBuf/"/>
      <url>/2024/07/18/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/ByteBuf/</url>
      
        <content type="html"><![CDATA[<h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><h2 id="从-ByteBuffer-说起"><a href="#从-ByteBuffer-说起" class="headerlink" title="从 ByteBuffer 说起"></a>从 ByteBuffer 说起</h2><p>Java NIO 有一个原生的 ByteBuffer，但由于 Java NIO 的 ByteBuffer 有一些设计上的缺陷和痛点，Netty 重新造了一个轮子</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206281000001.jpg" alt="img"></p><p>Java NIO 的 ByteBuffer 有四个属性</p><ul><li><strong>capacity</strong>：容量，表示当前 ByteBuffer 最大可写的数据量。</li><li><strong>limit</strong>：ByteBuffer 中有效的数据长度大小，具体含义与当前 ByteBuffer 处于哪种模式有关<ul><li>写模式：limit 是指能够往 Buffer 中写入多少数据，其值等于 capacity。</li><li>读模式：limit 表示能够从 Buffer 中最多能够读取多少数据出来。当从写模式切换到读模式时，limit 的写模式的 position。</li></ul></li><li><strong>position</strong>：当前位置，与 limit 一样，具体含义与当前 ByteBuffer 处于哪种模式有关<ul><li>写模式：当前写的位置，初始值为 0 ，最大值为 capacity - 1，当往 ByteBuffer 中写入一个数据时，position 就会向前移动到下一个待写入的位置。</li><li>读模式：当前读的位置，读一个数据，position 就往前移一位。</li></ul></li><li><strong>mark</strong>：标志位，一般都是用这个属性来标识某个特殊的位置，方便我们到时候回退到该位置。</li></ul><p>基于 ByteBuffer 的属性特点可以看出它有如下几个缺陷：</p><ol><li>只有一个标识位置的指针 position，在我们使用过程中需要频繁调用 <code>flip()</code>、<code>rewind()</code> 来进行读写模式的切换，我们需要非常清晰地知道这些 API 具体的含义，知道他们的使用场景，否则就会导致程序出错。</li><li>长度固定。我们在申请一个 ByteBuffer 的时候就已经固定了它的容量了，它无法扩容，然后在实际开发过程中，我们是无法来衡量一个具体的容量的，所以很难控制需要分配的容量。分配太多，容易造成内存浪费；分配太少，则会引发索引越界异常 BufferOverflowException。</li><li>提供的 API 不够丰富，一些高级和实用的特性它不支持，需要我们自己动手实现。</li></ol><p>而作为 Netty 的数据传输的载体，ByteBuffer 显然无法满足 Netty 的需求，所以 Netty 就另起炉灶实现了一个性能更高，灵活性更强的 ByteBuf。作为 ByteBuffer 的替代者，ByteBuf 具有如下几个优点：</p><ol><li>容量可以动态扩容</li><li>读写索引分开，读写模式可以随意切换，不需要调用 <code>flip()</code> 方法</li><li>支持引用计数</li><li>支持池化</li><li>通过内置的复合缓冲区类型实现透明的零拷贝</li><li>支持方法的链式调用</li></ol><h2 id="ByteBuf-原理"><a href="#ByteBuf-原理" class="headerlink" title="ByteBuf 原理"></a>ByteBuf 原理</h2><h3 id="ByteBuf-的内部结构"><a href="#ByteBuf-的内部结构" class="headerlink" title="ByteBuf 的内部结构"></a>ByteBuf 的内部结构</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206293000001.jpg" alt="img"></p><h3 id="ByteBuf-的三个指针"><a href="#ByteBuf-的三个指针" class="headerlink" title="ByteBuf 的三个指针"></a>ByteBuf 的三个指针</h3><ul><li>readerIndex：读指针</li><li>writerIndex：写指针</li><li>maxCapacity：最大容量</li></ul><h3 id="ByteBuf-的四个部分"><a href="#ByteBuf-的四个部分" class="headerlink" title="ByteBuf 的四个部分"></a>ByteBuf 的四个部分</h3><p>三个指针将整个 ByteBuf 分为四个部分：</p><ol><li><strong>废弃字节</strong>：表示已经丢弃的无效字节，我们可以调用 <code>discardReadBytes()</code> 释放这部分空间。</li><li><strong>可读字节</strong>：表示可以从 ByteBuf 中读取到的数据，这部分内容等于 writerIndex - readerIndex。readerIndex 随着我们读取 ByteBuf 中的数据而递增，当从 ByteBuf 中读取 N 个字节， readerIndex 就会自增 N，直到 readerIndex &#x3D; writerIndex 时，就表示 ByteBuf 不可读。</li><li><strong>可写字节</strong>：表示可以向 ByteBuf 可写入的字节。writerIndex 也是随着我们向 ByteBuf 中写入数据而自增，当想 ByteBuf 中写入 N 个字节，writerIndex 就会自增 N，当 writerIndex 超过 capacity 时，就需要扩容了。</li><li><strong>可扩容字节</strong>：表示 ByteBuf 最多可扩容多少字节 。当向 ByteBuf 写入的数据超过了 capacity 时，就会触发扩容，但是最多可扩容到 maxCapacity ，超过时就会报错。</li></ol><p>netty 为 读写操作分别设计指针，很好地解决了 NIO ByteBuffer 的不可扩容及读写模式切换的问题，使得 ByteBu 能够更加高效、更加灵活地处理数据</p><h2 id="ByteBuf-分类"><a href="#ByteBuf-分类" class="headerlink" title="ByteBuf 分类"></a>ByteBuf 分类</h2><p>Netty 提供的 ByteBuf 有多种实现类，每种都有不同的特性和使用场景，主要分为三种类型：</p><ol><li>Pooled 和 Unpooled：池化和非池化；</li><li>Heap 和 Direct：堆内存和直接内存；</li><li>Safe 和 Unsafe：安全和非安全。</li></ol><ul><li><strong>Pooled 和 Unpooled</strong></li></ul><p>Pooled 就是从预先分配好的内存中取出来，使用完成后又放回 ByteBuf 内存中，等待下一次分配。而 Unpooled 是直接调用系统 API 来申请内存的，使用完成后需要立刻销毁的。</p><p>从性能上来说，Pooled 要比 Unpooled 性能好，因为它可以重复利用，不需要每次都创建</p><ul><li><strong>Heap 和 Direct</strong></li></ul><p>Heap 就是在 JVM 堆内分配的，其生命周期受 JVM 管理，我们不需要主动回收他们。而 Direct 则由操作系统管理，使用完成后需要主动释放这部分内存，否则容易造成内存溢出。</p><ul><li><strong>Safe 和 Unsafe</strong></li></ul><p>主要是 Java 底层操作数据的一种安全和非安全的方式。Unsafe 表示每次调用 JDK 的 Unsafe 对象操作物理内存的，而 Safe 则不需要依赖 JDK 的 Unsafe 对象，直接通过数组下标的方式来操作。</p><p>经排列组合，可知 ByteBuf 共有 2^3 &#x3D;8 种实现</p><ol><li>池化 + 堆内存：PooledHeapByteBuf</li><li>池化 + 直接内存：PooledDirectByteBuf</li><li>池化 + 堆内存 + 不安全：PooledUnsafeHeapByteBuf</li><li>池化 + 直接内存 + 不安全：PooledUnsafeDirectByteBuf</li><li>非池化 + 堆内存：UnpooledHeapByteBuf</li><li>非池化 + 直接内存：UnpooledDirectByteBuf</li><li>非池化 + 堆内存 + 不安全：UnpooledUnsafeHeapByteBuf</li><li>非池化 + 直接内存 + 不安全：UnpooledUnsafeDirectByteBuf</li></ol><h2 id="ByteBuf-核心-API"><a href="#ByteBuf-核心-API" class="headerlink" title="ByteBuf 核心 API"></a>ByteBuf 核心 API</h2><p>ByteBuf 的核心 API 分为四类：</p><ol><li>容量相关 API</li><li>指针操作相关 API</li><li>数据读写相关 API</li><li>内存管理相关 API</li></ol><p>下面我们依次来了解这些 API。</p><h3 id="容量相关-API"><a href="#容量相关-API" class="headerlink" title="容量相关 API"></a>容量相关 API</h3><p>容量相关的 API 主要用来获取 ByteBuf 的容量的。</p><ul><li><strong>capacity()</strong></li></ul><p>表示 ByteBuf 占用了多少字节的内存，它包括已放弃 + 可读 + 可写。</p><ul><li><strong>maxCapacity()</strong></li></ul><p>表示 ByteBuf 最大能占用多少字节的内存。当不断向 ByteBuf 中写入数据的时候，如果发现容量不足时（writerIndex 超过 capacity）就会触发扩容，最大可扩容到 maxCapacity，如果超过 maxCapacity 时就会抛出异常。</p><h3 id="指针操作相关-API"><a href="#指针操作相关-API" class="headerlink" title="指针操作相关 API"></a>指针操作相关 API</h3><p>指针操作相关 API 就是操作读写指针的。</p><ul><li><strong>readerIndex() &amp; readerIndex(int)</strong></li></ul><p>前置返回读指针 readerIndex 的位置，而后者是设置读指针 readerIndex 的位置。</p><ul><li><strong>writerIndex() &amp; writerIndex(int)</strong></li></ul><p>前者返回写指针 writerIndex 的位置，而后者是设置写指针 writerIndex 的位置。</p><ul><li><strong>markReaderIndex() &amp; resetReaderIndex()</strong></li></ul><p><code>markReaderIndex()</code>用于标注当前 readerIndex 的位置，即把当前 readerIndex 保存起来。而 <code>resetReaderIndex()</code> 则是将当前的 readerIndex 指针恢复到之前保存的位置。</p><ul><li><strong>markWriterIndex() &amp; resetWriterIndex()</strong></li></ul><p>与 readerIndex 的一致。</p><h3 id="数据读写相关-API"><a href="#数据读写相关-API" class="headerlink" title="数据读写相关 API"></a>数据读写相关 API</h3><ul><li><strong>readableBytes() &amp; isReadable()</strong></li></ul><p><code>readableBytes()</code> 表示 ByteBuf 中有多少字节可以读，它的值等于 writerIndex - readerIndex。<code>isReadable()</code> 用于判断 ByteBuf 是否可读，若 <code>readableBytes()</code> 返回的值大于 0 ，则 <code>isReadable()</code> 则为 true。</p><ul><li><strong>readByte() &amp; writeByte(byte b)</strong></li></ul><p><code>readByte()</code> 是从 ByteBuf 中读取一个字节，则 readerIndex + 1。同理 <code>writeByte(byte b)</code> 是向 ByteBuf 中写入一个字节，相应的 writerIndex + 1。</p><p>在 Netty 中，它提供了 8 种基础数据类型的读取和写入 API，如 <code>readInt()</code>，<code>readLong()</code>，<code>readShort()</code> 等等，这里就不一一阐述了。</p><ul><li><strong>readBytes(byte[] dst) &amp; writeBytes(byte[] src)</strong></li></ul><p><code>readBytes(byte[] dst)</code> 是将 ByteBuf 里面的数据全部读取到 dst 中，这里 dst 数据的大小通常等于 <code>readableBytes()</code>。</p><p><code>writeBytes(byte[] src)</code> 则是将 src 数组里面的内容全部写到 ByteBuf 中。</p><ul><li><strong>getByte(int) &amp; setByte(int,int)</strong></li></ul><p>这两个方法与 <code>readByte()</code> &amp; <code>writeByte(byte b)</code> 方法类似，两者区别在于 <code>readByte()</code> 会改变 readerIndex 的位置，而 <code>getByte(int)</code> 则不会改变 readerIndex 的位置。</p><h3 id="内存管理相关-API"><a href="#内存管理相关-API" class="headerlink" title="内存管理相关 API"></a>内存管理相关 API</h3><ul><li><strong>retain() &amp; release()</strong></li></ul><p>ByteBuf 是基于引用计数设计的，它实现了 ReferenceCounted 接口。在默认情况下，我们创建一个 ByteBuf 时，它的计数为 1。</p><p>当计数大于 0 ，就说该 ByteBuf 还在被使用，当计数等于 0 的时候，说明该 ByteBuf 不再被其他对象所引用。</p><p>我们每调用一个 <code>retain()</code> ，计数就 + 1，每调用一次 <code>release()</code> 计数就 - 1，当计数减到 0 的时候，就会被回收。</p><ul><li><strong>slice() &amp; duplicate() &amp; copy()</strong></li></ul><p><code>slice()</code>从 ByteBuf 中截取一段从 readerIndex 到 writerIndex 之间的数据，该新的 ByteBuf 的最大容量为原始 ByteBuf 的 <code>readableBytes()</code>。新的 ByteBuf 其底层分配的内存、引用计数与原始的 ByteBuf 共享，这样就会有一个问题：如果我们调用新的 ByteBuf 的 write 系列方法，就会影响到原始的 ByteBuf 的底层数据。</p><p><code>duplicate()</code> 也是从 ByteBuf 中截取一段数据，返回一个新的 ByteBuf，但是它截取的是整个原始的 ByteBuf，与 <code>slice()</code> 一样，<code>duplicate()</code> 返回新的 ByteBuf 其底层分配的内存、引用计数与原始 ByteBuf 共享。</p><p><code>copy()</code> 从原始 ByteBuf 中拷贝所有信息，包括读写指针、底层分配的内存、引用计数等等所有的信息，所以新的 ByteBuf 是一个独立的个体，它与原始的 ByteBuf 不再共享。</p><p>在使用这三个方法的时候一定要切记如下点：</p><ul><li><code>slice()</code> 和 <code>duplicate()</code> 新的 ByteBuf 与原始的 ByteBuf 内存共享、引用计数共享、读写指针不共享</li><li><code>copy()</code> 新的 ByteBuf 与原始 ByteBuf 底层内存、引用计数、读写指针都不共享</li></ul><h2 id="ByteBuf-实现零拷贝"><a href="#ByteBuf-实现零拷贝" class="headerlink" title="ByteBuf 实现零拷贝"></a>ByteBuf 实现零拷贝</h2><ul><li>byte数组转换为ByteBuf对象。Unpooled.wrappedBuffer方法来将bytes 包装成为一个UnpooledHeapByteBuf对象, 而在包装的过程中, 是不会有拷贝操作的。最后我们生成的生成的ByteBuf对象是和bytes数组共用了同一个存储空间, 对bytes的修改也会反映到ByteBuf对象中.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 传统做法，这样的方式也是有一个额外的拷贝操作的</span></span><br><span class="line"><span class="type">byte</span>[] bytes = ...</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 无额外copy方式</span></span><br><span class="line"><span class="type">byte</span>[] bytes = ...</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure><ul><li><p>Unpooled工具类还提供了很多重载的wrappedBuffer方法:这些方法可以将一个或多个buffer包装为一个ByteBuf对象, 从而避免了拷贝操作。</p></li><li><p>通过slice操作实现零拷贝: slice操作和wrap操作刚好相反, Unpooled.wrappedBuffer可以将多个ByteBuf合并为一个, 而slice操作可以将一个ByteBuf切片 为多个共享一个存储区域的ByteBuf对象。</p><ul><li>ByteBuf 提供了两个 slice 操作方法:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">slice</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">slice</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>不带参数的slice方法等同于buf.slice(buf.readerIndex(), buf.readableBytes())调用, 即返回buf中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf的不同区域的切片.</li><li>用slice方法产生header和body的过程是没有拷贝操作的,header和 body对象在内部其实是共享了byteBuf存储空间的不同部分而已</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Bootstrap</title>
      <link href="/2024/07/17/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Bootstrap/"/>
      <url>/2024/07/17/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>Bootstrap 充当了 Netty 服务端或客户端应用程序的启动者，为 netty 应用开发提供了一种简洁且流畅的 API 来配置和启动网络服务。</p><p>在 Netty 中有两个主要的 Bootstrap 类型：</p><ul><li>ServerBootstrap：用于启动服务端应用。</li><li>Bootstrap：用于启动客户端应用。</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240724223711483.png" alt="image-20240724223711483" style="zoom: 67%;" /><h2 id="Bootstrap-的使用步骤"><a href="#Bootstrap-的使用步骤" class="headerlink" title="Bootstrap 的使用步骤"></a>Bootstrap 的使用步骤</h2><ol><li><strong>创建 Bootstrap 实例</strong>：创建 Bootstrap 或 ServerBootstrap 实例。</li><li><strong>设置 EventLoopGroup</strong>：EventLoopGroup 是处理 I&#x2F;O 操作的线程组。通常，客户端会设置一个 EventLoopGroup，而服务端会设置两个（一个用于接收连接，另一个用于处理连接）。</li><li><strong>选择 Channel 类型</strong>：指定要使用的 Channel 类型，例如 NioSocketChannel 或 EpollSocketChannel。</li><li><strong>添加 ChannelInitializer</strong>：通过 handler() 方法添加 ChannelInitializer，它会在每个新 Channel 创建后被调用，用于添加 ChannelHandler 到 ChannelPipeline。</li><li><strong>配置 Channel 选项</strong>：可以设置各种 ChannelOption，比如 TCP_NODELAY 和 SO_KEEPALIVE。</li><li><strong>连接或绑定</strong>：<ul><li>客户端调用 connect() 方法尝试连接到远程服务器。</li><li>服务端调用 bind() 方法绑定到本地端口并开始监听连接。</li></ul></li></ol><p>(ServerBootStrap 调用周期)</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202205221000003.jpg" alt="img" style="zoom: 30%;" /><h3 id="设置-EventLoopGroup-线程组"><a href="#设置-EventLoopGroup-线程组" class="headerlink" title="设置 EventLoopGroup 线程组"></a>设置 EventLoopGroup 线程组</h3><p>调用 <code>group()</code> 可以设置 EventLoopGroup 的线程组，该线程组其实就是 Reactor 的线程组</p><p>对于Server 端而言 ，Reactor 模式线程组有两个：</p><ul><li>BossGroup：服务器连接监听线程组，该线程组专门用来处理客户端的连接请求</li><li>WorkGroup：工作线程组，即业务处理线程组，用来处理每一条连接的数据收发的线程组。</li></ul><p>ServerBootstrap 提供了两个 <code>group()</code> 方法用来设置线程组：</p><ul><li><code>group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>：设置 BossGroup 和 WorkGroup。</li><li><code>group(EventLoopGroup group)</code>：这里只配置了一个线程组，也就是 BossGroup 和 WorkGroup 共用一个线程组。</li></ul><h3 id="设置-Channel-类型"><a href="#设置-Channel-类型" class="headerlink" title="设置 Channel 类型"></a>设置 Channel 类型</h3><p>在 NIO 中 Channel 是通信的根本，我们收发数据都是基于 Channel 来实现的，对于 Netty 来说 Channel 也是它通信的通道，不过 Netty 不仅仅只支持 NIO 模式，还有 OIO 。</p><p>调用 <code>channel()</code> 方法即可设置通道的 IO 类型。</p><p>Netty 支持的 IO 类型有如下几种：</p><ul><li><code>NioSocketChannel</code>：异步的客户端 TCP Socket 连接.</li><li><code>NioServerSocketChannel</code>：异步的服务器端 TCP Socket 连接.</li><li><code>NioDatagramChannel</code>：异步的 UDP 连接</li><li><code>NioSctpChannel</code>：异步的客户端 Sctp 连接.</li><li><code>NioSctpServerChannel</code>：异步的 Sctp 服务器端连接.</li><li><code>OioSocketChannel</code>：同步的客户端 TCP Socket 连接.</li><li><code>OioServerSocketChannel</code>：同步的服务器端 TCP Socket 连接.</li><li><code>OioDatagramChanne</code>：同步的 UDP 连接</li><li><code>OioSctpChanne</code>：同步的 Sctp 服务器端连接.</li><li><code>OioSctpServerChannel</code>：同步的客户端 TCP Socket 连接.</li></ul><p>从上面可以看出，Netty 不仅仅只支持 TCP 协议，还支持 UDP 、STCP 协议，同时每种协议都有 NIO 和 OIO 模式，从 Netty 支持的通道类型就可以看出，Netty 功能有多么强大了。</p><h3 id="配置-Option-参数"><a href="#配置-Option-参数" class="headerlink" title="配置 Option 参数"></a>配置 Option 参数</h3><p>调用 <code>option()</code> 可以设置 Channel 相关的参数，其实 ServerBootstrap 还有一个 <code>childOption()</code> 方法。两个方法的区别是：</p><ul><li><code>option()</code> ：是给 parent Channel 设置参数的</li><li><code>childOption()</code> ：是给 child Channel 设置参数的。</li></ul><p>为什么这里会有一个 parent Channel 和 child Channel 呢？首先我们需要明确一点，Channel 是 Socket 连接的一个抽象，我们可以理解它对 Socket 做了一些封装。当 Netty 建立一个连接后，它会为该连接 new 一个 Channel 实例。同时，它也有了父子的概念了，服务端监听的 Channel 叫做 parent Channel，对应每一个 Socket 连接的 Channel 叫做 child Channel。其实我们从设置 EventLoopGroup 的时候就可以看出，<code>group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>。</p><p>可以设置的参数比较多，之类列几个常见的：</p><ul><li>ChannelOption.CONNECT_TIMEOUT_MILLIS：客户端建立连接时，如果超过指定的时间仍未连接，则抛出 timeout 异常。</li><li>ChannelOption.SO_KEEPALIVE：是否开启 TCP 底层心跳机制，true 表示开启。</li><li>ChannelOption.TCP_NODELAY：是否启用 Nagle 算法，true 表示开启。开启可能会对消息的实时性有影响，因为为了提升效率， Nagle 算法会将一些较小的数据包收集后再进行发送，这样就会造成我们的消息有延迟。所以如果实时性要求高的话，一般不建议开启。</li><li>ChannelOption.SO_RCVBUF：设置接收缓冲区的大小  </li><li>ChannelOption.SO_SNDBUF：设置发送缓冲区的大小，一般 SO_RCVBUF 和 SO_SNDBUF 不建议手动设置，因为操作系统会根据当前占用，进行自动的调整。</li></ul><p>其他参数，大明哥就不一一介绍了，有兴趣的小伙伴可以自行研究，大明哥在后面的 Netty 调优部分会对这些字段进行详细讲解的。</p><h3 id="设置-pipeline"><a href="#设置-pipeline" class="headerlink" title="设置 pipeline"></a>设置 pipeline</h3><p>设值 pipeline 其实就是配置处理的 Handler，ChannelPipeline 负责协调这些 Handler，它是 Netty 处理请求的责任链，该链上每个节点都是 ChannelHandler，而这些 ChannelHandler 就是用来处理这些请求的。</p><p>ServerBoostrap 提供了 <code>childHandler()</code> 方法用来装配这些 ChannelHandler ，用来组装成一个处理请求的流水线。我们传递一个 ChannelInitializer 实例，ChannelInitializer 是一个特殊的 ChannelHandler，它主要是为我们提供了一个简单的工具，用于在某个 Channel 注册到 EventLoop 后，对这个 Channel 执行一些初始化操作。</p><p>ChannelInitializer 是一个抽象类，我们需要实现它的 <code>initChannel()</code>，在该方法中我们通过 ChannelPipeline 来完成流水线的装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;<span class="comment">//&#125;);</span></span><br></pre></td></tr></table></figure><p>ChannelHandler 有两种，分别是 ChannelInboundHandler 和 ChannelOutboundHandler，一个是处理进站，一个处理出站，通俗理解就是，ChannelInboundHandler 处理读入 IO 请求，ChannelOutboundHandler 处理写出 IO 请求。</p><p>我们调用 <code>ch.pipeline().addLast()</code> 方法可以装配一个 ChannelHandler 链，结构如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202205221000004.jpg" alt="img"></p><p>当读请求进来时，传播链从 head 出发，依次经过 InboundHandlerA，InboundHandlerB，InboundHandlerC，InboundHandlerD，最后在 Tail 终止。而写出 IO 请求则相反，它是从 Tail 出发，依次经过 OutboundHandlerB，OutboundHandlerA，最后在 Head 终止。</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Java%20%20NIO/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Java%20%20NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><h2 id="什么是-NIO"><a href="#什么是-NIO" class="headerlink" title="什么是 NIO"></a>什么是 NIO</h2><ul><li>Java NIO 全称 Java non-blocking IO，指的是 JDK 提供的新 API。从 JDK 1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO，即 New IO，是<code>同步非阻塞</code>的。</li><li>NIO 相关类都放在 java.nio 包下，并对原 java.io 包中很多类进行了改写。</li><li>NIO 有<strong>三大核心</strong>部分：<code>Channel（管道）</code>、<code>Buffer（缓冲区）</code>、<code>Selector（选择器）</code>。</li><li>NIO 是面向<code>缓冲区</code>编程的。数据读取到了一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络。</li><li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用数据，如果目前没有可用数据时，则说明不会获取，而不是保持线程阻塞，所以直到数据变为可以读取之前，该线程可以做其他事情。非阻塞写入同理。</li></ul><h2 id="三大核心组件"><a href="#三大核心组件" class="headerlink" title="三大核心组件"></a>三大核心组件</h2><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240716230507797.png" alt="image-20240716230507797"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="Channel-的概念"><a href="#Channel-的概念" class="headerlink" title="Channel 的概念"></a>Channel 的概念</h4><ul><li>Channel 是 Java NIO 中的一个接口，它定义了读写数据的基本操作。与传统的流不同，Channel 支持双向数据传输，即可以从 Channel 中读取数据，也可以向 Channel 写入数据。Channel 不直接处理数据，而是通过 Buffer 来读取和写入数据。这意味着数据总是从 Channel 读取到 Buffer 或者从 Buffer 写入到 Channel。</li></ul><h4 id="Channel-的类型"><a href="#Channel-的类型" class="headerlink" title="Channel 的类型"></a>Channel 的类型</h4><p>Java NIO 提供了几种不同的 Channel 类型，每种类型都有其特定的用途：</p><ul><li><code>FileChannel</code><ul><li>用于文件的读写操作。</li><li>可以从文件中读取数据到 Buffer，也可以从 Buffer 写入数据到文件。</li><li>支持映射文件到 Buffer，允许直接对文件内存映像进行操作。</li></ul></li><li><code>SocketChannel</code><ul><li>用于 TCP 套接字的读写操作。</li><li>可以从远程主机读取数据到 Buffer，也可以从 Buffer 向远程主机写入数据。</li><li>支持非阻塞模式，可以在没有数据可读或写的情况下不会阻塞线程。</li></ul></li><li><code>ServerSocketChannel</code><ul><li>用于监听 TCP 连接请求。</li><li>当有客户端尝试建立连接时，可以接受连接并创建一个新的 SocketChannel。</li><li>通常与 Selector 配合使用，以实现多路复用，即一个线程可以同时监听多个 ServerSocketChannel。</li></ul></li><li><code>DatagramChannel</code><ul><li>用于 UDP 协议的数据报文读写。</li><li>支持发送和接收 UDP 数据包。</li><li>由于 UDP 是无连接的协议，因此每次发送或接收数据都需要指定目标地址或源地址。</li></ul></li><li><code>Pipe.SinkChannel 和 Pipe.SourceChannel</code><ul><li>用于管道通信，SinkChannel 用于写入数据，SourceChannel 用于读取数据。</li><li>通常用于进程间通信或线程间的同步数据传输。</li></ul></li></ul><h4 id="Channel-的操作"><a href="#Channel-的操作" class="headerlink" title="Channel 的操作"></a>Channel 的操作</h4><p>Channel 提供了一系列的方法来执行读写操作，例如：</p><ul><li><code>read(ByteBuffer dst)</code>：从 Channel 读取数据到 Buffer。</li><li><code>write(ByteBuffer src)</code>：从 Buffer 写入数据到 Channel。</li><li><code>transferTo(long position, long count, WritableByteChannel target)</code>：直接从 Channel 转移数据到另一个 Channel，无需通过 Buffer。</li><li><code>transferFrom(ReadableByteChannel src, long position, long count)</code>：直接从另一个 Channel 转移数据到当前 Channel。</li></ul><h4 id="Channel-的特性"><a href="#Channel-的特性" class="headerlink" title="Channel 的特性"></a>Channel 的特性</h4><ul><li><strong>双向性</strong>：大多数 Channel 支持读写操作。</li><li><strong>非阻塞性</strong>：Channel 可以设置为非阻塞模式，这使得线程在没有数据可读或写时不会被阻塞。</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="Buffer的基本属性"><a href="#Buffer的基本属性" class="headerlink" title="Buffer的基本属性"></a>Buffer的基本属性</h4><p>Buffer主要由以下几个属性组成：</p><ul><li><code>capacity</code>（容量）：Buffer能够容纳的数据元素的最大数量。</li><li><code>limit</code>（界限）：Buffer中第一个不可读或不可写的位置，即Buffer中有效数据的末尾位置加一。</li><li><code>position</code>（位置）：下一个可读或可写元素的索引。当向Buffer写入数据时，position指向下一个可写入的位置；当从Buffer读取数据时，position指向下一个可读取的位置。</li><li><code>mark</code>（标记）：一个可选的备忘位置，可以用来保存position的值，稍后可以通过reset()方法恢复到这个位置。</li></ul><h4 id="Buffer的操作模式"><a href="#Buffer的操作模式" class="headerlink" title="Buffer的操作模式"></a>Buffer的操作模式</h4><p>Buffer 的操作模式分为读模式和写模式：</p><ul><li><strong>写模式</strong>：默认模式，此时position从0开始，可以向Buffer中写入数据，直到达到limit（默认为capacity）。</li><li><strong>读模式</strong>：通过调用flip()方法从写模式切换到读模式。此时，position变为0，limit变为之前的position，表示可以读取之前写入的所有数据。</li></ul><h4 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h4><ul><li><code>put()</code>：将数据写入Buffer。</li><li><code>get()</code>：从Buffer中读取数据。</li><li><code>flip()</code>：将Buffer从写模式切换到读模式。</li><li><code>rewind()</code>：重置position为0，但保留limit不变，通常用于再次读取Buffer中的所有数据。</li><li><code>clear()</code>：重置Buffer，position和limit都回到初始状态，相当于清空Buffer，使其可以再次被写入数据。</li><li><code>compact()</code>：将未读的数据移动到Buffer的起始位置，并清空已经读取的部分，position设置在未读数据的末尾，limit设置为capacity。这通常用于连续写入数据，而不需要重新分配Buffer。</li></ul><h4 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h4><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入Buffer</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换到读模式</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Buffer读取数据</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.remaining()];</span><br><span class="line">byteBuffer.get(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印读取的数据</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Selector是一个多路复用器，它能够同时监控多个Channel的I&#x2F;O操作。当一个Channel准备好进行读或写操作时，Selector会通知应用程序。这避免了轮询多个Channel的需要，从而减少了CPU的开销。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>注册Channel：应用程序首先需要将Channel注册到Selector上，注册时可以指定感兴趣的操作，如读、写或连接操作。</li><li>选择操作：Selector会阻塞在select()方法上，直到至少有一个Channel的I&#x2F;O操作就绪。select()方法返回就绪的Channel的数量。</li><li>处理事件：一旦select()返回，应用程序可以通过遍历Selector的selectedKeys()集合来获取就绪的Channel。每个就绪的Channel都有一个与之关联的SelectionKey，这个key包含了Channel的信息以及就绪的操作类型。</li><li>处理事件后清理：处理完就绪的Channel后，需要调用SelectionKey的cancel()方法来清除已处理的事件，否则这些事件会被重复报告。</li></ul><h4 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Selector</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 channel</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 选择就虚的channel </span></span><br><span class="line"><span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 没有就绪的Channel，可以做其他事情</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 处理就绪的Channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理就绪的channel </span></span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">   <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">   <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">       <span class="comment">// 处理新的连接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">       <span class="comment">// 读取数据</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">       <span class="comment">// 写入数据</span></span><br><span class="line">   &#125;</span><br><span class="line">   iterator.remove(); <span class="comment">// 清除已处理的key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p><strong>非阻塞性</strong></p><p>NIO允许应用程序在等待I&#x2F;O操作完成时执行其他任务，这在处理大量并发连接时特别有用，因为不必为每个连接分配一个线程。</p></li><li><p><strong>资源效率</strong></p><p>由于NIO使用较少的线程来处理更多的连接，因此可以显著降低系统的资源消耗，提高服务器的负载能力。</p></li><li><p><strong>高性能</strong></p><p>NIO通过使用Buffer和Channel，减少了数据复制的次数，提高了数据处理的速度。此外，使用Selector可以高效地管理多个Channel，避免了轮询的开销。</p></li><li><p><strong>灵活性</strong></p><p>NIO提供了更高级别的抽象，如文件映射缓冲区，允许直接在内存映射文件上操作，这在大数据量的文件处理中非常高效。</p></li><li><p><strong>异步操作</strong></p><p>NIO支持异步文件操作，如异步读写，这在处理大文件或长时间运行的任务时非常有用。</p></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p><strong>复杂性</strong></p><p>NIO的API比传统的IO API更复杂，需要程序员对Buffer、Channel和Selector有深入的理解才能正确使用。</p><p>此外开发者还需要花费很多时间去学习NIO的概念和编程模式，这对于习惯了传统IO的开发者来说可能是一个挑战。</p></li><li><p>调试难度</p><p>NIO的非阻塞性质使得调试和定位问题变得困难，尤其是当涉及到复杂的并发问题时。</p></li><li><p>兼容性</p><p>NIO的一些高级特性可能在某些老旧的JVM版本或操作系统上不受支持，这可能限制了其在某些环境下的应用。</p></li><li><p>错误处理</p><p>错误处理在NIO中更加复杂，因为错误可能不会立即显现，而是会在后续的I&#x2F;O操作中才被发现。</p></li><li><p>线程安全</p><p>在多线程环境中使用NIO需要额外注意线程安全，因为Buffer和Channel的操作需要在适当的同步机制下进行</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Netty%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Netty%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty-概述"><a href="#Netty-概述" class="headerlink" title="Netty 概述"></a>Netty 概述</h1><h2 id="Netty-总体内容"><a href="#Netty-总体内容" class="headerlink" title="Netty 总体内容"></a>Netty 总体内容</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/CgqCHl-NAQaABGcDAAZa0pmBs40719.png" alt="CgqCHl-NAQaABGcDAAZa0pmBs40719"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/420lgrdxx7.png" alt="img"></p><ul><li>基础知识<ul><li>Java NIO：Netty 基于 Java NIO 构建，因此理解 NIO 的概念（如 Selector, Channel, Buffer）是非常重要的。</li><li>多线程：熟悉 Java 的多线程编程，理解线程模型和并发控制。</li><li>网络编程：了解 TCP&#x2F;IP 协议栈，熟悉网络编程的基本原理和术语。</li></ul></li><li>Netty 核心概念<ul><li>EventLoop 和 EventLoopGroup：理解 Netty 的事件循环机制，如何管理和调度 I&#x2F;O 任务。</li><li>Channel 和 ChannelHandlerContext：Channel 是 Netty 中 I&#x2F;O 操作的中心，而 ChannelHandlerContext 提供了对 Channel 的操作上下文。</li><li>Pipeline：理解 Channel 的 Pipeline 概念，以及如何使用 Inbound 和 Outbound handlers 来处理 I&#x2F;O 事件。</li><li>Bootstrap：Bootstrap 是启动 Netty 服务的起点，用于配置服务的参数和初始化 Channel。</li></ul></li><li>编码和解码<ul><li>ByteBuf：Netty 中用于操作字节缓冲区的类，了解如何使用 ByteBuf 进行数据读写。</li><li>Codec：学习如何使用编解码器（Encoder 和 Decoder）来处理数据的序列化和反序列化。</li><li>MessageToMessageEncoder &#x2F; MessageToMessageDecoder：用于在不同消息类型之间转换的编解码器。</li></ul></li><li>网络协议<ul><li>HTTP&#x2F;HTTPS：Netty 支持多种协议，了解如何使用 Netty 开发 HTTP 或 HTTPS 服务器和客户端。</li><li>WebSocket：学习 WebSocket 协议的实现，以及如何使用 Netty 构建 WebSocket 服务。</li></ul></li><li>高级特性<ul><li>ChannelFuture：用于异步操作的结果和回调。</li><li>ChannelPromise：用于异步操作的承诺，通常在 ChannelFuture 的回调中使用。</li><li>ChannelOption 和 Attribute：了解如何配置 Channel 的选项和附加属性。</li><li>自定义 Handler：学习如何开发自定义的 ChannelHandler 来处理特定的 I&#x2F;O 事件。</li></ul></li><li>性能优化<ul><li>Zero-Copy：理解 Netty 中的零拷贝技术，如何减少数据复制以提高性能。</li><li>内存管理：了解 Netty 的内存管理机制，以及如何避免内存泄漏。</li></ul></li><li>故障处理和调试<ul><li>异常处理：学习如何处理 Netty 中可能出现的各种异常和错误。</li><li>日志记录：了解如何配置和使用日志记录来调试和监控 Netty 应用程序。</li></ul></li></ul><h2 id="Netty-入门"><a href="#Netty-入门" class="headerlink" title="Netty 入门"></a>Netty 入门</h2><h3 id="HelloWorld-案例"><a href="#HelloWorld-案例" class="headerlink" title="HelloWorld 案例"></a>HelloWorld 案例</h3><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 boosGroup、workerGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动对象，设置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//设置两个线程组boosGroup和workerGroup</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">//设置服务端通道实现类型    </span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//设置线程队列得到连接个数    </span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//设置保持活动连接状态    </span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//使用匿名内部类的形式初始化通道对象    </span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(<span class="number">7777</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发送消息给客户端</span></span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;message received&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发生异常，关闭通道</span></span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建bootstrap对象，配置参数</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置线程组</span></span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                <span class="comment">//设置客户端的通道实现类型    </span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//使用匿名内部类初始化通道</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//添加客户端通道的处理器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对通道关闭进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发送消息到服务端</span></span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Hello Server&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//接收服务端发送过来的消息</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心组件-属性"><a href="#核心组件-属性" class="headerlink" title="核心组件&#x2F;属性"></a>核心组件&#x2F;属性</h3><ul><li>ServerBootStrap &#x2F; BootStrap</li><li>EventLoopGroup — bossGroup &#x2F; workerGroup</li><li>option &#x2F; childOption</li><li>pipeline</li><li>handler</li><li>channel</li><li>ChannelHandlerContext</li><li>ByteBuf</li></ul><p>后续会对其中的组件分别进行介绍</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/IO%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/IO%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-概述"><a href="#IO-概述" class="headerlink" title="IO 概述"></a>IO 概述</h1><p>输入&#x2F;输出（Input&#x2F;Output，简称I&#x2F;O）是计算机科学中的基本概念，涉及计算机与外部世界的数据交换。I&#x2F;O操作可以发生在硬件设备之间，也可以在软件与硬件之间进行。下面是对I&#x2F;O系统的全面介绍，包括其概念、分类、模型以及在现代操作系统中的实现。</p><h2 id="I-O的概念"><a href="#I-O的概念" class="headerlink" title="I&#x2F;O的概念"></a>I&#x2F;O的概念</h2><p>I&#x2F;O是指计算机系统与外部环境之间的数据传输过程。输入操作是从外部设备读取数据到计算机系统，而输出操作是将数据从计算机系统发送到外部设备。外部设备可以是键盘、鼠标、显示器、打印机、磁盘驱动器、网络接口卡等。</p><h2 id="I-O的分类"><a href="#I-O的分类" class="headerlink" title="I&#x2F;O的分类"></a>I&#x2F;O的分类</h2><p>I&#x2F;O可以按照不同的标准进行分类：</p><ul><li>按设备类型：分为字符设备（如键盘、终端）和块设备（如硬盘、光驱）。</li><li>按数据传输方向：分为输入（从设备到系统）和输出（从系统到设备）。</li><li>按数据传输方式：分为串行I&#x2F;O和并行I&#x2F;O。</li><li>按数据传输速度：分为高速I&#x2F;O和低速I&#x2F;O。</li><li>按数据传输协议：分为USB、PCI、SATA、Ethernet等。</li></ul><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>I&#x2F;O模型描述了数据如何在用户空间和内核空间之间传输，主要有以下几种：</p><ul><li><strong>阻塞I&#x2F;O</strong>（Blocking I&#x2F;O）：是最常见的模型，当进程发起I&#x2F;O请求时，它会被挂起直到I&#x2F;O操作完成。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125534850-1197249268.png" alt="img"></p><ul><li><strong>非阻塞I&#x2F;O</strong>（Non-blocking I&#x2F;O）：进程发起I&#x2F;O请求后不会被挂起，而是立即返回，如果数据不可用则返回一个错误。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125615836-918812694.png" alt="img"></p><ul><li><strong>I&#x2F;O多路复用</strong>（I&#x2F;O Multiplexing）：使用如select、poll或epoll等系统调用，可以让单个进程同时监听多个文件描述符的I&#x2F;O事件。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125835677-896662204.png" alt="img"></p><ul><li><strong>异步I&#x2F;O</strong>（Asynchronous I&#x2F;O）：进程发起I&#x2F;O请求后继续执行，当I&#x2F;O操作完成时，系统会通知进程。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125908929-2128858514.png" alt="img"></p><ul><li><strong>信号驱动I&#x2F;O</strong>（Signal-driven I&#x2F;O）：类似于异步I&#x2F;O，但使用信号来通知进程I&#x2F;O事件的发生。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125811408-1472626030.png" alt="img"></p><h3 id="基本分类依据"><a href="#基本分类依据" class="headerlink" title="基本分类依据"></a>基本分类依据</h3><ul><li>阻塞&#x2F;非阻塞（Blocking vs Non-blocking）<ul><li>阻塞I&#x2F;O（Blocking I&#x2F;O）<ul><li>当一个线程发起一个阻塞I&#x2F;O操作时，该线程会暂停执行，直到I&#x2F;O操作完成。</li><li>在此期间，线程不能执行任何其他任务，这可能浪费计算资源，尤其是在I&#x2F;O操作耗时较长的情况下。</li><li>阻塞I&#x2F;O常用于单线程或多线程环境中的简单I&#x2F;O操作。</li></ul></li><li>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）<ul><li>当一个线程发起一个非阻塞I&#x2F;O操作时，如果I&#x2F;O操作不能立即完成，该操作会立即返回一个错误或特殊值，线程可以继续执行其他任务。</li><li>线程需要定期检查I&#x2F;O操作是否完成，这通常通过轮询或使用I&#x2F;O多路复用来实现。</li><li>非阻塞I&#x2F;O允许线程在等待I&#x2F;O的同时执行其他工作，提高了资源利用率。</li></ul></li></ul></li><li>同步&#x2F;异步（Synchronous vs Asynchronous）<ul><li>同步（Synchronous）<ul><li>在同步操作中，调用者发出一个请求后，必须等待直到请求完成才能继续执行后续代码。</li><li>请求的响应是同步返回的，调用者在等待响应时无法执行其他任务。</li><li>同步操作通常用于短时间操作或在单线程环境中。</li></ul></li><li>异步（Asynchronous）<ul><li>在异步操作中，调用者发出一个请求后，可以立即继续执行后续代码，无需等待请求完成。</li><li>请求的响应会在将来某个时刻通过回调、事件、future&#x2F;promise等方式返回，调用者可以在此期间执行其他任务。</li><li>异步操作适用于长时间运行的操作或在多线程&#x2F;多进程环境中。</li></ul></li></ul></li><li>区别总结<ul><li>阻塞&#x2F;非阻塞 关注的是线程在等待I&#x2F;O操作时的状态，即是否会被挂起。</li><li>同步&#x2F;异步 关注的是调用者在等待操作完成时的行为，即是否可以继续执行其他操作。</li></ul></li></ul><h2 id="I-O在操作系统中的实现"><a href="#I-O在操作系统中的实现" class="headerlink" title="I&#x2F;O在操作系统中的实现"></a>I&#x2F;O在操作系统中的实现</h2><p>在现代操作系统中，I&#x2F;O操作的实现通常涉及以下几个关键组件：</p><ul><li>设备驱动程序：负责与物理设备通信，提供设备的抽象接口。</li><li>缓冲区管理：操作系统使用缓冲区来缓存数据，以减少对物理设备的访问次数，提高性能。</li><li>中断处理：设备完成I&#x2F;O操作后，会向CPU发送中断信号，操作系统会响应中断并处理I&#x2F;O结果。</li><li>系统调用：如read、write、open、close等，提供用户空间与内核空间交互的接口。</li></ul><h2 id="I-O性能优化"><a href="#I-O性能优化" class="headerlink" title="I&#x2F;O性能优化"></a>I&#x2F;O性能优化</h2><p>为了提高I&#x2F;O性能，操作系统和应用程序可能会采用以下策略：</p><ul><li>缓存：使用高速缓存来减少对慢速设备的访问。</li><li>DMA（Direct Memory Access）：允许设备直接访问内存，无需CPU介入，提高数据传输速度。</li><li>并发：通过多线程或异步I&#x2F;O，允许多个I&#x2F;O操作同时进行。</li><li>批处理：一次处理多个I&#x2F;O请求，减少I&#x2F;O操作的开销。</li><li>预测性I&#x2F;O：基于历史模式预测未来的I&#x2F;O请求，提前加载数据。</li></ul><h2 id="IO-交互过程"><a href="#IO-交互过程" class="headerlink" title="IO 交互过程"></a>IO 交互过程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125037162-803835128.png" alt="img"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125247097-1784257745.png" alt="img"></p><p>内核空间中存放的是内核代码和数据、而进程的用户空间中存放的是用户程序的代码和数据、不管是内核空间还是用户空间、它们都处于虚拟空间中、Linux使用两级保护机制：0级供内核使用、3级供用户程序使用、</p><p> 操作系统和驱动程序运行在内核空间、应用程序运行在用户空间、两者不能简单地使用指针传递数据、因为Linux使用的虚拟内存机制、其必须通过系统调用请求kernel来协助完成IO动作、内核会为每个IO设备维护一个缓冲区、用户空间的数据可能被换出、当内核空 间使用用户空间指针时、对应的数据可能不在内存中</p><p>对于一个输入操作来说、进程IO系统调用后、内核会先看缓冲区中有没有相应的缓存数据、没有的话再到设备中读取、因为设备IO一般速度较慢、需要等待、内核缓冲区有数据则直接复制到进程空间、</p><p>所以、对于一个网络输入操作通常包括两个不同阶段：</p><p>（1）等待网络数据到达网卡 –&gt; 读取到内核缓冲区</p><p>（2）从内核缓冲区复制数据 –&gt; 用户空间</p><p>IO有内存IO、网络IO和磁盘IO三种、通常我们说的IO指的是后两者</p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/1、HTTP/2 和 HTTP/3 对比</title>
      <link href="/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/QUIC%20%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/QUIC%20%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="QUIC-协议介绍"><a href="#QUIC-协议介绍" class="headerlink" title="QUIC 协议介绍"></a>QUIC 协议介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>QUIC，发音同quick，是”Quick UDP Internet Connections”的简称，是一种通用的传输层网络协议。QUIC与TCP相同，是一种有连接的传输协议。但是与TCP不同的是QUIC是建立在UDP传输层协议之上的，实现了在两个端点之间的多路复用。QUIC的是在用户空间实现的，TCP&#x2F;UDP则是在内核空间实现的。</p><p>QUIC所处的网络层次如下图所示。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194320126-1654964147.png" style="zoom:67%;" /><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：<br>1、减少了 TCP 三次握手及 TLS 握手时间。<br>2、改进的拥塞控制。<br>3、避免队头阻塞的多路复用。<br>4、连接迁移。<br>5、前向安全。</p><h3 id="快速建联"><a href="#快速建联" class="headerlink" title="快速建联"></a>快速建联</h3><p>QUIC实现了快速握手，并把握手过程分为两种情况，分别是1-RTT和0-RTT。（前置知识： Diffie-Hellman算法的基本原理）</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194321095-535625030.png" alt="image_202"></p><p>在上图中显示了三种不同情况的连接过程。其中最左边的图表示的是第一次连接时的情况，中间的图表示重复连接的情况（在一定条件下，客户端可以重新连接服务器而不需要从初始化情况连接），最右边的图则是重连失败之后从初始话连接的情况。最后一种情况是第一种情况的组会，0-RTT也是1-RTT的一部分，后文中将重点介绍1-RTT的连接过程。</p><h4 id="1-RTT"><a href="#1-RTT" class="headerlink" title="1-RTT"></a>1-RTT</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194321846-1226453431.png" alt="QUIC_1_RTT"></p><p><strong>第一次握手</strong>：</p><ul><li>客户端主动向服务器发送Inchoate CHLO报文</li><li>服务器会向客户端发送REJ报文。REJ报文包含了服务器的配置信息，如长期的Diffie-Hellman值，服务器配置的签名，source-address-token(stk, 用于验证的加密块，包含有服务器看到的客户端的IP地址和服务器当前的时间戳，之后客户端会将该stk发回)等，为了进行身份证明还会使用私钥进行签名，同时也可以防篡改；</li><li>在收到服务器的配置信息后，客户端会通过证书链机制验签，并实现对服务器的身份认证。</li></ul><p><strong>第二次握手</strong>：</p><ul><li>客户端在通过对服务器的验证之后，客户端会生成一个Diffie-Hellman值。此时客户端有了自身和对方的Diffie-Hellman值，就可以计算出初始密钥（initial key, ik）；</li><li>客户端将包含有DH公开之的明文Complete CHLO发送至服务器；</li><li>客户端使用ik对请求数据加密，发送至服务器；</li><li>服务器收到Complete CHLO之后就可以获得客户端的Diffie-Hellman的值，就可以计算出初始密钥。</li><li>服务器立即向客户端发送SHLO报文（ik加密的）。SHLO报文含有一个服务器临时Diffie-Hellman值，可以用于计算前向安全的密钥（会话密钥）；</li><li>服务器收到加密的请求数据，使用初始密钥进行解密；</li><li>服务器使用会话密钥对响应数据进行加密，发回给客户端。</li><li>客户端在收到SHLO之后使用初始密钥解密得到服务器的临时DH公开值，根据该临时值计算出会话密钥；</li><li>客户端收到加密的响应数据后，使用会话密钥进行解密。</li></ul><p>整个握手过程会在2个RTT内完成。</p><h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p>客户端在重连同一个服务器时，会使用已经缓存的服务器相关配置信息（stk，DH公开值等信息），并直接向服务器发送Complete CHLO报文，并使用ik对请求报文进行加密。但是服务器方面会标识相应的stk等信息已经过期，这时服务器会发送REJ信息，客户端需要重新与服务器进行连接。</p><p>如果没有过期的话，就可以直接建立连接，省下了重新建立连接的开销。</p><p>【注】其实需要发送 initial 报文，明文提供历史会话信息 和 客户端 ID ，供服务端查找 PSK </p><h4 id="多路复用机制"><a href="#多路复用机制" class="headerlink" title="多路复用机制"></a>多路复用机制</h4><p>基于TCP的应用程序会在TCP单字节流抽象层中实现多路复用。为了避免由于TCP顺序传递导致的头部阻塞（head-of-line blocking），QUIC支持在单个UDP连接中复用多个流，并保证UDP报文的丢失仅影响相应的流，而不会影响其他的流（stream）。</p><p>可以在QUIC流上构建任意大小的应用程序报文，最多支持264264的字节。并且stream的实现是轻量级的，即使消息报文很小也可以为它们使用单独的流。每一个Stream都有stream ID唯一标识。这些流ID由客户端&#x2F;服务器进行静态分配。客户端主动发起的流的ID永远是奇数，服务器发起的流的ID是偶数。这样可以避免冲突。当在一个未使用过的流上发送数据时，流会自动创建；当需要关闭时，就会在最后一帧数据上设置一个FIN的标志指示接收方关闭流。如果发送方或接收方确定不再需要流上的数据，则可以取消流，而无需断开整个 QUIC 连接。尽管流是可靠的抽象，但 QUIC 不会为已取消的流重新传输数据。</p><p>一个QUIC包是由一个公共的头后面跟着一个或多个帧组成的，如下图所示。QUIC流复用是通过将流数据封装在一个或多个流帧中来实现的，单个QUIC包可以携带来自多个流的流帧.</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194322442-307715805.png" alt="image_205"></p><h3 id="丢包重传"><a href="#丢包重传" class="headerlink" title="丢包重传"></a>丢包重传</h3><p>TCP 序列号有助于提高可靠性，并表示在接收方传送字节的顺序。这种混淆会导致“重传模糊”（retransmission ambiguity）问题，因为重传的 TCP 段携带与原始数据包相同的序列号 。 TCP ACK 的接收者无法确定 ACK 是为原始传输还是为重传而发送，并且通常通过昂贵的超时来检测重传段的丢失。每个 QUIC 数据包都携带一个新的数据包编号，包括那些携带重传数据的数据包。这种设计不需要单独的机制来区分重传的 ACK 和原始传输的 ACK，从而避免了 TCP 的重传模糊问题。流帧中的流偏移用于传递排序，数据包编号表示一个明确的时间顺序，这使得丢失检测比 TCP 更简单、更准确。</p><p>QUIC的ACK显示地记录了接收的数据报文和ACK之间的延迟。单调增加的报文编号一起，可以精确估算RTT，有助于丢失检测。QUIC的确认报文支持多达256个ACK，这是使得QUIC比带有SACK的TCP更能适应重新排序或丢失的情况下在线路上保留更多字节。</p><h3 id="流量控制-Flow-Control"><a href="#流量控制-Flow-Control" class="headerlink" title="流量控制(Flow Control)"></a>流量控制(Flow Control)</h3><p>当应用程序从QUIC的接收缓冲区中读取数据较慢时，留恋控制就会限制接收者必须保持的接收缓冲区大小。一个缓慢耗尽的stream会逐渐耗尽整个连接connection的缓冲区，因此必须要限制QUIC连接上的每个流可以消耗的缓冲区大小，避免消耗其他流的缓冲区的大小。这样可以改善流之间潜在的队头阻塞（head-of-line blocking）。因此QUIC采用连接级别的流量控制（connection-level flow control），这样可以限制发送者在所有流中接收者使用的聚合缓冲区；采用流级别的流量控制(stream-level flow control)可以限制发送者在任何给定流上使用的缓冲区。</p><p>与HTTP&#x2F;2类似，QUIC采用基于信用的流量控制。QUIC接收器在每个流中通告接收器愿意接收数据的绝对字节偏移量。在特定流上发送、接收和传递数据时，接收器会定期发送窗口更新帧，以增加该流的窗口偏移限制，从而允许对等方在该流上发送更多数据。连接级流量控制的工作方式与流级流量控制相同，但传递的字节数和接收到的最高偏移量是所有流的。</p><h3 id="拥塞控制（Congestion-Control）"><a href="#拥塞控制（Congestion-Control）" class="headerlink" title="拥塞控制（Congestion Control）"></a>拥塞控制（Congestion Control）</h3><p>QUIC支持的拥塞控制算法有：<br>Reno（TCP用的）、基于Pacing的拥塞控制算法（PBCCA）、TCP CUBIC等。</p><h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>QUIC连接使用随机生成的64bit的cid唯一确定。cid允许客户机在网络之间漫游，而不受网络或传输层参数变化的影响。</p><p>cid使得客户端能够独立于网络地址转换（network address translation, NAT）之外。cid 在路由中起着重要作用，特别是用于连接标识的目的。此外，使用 cids 可以通过探测连接的新路径实现多路径。</p><p>在连接迁移期间，端点假设对等方愿意在其当前地址接受数据包。因此，端点可以迁移到新的 IP 地址，而无需首先验证对等方的 IP 地址。新的路由路径可能不支持端点的当前发送速率。在这种情况下，端点需要重新构建它的拥塞控制器。另一方面，从一个新的对等地址接收非探测包 ，确认对等地址已迁移到新的 IP 地址。</p><h2 id="QUIC-协议的安全风险分析"><a href="#QUIC-协议的安全风险分析" class="headerlink" title="QUIC 协议的安全风险分析"></a>QUIC 协议的安全风险分析</h2><h3 id="1-重放攻击"><a href="#1-重放攻击" class="headerlink" title="1. 重放攻击"></a>1. 重放攻击</h3><p>QUIC 协议中的 0-RTT 握手机制虽然显著减少了连接建立的延迟，但也带来了重放攻击的风险。在 0-RTT 握手中，客户端可以在首次发送数据包时就包含应用数据，这使得攻击者可以通过重发这些数据包来完成攻击。</p><p><strong>应对措施</strong>：</p><ul><li><strong>幂等性</strong>：QUIC 对帧的处理是幂等的，无论是重放、重排序、包丢失，都不会导致无效的连接状态。</li><li><strong>校验机制</strong>：0-RTT 握手时，QUIC 要求客户端传输 TLS 会话 ticket 和地址验证 token，使得连接状态高效地检查和恢复。</li><li><strong>关闭 0-RTT</strong>：关闭 0-RTT 是对抗重放攻击最有效的手段。如果要使用 0-RTT，QUIC 要求应用程序做进一步的安全校验。</li></ul><h3 id="2-连接迁移中的安全风险"><a href="#2-连接迁移中的安全风险" class="headerlink" title="2. 连接迁移中的安全风险"></a>2. 连接迁移中的安全风险</h3><p>QUIC 支持连接迁移，允许客户端在不同网络之间无缝切换。然而，这一特性也可能被攻击者利用，例如通过篡改连接 ID 或源地址 token 来发起攻击。</p><p><strong>应对措施</strong>：</p><ul><li><strong>IP 地址验证</strong>：QUIC 使用特殊的机制来验证新的客户端地址，例如服务器发送一个特殊的探测包到新地址，客户端必须正确响应这个探测才能完成迁移。</li><li><strong>限制连接迁移</strong>：在某些高安全需求的场景中，可以限制连接迁移的使用，或者对迁移后的连接进行额外的安全检查。</li></ul><h3 id="3-反射放大攻击"><a href="#3-反射放大攻击" class="headerlink" title="3. 反射放大攻击"></a>3. 反射放大攻击</h3><p>QUIC 协议在设计之初就考虑了防止反射放大攻击的安全风险，但实际应用中仍存在被利用的可能性。攻击者可以利用 QUIC 服务器作为反射放大器，发送大量恶意的 Initial 请求，消耗服务器资源和带宽，甚至导致拒绝服务。</p><p><strong>应对措施</strong>：</p><ul><li><strong>流量监测与过滤</strong>：对 QUIC 流量进行实时监测，识别并过滤异常流量，特别是那些具有反射放大特征的流量。</li><li><strong>限制请求来源</strong>：通过限制请求来源的 IP 地址范围或域名，减少反射放大攻击的可能性。</li><li><strong>使用专业的 DDoS 防护服务</strong>：在面对大规模反射放大攻击时，建议寻求专业的 DDoS 防护团队协助。</li></ul><h3 id="4-前向安全性"><a href="#4-前向安全性" class="headerlink" title="4. 前向安全性"></a>4. 前向安全性</h3><p>QUIC 协议支持前向安全性，即使长期密钥被泄露，过去的通信仍然是安全的。这一特性通过定期更新加密密钥来实现。</p><p><strong>潜在风险</strong>：</p><ul><li><strong>密钥更新机制的实现问题</strong>：如果密钥更新机制没有正确实现，可能会导致前向安全性受损。</li></ul><p><strong>应对措施</strong>：</p><ul><li><strong>严格遵循协议规范</strong>：确保 QUIC 实现严格遵循协议规范，正确实现密钥更新机制。</li><li><strong>定期审计与测试</strong>：对 QUIC 实现进行定期的安全审计和测试，确保前向安全性机制的有效性。</li></ul><h3 id="5-其他安全风险"><a href="#5-其他安全风险" class="headerlink" title="5. 其他安全风险"></a>5. 其他安全风险</h3><ul><li><strong>源地址 token 操作攻击</strong>：攻击者可以篡改源地址 token，导致客户端和服务器生成不同的密钥，从而无法完成正常的信息交流。</li><li><strong>加密流偏移攻击</strong>：攻击者可以通过反转字节流数据，破坏字节流，导致连接建立失败。</li></ul><p><strong>应对措施</strong>：</p><ul><li><strong>增强加密机制</strong>：使用更强大的加密算法和密钥管理机制，减少此类攻击的风险。</li><li><strong>应用层防护</strong>：在应用层实现额外的安全校验机制，确保数据的完整性和一致性。</li></ul><h2 id="QUIC-实施难点与应对策略"><a href="#QUIC-实施难点与应对策略" class="headerlink" title="QUIC 实施难点与应对策略"></a>QUIC 实施难点与应对策略</h2><h3 id="中间设备兼容性"><a href="#中间设备兼容性" class="headerlink" title="中间设备兼容性"></a>中间设备兼容性</h3><p>许多现有的防火墙和 NAT 设备可能不理解或不支持 QUIC 协议，可能会错误地阻止 QUIC 流量。此外，传统的基于 TCP 的负载均衡器可能无法正确处理 QUIC 流量。</p><h4 id="应对策略："><a href="#应对策略：" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>升级防火墙、NAT 设备和负载均衡器，以支持 QUIC 协议。</li><li>使用支持 QUIC 的网络监控工具，以确保网络的可管理性和安全性。</li></ul><h3 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h3><p>QUIC 默认对所有数据进行加密，这增加了 CPU 的计算负担。在高吞吐量场景下，这可能导致服务器和客户端的 CPU 使用率显著增加。</p><h4 id="应对策略：-1"><a href="#应对策略：-1" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>使用更高效的加密算法，减少加密开销。</li><li>利用硬件加速技术（如 GPU 或专用加密芯片）来处理加密和包处理任务。</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>由于 QUIC 流量是加密的，传统的网络分析工具可能无法提供详细的可见性。这增加了识别和解决网络问题的难度。</p><h4 id="应对策略：-2"><a href="#应对策略：-2" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>使用支持 QUIC 协议的调试工具，如 Wireshark。</li><li>在应用程序和服务中实现详细的日志记录功能，以便在出现问题时能够快速定位和解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> UDP </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/1、HTTP/2 和 HTTP/3 对比</title>
      <link href="/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1%20HTTP2%20HTTP3%20%20%E6%BC%94%E5%8C%96%E4%B8%8E%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1%20HTTP2%20HTTP3%20%20%E6%BC%94%E5%8C%96%E4%B8%8E%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-1、HTTP-2-和-HTTP-3-对比：关键特性与演变"><a href="#HTTP-1、HTTP-2-和-HTTP-3-对比：关键特性与演变" class="headerlink" title="HTTP&#x2F;1、HTTP&#x2F;2 和 HTTP&#x2F;3 对比：关键特性与演变"></a>HTTP&#x2F;1、HTTP&#x2F;2 和 HTTP&#x2F;3 对比：关键特性与演变</h2><h3 id="HTTP-1-0：基础与局限"><a href="#HTTP-1-0：基础与局限" class="headerlink" title="HTTP&#x2F;1.0：基础与局限"></a>HTTP&#x2F;1.0：基础与局限</h3><h4 id="关键特性：短连接"><a href="#关键特性：短连接" class="headerlink" title="关键特性：短连接"></a>关键特性：短连接</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的第一个广泛应用版本，其核心特性是<strong>短连接</strong>。每次请求都需要建立一个新的 TCP 连接，请求完成后立即关闭连接。这种机制简单直接，但存在显著的性能问题：</p><ul><li><strong>高延迟</strong>：频繁建立和关闭 TCP 连接导致高延迟。</li><li><strong>资源消耗</strong>：每个请求都需要完整的 TCP 三次握手和四次挥手。</li></ul><p>此外，HTTP&#x2F;1.0 的协议结构简单，仅支持基本的请求方法（如 GET、POST）和头部字段。虽然引入了基础的缓存支持（如 <code>Expires</code> 字段），但缺乏细粒度的缓存控制。</p><h3 id="HTTP-1-1：性能优化与持久连接"><a href="#HTTP-1-1：性能优化与持久连接" class="headerlink" title="HTTP&#x2F;1.1：性能优化与持久连接"></a>HTTP&#x2F;1.1：性能优化与持久连接</h3><h4 id="关键特性：持久连接与管道化"><a href="#关键特性：持久连接与管道化" class="headerlink" title="关键特性：持久连接与管道化"></a>关键特性：持久连接与管道化</h4><p>HTTP&#x2F;1.1 在 HTTP&#x2F;1.0 的基础上引入了<strong>持久连接</strong>和<strong>管道化</strong>。持久连接允许在单个 TCP 连接上发送多个请求和响应，减少了连接建立和关闭的开销。管道化则允许客户端在收到上一个响应之前发送下一个请求，提高了请求的并发性。</p><p>然而，HTTP&#x2F;1.1 仍然存在<strong>队头阻塞</strong>问题。由于响应必须按顺序返回，一个慢响应会阻塞后续响应。此外，HTTP&#x2F;1.1 的头部信息冗余较高，每个请求都会发送完整的头部信息。</p><h3 id="HTTP-2：二进制分帧与多路复用"><a href="#HTTP-2：二进制分帧与多路复用" class="headerlink" title="HTTP&#x2F;2：二进制分帧与多路复用"></a>HTTP&#x2F;2：二进制分帧与多路复用</h3><h4 id="关键特性：二进制分帧与多路复用"><a href="#关键特性：二进制分帧与多路复用" class="headerlink" title="关键特性：二进制分帧与多路复用"></a>关键特性：二进制分帧与多路复用</h4><p>HTTP&#x2F;2 的核心特性是<strong>二进制分帧</strong>和<strong>多路复用</strong>。二进制分帧机制将数据划分为更小的帧，这些帧可以独立传输和重组，使得协议解析更高效。多路复用则允许在单个 TCP 连接上并行发送多个请求和响应，解决了 HTTP&#x2F;1.1 的队头阻塞问题。</p><p>HTTP&#x2F;2 还引入了<strong>头部压缩</strong>（HPACK 算法），减少了头部信息的冗余。此外，HTTP&#x2F;2 支持<strong>服务器推送</strong>，允许服务器主动向客户端推送资源，优化了页面加载速度。</p><h3 id="HTTP-3：基于-QUIC-的下一代协议"><a href="#HTTP-3：基于-QUIC-的下一代协议" class="headerlink" title="HTTP&#x2F;3：基于 QUIC 的下一代协议"></a>HTTP&#x2F;3：基于 QUIC 的下一代协议</h3><h4 id="关键特性：QUIC-协议"><a href="#关键特性：QUIC-协议" class="headerlink" title="关键特性：QUIC 协议"></a>关键特性：QUIC 协议</h4><p>HTTP&#x2F;3 是基于 QUIC 协议的下一代 HTTP 协议。QUIC 是一种基于 UDP 的传输层协议，旨在减少网络延迟，提高网络速度。HTTP&#x2F;3 的核心特性包括：</p><ul><li><strong>连接迁移</strong>：通过引入 Connection ID，HTTP&#x2F;3 支持连接迁移，即使客户端的 IP 地址或端口发生变化，连接依然可以维持。</li><li><strong>无队头阻塞</strong>：QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流，解决了 TCP 中队头阻塞的问题。</li><li><strong>更快的连接建立</strong>：QUIC 允许 TLS 版本协商与加密和传输握手同时发生，显著减少了连接建立时间。</li><li><strong>零往返时间（0-RTT）</strong>：对于已经连接的服务器，客户端可以跳过握手要求，进一步减少了延迟。</li></ul><h3 id="关键特性对比"><a href="#关键特性对比" class="headerlink" title="关键特性对比"></a>关键特性对比</h3><table><thead><tr><th align="left">特性</th><th align="left">HTTP&#x2F;1.0</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2</th><th align="left">HTTP&#x2F;3</th></tr></thead><tbody><tr><td align="left"><strong>连接管理</strong></td><td align="left">短连接（每次请求新建连接）</td><td align="left">持久连接（默认 keep-alive）</td><td align="left">多路复用（一个连接并行处理）</td><td align="left">基于 UDP 的 QUIC，无 TCP 连接</td></tr><tr><td align="left"><strong>数据传输</strong></td><td align="left">文本格式</td><td align="left">文本格式</td><td align="left">二进制格式</td><td align="left">二进制格式</td></tr><tr><td align="left"><strong>队头阻塞</strong></td><td align="left">存在</td><td align="left">存在（管道化部分缓解）</td><td align="left">完全解决</td><td align="left">完全解决</td></tr><tr><td align="left"><strong>头部压缩</strong></td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持（HPACK 算法）</td><td align="left">支持（QPACK 算法）</td></tr><tr><td align="left"><strong>服务器推送</strong></td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">无</td><td align="left">无</td><td align="left">通常基于 HTTPS</td><td align="left">通常基于 HTTPS</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">低</td><td align="left">中等</td><td align="left">高</td><td align="left">最高</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTP&#x2F;1.0 作为基础版本，虽然简单但存在性能瓶颈。HTTP&#x2F;1.1 通过持久连接和管道化显著提升了性能，但仍存在队头阻塞问题。HTTP&#x2F;2 通过二进制分帧和多路复用解决了队头阻塞问题，显著提升了并发性能。HTTP&#x2F;3 基于 QUIC 协议，进一步解决了 TCP 的队头阻塞问题，并支持连接迁移，显著提升了网络性能和用户体验。</p><p>在实际应用中，选择合适的 HTTP 版本需要根据具体需求进行权衡。对于高性能和低延迟的需求，HTTP&#x2F;3 是最佳选择；对于一般的 Web 应用，HTTP&#x2F;2 已经能够提供良好的性能；而对于一些对性能要求不高的场景，HTTP&#x2F;1.1 仍然可以使用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 应用层</title>
      <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-——-应用层"><a href="#计算机网络-——-应用层" class="headerlink" title="计算机网络 —— 应用层"></a>计算机网络 —— 应用层</h1><h2 id="常见应用层协议"><a href="#常见应用层协议" class="headerlink" title="常见应用层协议"></a>常见应用层协议</h2><ul><li>DNS（Domain Name System，域名系统）</li><li>DNS用于将人类可读的域名转换成计算机可以识别的IP地址。</li><li>FTP（File Transfer Protocol，文件传输协议）</li><li>FTP提供了一种在互联网上传输文件的标准方法，支持文件上传和下载。</li><li>Telnet（远程终端协议）</li><li>Telnet允许用户登录到远程计算机并执行命令，尽管现在SSH（Secure Shell）已经替代了它在安全方面的应用。</li><li>HTTP（Hypertext Transfer Protocol，超文本传输协议）</li><li>HTTP是用于从万维网服务器传输超文本到本地浏览器的传输协议。</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</li><li>SMTP用于在邮件服务器之间发送电子邮件，以及从用户的邮件客户端向邮件服务器发送邮件。</li><li>POP3（Post Office Protocol Version 3，邮局协议第三版）</li><li>POP3是一种接收电子邮件的协议，允许用户从邮件服务器上下载邮件。</li><li>IMAP（Internet Message Access Protocol，互联网消息访问协议）</li><li>IMAP也用于接收电子邮件，但与POP3不同的是，它通常允许邮件保留在服务器上，以便多设备同步。</li><li>HTTPS（Hypertext Transfer Protocol Secure，安全超文本传输协议）</li><li>HTTPS是HTTP的安全版本，使用SSL&#x2F;TLS加密来保护数据传输。</li><li>SSH（Secure Shell，安全外壳协议）</li><li>SSH提供了一个安全的网络环境，用于远程登录、远程命令执行、文件传输等功能。</li><li>TLS&#x2F;SSL（Transport Layer Security &#x2F; Secure Sockets Layer，传输层安全&#x2F;安全套接字层）</li><li>虽然通常被认为是传输层协议，但在应用层中使用，为应用数据提供加密和身份验证。</li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）</li><li>SNMP用于监控网络设备的状态和性能，是网络管理的重要工具。</li><li>RTSP（Real Time Streaming Protocol，实时流媒体协议）</li><li>RTSP用于控制实时媒体数据的传输，例如音频和视频流。</li><li>NTP（Network Time Protocol，网络时间协议）</li><li>NTP用于在分布式时间服务器和客户端之间同步时钟。</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS的基本功能"><a href="#DNS的基本功能" class="headerlink" title="DNS的基本功能"></a>DNS的基本功能</h3><p>DNS的主要功能是将人类可读的域名转换为计算机可理解的IP地址，以便计算机能够定位和访问互联网上的资源。这个过程被称为“域名解析”。</p><h3 id="DNS的结构"><a href="#DNS的结构" class="headerlink" title="DNS的结构"></a>DNS的结构</h3><p>DNS采用层次化的树状结构，从根域开始，向下分为顶级域（如.com、.org、.edu等）、二级域、三级域等，直至具体的主机名。</p><h3 id="DNS的组件"><a href="#DNS的组件" class="headerlink" title="DNS的组件"></a>DNS的组件</h3><ul><li>根域名服务器：位于DNS层次结构的最顶端，负责维护顶级域名服务器的信息。</li><li>顶级域名服务器：负责管理特定的顶级域，如.com、.org等。</li><li>权威名称服务器：负责具体域名的解析，存储该域名的A记录（IP地址）、MX记录（邮件服务器信息）等。</li><li>本地DNS解析器：运行在用户计算机上的软件，负责向DNS服务器发起查询并缓存查询结果。</li></ul><h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p>DNS查询通常有两种方式：递归查询和迭代查询。</p><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><ol><li>用户的计算机向本地DNS解析器发送查询请求。</li><li>如果本地DNS解析器没有缓存结果，它会向根域名服务器发起查询。</li><li>根域名服务器返回顶级域名服务器的地址。</li><li>本地DNS解析器继续向顶级域名服务器查询，直到找到权威名称服务器。</li><li>权威名称服务器返回域名对应的IP地址。</li><li>本地DNS解析器将结果返回给用户计算机，并将结果缓存。</li></ol><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>迭代查询与递归查询类似，但每个DNS服务器只提供下一步查询的线索，而不是最终答案。这意味着查询请求会从一个DNS服务器跳转到另一个，直到找到权威名称服务器为止。</p><h3 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h3><ul><li>除了A记录（IP地址），DNS还支持多种记录类型，包括但不限于：</li><li>CNAME记录：别名记录，用于将一个域名指向另一个域名。</li><li>MX记录：邮件交换记录，指定邮件服务器的位置。</li><li>NS记录：名称服务器记录，列出负责某个域的权威DNS服务器。</li><li>TXT记录：文本记录，用于存储任意文本信息，常用于SPF（Sender Policy Framework）记录，防止邮件伪造。</li><li>PTR记录：指针记录，用于反向DNS查找，即将IP地址映射回域名。</li><li>SOA记录：起始授权记录，包含有关DNS区域的管理信息。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP，即HyperText Transfer Protocol（超文本传输协议），是用于从Web服务器传输超文本到本地浏览器的传送协议。它是互联网上应用最为广泛的一种网络协议</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/7a13a69686adce6f209b9070fa7061bd.jpeg" alt="HTTP 请求报文由请求行、请求头部、空行 和 请求包体 4 个部分组成" style="zoom:130%;" /><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/085c7e5a4d33cfda578afcb6b4bd83ab.png" alt="img" style="zoom:130%;" /><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul><li>HTTP&#x2F;1.0：早期版本，每个请求都需要建立一个新的连接。</li><li>HTTP&#x2F;1.1：改进版本，支持持久连接（keep-alive），允许在一个TCP连接上发送多个请求和响应。</li><li>HTTP&#x2F;2：二进制协议，支持多路复用、头部压缩、服务器推送等功能，提高了性能。</li><li>HTTP&#x2F;3：基于QUIC协议，进一步优化了延迟和丢包恢复。</li></ul><h3 id="进阶特性"><a href="#进阶特性" class="headerlink" title="进阶特性"></a>进阶特性</h3><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>Keep-Alive 机制是 http 从 1.1 版本开始支持的一种优化网络性能的技术，它允许客户端和服务器在完成一次请求和响应后，保持TCP连接处于打开状态，以便后续的请求可以复用这个连接，而不需要重新建立连接。这种机制显著减少了因频繁建立和关闭连接带来的网络开销，提高了Web应用的性能和响应速度。</p><p><strong>Keep-Alive的好处</strong></p><ul><li>减少连接建立的延迟：避免了每次请求都需要进行TCP连接建立的时间，提高了响应速度。</li><li>降低网络负载：减少了连接建立和关闭的次数，降低了网络带宽的消耗。</li><li>提高服务器吞吐量：更少的连接意味着更少的系统内核调用，如accept()和close()，从而提高了服务器的处理能力。</li></ul><p><strong>Keep-Alive的实现细节</strong></p><ul><li>超时设置：服务器通常会设置一个超时时间，如果在这段时间内没有收到新的请求，连接将被关闭。这是因为长时间保持连接打开可能会占用过多的系统资源。</li><li>空闲检测：客户端和服务器可以通过发送空的“心跳”数据包来检测连接是否仍然有效，这称为TCP的keepalive选项，但要注意不要与HTTP的Keep-Alive混淆。</li><li>并发限制：尽管Keep-Alive可以提高性能，但每个客户端与服务器之间的连接数量通常会受到限制，以防止服务器资源过度消耗。</li></ul><h4 id="multipart"><a href="#multipart" class="headerlink" title="multipart"></a>multipart</h4><p>Multipart主要用于在单个HTTP请求或响应中传输多个部分的数据，尤其适用于上传文件或多部分消息。</p><p>Multipart编码允许在同一个请求中发送多个实体，每个实体可以有不同的数据类型，比如文本、图像、音频等。这在提交包含文件和表单字段的HTTP POST请求时非常有用。</p><p>Multipart编码通常使用边界（boundary）来分隔不同的实体，边界是一个随机生成的字符串，用于标记每个实体的开始和结束。每个实体都包含自己的头部信息，如Content-Disposition、Content-Type等，用于描述实体的性质。</p><p><strong>Multipart的使用场景：</strong></p><ul><li>文件上传：允许用户在Web表单中上传一个或多个文件。</li><li>多部分消息：在邮件中，可以使用multipart来组合文本、图片和其他附件。</li></ul><h4 id="chunked"><a href="#chunked" class="headerlink" title="chunked"></a>chunked</h4><p>Chunked transfer encoding是一种传输编码方式，用于在不知道数据总长度的情况下，允许服务器动态地发送数据。在HTTP&#x2F;1.1中，当服务器无法预知响应的总长度时，可以使用chunked编码来发送数据。</p><p>Chunked编码将数据分割成一系列的块（chunks），每个块都有一个明确的长度，块的长度以十六进制数表示，后面跟着块数据，最后以零长度的块表示数据传输的结束。这种方式允许服务器在生成响应的同时发送数据，而不需要等待整个响应构建完成。</p><p><strong>Chunked的使用场景：</strong></p><ul><li>动态生成的响应：服务器在生成响应的过程中可以立即开始发送数据。</li><li>长连接的流式传输：在持续的HTTP连接中，服务器可以持续发送数据，而不需要知道总的数据量。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><ul><li>最终用对称加密</li><li>对称加密秘钥通过特定算法生成，如 ECDHE，期间可能涉及一些随机数</li><li>对称密钥依赖的数据通过非对称加密进行交换</li><li>非对称加密可靠性通过证书方式进行验证</li></ul><h3 id="https-握手流程"><a href="#https-握手流程" class="headerlink" title="https 握手流程"></a>https 握手流程</h3><p>实则依赖具体算法套件</p><h4 id="ECDH-握手"><a href="#ECDH-握手" class="headerlink" title="ECDH 握手"></a>ECDH 握手</h4><p>ECDH是一种基于椭圆曲线的Diffie-Hellman密钥交换算法，它允许两个通信方在不安全的信道上安全地协商出一个共享密钥。然而，在TLS中，ECDH本身并不提供前向安全性（Forward Secrecy），因为一旦服务器的长期私钥被破解，所有使用该私钥协商的会话密钥都可以被追溯破解。</p><h5 id="ECDH-握手过程"><a href="#ECDH-握手过程" class="headerlink" title="ECDH 握手过程"></a>ECDH 握手过程</h5><ul><li>服务器在ServerHello消息中选择ECDH作为密钥交换算法。</li><li>服务器发送Certificate消息，其中包含其长期公钥。</li><li>服务器发送ServerKeyExchange消息，其中包含用于ECDH密钥交换的参数。</li><li>客户端使用服务器的长期公钥计算出预主密钥（pre-master secret），并发送ClientKeyExchange消息。</li><li>双方计算出会话密钥，并开始使用该密钥加密通信。</li></ul><h4 id="ECDHE-握手"><a href="#ECDHE-握手" class="headerlink" title="ECDHE 握手"></a>ECDHE 握手</h4><p>ECDHE是ECDH的一个变种，它引入了短暂（ephemeral）密钥的概念，即每次握手时生成一个新的密钥对。这意味着即使服务器的长期私钥在未来被破解，过去握手过程中协商的会话密钥仍然是安全的，因为它们都是基于短暂密钥对生成的。ECDHE提供了前向安全性，这是现代安全通信的一个重要特性。</p><h5 id="ECDHE握手过程"><a href="#ECDHE握手过程" class="headerlink" title="ECDHE握手过程"></a>ECDHE握手过程</h5><ul><li>服务器在ServerHello消息中选择ECDHE作为密钥交换算法。</li><li>服务器发送Certificate消息，其中包含其长期公钥，但这不是用于ECDHE密钥交换的公钥。</li><li>服务器发送ServerKeyExchange消息，其中包含一个短暂（ephemeral）的公钥，用于此次握手的ECDHE密钥交换。</li><li>客户端使用服务器的短暂公钥计算出预主密钥，并发送ClientKeyExchange消息。</li><li>双方计算出会话密钥，并开始使用该密钥加密通信。</li></ul><h2 id="输入网址到显示网页全过程"><a href="#输入网址到显示网页全过程" class="headerlink" title="输入网址到显示网页全过程"></a>输入网址到显示网页全过程</h2><p>在浏览器中输入一个网址并按下回车键，直到页面完全加载并展示出来，期间会发生一系列复杂的操作。这个过程大致可以分为以下几个阶段：</p><ul><li><strong>解析URL</strong><ul><li>浏览器首先解析你输入的URL，确定协议（如HTTP、HTTPS）、主机名、端口号、路径、查询参数等。</li></ul></li><li><strong>域名解析（DNS查询）</strong><ul><li>浏览器需要将域名转换为IP地址。它首先检查本地缓存，如果找不到，则向DNS服务器发送请求。DNS服务器会返回相应的IP地址，或者继续递归查询直到找到正确的IP地址。</li></ul></li><li><strong>建立TCP连接</strong><ul><li>获取到IP地址后，浏览器会尝试与服务器建立TCP连接。这涉及到TCP的三次握手过程，以确保连接的建立。</li></ul></li><li><strong>发送HTTP请求</strong><ul><li>TCP连接建立成功后，浏览器发送HTTP请求到服务器。请求中包含了请求方法（GET、POST等）、请求头、请求体等信息。</li></ul></li><li><strong>服务器处理请求</strong><ul><li>服务器接收到请求后，根据请求的内容处理请求，这可能包括读取文件、执行脚本、数据库查询等。</li></ul></li><li><strong>服务器响应</strong><ul><li>服务器处理完请求后，会构建一个HTTP响应并发送回浏览器。响应中包含了状态码、响应头和响应体。</li></ul></li><li><strong>接收数据</strong><ul><li>浏览器接收服务器的响应数据。如果是HTML文档，浏览器会开始解析HTML文档；如果是其他资源（如CSS、JavaScript、图片等），浏览器会异步下载这些资源。</li></ul></li><li><strong>解析HTML文档</strong><ul><li>浏览器解析HTML文档，构建DOM树（Document Object Model）。DOM树是HTML文档的结构化表示，用于浏览器进一步渲染页面。</li></ul></li><li><strong>请求并加载外部资源</strong><ul><li>HTML文档中可能引用了外部资源，如CSS样式表、JavaScript脚本、图片等。浏览器会根据这些资源的URL发起新的请求，并下载这些资源。</li></ul></li><li><strong>执行JavaScript</strong><ul><li>如果页面中有JavaScript代码，浏览器会执行这些代码。JavaScript可能修改DOM树，或者发起新的网络请求，进一步改变页面内容。</li></ul></li><li><strong>渲染页面</strong><ul><li>浏览器将DOM树和CSS样式结合，创建渲染树。渲染树描述了页面元素的视觉表现，浏览器使用渲染树绘制页面到屏幕上。</li></ul></li><li><strong>关闭TCP连接</strong><ul><li>页面加载完成后，浏览器和服务器之间的TCP连接通常会被关闭，除非使用了Keep-Alive机制，那么连接可能会保持一段时间以供后续请求使用。</li></ul></li><li><strong>事件监听和交互</strong><ul><li>页面加载完成后，浏览器会监听用户的交互事件，如点击、滚动等，并响应这些事件。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拥塞控制算法</title>
      <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h1><p>拥塞控制算法是网络通信中用于管理数据传输速率的关键机制，以避免网络拥塞和确保数据包有效传输</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ul><li>基于 目标 &#x2F; 控制策略<ul><li>基于丢包</li><li>基于延迟</li></ul></li><li>基于控制机制<ul><li>基于链路容量预测</li><li>基于学习或探测</li></ul></li></ul><h2 id="常见拥塞控制算法"><a href="#常见拥塞控制算法" class="headerlink" title="常见拥塞控制算法"></a>常见拥塞控制算法</h2><h3 id="RENO"><a href="#RENO" class="headerlink" title="RENO"></a>RENO</h3><p>也即传统的 拥塞控制算法，包含 慢启动，拥塞避免，快重传，快恢复 四个阶段</p><h4 id="RENO-的局限性"><a href="#RENO-的局限性" class="headerlink" title="RENO 的局限性"></a>RENO 的局限性</h4><ul><li><strong>慢启动阈值（ssthresh）的设定：</strong><ul><li>在Reno算法中，当检测到网络拥塞（如超时或重复ACK）时，慢启动阈值ssthresh会被减半，然后拥塞窗口cwnd也会被重置为1 MSS（最大报文段大小），并进入慢启动阶段。这种方法在高速网络中会导致拥塞窗口恢复得过慢，从而降低了网络的利用率。</li></ul></li><li><strong>拥塞避免的线性增长：</strong><ul><li>在拥塞避免阶段，Reno算法中的拥塞窗口cwnd每次接收到一个ACK时仅增加1 MSS&#x2F;cwnd。在高带宽延迟产品（BDP）的网络中，这种线性增长速度过慢，不能充分利用网络带宽。</li></ul></li><li><strong>拥塞恢复机制：</strong><ul><li>Reno的快速重传和快速恢复机制在检测到数据包丢失时，会将拥塞窗口cwnd设置为ssthresh，然后以慢启动的方式恢复。这种方法在高带宽网络中可能导致拥塞窗口恢复得太慢，影响了网络的吞吐量。</li></ul></li><li><strong>对丢包的敏感性：</strong><ul><li>Reno算法对丢包非常敏感，即使是非拥塞引起的丢包（如链路质量差、硬件故障等），也会触发拥塞控制机制，导致不必要的窗口收缩。</li></ul></li><li><strong>对高延迟网络的不适应性：</strong><ul><li>在高延迟网络中，Reno算法的慢启动和拥塞避免机制可能无法及时响应网络状态变化，导致网络资源的浪费和低效利用。</li></ul></li><li><strong>公平性问题：</strong><ul><li>在多条并发连接共享同一网络资源时，Reno算法可能会导致某些连接的不公平竞争，尤其是在混合连接类型（如Reno与更先进的拥塞控制算法）共存的场景下。</li></ul></li><li><strong>对网络容量的适应性：</strong><ul><li>Reno算法可能无法准确地探测和适应网络的实际容量，特别是在网络条件动态变化的环境中。</li></ul></li></ul><h3 id="CUBIC"><a href="#CUBIC" class="headerlink" title="CUBIC"></a>CUBIC</h3><h4 id="CUBIC-出现的背景"><a href="#CUBIC-出现的背景" class="headerlink" title="CUBIC 出现的背景"></a>CUBIC 出现的背景</h4><p>CUBIC（Cube Root Increase Decrease）拥塞控制算法的出现主要是为了应对高速网络环境中的性能挑战，特别是针对TCP Reno算法在高带宽和高延迟网络中的局限性。在20世纪末和21世纪初，随着互联网基础设施的快速发展，骨干网络的带宽和覆盖范围显著提升，传统的TCP拥塞控制算法如Reno开始显现出不足。</p><p>在高速网络中，Reno算法的拥塞窗口调整机制导致了几个关键问题，包括：</p><ul><li><strong>恢复速度慢</strong>：在检测到拥塞时，Reno会将慢启动阈值（ssthresh）减半，并将拥塞窗口（cwnd）重置为1 MSS，这在高带宽网络中导致了拥塞窗口恢复得过慢，影响了网络的利用率。</li><li><strong>利用率低</strong>：Reno的线性拥塞避免策略在高带宽延迟产品（BDP）的网络中无法充分使用网络带宽。</li><li><strong>公平性问题</strong>：在多连接共享网络资源时，Reno 可能无法提供足够的公平性，尤其是在混合连接类型共存的场景下。</li></ul><p>为了解决这些问题，CUBIC 算法被提出，旨在提高 TCP 在高速网络中的性能和效率，同时保持良好的公平性和稳定性。</p><h4 id="CUBIC-与-RENO-的主要区别"><a href="#CUBIC-与-RENO-的主要区别" class="headerlink" title="CUBIC 与 RENO 的主要区别"></a>CUBIC 与 RENO 的主要区别</h4><ul><li><strong>窗口调整机制：</strong><ul><li>Reno使用慢启动和线性拥塞避免策略，而CUBIC使用立方根函数来动态调整拥塞窗口，这使得窗口增长和减少更加平滑和适应性强。</li></ul></li><li><strong>恢复机制：</strong><ul><li>Reno在检测到拥塞时，会大幅度减少拥塞窗口，而CUBIC使用线性减少策略，这有助于更精确地控制拥塞窗口的大小，避免过度反应。</li></ul></li><li><strong>阈值调整：</strong><ul><li>Reno的慢启动阈值（ssthresh）在检测到拥塞时被减半，而CUBIC会根据网络条件动态调整ssthresh，这有助于在拥塞发生后更快地恢复到较高的传输速率。</li></ul></li><li><strong>适应性：</strong><ul><li>CUBIC算法能够更好地适应高带宽和高延迟的网络环境，而Reno在这些条件下性能较差。</li></ul></li></ul><h4 id="CUBIC-的核心原理"><a href="#CUBIC-的核心原理" class="headerlink" title="CUBIC 的核心原理"></a>CUBIC 的核心原理</h4><p>CUBIC算法的核心在于其拥塞窗口调整策略，它使用了一个累积增加的变量C，这个变量随时间t的增加而增加。当网络中没有拥塞时，C按时间的立方根增加，而当检测到拥塞时，C 减少，导致拥塞窗口减少。</p><p>拥塞窗口的大小与C的关系为：$[ cwnd &#x3D; C^{1&#x2F;3} ]$</p><p>这里的 C 实际是一个累积的变量，它在没有拥塞的情况下随时间增加，在检测到拥塞时减少。通过这种方式，CUBIC 算法能够实现更平稳的拥塞窗口调整，避免了传统算法中拥塞窗口剧烈波动的问题，从而提高了网络资源的利用率和传输效率。</p><p>CUBIC 算法的设计使得它在各种网络条件下都能表现出较好的性能，尤其在高带宽和高延迟的网络中，能够更有效地利用网络资源，减少数据包的丢失，同时保持良好的公平性。</p><h3 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h3><p>BBR（Bottleneck Bandwidth and RTT）是Google开发的一种新型TCP拥塞控制算法，旨在解决传统拥塞控制算法（如Reno和CUBIC）在现代网络中的一些问题，尤其是对于高带宽和高延迟网络的效率和公平性问题。BBR的设计理念是直接对网络拥塞进行建模，而不是依赖于数据包丢失作为拥塞的唯一指标。</p><h4 id="BBR的出现背景"><a href="#BBR的出现背景" class="headerlink" title="BBR的出现背景"></a>BBR的出现背景</h4><p>传统的拥塞控制算法，如 Reno 和 CUBIC，主要依赖于数据包的丢失来检测网络拥塞，这在很多情况下是有效的，但在高速网络中，这种机制可能导致不必要的性能下降和资源浪费。此外，这些算法在多路径和高延迟网络中也面临挑战，因为它们可能无法准确地估计网络的瓶颈带宽和往返时间（RTT）。</p><p>BBR算法的开发是为了克服这些局限性，提供一种更准确地测量网络容量和响应网络条件变化的机制，从而实现更高效、更公平的数据传输。</p><h4 id="BBR与传统算法的主要区别"><a href="#BBR与传统算法的主要区别" class="headerlink" title="BBR与传统算法的主要区别"></a>BBR与传统算法的主要区别</h4><ul><li><strong>拥塞检测：</strong><ul><li>传统算法依赖于数据包丢失作为拥塞的信号，而 BBR 则直接测量网络的 瓶颈带宽 和 RTT ，以更准确地识别和响应拥塞。</li></ul></li><li><strong>状态机：</strong><ul><li>BBR具有两种主要的操作模式：探测（Probing）和 加载（Loading）。在探测模式下，BBR会尝试推断网络的瓶颈带宽和RTT；在加载模式下，BBR会以接近瓶颈带宽的速度发送数据，同时监控网络状态以避免拥塞。</li></ul></li><li><strong>动态调整：</strong><ul><li>BBR算法能够根据网络反馈动态调整发送速率，这使得它能够更有效地利用网络资源，同时避免过度使用而导致的拥塞。</li></ul></li><li><strong>抗丢包能力：</strong><ul><li>BBR的抗丢包能力较强，即使在网络中出现丢包时，也能保持相对稳定的传输速率，而不像传统算法那样可能需要大幅降低速率。</li></ul></li></ul><h4 id="BBR的核心原理"><a href="#BBR的核心原理" class="headerlink" title="BBR的核心原理"></a>BBR的核心原理</h4><p>BBR的核心原理是基于对网络瓶颈带宽和RTT的精确估计，通过主动探测和动态调整发送速率来避免拥塞。它的工作流程可以概括为以下步骤：</p><ul><li><strong>探测阶段（Probing）：</strong><ul><li>在此阶段，BBR会以高于当前估计的瓶颈带宽的速率发送数据，以探测网络的实际容量。通过分析往返时间的变化，BBR可以更新其对瓶颈带宽的估计。</li></ul></li><li><strong>加载阶段（Loading）：</strong><ul><li>在探测阶段之后，BBR会进入加载阶段，此时它会以接近瓶颈带宽的速度发送数据。BBR会持续监控网络状态，如RTT的变化，以确保不会引起网络拥塞。</li></ul></li><li><strong>动态调整：</strong><ul><li>BBR会根据网络反馈动态调整其发送速率，以维持一个稳定的传输速率，同时避免拥塞。这种调整是基于对网络状态的实时评估，而不是依赖于数据包丢失的滞后信号。</li></ul></li></ul><p>BBR算法的设计使得它在现代网络环境中表现出色，尤其是在高带宽、高延迟和多路径网络中，能够提供更高效、更公平的数据传输服务。自发布以来，BBR已经在Linux内核中得到实现，并在数据中心和广域网等多种场景中得到了广泛应用。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 传输层</title>
      <link href="/2024/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2024/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——传输层"><a href="#计算机网络——传输层" class="headerlink" title="计算机网络——传输层"></a>计算机网络——传输层</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240702234147757.png" alt="image-20240702234147757" style="zoom:70%;" /><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><p>传输层是计算机网络模型中的第4层，位于网络层之上、会话层之下，它的主要功能是为网络中的应用程序提供端到端的通信服务。传输层是整个网络体系结构中承上启下的关键层次，它确保数据能够从一个网络中的程序可靠、有序地传输到另一个网络中的对应程序，而不关心底层网络的具体细节。以下是传输层的几个关键方面：</p><h3 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h3><ul><li><strong>端到端连接</strong>：传输层为应用层提供虚拟的、逻辑上的端到端连接，使得上层应用感觉像是直接在两个端点之间通信，而无需了解中间网络的复杂性。</li><li><strong>数据分割与重组</strong>：传输层可以将上层数据分割成适合网络层传输的数据段，并在接收端重新组合成原始数据，这有助于提高数据传输的效率。</li><li><strong>错误检测与纠正</strong>：通过校验和等机制，传输层可以检测数据在传输过程中是否发生错误，并在某些协议（如TCP）中尝试纠正这些错误。</li><li><strong>流量控制</strong>：为了避免数据发送过快导致接收方无法处理，传输层实施流量控制机制，确保发送速率与接收方的处理能力相匹配。</li><li><strong>拥塞控制</strong>：在网络拥堵时，传输层可以调整数据的发送速率，以减少网络拥塞，提高整体网络的效率和稳定性。</li></ul><h3 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h3><ul><li><code>TCP（Transmission Control Protocol）</code>：TCP是一个面向连接的、可靠的传输协议，它通过确认、重传、排序等机制确保数据的可靠传输。TCP还提供流量控制和拥塞控制功能，适用于对数据完整性要求高的应用，如Web浏览、电子邮件等。</li><li><code>UDP（User Datagram Protocol）</code>：UDP是一个无连接的、不可靠的传输协议，它不保证数据的顺序或可靠性，但因为省去了建立连接和确认的过程，所以传输速度快，适用于实时性要求高、能容忍少量数据丢失的应用，如在线游戏、语音通话、视频流等。</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240702235349511.png" alt="image-20240702235349511"></p><h4 id="TCP-首部字段"><a href="#TCP-首部字段" class="headerlink" title="TCP 首部字段"></a>TCP 首部字段</h4><ul><li><p><strong>源端口和目的端口</strong>：各占两个字节；(16bit的端口号+32bit的ip地址形成了一个套接字socket，每一条TCP连接唯一的被两端的两个端点也就是两个套接字确认，所以这也构成了传输层的点到点通信)</p></li><li><p>**序号(seq)**：占4个字节；(在传输的数据中，每一个字节都有一个序号，这个序号就是本次传输数据的第一个字节的序号)；</p></li><li><p>**确认号(ack)**：占4个字节；(这个值是代表期待收到对方下次发送的数据的第一个字节的序号，比如如果发送ack&#x3D;301，则表示前300个我收到了，下次你给我发第301个)；</p></li><li><p><strong>数据偏移</strong>：占4位，也叫首部长度(Header length),一般情况下首部长度是20字节，但是也可以扩展，比如这4位都置为1时十进制是15，代表可以首部可以有15行，一行4个字节，所以是60个字节；</p></li><li><p><strong>6个控制位</strong></p><ul><li><p><strong>URG</strong>:  紧急指针有效位，和第5行的紧急指针一起用，可以让紧急数据进行加塞，接收端可以优先快速的获取紧急数据；</p></li><li><p><strong>ACK</strong>:  指示ack确认号是否有效；</p></li><li><p><strong>PSH</strong>:  置为1时表示将本报文段立即向上交付有应用层，而不用等缓存填满再交付；</p></li><li><p><strong>RST</strong>:  置为1时通知重新建立TCP连接；</p></li><li><p><strong>SYN</strong>:  同步序号位，置为1表示需要建立连接；比如SYN&#x3D;1,ACK&#x3D;0时表明是一个连接建立请求；而SYN&#x3D;1,ACK&#x3D;1,表明是一个连接接受请求；  </p></li><li><p><strong>FIN</strong>:  置为1时表明发送数据结束，连接释放；</p></li></ul></li><li><p><strong>窗口</strong>：占2个字节：用来说明本地可以接收的数据段的数目，以字节为单位，流量控制就是基于这个窗口来实现的，其大小是可变的；</p></li><li><p><strong>检验和</strong>：占2个字节：用来做差错控制，在发送端计算一次所有数据的检验和，在接收端再计算一次，一致则说明数据基本正确；</p></li><li><p><strong>紧急窗口</strong>：和URG配合使用；</p></li></ul><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240703000934584.png" alt="image-20240703000934584" style="zoom: 67%;" /><h4 id="TCP-握手为什么是三次"><a href="#TCP-握手为什么是三次" class="headerlink" title="TCP 握手为什么是三次"></a>TCP 握手为什么是三次</h4><ul><li>确认消息相互可达</li><li>同步序列号</li><li>两次握手无法确认 Server 到 Client 消息可达</li><li>两次握手无法规避历史连接</li><li>三次可以达到以上目的，无需四次，或者说中间的握手实际就是四次握手的中间两次进行合并的</li></ul><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240706225451043.png" alt="image-20240706225451043" style="zoom: 63%;" /><h4 id="TCP-回收为什么是四次"><a href="#TCP-回收为什么是四次" class="headerlink" title="TCP 回收为什么是四次"></a>TCP 回收为什么是四次</h4><ul><li>需要双方均确认关闭</li><li>被动关闭方在收到FIN 时，可能还有数据需要发送，因此不能像 三次握手一样将中间两次进行合并</li></ul><h3 id="TCP-可靠性原理"><a href="#TCP-可靠性原理" class="headerlink" title="TCP 可靠性原理"></a>TCP 可靠性原理</h3><ul><li><strong>错误</strong> —— 校验和</li><li><strong>乱序</strong> —— 序列号</li><li><strong>丢包</strong> —— 丢包重传<ul><li>序列号</li><li>确认应答</li><li>超时重传</li><li>快速重传</li><li>连接管理 —— 三次握手，四次挥手</li><li>（拥塞控制）</li></ul></li></ul><h3 id="TCP-流量控制-拥塞控制"><a href="#TCP-流量控制-拥塞控制" class="headerlink" title="TCP 流量控制 &#x2F; 拥塞控制"></a>TCP 流量控制 &#x2F; 拥塞控制</h3><h4 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h4><p><strong>拥塞控制</strong>：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p><p><strong>流量控制</strong>：流量控制 由 接收者 控制 发送者 的发送速度 从而使接收者来得及接收，防止分组丢失的。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 流量控制通过 滑动窗口协议 (连续 ARQ) 实现，关于 ARQ 协议参见 ： <a href="https://blog.csdn.net/aaahuahua/article/details/119965804">TCP可靠传输：ARQ协议（停止等待、超时重传、滑动窗口、回退N帧、选择重传）-CSDN博客</a></p><h4 id="经典-TCP-拥塞控制-——-RENO-算法"><a href="#经典-TCP-拥塞控制-——-RENO-算法" class="headerlink" title="经典 TCP 拥塞控制 —— RENO 算法"></a>经典 TCP 拥塞控制 —— RENO 算法</h4><ul><li><strong>类型： 基于丢包</strong></li><li><strong>核心概念：</strong> <ul><li><strong>拥塞窗口</strong></li><li><strong>门限值</strong></li></ul></li><li><strong>具体实现：</strong><ul><li><strong>慢启动（Slow Start）：</strong><br>慢启动算法在连接建立初期或在经历长时间静默后，此阶段每收到 一个 ACK 则 CWND +1 ，以指数增长的方式增加拥塞窗口大小 直到遇到网络拥塞的迹象（如超时或重复ACK）。</li><li><strong>拥塞避免（Congestion Avoidance）：</strong><br>当慢启动阶段结束，拥塞避免算法开始以线性方式增加拥塞窗口大小，即每收到一个ACK，cwnd增加一个MSS（最大报文段大小）。</li><li><strong>快速重传（Fast Retransmit）：</strong><br>在发送方收到三个重复的ACK时，会立即重传丢失的数据段，而不需要等到超时发生。</li><li><strong>快速恢复（Fast Recovery）：</strong><br>在快速重传之后使用，它会将拥塞窗口设置为当前 cwnd 的一半，然后开始缓慢增加，直到收到丢失数据段的ACK。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/6f1657d8b22e4ea79b1f6ba2243a7dcd.png" alt="img"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h3><ul><li><strong>无连接：</strong><ul><li>UDP在发送数据前不需要建立连接，这意味着它可以立即开始发送数据，而无需等待连接建立的过程。</li></ul></li><li><strong>不可靠：</strong><ul><li>UDP不保证数据的可靠传输，即发送的数据可能丢失、重复或乱序到达目的地。它不提供确认机制或重传机制，因此数据传输的可靠性完全依赖于应用层。</li></ul></li><li><strong>最小开销：</strong><ul><li>UDP头部非常简单，只有8字节，包括源端口、目的端口、长度和校验和字段。这使得UDP的处理速度比TCP快，因为它不需要处理TCP的复杂状态机和拥塞控制算法。</li></ul></li><li><strong>广播和多播支持：</strong><ul><li>UDP非常适合用于广播和多播通信，因为它不需要逐个建立连接就可以向多个接收者发送数据。</li></ul></li><li><strong>数据报：</strong><ul><li>UDP使用数据报的形式传输数据，每个数据报独立于其他数据报发送，可能沿着不同的路径到达目的地。</li></ul></li><li><strong>校验和：</strong><ul><li>UDP提供了一个可选的校验和字段，用于检测数据报在传输过程中的错误。但是，这个校验和不是强制性的，可以被应用层禁用。</li></ul></li></ul><h3 id="UDP-应用场景"><a href="#UDP-应用场景" class="headerlink" title="UDP 应用场景"></a>UDP 应用场景</h3><ul><li><strong>实时音频和视频流：</strong><ul><li>对于实时多媒体应用，如VoIP（Voice over IP）、在线游戏和视频会议，UDP的低延迟特性比可靠性更为重要。</li></ul></li><li><strong>DNS查询：</strong><ul><li>DNS（Domain Name System）查询通常使用UDP，因为大多数查询只需要单次往返即可完成，且数据量不大。</li></ul></li><li><strong>网络管理：</strong><ul><li>SNMP（Simple Network Management Protocol）和其他网络管理协议使用UDP，因为它们通常发送的是小数据包，且可以容忍数据丢失。</li></ul></li><li><strong>多播应用：</strong><ul><li>UDP的多播能力使其成为多播应用的理想选择，如实时股票行情更新、新闻广播等。</li></ul></li><li><strong>游戏和实时通信：</strong><ul><li>实时游戏和实时通信应用往往使用UDP，因为它们需要快速响应时间，可以容忍偶尔的数据包丢失。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> UDP </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 网络层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——网络层"><a href="#计算机网络——网络层" class="headerlink" title="计算机网络——网络层"></a>计算机网络——网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层是计算机网络体系结构中的一层，也是整个互联网的核心；网络层负责处理数据的传输、路由和转发。它位于传输层和数据链路层之上，为上层提供了透明的数据传输服务，并通过路由选择和转发算法，实现了不同网络之间的互联和通信</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630233644164.png" alt="image-20240630233644164" style="zoom:50%;" /><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>网络层在计算机网络中具有以下主要功能：</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>网络层负责将数据从源主机传输到目标主机。它接收上层传来的数据，并根据目标地址和路由表等信息，将数据分组成数据包进行传输。网络层通过逐跳传输，将数据包从源主机经过一系列中间节点（路由器）转发到目标主机。</p><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>路由选择是网络层的核心功能之一。当数据包从源主机发出后，网络层需要决定数据包的传输路径。路由选择算法根据目标地址、网络拓扑、链路状态等因素，选择最佳的路径将数据包转发到目标主机。常见的路由选择协议包括RIP（Routing Information Protocol）、OSPF（Open Shortest Path First）和BGP（Border Gateway Protocol）等。</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>转发是网络层的另一个重要功能，它是指在路由器上根据目标地址，将接收到的数据包从一个接口转发到另一个接口。转发过程是基于路由表进行的，路由表记录了目标地址与出接口之间的映射关系。当接收到数据包时，路由器根据路由表中的信息，进行转发操作，将数据包发送到正确的接口，以便继续向目标主机传输。</p><h3 id="路由器通信"><a href="#路由器通信" class="headerlink" title="路由器通信"></a>路由器通信</h3><p>网络层通过路由器实现不同网络之间的互联和通信。路由器是网络层的关键设备，它通过连接多个网络的接口，实现数据包在不同网络之间的转发。路由器通过学习路由信息、更新路由表和转发数据包，实现网络之间的通信和连接。</p><h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><ul><li>IP</li><li>ICMP</li><li>IGMP</li><li>ARP</li></ul><h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>IP 提供了一种不可靠，无连接的数据包交付服务。依赖其他层的协议进行差错控制。 </p><ul><li><strong>不可靠</strong>: IP数据报不保证能成功的到达目的地，如果出现错误则选择丢弃该数据，然后发送ICMP消息报给信源端 </li><li><strong>无连接</strong>: IP不提供任何后续数据报的状态信息，每个数据报处理都是独立的。如果一个信源发送了连续的两个数据报，每个数据报选择独立的路由，两个数据可能不同时到达。IP通信双方都不长久地维持对方的任何信息。这样上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</li></ul><h3 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h3><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067" alt="img" style="zoom:75%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。</p><p>分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。 </p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<strong>数据报标识</strong>、**标志 ** 和 <strong>片偏移</strong>。</p><p>一个IP数据报的每个分片都具有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置位该分片的长度。</p><h3 id="IP-转发"><a href="#IP-转发" class="headerlink" title="IP 转发"></a>IP 转发</h3><p>当主机收到一个数据报时，首先检查目的地址：</p><ul><li>如果是自己（自己某一个接口所配置的IP地址或IP广播或者组播地址），则交给协议字段或者IPv6头部的下一个头部字段指定的协议模块处理。</li><li>如果不是： <ul><li>如果IP层被配置为路由器，则转发该数据报。</li><li>否则默默丢弃，必要时生成ICMP报文给发送者。</li></ul></li></ul><p>转发不会改变数据报的IP地址，只是通过设置链路层地址来完成交付的过程：</p><ul><li>发送者定义好源IP和目的IP，如果目的IP不在本地，则将链路层的目的MAC地址设置为路由器，由路由器代为转发。</li><li>每一跳路由器在转发时，都会将源MAC地址设置为自己，目的MAC地址设置为下一跳路由器。</li></ul><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IPv4（Internet Protocol Version 4）地址是一个32位的二进制数字，通常以点分十进制形式表示，由四个介于0到255之间的十进制数构成，各部分之间用句点（.）分隔。每个十进制数实际上代表了8位二进制数，因此整个IPv4地址共由四个8位段组成，总共32位。下面是IPv4地址的详细组成和功能说明：</p><ul><li>地址结构：<ul><li>一个IPv4地址看起来像这样：xxx.xxx.xxx.xxx，其中每个xxx是一个0到255之间的十进制数。</li></ul></li><li>网络部分（Network ID）：<ul><li>这一部分标识了网络或子网。根据不同的子网掩码（Netmask或Subnet Mask），网络部分的长度可以变化，决定了该地址属于哪个网络或子网。</li></ul></li><li>主机部分（Host ID）：<ul><li>这一部分用于标识网络内的特定主机。在同一网络中，每个主机的主机部分必须是唯一的。</li></ul></li><li>特殊地址：<ul><li>广播地址：全1的主机部分（如255.255.255.255）用于向网络内的所有主机发送数据。</li><li>网络地址：全0的主机部分表示网络本身，不指向任何特定主机。</li><li>回环地址：127.0.0.1是一个特殊的回环地址，用于本机测试，发送到该地址的数据包会被送到本机。</li></ul></li><li>子网掩码（Subnet Mask）：<ul><li>用于区分IP地址中的网络部分和主机部分，通常与IP地址一起使用。子网掩码也是一个32位的二进制数，其中网络部分对应位设为1，主机部分对应位设为0。</li></ul></li></ul><h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类，如下图所示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20211119105027526.png" alt="image-20211119105027526" style="zoom:80%;" /><ul><li>A类（Class A）：<ul><li>范围：1.0.0.0 到 126.255.255.255</li><li>第一个字节的最高位固定为0，接下来的7位表示网络地址，最后24位表示主机地址。</li><li>A类地址适用于大型网络，每个网络可以有大约1677万个主机地址。</li></ul></li><li>B类（Class B）：<ul><li>范围：128.0.0.0 到 191.255.255.255</li><li>前两个字节中，最高两位固定为10，接下来的14位表示网络地址，最后16位表示主机地址。</li><li>B类地址适用于中等规模的网络，每个网络最多可有65534个主机地址。</li></ul></li><li>C类（Class C）：<ul><li>范围：192.0.0.0 到 223.255.255.255</li><li>前三个字节中，最高三位固定为110，接下来的21位表示网络地址，最后8位表示主机地址。</li><li>C类地址适用于小型网络，每个网络最多可有254个主机地址，是最常见的分配给家庭用户和小型企业的地址类型。</li></ul></li><li>D类（Class D）：<ul><li>范围：224.0.0.0 到 239.255.255.255</li><li>第一个字节的最高四位固定为1110，用于多播（组播）通信，不分配给特定网络或主机，而是用于向一组主机同时发送数据。</li></ul></li><li>E类（Class E）：<ul><li>范围：240.0.0.0 到 255.255.255.255</li><li>第一个字节的最高位固定为11110，保留作研究和将来使用，目前不分配给任何网络或作为常规用途。</li></ul></li></ul><h4 id="特殊的主机地址"><a href="#特殊的主机地址" class="headerlink" title="特殊的主机地址"></a>特殊的主机地址</h4><p>在IPv4中，主机地址部分确实有一些特殊值，这些值具有特定的含义和用途，以下是一些重要的特殊值：</p><ul><li><strong>全 0 主机地址</strong>：<ul><li>当主机部分的所有位都是0时，这个地址表示的是网络地址，而不是任何特定的主机。它标识了一个特定的网络或子网，而不是网络内的某个设备。</li></ul></li><li><strong>全 1 主机地址</strong>：<ul><li>当主机部分的所有位都是1时，这个地址是广播地址。在IPv4中，广播地址用于向同一网络内的所有主机发送数据包。例如，192.168.1.255（假设网络部分是192.168.1）就是一个广播地址。</li></ul></li><li><strong>回环地址</strong>：<ul><li>虽然严格意义上这不是主机地址部分的特殊值，但127.0.0.1是一个特殊的IPv4地址，被称为回环地址。发送到这个地址的数据包不会离开本地计算机，而是被送回给发送方，常用于测试本地网络软件栈。</li></ul></li></ul><p>除了上述之外，还有一些地址被保留用于特殊目的，虽然它们不是仅通过主机地址部分的特殊值来定义，但它们在实际应用中具有特殊意义：</p><ul><li><strong>私有IP地址</strong>：<ul><li>私有IP地址范围内的地址（如10.0.0.0&#x2F;8、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16）在内部网络中使用，不能直接在公网上路由，用于节省公网IP地址资源。</li></ul></li><li><strong>未指定地址</strong>：<ul><li>0.0.0.0有时被用作未指定地址，特别是在配置中表示默认路由或作为源地址时，意味着“任意”或“本机尚未获得有效IP地址”。</li></ul></li></ul><h4 id="子网划分-与-子网掩码"><a href="#子网划分-与-子网掩码" class="headerlink" title="子网划分 与 子网掩码"></a>子网划分 与 子网掩码</h4><p>子网划分是网络工程中的一种技术，它允许将一个大的IP网络划分为多个更小的网络，称为子网。这样做可以更有效地利用IP地址空间，增强网络管理的灵活性，并提高网络安全性。以下是子网划分的基本概念和步骤：</p><ul><li><strong>子网划分的目的</strong><ul><li>节约IP地址：通过创建较小的子网，可以避免地址空间的浪费，尤其是在大型网络中。</li><li>增强网络管理：子网使得网络可以按逻辑或物理区域组织，便于管理和故障排查。</li><li>提高安全性：限制广播域，减少广播流量，同时可以通过子网隔离提高网络的安全级别。</li><li>便于路由聚合：在互联网中，CIDR允许将多个连续的子网聚合为一个更大的网络前缀，简化路由表。</li></ul></li><li><strong>子网划分的过程</strong><ul><li>确定子网掩码：子网掩码是一个32位的二进制数，其作用是区分IP地址中的网络部分和主机部分。通过增加子网掩码中1的个数，可以减少主机部分的位数，从而创建子网。</li><li>计算子网数量和主机数：</li><li>子网数量由子网掩码的位数决定。例如，&#x2F;24（即255.255.255.0）的网络，若划分为&#x2F;26（即255.255.255.192），则每个子网有(2^{2^(32-26)} &#x3D; 2^6 &#x3D; 64)个地址，减去网络地址和广播地址，每个子网可用主机数为62。</li><li>分配子网：根据网络的需求，将大网络划分为多个子网，并为每个子网分配一段连续的IP地址范围。</li><li>配置网络设备：在路由器和网络设备上设置正确的子网掩码和路由规则，确保数据包能够正确地在子网间转发。</li></ul></li><li><strong>子网划分实例</strong><ul><li>假设有一个C类网络192.168.1.0，默认子网掩码为255.255.255.0（&#x2F;24）。如果需要划分为4个子网，可以使用&#x2F;26的子网掩码（即255.255.255.192），这样每个子网将有64个地址，去除网络地址和广播地址后，每个子网实际可用的主机地址为62个。</li></ul></li></ul><h4 id="无分类-IP-地址-CIDR"><a href="#无分类-IP-地址-CIDR" class="headerlink" title="无分类 IP 地址 CIDR"></a>无分类 IP 地址 CIDR</h4><p>CIDR，全称 Classless Inter-Domain Routing（无类域间路由选择），是一种在Internet上管理和分配IP地址以及进行路由决策的策略。它是对传统分类网络地址体系（A类、B类、C类等）的改进，旨在更有效地利用IPv4地址空间，并简化路由表的管理。</p><ul><li><strong>CIDR的核心特点</strong>：<ul><li><strong>无类</strong>：CIDR摒弃了传统的A、B、C类地址的分类方式，不再根据地址的首位来决定网络大小，而是使用变长子网掩码（VLSM，Variable Length Subnet Mask），允许网络管理员灵活地分配地址空间。</li><li><strong>网络前缀</strong>：CIDR使用斜杠记法（&#x2F;）来表示IP地址和其对应的网络前缀长度。例如，192.168.1.0&#x2F;24表示前24位是网络部分，剩下的8位是主机部分。这等同于说该IP地址属于一个具有24位网络掩码的网络。</li><li><strong>路由聚合</strong>：CIDR允许将多个连续的网络汇聚成一个单一的、更短的路由条目，减少了路由表的大小，提高了路由器的效率和Internet路由的可扩展性。这一过程也称为超网（Supernetting）。</li><li><strong>地址分配效率</strong>：通过精细地调整子网大小，CIDR使得IP地址分配更加高效，尤其是在面对不同规模的网络需求时，可以更灵活地适应。</li></ul></li><li><strong>实施效果</strong>：<ul><li><strong>减少路由表项</strong>：通过路由聚合，ISP和其他大型网络运营商能够将大量网络汇总为少数几条路由，减轻了路由器的负担，加速了路由更新和查找过程。</li><li><strong>优化地址分配</strong>：CIDR使得IP地址的分配更加动态和适应性强，尤其是对于快速增长的网络和ISP而言，能够更合理地规划和使用稀缺的IPv4地址资源。</li><li><strong>促进过渡到IPv6</strong>：虽然CIDR有效缓解了IPv4地址耗尽的问题，但它也是推动向更大地址空间的IPv6过渡的一部分策略，因为IPv6的设计从一开始就采用了无类地址结构。</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p><code>IPv6</code>（Internet Protocol version 6）是互联网协议的第六版，设计用于替代<code>IPv4</code>，以解决IPv4地址空间耗尽的问题并提升网络性能。IPv6于1998年正式成为标准，其主要特点和改进包括：</p><ul><li><strong>扩大地址空间</strong>： IPv6使用128位地址，相较于IPv4的32位，这提供了极其庞大的地址空间（大约3.4×10^38个地址），足以满足全球网络扩张的需求，并且支持未来互联网设备的指数增长。</li><li><strong>简化报头结构</strong>： IPv6报头更为简洁，固定长度为40字节，而IPv4的报头长度可变。简化后的报头提升了数据包处理的效率，减少了延迟。</li><li><strong>内置安全特性</strong>： IPv6原生支持IPsec（Internet Protocol Security），提供更强的数据安全和验证功能，有助于保障端到端的通信安全。</li><li><strong>取消广播，采用组播</strong>： IPv6不再支持广播地址，而是使用一种更灵活的组播（Multicast）通信，使得数据可以高效地传送到一组感兴趣的接收者。</li><li><strong>无状态地址自动配置</strong>（SLAAC）： IPv6设备可以自动配置其接口地址，无需DHCP服务器，简化了网络管理。设备通过路由器宣告的路由器广告消息获得网络前缀和配置信息。</li><li><strong>邻居发现协议</strong>（NDP）： 替代了IPv4中的ARP协议，提供地址解析、重复地址检测、邻居状态跟踪等多种功能。</li><li><strong>流标签</strong>： IPv6报头中的流标签字段允许数据包标记特定的流量，便于路由器对特定数据流应用特定的服务质量（QoS）策略。</li><li><strong>扩展报头</strong>： IPv6使用一系列可选的扩展报头来实现分片、路由选择、认证、封装等高级功能，这些报头可以根据需要插入到基本报头之后，提供了更高的灵活性和扩展性。</li><li><strong>兼容性和过渡技术</strong>： 为实现IPv4向IPv6的平滑过渡，开发了一系列过渡技术，如双栈（Dual Stack）、隧道技术（如6to4、ISATAP）和翻译技术（如NAT64）。</li></ul><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p><code>ARP（Address Resolution Protocol，地址解析协议）</code>是网络层和数据链路层之间的一个重要协议，<strong>主要用于在局域网（LAN）中将已知的IP地址解析为对应的MAC（Media Access Control，媒体访问控制）地址</strong>。在IPv4网络中，数据链路层的通信依赖于MAC地址，而网络层的通信则使用IP地址。因此，ARP协议在IP通信过程中扮演着桥梁的角色，确保数据包能够从发送方正确地传递到接收方。以下是ARP协议的工作原理和过程：</p><h3 id="ARP-工作原理"><a href="#ARP-工作原理" class="headerlink" title="ARP 工作原理"></a>ARP 工作原理</h3><ul><li><strong>查询过程：</strong><ul><li>当一台主机需要向同一局域网内的另一台主机发送数据时，首先检查自己的ARP缓存表中是否有目标IP地址对应的MAC地址。</li><li>如果没有找到，则该主机构造一个ARP请求报文，该报文中包含发送方的IP地址和MAC地址，以及目标IP地址（但不包含目标MAC地址，因为这就是查询的目的）。</li><li>这个ARP请求以广播形式发送到局域网内所有主机，因为此时发送方不知道目标的具体MAC地址。</li></ul></li><li><strong>响应过程：</strong><ul><li>目标主机接收到ARP请求后，识别出请求中的IP地址与自己的相符，便将自己MAC地址封装在一个ARP响应报文中，然后以单播形式发送给请求方。</li><li>发送方收到响应后，将目标IP地址与MAC地址的对应关系存储到自己的ARP缓存表中，以便后续通信直接使用，同时可以开始数据的传输。</li></ul></li></ul><h3 id="ARP缓存"><a href="#ARP缓存" class="headerlink" title="ARP缓存"></a>ARP缓存</h3><ul><li>每个主机都维护一个ARP缓存表，用来存储已知的IP地址到MAC地址的映射关系，以减少网络中的ARP请求广播。缓存中的条目可以是动态学习的（通过ARP响应获得），也可以是静态配置的（由网络管理员设定）。</li></ul><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul><li>ARP协议基于信任机制，容易受到ARP欺骗攻击。攻击者可以通过发送伪造的ARP响应，误导其他主机将数据发送到错误的MAC地址，从而截获或中断通信。</li></ul><h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p><code>ICMP（Internet Control Message Protocol，互联网控制消息协议）</code>是网络层的一个重要协议，它主要用于在IP主机、路由器之间传递控制和差错报告信息。ICMP并非为传输数据而设计，而是作为IP协议的补充，提供网络层的错误报告、拥塞控制、路径探测等功能。以下是ICMP协议的主要功能和消息类型：</p><h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><ul><li><strong>差错报告</strong>：当IP数据包无法送达目的地时，沿途的路由器或目标主机可能通过ICMP发送错误消息给源主机，告知数据包无法送达的原因，如目标不可达、超时、重定向等。</li><li><strong>网络诊断</strong>：最著名的应用是ping命令，它利用ICMP的Echo Request和Echo Reply消息来测试两台主机之间的连通性及往返时间（RTT）。</li><li><strong>路径控制</strong>：路由器可以使用ICMP重定向消息通知主机关于更好的路由路径，帮助改善网络性能。</li><li><strong>拥塞控制</strong>：某些类型的ICMP消息可以用来指示网络拥塞，尽管现代网络中这种方法已较少使用。</li></ul><h3 id="常见ICMP消息类型："><a href="#常见ICMP消息类型：" class="headerlink" title="常见ICMP消息类型："></a>常见ICMP消息类型：</h3><ul><li>Echo Request (Type 8)：用于测试目的主机的可达性，通常与ping命令关联。</li><li>Echo Reply (Type 0)：作为对Echo Request的响应，确认目的主机已收到请求并返回。</li><li>Destination Unreachable (Type 3)：当数据包无法到达目的地时，路由器或主机发送此消息，指出不可达的原因。</li><li>Time Exceeded (Type 11)：当IP数据包生存时间（TTL）耗尽仍未到达目的地时，路由器会发送此消息。</li><li>Parameter Problem (Type 12)：如果IP数据包头部有错误（如必要的字段缺失），接收方会发送此消息。</li><li>Redirect (Type 5)：路由器使用此消息通知主机应该使用另一个路由器作为到达特定目的地的下一跳。</li><li>Source Quench (Type 4)：已被废弃，过去用于拥塞控制，通知发送方降低发送速率。</li></ul><h2 id="网络层设备-——-路由器"><a href="#网络层设备-——-路由器" class="headerlink" title="网络层设备 —— 路由器"></a>网络层设备 —— 路由器</h2><p>路由器（Router）是计算机网络中至关重要的网络设备，<strong>它负责在不同的网络之间转发数据包</strong>。路由器的功能如下：</p><h4 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h4><ul><li>寻址与转发：路由器读取每个数据包中的IP地址信息，根据路由表中的信息决定数据包的转发路径，实现不同网络之间的互联互通。</li><li>协议理解：路由器能够理解并处理多种网络通信协议，如以太网协议、TCP&#x2F;IP协议等，确保不同协议的数据包能够正确转发。</li><li>路由选择：路由器依据路由算法（包括静态路由和动态路由）来决定最佳路径，动态路由能够根据网络状况变化自动调整路由选择。</li></ul><h4 id="网络互连："><a href="#网络互连：" class="headerlink" title="网络互连："></a>网络互连：</h4><p>路由器作为网关设备，可以连接不同类型的网络，例如将局域网（LAN）与广域网（WAN）相连，或者连接不同协议的网络。</p><h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>在必要时，路由器可以执行网络地址转换（NAT），将内部私有IP地址转换为外部公共IP地址，或者反之，以便不同类型的网络间能够相互通信。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 物理层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——物理层"><a href="#计算机网络——物理层" class="headerlink" title="计算机网络——物理层"></a>计算机网络——物理层</h1><p>物理层 负责解决在各种传输媒体上传输比特 0 和 1 的问题，进而给数据链路层提供透明传输比特流的服务</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20191128164313811.JPG" alt="img"></p><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p>物理层的功能：怎样在连接各种计算机的传输媒体上传输数据比特流，屏蔽不同传输媒体和通信手段的差异</p><p>规程：用于物理层的协议</p><p>传输媒体接口的特性：</p><ul><li>机械特性：接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li><li>电气特性：接口电路的各条线上出现的电压范围</li><li>功能特性：某条线上出现某一电平电压的意义</li><li>过程特性：对于不同功能的各种可能事件的出现顺序</li></ul><h2 id="数据通信基本知识"><a href="#数据通信基本知识" class="headerlink" title="数据通信基本知识"></a>数据通信基本知识</h2><h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630211130501.png" alt="image-20240630211130501" style="zoom: 67%;" /><ul><li>如上图所示，一个数据通信系统可划分为三大部分，即<ul><li><strong>源系统（或发送端、发送方)</strong></li><li><strong>传输系统（或传输网络）</strong></li><li>**目的系统（或接收端、接收方)**。</li></ul></li></ul><ul><li><p>常用术语：</p><ul><li><p><strong>消息</strong>：通信的目的是传送消息，如语音、文字、图像、视频等</p></li><li><p><strong>数据</strong>：是运送消息的实体；使用特定方式表示的信息，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：数据的电气或电磁表现</p></li><li><p>**模拟信号 (连续信号)**：代表消息的参数取值是连续的</p></li><li><p>**数字信号 (离散信号)**：代表消息的参数的取值是离散的</p></li><li><p><strong>码元</strong>：代表不同离散数值的基本波形</p></li></ul></li></ul><h3 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h3><ul><li><p><strong>信道</strong>：表示向某一个方向传送信息的媒体</p></li><li><p><strong>信息交互的方式</strong>：</p><ul><li><p>单向通信(单工通信)：只能有一个方向的通信而没有反方向的交互；只需要一条信道</p></li><li><p>双向交替通信(半双工通信)：通信的双方都可以发送信息，但不能双方同时发送，而是一方发送另一方接收，一段时间后可以反过来；两条信道</p></li><li><p>双向同时通信(全双工通信)：通信双方可以同时发送和接收信息；两条信道；传输效率最高</p></li></ul></li><li><p><strong>基带信号</strong>：来自信源的信号；如计算机输出的代表文字或图像的数据信号都是基带信号</p></li><li><p><strong>调制分类</strong>：</p><ul><li><p>**基带调制(编码)**：仅对基带信号的波形进行变换，使其能与信道特性相适应，变换后的信号仍是基带信号</p></li><li><p><strong>带通调制</strong>：使用载波进行调制，把基带信号的频率范围移到较高频段，并转换为模拟信号，变换后的信号称为带通信号</p></li></ul></li><li><p><strong>常用编码方式</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630212518146.png" alt="image-20240630212518146"></p><ul><li><p><strong>不归零制</strong>：正电平代表1，负电平代表0</p></li><li><p><strong>归零制</strong>：正脉冲代表1，负脉冲代表0</p></li><li><p><strong>曼切斯特编码</strong>：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1；也可反过来定义</p></li><li><p><strong>差分曼切斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，位开始边界没有跳变代表1</p></li></ul></li></ul><p><strong>基本带通调制方法</strong></p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630212440455.png" alt="image-20240630212440455" style="zoom: 80%;" /><ul><li><strong>调幅</strong>：载波的振幅随基带数字信号而变化；如0或1分别对应无载波或有载波输出</li><li><strong>调频</strong>：载波的频率随基带数字信号而变化；如0或1分别对应频率f1或f2</li><li><strong>调相</strong>：载波的初始相位随基带数字信号而变化；如0或1分别对应于相位0度或180度</li></ul><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>限制码元在信道上传输速率的因素：</p><ul><li><p>信道能够通过的频率范围：</p><ul><li><strong>码间串扰</strong>：信号中高频分类受到衰减，在接收端收到的波形前沿和后沿不那么陡峭，每个码元所占时间界限不明确，失去了码元间的清晰界限的现象</li><li><strong>奈氏准则</strong>：在任何信道，码元传输的速率是有上限的，超过上限就会出现严重的码间串扰，使接收端对码元无法识别</li></ul></li><li><p>信噪比：</p><ul><li><p>定义：信号的平均功率和噪声的平均功率之比，记作S&#x2F;N</p><p>$$信噪比 (dB)&#x3D;10 log 10 (S&#x2F;N)$$</p></li><li><p>香农公式：信道的极限信息传输速率C是</p><p>$$C&#x3D;Wlog<del>2</del>(1+S&#x2F;N)(bit&#x2F;s)$$</p><p>其中</p><ul><li>W为信道带宽，</li><li>S为信道内所传信号的平均功率，</li><li>N为信道内部的高斯噪声功率</li></ul><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</p><p>香农公式的意义：只要信息传输速率低于信道的极限速率，就一定存在某种方法来实现无差错的传输</p></li></ul></li></ul><h2 id="物理层传输媒体"><a href="#物理层传输媒体" class="headerlink" title="物理层传输媒体"></a>物理层传输媒体</h2><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类：</p><ul><li><strong>导引型传输媒体</strong>：在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播；</li><li><strong>非导引型传输媒体</strong>：非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</li></ul><p>下图是电信领域使用的电磁波的频谱。<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630213537285.png" alt="image-20240630213537285" style="zoom:70%;" /></p><h3 id="引导型传输媒体"><a href="#引导型传输媒体" class="headerlink" title="引导型传输媒体"></a>引导型传输媒体</h3><p>常见引导性传输媒体包括</p><ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul><h3 id="非引导性媒体"><a href="#非引导性媒体" class="headerlink" title="非引导性媒体"></a>非引导性媒体</h3><p>若通信线路要通过一些高山或岛屿，有时就很难施工。即使是在城市中，挖开马路敷设电缆也不是一件很容易的事。当通信距离很远时，敷设电缆既昂贵又费时。但利用无线电波在自由空间的传播就可较快地实现多种通信。非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。无线传输所使用的频段很广。短波通信主要是靠电离层的反射，但短波信道的通信质量较差。</p><p>两种通信方式：</p><ul><li><strong>地面微波接力通信</strong>：微波接力通信可传输电话、电报、图像、数据等信息。微波波段频率很高，其频段范围也很宽，因此其通信信道的容量很大。与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。但是微波接力通信与电缆通信系统比较，微波通信的隐蔽性和保密性较差，同时对大量中继站的使用和维护要耗费较多的人力和物力。</li><li><strong>卫星通信</strong>：卫星通信的频带很宽，通信容量很大，信号所受到的干扰也较小，通信比较稳定。卫星通信的另一特点就是具有较大的传播时延。</li></ul><p>当利用无线信道传送数字信号时，必须使误码率（即比特错误率）不大于可容许的范围。三个有关的基本概念：</p><ul><li>对于给定的调制方式和数据率，信噪比越大，误码率就越低。</li><li>对于同样的信噪比，具有更高数据率的调制技术的误码率也更高。</li><li>如果移动用户在进行通信时还在不断改变自己的地理位置，就会引起无线信道特性的改变，因而信噪比和误码率都会发生变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 链路层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——数据链路层"><a href="#计算机网络——数据链路层" class="headerlink" title="计算机网络——数据链路层"></a>计算机网络——数据链路层</h1><h2 id="链路层功能"><a href="#链路层功能" class="headerlink" title="链路层功能"></a>链路层功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。</p><p> 数据链路指网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><ul><li><p><strong>无确认的无连接服务</strong><br>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。适用于实时通信或误码率较低的通信信道，如以太网。</p></li><li><p><strong>有确认的无连接服务</strong><br>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧。该服务适用于误码率较高的通信信道，如无线通信。</p></li><li><p><strong>有确认的面向连接服务</strong><br>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。该服务适用于通信要求（可靠性、实时性）较高的场合。</p></li></ul><h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p> 数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</p><h4 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h4><p> 两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。</p><ul><li>帧构成：数据前后添加首部和尾部。帧长&#x3D;数据长度+首部长度+尾部长度</li><li>帧定界：帧首部尾部包含控制信息，其中一个重要作用是确定帧的界限。</li><li>帧同步：接收方应能从接收到的二进制比特流中区分出帧的起始与终止。</li><li>最大传送单元（MTU）：为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据链路层协议都规定了帧的数据部分的长度上限——最大传送单元（MTU）。</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>由于信道噪声等原因，帧在传输过程中可能出现错误。</li><li>用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。</li><li>位错 —— 帧中某些位出现了差错<ul><li>通常采用循环冗余校验（CRC）方式发现<strong>位错</strong> （帧中某些位出现了差错）</li><li>通过自动重传请求（Automatic Repeat reQuest, ARQ）方式来重传出错的帧。</li></ul></li><li>帧错 —— 帧的丢失、重复或失序等错误。<ul><li>在数据链路层引入定时器和编号机制，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</li></ul></li></ul><h2 id="链路分类"><a href="#链路分类" class="headerlink" title="链路分类"></a>链路分类</h2><h3 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</p><h3 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>频分复用： 将多路信号调制到不同频率的载波上再进行叠加</li><li>时分复用： 将物理信道按时间划分为若干时间片，轮流给不同信道使用</li><li>波分复用： 光纤中传输不同波长的光信号 —— 实际也是频分</li><li>码分复用： 靠不同的编码来区分各路原始信号，如 CDMA 技术</li></ul><h2 id="如何实现-随机访问"><a href="#如何实现-随机访问" class="headerlink" title="如何实现 随机访问"></a>如何实现 随机访问</h2><p>略</p><h2 id="关键协议"><a href="#关键协议" class="headerlink" title="关键协议"></a>关键协议</h2><ul><li><strong>以太网（Ethernet）：</strong><ul><li>最常见的局域网（LAN）技术之一，基于载波侦听多点接入&#x2F;碰撞检测（CSMA&#x2F;CD）协议，适用于共享介质环境。以太网定义了如何封装数据成帧，以及如何在物理层之上提供错误检测和纠正功能。</li></ul></li><li><strong>点对点协议（PPP, Point-to-Point Protocol）：</strong><ul><li>通常用于串行线路，如拨号连接或DSL，提供简单、直接的两节点间的连接。PPP支持多种网络层协议（如IP），并具备错误检测、支持认证等功能。</li></ul></li><li><strong>高级数据链路控制（HDLC, High-Level Data Link Control）：</strong><ul><li>一种面向比特的协议，常用于广域网（WAN）和专线连接，提供可靠的数据传输服务。HDLC支持多种操作模式，包括正常响应模式（NRM）、异步平衡模式（ABM）等。</li></ul></li><li><strong>帧中继（Frame Relay）：</strong><ul><li>一种面向连接的数据链路层协议，主要用于广域网通信。帧中继提供了一种高效的、基于虚电路的服务，它在性能上介于传统的电路交换和包交换之间，适用于高速数据传输。</li></ul></li><li><strong>异步传输模式（ATM, Asynchronous Transfer Mode）：</strong><ul><li>设计用于宽带网络，ATM是一种面向连接的、分组交换的技术，它将数据分割成固定长度的信元（cell），适用于高速网络和多媒体传输。</li></ul></li><li><strong>IEEE 802系列标准：</strong><ul><li>包括了多种局域网和城域网的数据链路层协议，如IEEE 802.3（以太网）、IEEE 802.11（无线局域网Wi-Fi）、IEEE 802.15（无线个人区域网，如蓝牙）等。</li></ul></li></ul><h2 id="关键设备"><a href="#关键设备" class="headerlink" title="关键设备"></a>关键设备</h2><ul><li><strong>网络交换机（Switch）：</strong><ul><li>网络交换机是局域网中最常见的设备，能够根据数据帧中的MAC地址（媒体访问控制地址）来转发数据帧。它通过学习连接设备的MAC地址并建立MAC地址表来高效地在不同端口之间转发数据，支持多个设备同时通信而不冲突。</li></ul></li><li><strong>网桥（Bridge）：</strong><ul><li>网桥用于连接两个或多个局域网（LAN），通过检查数据帧的MAC地址来决定是否转发该帧到另一个网络段，以此来分割广播域，减少网络拥堵，提高网络性能。网桥相比交换机，功能较为基础，通常应用于较小规模的网络中。</li></ul></li><li><strong>网卡（Network Interface Card, NIC）：</strong><ul><li>网卡是安装在计算机或网络设备上的硬件组件，它提供了一个物理接口，用于连接到网络媒介（如双绞线、光纤等）。网卡负责在计算机和网络之间转换数据帧，执行数据链路层的封装和解封装，以及物理层的信号编码与解码。</li></ul></li><li><strong>路由器（Router）：</strong><ul><li>虽然路由器主要工作在网络层，但在某些讨论中，其数据链路层功能也不容忽视，特别是当涉及到不同局域网间的数据链路层协议转换时（如在某些多协议标签交换MPLS应用中）。路由器使用网络层地址（如IP地址）来转发数据包，但在实际操作中也会涉及到数据链路层的帧封装。</li></ul></li></ul><p>虽然路由器通常归在网络层设备，但在实际网络部署中，路由器的接口也会执行数据链路层的功能，如以太网接口的MAC地址处理。因此，根据上下文，路由器有时也被提及在数据链路层的讨论中。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h3><ul><li><strong>广义观点</strong>：能实现远程信息处理的系统或能进一步达到资源共享的系统。</li><li><strong>资源共享观点</strong>：以能够相互 共享资源 的方式互连起来的自治计算机系统的集合。</li><li>目的：资源共享；组成：多台自治计算机；规则：网络协议</li><li><strong>用户透明性观点</strong>：整个网络就像一个大的计算机系统一样对用户是透明的。</li></ul><h3 id="链路，结点，协议和服务，实体和对等实体，PDU"><a href="#链路，结点，协议和服务，实体和对等实体，PDU" class="headerlink" title="链路，结点，协议和服务，实体和对等实体，PDU"></a>链路，结点，协议和服务，实体和对等实体，PDU</h3><ul><li><strong>链路</strong>：连接结点的称为链路，可以是铜缆，光纤，卫星等</li><li><strong>结点</strong>：可以是计算机，集线器，交换机或路由器等</li><li><strong>协议</strong>： 两个对等实体之间的通信规则。协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的动作。协议有三要素：语法（数据与控制信息的结构或格式、信号电平）、语义（需要发出何种控制信息、完成何种动作以及做出何种响应、差错控制）、时序（事件顺序、速度匹配）</li><li><strong>服务</strong>：在协议的控制下，本层向上一层提供服务，本层使用下一层所提供的服务</li><li><strong>实体</strong>：任何可发送或接收信息的硬件或软件进程</li><li><strong>对等实体</strong>：位于同等层中相互通信的两个实体。对等实体之间处理相同的PDU。</li><li><strong>PDU</strong>：对等层之间传送的数据单位</li></ul><h3 id="C-S模式，B-S模式，P2P模式"><a href="#C-S模式，B-S模式，P2P模式" class="headerlink" title="C&#x2F;S模式，B&#x2F;S模式，P2P模式"></a>C&#x2F;S模式，B&#x2F;S模式，P2P模式</h3><ul><li><strong>C&#x2F;S模式</strong>：也即客户-服务器方式。客户是服务请求方，服务器是服务提供方。客户必须知道服务器的地址，反之不必</li><li><strong>B&#x2F;S模式</strong>：也即浏览器-服务器方式。在服务器安装SQLserver，MYSQL等数据库，浏览器通过web server同数据库进行数据交换</li><li><strong>P2P模式</strong>：对等方式，通信在对等实体之间直接进行。每一个主机既是客户又是服务器，本质上仍是C&#x2F;S</li></ul><h3 id="LAN-WAN-MAN-PAN的划分"><a href="#LAN-WAN-MAN-PAN的划分" class="headerlink" title="LAN, WAN, MAN, PAN的划分"></a>LAN, WAN, MAN, PAN的划分</h3><table><thead><tr><th>网络</th><th>范围</th><th>特点</th></tr></thead><tbody><tr><td>广域网（WAN）</td><td>10km-1000km</td><td>互联网、交换技术</td></tr><tr><td>城域网（MAN）</td><td>5km-50km</td><td>以太网</td></tr><tr><td>局域网（LAN）</td><td>10m-5km</td><td>广播技术</td></tr><tr><td>个人局域网（PAN）</td><td>0-10m</td><td>无线技术</td></tr></tbody></table><h3 id="网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率"><a href="#网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率" class="headerlink" title="网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率"></a>网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率</h3><ul><li>速率：数据的传送速率，单位是Bit&#x2F;s</li><li>带宽:在计算机网络中，网络带宽表示单位时间内网络中某信道所能通过的“最高数据率”，单位为bit&#x2F;s</li><li>吞吐量:表示在发送端与接收端之间实际的传送数据速率（bit&#x2F;s）</li><li>时延:指数据从网络的一端传送到另外一端所需的时间。</li><li>发送时延：是主机或路由器发送数据帧所需要的时间。公式为：数据帧长度（bit）&#x2F;发送速率（bit&#x2F;s）</li><li>传播时延：是电磁波在信道中传播一定的距离需要花费的时间。公式为：信道长度（m）&#x2F;电磁波在信道上的传播速率（m&#x2F;s）</li><li>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理</li><li>排队时延：在分组进入路由器后要先在输入队列中排队等待处理</li><li>往返时间:从发送方发送数据开始，到发送方收到来自接受方的确认，总共经历的时间</li><li>信道利用率:指某信道有百分之几的时间是有数据通过的<ul><li>信道利用率并非越高越好，因为当利用率增大时，该信道引起的时延也就迅速增加</li></ul></li></ul><h3 id="互联网的组成（边缘部分与核心部分的作用）"><a href="#互联网的组成（边缘部分与核心部分的作用）" class="headerlink" title="互联网的组成（边缘部分与核心部分的作用）"></a>互联网的组成（边缘部分与核心部分的作用）</h3><ul><li><strong>边缘部分</strong>：各种端系统如主机，手机，大型或超级计算机组成。位于网络边缘；运行网络应用程序</li><li><strong>核心部分</strong>：互联的路由器网络。关键功能：路由和转发，其中交换机是在同一个子网内部转发数据，路由器是在不同子网之间转发数据。以数据交换的方式实现数据从源主机通过网络核心到达目的主机。</li></ul><h3 id="互联网基本拓扑类型"><a href="#互联网基本拓扑类型" class="headerlink" title="互联网基本拓扑类型"></a>互联网基本拓扑类型</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630205630445.png" alt="image-20240630205630445"></p><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>最经典的电路交换网络是电话网络。主要特点就是独占资源。电路交换的三个阶段：建立连接（呼叫）、通信、释放连接（挂机）。用多路复用技术解决一条链路被多路通信共享的问题</p><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><p>报文：源应用发送的信息整体<br>分组：由报文拆分成较小的数据块<br>在发送端，先把较长的报文划分成较短的，固定长度的数据段<br>每一个数据段前面添加上首部构成分组。每一个分组的首部都含有地址等控制信息<br>依次把各分组发送到接收端。每个分组在互联网中独立地选择传输路径<br>接收端收到分组后剥去首部还原成报文</p><h4 id="数据报交换"><a href="#数据报交换" class="headerlink" title="数据报交换"></a>数据报交换</h4><p>将整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点</p><h4 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h4><p>即先建一条逻辑通路，其通信过程类似电路交换。每个分组除了包含数据之外还包含一个虚电路标识号，而不是目的地址的信息；在预先建好的路径上的每个节点都知道把这些分组引导到哪里去，数据分组按已建立的路径顺序通过网络，不再需要路由选择判定。</p><h1 id="计算机网络层次划分"><a href="#计算机网络层次划分" class="headerlink" title="计算机网络层次划分"></a>计算机网络层次划分</h1><p>主要有三种划分方式</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630202830599.png" alt="image-20240630202830599"></p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI,它们共同组成PDU。</p><ul><li>服务数据单元(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li>协议控制信息(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCL。</li><li>协议数据单元(PDU)：对等层次之间传送的数据单位称为该层的PDU。</li></ul><h2 id="OSI-链路模型"><a href="#OSI-链路模型" class="headerlink" title="OSI 链路模型"></a>OSI 链路模型</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630205411614.png" alt="image-20240630205411614"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 状态详解</title>
      <link href="/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-状态详解"><a href="#TCP-状态详解" class="headerlink" title="TCP 状态详解"></a>TCP 状态详解</h1><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2846604-6a8557619966204d.png" alt="img"></p><h2 id="TCP-状态梳理"><a href="#TCP-状态梳理" class="headerlink" title="TCP 状态梳理"></a>TCP 状态梳理</h2><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待来自远程TCP应用程序的请求</td></tr><tr><td>SYN_SENT</td><td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td></tr><tr><td>SYN-RECEIVED</td><td>该端点已经接收到连接请求并发送确认。 该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td></tr><tr><td>ESTABLISHED</td><td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td></tr><tr><td>FIN_WAIT_1</td><td>等待来自远程TCP的终止连接请求或终止请求的确认</td></tr><tr><td>FIN_WAIT_2</td><td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td></tr><tr><td>CLOSE_WAIT</td><td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td></tr><tr><td>CLOSING</td><td>等待来自远程TCP的连接终止请求确认</td></tr><tr><td>LAST_ACK</td><td>等待先前发送到远程TCP的连接终止请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td></tr></tbody></table><p><strong>牢记： TCP 到处都是坑</strong>， 现在就开始找坑</p><h2 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h2><ul><li><p>归属： 客户端独有</p></li><li><p>原因：</p><ul><li>网络延迟</li><li>服务器负载过高</li><li>防火墙有问题</li><li>中病毒——自动扫描其它机器</li></ul></li><li><p>限制</p><ul><li>超时后重传，重传间隔时间递增</li><li>限制最大重传次数</li></ul></li><li><p>linux syn 重试次数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syn_retries=6</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 6 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure></li></ul><h2 id="SYN-RECV"><a href="#SYN-RECV" class="headerlink" title="SYN_RECV"></a>SYN_RECV</h2><ul><li><p>归属： 服务端独有</p></li><li><p>原因：</p><ul><li>对端网络突然异常 ？</li><li>网络攻击 —— <strong>SYN 泛洪攻击</strong></li></ul></li><li><p>术语</p><ul><li>SYN_FLOOD 泛洪攻击</li><li>半连接队列 <ul><li>自然 还有一个全连接队列</li></ul></li></ul></li><li><p>SYN_FLOOD 防范</p><ul><li>扩展半连接队列上限<ul><li><code>net.ipv4.tcp_max_syn_backlog</code></li></ul></li><li>覆盖最早半连接记录</li><li>SYN Cookie<ul><li>原理： <ul><li>收到 SYN 请求不加入半连接队列，而是通过提取当前 socket 及其他相关特征参数 通过某种特定算法生成 一个 cookie 并作为 seq &#x2F; 时间戳 或设置为其 高位部分</li><li>客户端收到后，再次返回 ACK ， 其中 cookie 所存储在的字段保留返回</li><li>server 端收到 ACK 之后，拿到 cookie ， 并当前状态重新计算一个 cookie ，进行对比验证，通过则直接加入 全连接队列， 否则 关闭相应 SOCKET</li></ul></li><li>优点： 可以在一定程度上规避 SYN Flood 攻击造成的资源消耗</li><li>缺点： <ul><li>误判风险：在某些情况下，合法的连接请求可能会因为Cookie验证失败而被错误地拒绝，尤其是在网络条件不稳定或时间同步问题导致时间戳不准确时。</li><li>功能限制：SYN Cookie不记录连接元数据，因此在连接建立后，服务器无法恢复到正常TCP行为下的某些高级特性，如TCP窗口缩放等。</li></ul></li></ul></li></ul></li><li><p>非攻击导致 半连接队列高涨</p><ul><li>可考虑修改 <code>net.ipv4.tcp_synack_retries</code></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240629203831107.png" alt="image-20240629203831107" style="zoom:67%;" /></li></ul><h2 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN_WAIT_1"></a>FIN_WAIT_1</h2><ul><li>TCP 主动断开方，用户态进行系统调用 close()，内核发送 FIN 包， SOCKET 进入 FIN_WAIT_1 状态</li><li>FIN_WAIT_1 超时<ul><li>假设另一端非标准 或 恶意 TCP 端，诱导你发送 FIN，但一直不回 ACK，怎么办？</li><li>参考： <a href="https://blog.csdn.net/dog250/article/details/81697403">TCP FIN_WAIT1 超时机制 及 TCP假连接问题</a> ， 相关结论如下：<ul><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1，若对端此后无ACK返回，则无论是 pending在发送缓冲的数据 还是 FIN，Linux 内核都会尝试重新发送，并在收到 ACK 前会尝试 N 次退避， N 由 tcp_orphan_retries 参数控制</li><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1状态，此时如果对端接收窗口呈现打开状态，则主动断开端的 TCP 发送队列中的数据包会继续发往接收端，并在最后发送FIN包，收到FIN包ACK后进入FIN_WAIT2</li><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1状态，此时如果对端接收窗口呈现关闭状态(零窗口)，此时主动端开端会不断发送零窗口探测包。且发送次数限制为：<ul><li>低版本内核(至少社区3.10及以下)：永久尝试，如果探测ACK每次都返回，则没完没了。</li><li>高版本内核(至少社区4.6及以上)：限制尝试tcp_orphan_retries次，不管是否收到探测ACK。</li></ul></li></ul></li></ul></li></ul><h2 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN_WAIT_2"></a>FIN_WAIT_2</h2><ul><li>主动断开方，在 进入 <code>FIN_WAIT_1</code> 之后，收到对端 ACK，即进入 <code>FIN_WAIT_2</code> 状态，直到收到对端发来的 FIN 包，</li><li><code>FIN_WAIT_2</code> 连接数限制<ul><li>原因： server 端可能由于 KeepAlive 机制等原因导致 SERVER 主动关闭，若进入 FIN_WAIT_2 后，由于默认缺乏超时机制，可能导致 FIN_WAIT_2 连接数过多，占用系统资源，导致 系统 crash</li><li>方案：  修改系统配置  <code>/etc/sysctl.conf</code><ul><li><code>net.ipv4.tcp_fin_timeout = 30</code></li></ul></li></ul></li></ul><h2 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h2><ul><li>被动端开方，收到对端发送的 FIN 包并回复 ACK 后随机进入 CLOSE_WAIT 状态，直到 自身所有数据发送完毕，随后发送 FIN 包</li><li>没有默认的超时时间</li><li>CLOSE_WAIT 状态连接数过多 —— 一般是代码编写逻辑有问题<ul><li>需确保在 收到 FIN 报文后，尽快对 相应 socket 也发起 close 系统调用，以保证 连接正确释放</li></ul></li></ul><h2 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST_ACK"></a>LAST_ACK</h2><ul><li>被动端开方，进入 CLOSE_WAIT 状态后，自身数据发送完毕，随机也发送 FIN 包，进入 LAST_ACK 状态并等待 主动断开方回复最后的 ACK</li><li>若预期时间内没有收到 ACK ，则被动断联方会重新发送 FIN 包，直到超时 或 成功收到确认</li><li>超时限制调整 —— 内核没有直接针对 LAST_ACK 状态的超时参数</li><li>极限情况下只能修改内核源码并重新编译来直接调整 LAST_ACK 状态的超时逻辑</li></ul><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><ul><li>描述： 主动断开方收到对端 FIN 包后回复 ACK 并进入 <code>TIME_WAIT</code></li><li>时长： 2MSL (MSL：Maximum Segment Lifetime，通常默认为两分钟)</li><li>作用： 防止 ACK 丢失， 2MSL 的时长可确保 被动关闭方在 LAST_ACK 状态后未收到 ACK 还可重传 FIN</li><li>限制： 在高并发短连接的场景下，大量的 TIME_WAIT连接可能占用较多资源，影响服务的扩展性和性能<ul><li><code>net.ipcv4,tcp_tw_reuse</code>： 位于<code>/etc/sysctl.conf </code>文件中 ， 当 ~ 置为 1 时，内核允许将 TIME_WAIT 状态的 socket 的本地端口用于新的 TCP 连接请求</li><li><code>net.ipv4.tcp_tw_recycle</code>：同样位于<code>/etc/sysctl.conf 文件</code>中 ， 当 ~ 置为 1 时，内核会尝试快速回收那些处于 <code>TIME_WAIT</code> 状态的连接。它通过检查接收到的数据包中的 TCP 时间戳选项（TCP Timestamps），并与本机维护的最新时间戳进行对比，以此来判断数据包是否来自一个“旧”连接。如果时间戳过旧，内核将丢弃这些数据包，认为它们属于已经关闭的连接，从而可以更快地回收 TIME_WAIT 状态的套接字<ul><li>注意事项：<ul><li>兼容性问题：tcp_tw_recycle 的使用依赖于 TCP 时间戳选项，但并非所有系统或应用程序都会启用这个选项。这可能导致来自不支持或未启用时间戳功能的客户端的连接出现问题，比如连接失败或不稳定。</li><li>网络配置复杂性：由于时间戳的使用和校验，该参数在有中间网络设备（如 NAT 网关、负载均衡器）的环境中可能引起问题，因为这些设备可能会改变或去除时间戳，导致合法的数据包被错误地丢弃。</li><li>已知问题与建议：由于上述原因，尤其是在存在 NAT 环境或与互联网上的广泛客户端交互的场景下，使用 tcp_tw_recycle 可能弊大于利。实际上，该参数在较新的 Linux 内核版本中已被废弃或默认禁用，推荐使用 tcp_tw_reuse 作为替代方案，以更安全的方式复用端口</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS 详解</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS-BASIC"><a href="#HDFS-BASIC" class="headerlink" title="HDFS BASIC"></a>HDFS BASIC</h1><p>  当需要存储的数据集的大小超过了一台独立的物理计算机的存储能力时，就需要对数据进行分区并存储到若干台计算机上去。管理网络中跨多台计算机存储的文件系统统称为<strong>分布式文件系统（distributed fileSystem）</strong>。</p><p>  分布式文件系统由于其跨计算机的特性，所以依赖于网络的传输，势必会比普通的本地文件系统更加复杂，比如：如何使得文件系统能够容忍节点的故障并且保证不丢失数据，这就是一个很大的挑战</p><h2 id="HDFS简介及其基本概念"><a href="#HDFS简介及其基本概念" class="headerlink" title="HDFS简介及其基本概念"></a>HDFS简介及其基本概念</h2><p>  HDFS（Hadoop Distributed File System）是hadoop生态系统的一个重要组成部分，是hadoop中的的存储组件，在整个Hadoop中的地位非同一般，是最基础的一部分，因为它涉及到数据存储，MapReduce等计算模型都要依赖于存储在HDFS中的数据。HDFS是一个分布式文件系统，以流式数据访问模式存储超大文件，将数据分块存储到一个商业硬件集群内的不同机器上。</p><p>  这里重点介绍其中涉及到的几个概念：</p><p>（1）<strong>超大文件</strong>。目前的hadoop集群能够存储几百TB甚至PB级的数据。</p><p>（2）<strong>流式数据访问</strong>。HDFS的访问模式是：<strong>一次写入，多次读取</strong>，更加关注的是读取整个数据集的整体时间。</p><p>（3）<strong>商用硬件。</strong>HDFS集群的设备不需要多么昂贵和特殊，只要是一些日常使用的普通硬件即可，正因为如此，hdfs节点故障的可能性还是很高的，所以<strong>必须要有机制来处理这种单点故障</strong>，保证数据的可靠。</p><p>（4）<strong>不支持低时间延迟的数据访问</strong>。hdfs关心的是高数据吞吐量，不适合那些要求低时间延迟数据访问的应用。</p><p>（5）<strong>单用户写入，不支持任意修改。</strong>hdfs的数据以读为主，只支持单个写入者，并且写操作总是以添加的形式在文末追加，不支持在任意位置进行修改。</p><h2 id="HDFS-整体架构"><a href="#HDFS-整体架构" class="headerlink" title="HDFS 整体架构"></a>HDFS 整体架构</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616194928432.png" alt="image-20240616194928432"></p><ul><li>主从 —— nameNode + DataNode</li><li>Namenode—— Active &#x2F; Standby ，高可用</li></ul><h2 id="BLOCK-数据块-与-DataNode"><a href="#BLOCK-数据块-与-DataNode" class="headerlink" title="BLOCK 数据块 与 DataNode"></a>BLOCK 数据块 与 DataNode</h2><ul><li>HDFS 最小存储单元</li><li>多BLOCK多副本<ul><li>文件被器分为若干个 Block， 每个Block 有多个副本（默认3）</li><li>BLock 以 DataNode 为存储单元，即一个DataNode 智能存储Block的一个副本</li><li>机架感知： 尽量将 副本存放到不同的几家上，以提高容灾能力</li><li>副本均匀分布： DataNode 的 BLock 副本数和访问负荷要比较接近，已实现负载均衡</li></ul></li><li>Block 大小<ul><li>默认 128M，可调整（若Block中数据实际大小 &lt; 设定值，则Block 大小 &#x3D; 实际数据大小）</li><li>如何调整Block大小<ul><li>目标： <ul><li>最小化寻址开销， 降到 1%以下</li><li>任务并发度 和 集群负载比较适中，作业运行速度较快</li></ul></li><li>块太小<ul><li>寻址时间占比过高</li><li>Map 任务太多，并发度高，导致集群负载过高，作业变慢</li></ul></li><li>块太大<ul><li>Map 任务少，并发度太低，导致集群负载过低，作业变慢</li></ul></li></ul></li></ul></li><li>Block 文件<ul><li>Block 文件是DataNode 本地磁盘中名为 “blk_blockId”  的Linux 文件<ul><li>DataNode 在启动时自动创建存储目录，无需格式化</li><li>DataNode 的 current 目录下的文件名都已 “blk_” 为前缀</li><li>Block 的元数据文件（*.meta） 由一个包含版本、类型信息的头文件和一系列校验值组成</li></ul></li></ul></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616200613192.png" alt="image-20240616200613192" style="zoom:73%;" /><h2 id="NameNode-与-元数据存储"><a href="#NameNode-与-元数据存储" class="headerlink" title="NameNode 与 元数据存储"></a>NameNode 与 元数据存储</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li>目录文件爱你的基本属性（名称、所有者等），Block 相关信息（如文件包含哪些 Block，Block 放在那些节点上）、DataNode 相关信息</li><li>主要存储在 内存 <ul><li>为确保集群数据安全，需要对数据进行落盘 <ul><li>Block 位于哪些 DataNode    会由 DataNode 进行上报</li><li>因此仅持久化 文件划分成了 哪些 Block 的信息</li></ul></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616201427764.png" alt="image-20240616201427764"></p><h3 id="内存元数据"><a href="#内存元数据" class="headerlink" title="内存元数据"></a>内存元数据</h3><ul><li>Active NameNode : 最新的元数据（fsimage + edits）</li><li>Standby NameNode： 通过QJM （默认60s ）同步AN 的元数据</li></ul><h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><ul><li>内存元数据持久化后形成的文件</li><li>edits （编辑日志文件）<ul><li>保存了最近一个 Checkpoint 检查点之后的所有变更操作</li><li>变更操作应先写 edits ， 再写内存</li><li>edits 文件名通过 “Transaction Id 前后缀” 标记所包含更新操作的范围</li></ul></li><li>fsimage （元数据检查点镜像文件）<ul><li>Standby NameNode 在 CheckPoint 检查点定期对内存中的元数据进行持久化，生成 fsimage 镜像文件</li><li>fsimage 的写入速度较慢，所以不可能对变更操作进行实时持久化</li><li>fsimage 文件名标记处最后一个变更操作的 TransactionId ，一下图为例， 只要在内存冲载入 fsimage_*19，然后在内存中执行 edits_improgress_*20 就可以还原出最新的元数据<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202407518.png" alt="image-20240616202407518"></li></ul></li></ul><h3 id="edits-fsimage-重写"><a href="#edits-fsimage-重写" class="headerlink" title="edits &#x2F; fsimage 重写"></a>edits &#x2F; fsimage 重写</h3><h4 id="Hadoop-1-X-实现方式"><a href="#Hadoop-1-X-实现方式" class="headerlink" title="Hadoop 1.X 实现方式"></a>Hadoop 1.X 实现方式</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202545245.png" alt="image-20240616202545245"></p><h4 id="Hadoop-2-X-实现方式"><a href="#Hadoop-2-X-实现方式" class="headerlink" title="Hadoop 2.X 实现方式"></a>Hadoop 2.X 实现方式</h4><ul><li>QJM 共享存储系统<ul><li>基于 Paxos 算法实现的 JournalNode 集群， 实现了 edits 的高可用存储和共享访问</li><li>最好部署奇数（2*n+1）个节点 ， 也即最多容忍 n 个节点宕机</li><li>过半节点写入成功，即代表写入成功</li></ul></li><li>基于 QJM 的 edits 持久化<ul><li>AN 将变更操作同步写入本地和 QJM 的 edits</li><li>在内存中继续执行该操作，并将结果反馈给 Client</li></ul></li><li>基于 QJM 的 fsimage 持久化<ul><li>在 checkpoint 检查点，SN 先将内存元数据变为只读来暂停 QJM edits 的定期同步，再讲元数据镜像到 fsimage 中</li><li>SN 将 fsimage 上传到 AN ，同时回复 QJM 定期同步</li><li>AN 根据 fsimage 的事务Id ，删除旧 edits ，实现瘦身</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202739569.png" alt="image-20240616202739569"></p><h2 id="HDFS-读写流程"><a href="#HDFS-读写流程" class="headerlink" title="HDFS 读写流程"></a>HDFS 读写流程</h2><h3 id="HDFS-写流程"><a href="#HDFS-写流程" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><p><strong>注意点</strong></p><ul><li>block 拆分由 client 完成</li><li>Block 逐个发送</li><li>备份写入以 pipeline 形式实现，并递归返回写入结果</li><li>Block 全部写入后，Client 上报 AN ,  AN 生成元数据</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616203557631.png" alt="image-20240616203557631"></p><h3 id="HDFS-写流程-1"><a href="#HDFS-写流程-1" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><ul><li>Block 对应DataNode 副本列表， AN 会以 距离远近进行排序</li><li>Block 逐个读取</li><li>副本建联，按AN 返回列表顺序进行尝试</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616204521373.png" alt="image-20240616204521373"></p><h2 id="HDFS-安全模式"><a href="#HDFS-安全模式" class="headerlink" title="HDFS 安全模式"></a>HDFS 安全模式</h2><h3 id="什么是安全模式"><a href="#什么是安全模式" class="headerlink" title="什么是安全模式"></a>什么是安全模式</h3><ul><li>安全模式 是 HDFS 的一种特殊状态，</li><li>进入 ~ 后， HDFS 只接受 读数据请求，不接收 增删改 数据请求</li><li>安全模式是 HDFS 确保BLock 数据安全的一种保护机制</li><li>AN 启动时，HDFS 进入安全模式， DataNode 主动向 AN 汇报Block 列表信息，直至 DataNode 上报数量达到阈值， AN 离开安全模式</li></ul><h3 id="何时离开安全模式"><a href="#何时离开安全模式" class="headerlink" title="何时离开安全模式"></a>何时离开安全模式</h3><ul><li>BLock 上报率： DataNode 上报的可用 Block 数量 &#x2F; NameNode 元数据记录的 Block 数量</li><li>阈值： 上报率 &gt;&#x3D; 0.999 （默认， 可调）</li><li>不建议手动强制退出安全模式</li></ul><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><ul><li>DataNode —— 是否有 DataNode 不能正常启动，手动重启</li><li>NameNode 内存或磁盘不足？</li></ul><h1 id="HDFS-架构设计思考"><a href="#HDFS-架构设计思考" class="headerlink" title="HDFS 架构设计思考"></a>HDFS 架构设计思考</h1><h2 id="HDFS-优劣势"><a href="#HDFS-优劣势" class="headerlink" title="HDFS 优劣势"></a>HDFS 优劣势</h2><h3 id="DHFS-架构设计优势"><a href="#DHFS-架构设计优势" class="headerlink" title="DHFS 架构设计优势"></a>DHFS 架构设计优势</h3><ul><li>高容错性</li><li>一定的扩展性</li><li>可支持海量数据的可靠读写</li></ul><h3 id="HDFS-劣势"><a href="#HDFS-劣势" class="headerlink" title="HDFS 劣势"></a>HDFS 劣势</h3><ul><li><p>NameNode 内存受限问题</p><ul><li>通过 Federation 机制进一步扩展<ul><li>实际是基于 “路径” 的联邦， 属于 基本业务层扩展<ul><li>路径划分不合理，仍有可能导致 单路径下存储压力过大，以及不同路径下存储压力严重不均衡的问题</li></ul></li></ul></li></ul></li><li><p>NameNode 单点故障问题</p><ul><li>对 NameNode 做高可用</li></ul></li></ul><h2 id="HDFS-NA-高可用架构"><a href="#HDFS-NA-高可用架构" class="headerlink" title="HDFS NA 高可用架构"></a>HDFS NA 高可用架构</h2><ul><li>以下给出了 一种 高可用架构实现参考<ul><li>实际还需要考虑 DataNode 对于 NA 的变更感知</li><li>以及 edits 的一致性问题</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210305888.png" alt="image-20240616210305888"></p><h1 id="HDFS-API"><a href="#HDFS-API" class="headerlink" title="HDFS API"></a>HDFS API</h1><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210654411.png" alt="image-20240616210654411" style="zoom:70%;" align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210915156.png" alt="image-20240616210915156" style="zoom:75%;"  align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616211122508.png" alt="image-20240616211122508" style="zoom:80%;" align="left"/>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="部署HDFS"><a href="#部署HDFS" class="headerlink" title="部署HDFS"></a>部署HDFS</h1><p>HDFS的基本操作可以分为集群管理和文件系统操作两种类型：</p><ul><li>集群管理：包括Namenodede 的格式化、集群的启动和停止、集群信息查看等。</li><li>文件系统：包括对目录、文件和权限等内容的操作。</li></ul><p>HDFS中的命令主要在sbin和bin目录下[一般要进行环境变量的设置]：</p><ul><li>sbin:集群控制脚本(.sh)。</li><li>bin:hadoop的文件系统命令和其他管理维护工具。</li></ul><h2 id="hadoop安装和维护的方式"><a href="#hadoop安装和维护的方式" class="headerlink" title="hadoop安装和维护的方式"></a>hadoop安装和维护的方式</h2><p>主要有2种方式：</p><ul><li>一是从开源软件的官网网站直接下载软件包。</li><li>二是利用集成化软件对Hadoop集群进行部署和维护。[集成化工具：amabri、cloudera manager、华为的FusionInsight]</li></ul><p>第一种方式缺点：</p><ul><li>配置优化难度</li><li>组件整合难度</li></ul><h2 id="部署HDFS的核心步骤和部署原则"><a href="#部署HDFS的核心步骤和部署原则" class="headerlink" title="部署HDFS的核心步骤和部署原则"></a>部署HDFS的核心步骤和部署原则</h2><h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><ul><li><p>hadoop系统的规模</p></li><li><p>组件和角色规划</p><ul><li>A.确定需要安装哪些组件：比如要实现Namenode的高可用性，就需要额外安装ZK组件。</li><li>B.确定组件中的不同角色分别安装在哪些节点上：比如需要几个Datanode，分别安装在哪些服务器上，Namenode是安装在独立服务器上，还是和某个Datanode共享一台服务器。</li><li>C.根据角色规划确定所需的服务器性能需求：比如namenode所在服务器可以适当加大内存，以适应fsimage的可能大小，并且安装多块硬盘，将元数据信息保存在多个硬盘路径上，防止单个硬盘发生故障。</li><li>D.节点扩增：计算和存储能力不够时，很多时候就通过节点数量解决。</li></ul></li><li><p>配置规划：Datanode和Namenode一般都可以配置多个存储路径。</p><ul><li>A.Datanode实现多硬盘均匀存储。</li><li>B.Namenode可以实现多副本备份。</li></ul></li></ul><h3 id="linux环境准备"><a href="#linux环境准备" class="headerlink" title="linux环境准备"></a>linux环境准备</h3><p>HDFS作为hadoop的核心组件，随Hadoop一起整体部署。</p><p>安装hadoop前的环境准备：</p><ol><li>配置java环境变量：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</li><li>hadoop部署在多台服务器上，主从节点之间、各节点之间可以通过TCP&#x2F;IP协议相互访问[通过设置DNS或hosts文件，使得主机名和IP地址绑定，实现通过主机名就能访问对方]</li><li>确保hadoop所需端口打开：hadoop以及各类配套模板需要使用大量网络端口，但是自带的防火墙软件，设置不当造成功能无法正确运行。</li><li>SSH接口免密登录</li><li>Hadoop以及分布式NoSQL数据库要求各个节点之间的时间同步：最常见的集群时间同步方案是部署NTP服务。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//确保hadoop所需端口打开，通过命令禁用并停止防火墙服务</span><br><span class="line">systemctl mask filewalld</span><br><span class="line">systemctl stop fillwalld</span><br></pre></td></tr></table></figure><h3 id="Hadoop的软件包部署"><a href="#Hadoop的软件包部署" class="headerlink" title="Hadoop的软件包部署"></a>Hadoop的软件包部署</h3><ul><li>sbin目录：存放HDFS和Yarn组件的集群控制命令。</li><li>bin目录：存放HDFS的文件系统命令行工具以及Yarn等组件的命令行工具。</li><li>etc&#x2F;hadoop目录：存放hadoop的配置文件。</li><li>share目录：存放hadoop的各类库包(Jar)。</li></ul><p>PS:分布式的时候，hadoop软件包需要解压缩，并复制到所有节点上，并且在每个节点上的存储位置都是相同的，并给予足够的用户访问权限。其次，进行系统配置。</p><h1 id="HDFS的基本配置"><a href="#HDFS的基本配置" class="headerlink" title="HDFS的基本配置"></a>HDFS的基本配置</h1><p>HDFS的配置文件：大多数默认是XML和TXT格式存在。配置文件默认存放在&#x2F;etc&#x2F;hadoop目录下。</p><p>HDFS中6个重要的配置文件：</p><ol><li><strong>core-site.xml</strong>: Hadoop全局的配置文件，也包含一些HDFS的宏观配置。</li><li><strong>dfs-site.xml</strong>: HDFS配置文件。</li><li><strong>yarn-site.xml</strong>: YARN配置文件。</li><li><strong>mapred-sie.xml</strong>: MapReduce配置文件。</li><li><strong>slaves</strong>: 从节点列表。</li><li><strong>hadoop-env.sh</strong>: 与运行脚本的环境变量相关的配置文件。</li></ol><h2 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//core-site.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>       </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--指定namenode的地址--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">description</span>&gt;</span>node1节点为该集群的Namenode,对应节点的端口是8020<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--用来指定使用hadoop时产生文件的存放目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/data/hadoop/hadoop-2.6.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="dfs-site-xml"><a href="#dfs-site-xml" class="headerlink" title="dfs-site.xml"></a>dfs-site.xml</h2><p><strong>dfs-site.xml</strong> 是HDFS的重要配置文件，其Namenode节点和Datanode节点相关的配置项不同。</p><p><strong>Namenode</strong>主要有3个配置项: <code>dfs.namenode.name.dir</code>、<code>dfs.blocksize</code>、<code>dfs.replication</code>。</p><p><strong>Datanode</strong>主要有1个配置项：<code>dfs.datanode.data.dir</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Namenode主要有3个配置项dfs.namenode.name.dir、dfs.blocksize、dfs.replication。</span><br><span class="line">//Datanode主要有1个配置项</span><br><span class="line">dfs.datanode.data.dir   </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                 </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>namenode的目录位置，对应的目录需要存在value里面的路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode的目录位置，对应的目录需要存在value里面的路径，可以是一个或多个用逗号分隔的本地路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="tag">&lt;<span class="name">description</span>&gt;</span>hdfs系统的副本数量    </span><br><span class="line">         <span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>备份namenode的http地址，master是主机名<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 </span><br></pre></td></tr></table></figure><h2 id="slave-xml"><a href="#slave-xml" class="headerlink" title="slave.xml"></a>slave.xml</h2><p>slaves:在Namenode节点还需要建立一个名为slaves的文本文件，里面记录Datanode的子节点机名，用换行分割。</p><h2 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h2><p>JAVA_HOME进行环境变量配置：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</p><h2 id="配置机架感知策略"><a href="#配置机架感知策略" class="headerlink" title="配置机架感知策略"></a>配置机架感知策略</h2><p>需要实现机架感知的配置内容，在core-site.xml中实现两个配置项。</p><p>net.topology.node.switch.mapping.imp:org.apache.hadoop.net.TableMapping,表示采用映射文件的方式实现机架映射。</p><p>net.topology.table.file.name:内容为映射文件的路径和名称。</p><h1 id="集群的启动和停止"><a href="#集群的启动和停止" class="headerlink" title="集群的启动和停止"></a>集群的启动和停止</h1><p>软件包sbin目录下的start-dfs.sh和stop-dfs.sh为HDFS的集群启动和停止命令。</p><p>单独启动或停止一个HDFS进程，或者对单独的角色进行控制命令：hadoop-daemon.sh start | stop namenode |datanode|secondarynamenode</p><p>其次可以通过查看<a href="http://namenode:50070/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AF%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%9B%86%E7%BE%A4ID%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">http://namenode:50070/查看系统的状态，比如该系统的启动时间、版本、集群ID等信息。</a></p><h2 id="使用和管理HDFS"><a href="#使用和管理HDFS" class="headerlink" title="使用和管理HDFS"></a>使用和管理HDFS</h2><p>作为文件系统，HDFS的使用主要指对<strong>文件的上传、下载和移动，以及查看内容、建立或删除目录</strong>等。</p><p>查看HDFS状态，主要指查看节点的健康状态，查看存储容量，查看分块信息等。</p><p>控制HDFS，主要指对系统进行初始化，增加或删除子节点，以及提高HDFS的可用性等。</p><h2 id="管理和操作命令"><a href="#管理和操作命令" class="headerlink" title="管理和操作命令"></a>管理和操作命令</h2><p>hdfs的命令行操作用命令hdfs实现，即命令行敲入：hdfs.hdfs命令文件放在Hadoop目录下的bin子目录中，包含了HDFS绝大多数的用户命令，不带任何参数地执行hdfs，可以看到所有可用的指令。</p><ol><li>dfs:HDFS的文件系统操作指令。</li><li>dfsadmin:HDFS的集群管理命令，比如：查看机架感知状态，可以执行hdfs dfsadmin-printTopology。</li><li>fsck:HDFS的集群检查工具。</li><li>namenode-format:主节点格式化指令。</li><li>balaner:数据平衡指令。</li></ol><h2 id="格式化Namenode"><a href="#格式化Namenode" class="headerlink" title="格式化Namenode"></a>格式化Namenode</h2><p>hdfs namenode -format</p><h2 id="Namenode的安全模式"><a href="#Namenode的安全模式" class="headerlink" title="Namenode的安全模式"></a>Namenode的安全模式</h2><p>当namenode启动时，需要将fsimage等信息读入内存，并且等待各个Datanode上报存储状态，在这个过程完成之前，叫安全模式。（safenode）</p><p>此时namenode为只读状态，只能读取不能写入，当足够数量的节点以及数据块处在健康状态时，系统会自动退出安全模式。</p><p>手动对安全模式进行管理：hdfs dfsadmin -safemode [enter | leave |get |wait]</p><h2 id="元数据恢复"><a href="#元数据恢复" class="headerlink" title="元数据恢复"></a>元数据恢复</h2><p>由于secondary namenode在进行元数据合并时，保存了元数据的副本信息，当Namenode发生损坏时，可以利用secondary namenode中的数据进行恢复。</p><ol><li>利用stop-dfs.sh命令停止整个集群</li><li>清空namenode原有的元数据信息，路径可以从配置项dfs.namenode.name.dir中获得。</li><li>如果secondary namenode和namenode没有部署在同一个节点上，需要将secondary namenode存储的副本信息复制到namenode,其路径和secondary namenode中的元数据副本的路径一致，可以从配置项dfs.namenode.checkpoint.dir中获得。</li><li>执行hadoop namenode-importCheckpoint,系统将检查副本数据，并将其复制到dfs.namenode.name.dir所指示的路径当中。</li></ol><h2 id="子节点添加与删除"><a href="#子节点添加与删除" class="headerlink" title="子节点添加与删除"></a>子节点添加与删除</h2><p>大数据业务要求数据被不断采集、不断积累，需要分布式存储和NoSQL数据库等实现方便的横向扩展（scale out）。HDFS可以很方便的进行Datanode节点添加和删除。</p><h3 id="1-静态添加-删除Datanode的方法"><a href="#1-静态添加-删除Datanode的方法" class="headerlink" title="1.静态添加&#x2F;删除Datanode的方法"></a>1.静态添加&#x2F;删除Datanode的方法</h3><ul><li>利用stop-dfs.sh命令停止整个集群</li><li>在namenode节点上的slaves配置文件中添加新的节点，或删掉旧的节点。添加新节点时，要确保新节点和其他节点之间主机名和IP地址可以相互访问，可以实现SSH无密码访问等。</li><li>利用start-dfs.sh重新启动集群，在新节点配置正确的情况下，会随命令启动Datanode角色，并和Namenode连接。</li><li>可以执行hdfs balancer命令，在节点之间进行手动的数据平衡。删除节点之后，namenode会自动检查副本数量，并选择新的节点存储不足的副本。</li></ul><h3 id="2-动态添加Datanode的方法"><a href="#2-动态添加Datanode的方法" class="headerlink" title="2.动态添加Datanode的方法"></a>2.动态添加Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>在namenode节点上的slaves配置文件中添加新的节点。</li><li>在新节点执行hadoop-daemon.sh start datanode ,启动Datanode角色</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表，Namenode会根据新列表和子节点建立联系。</li></ul><h3 id="3-动态删除Datanode的方法"><a href="#3-动态删除Datanode的方法" class="headerlink" title="3.动态删除Datanode的方法"></a>3.动态删除Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>提前在hdfs-site.xml中配置dfs.hosts.exclude属性，内容为一个本地文本文件的路径，该文件可以称为exclude文件，其结构和slave文件的相同，即为每行一个节点主机名的列表。 记录在exclude文件中的主机，会在刷新之后被记作禁用状态，并在界面上看到这个状态。</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表。</li><li>在节点写入exclude文件，并执行hdfs dfsadmin -refreshNodes，刷新节点列表。</li></ul><p>添加&#x2F;删除Datanode完成之后，可以通过两种手段查看结果。</p><ul><li>在命令行执行hdfs dfsadmin -report 查看节点列表信息。</li><li>通过web界面，切换到Datanodes标签，可以查看子节点的列表，in operation表示正在使用的节点，decommissinoning，表示目前禁用的节点。</li></ul><h2 id="HDFS文件系统操作"><a href="#HDFS文件系统操作" class="headerlink" title="HDFS文件系统操作"></a>HDFS文件系统操作</h2><p>可以通过执行hdfs dfs指令来进行各类操作，包括建立、删除目录、HDFS上的文件复制、移动和改名、本地文件系统和HDFS系统之间的文件相互复制等、文件的权限操作等。</p><ul><li>hdfs dfs -ls &#x2F;  —-查看文件目录状态</li><li>hdfs dfs -lsr &#x2F; —-递归查看hdfs的根目录下的内容的</li><li>hdfs dfs -mkdir &#x2F;d1 —-在hdfs上创建文件夹d1</li><li>hdfs dfs -put <linux source > <hdfs destination> —-把数据从linux[本地文件]上传到hdfs的特定路径中[HDFS文件或路径]</li><li>hdfs dfs -get <hdfs source> <linux destination>—-把数据从hdfs下载到linux的特定路径下</li><li>hdfs dfs -mv&#x2F;-cp <hdfs source > <hdfs destination>—在HDFS系统中进行文件移动或复制，参数为HDFS的源地址和目的地址。</li><li>hdfs dfs -text &lt;hdfs文件&gt; —将序列号文件转换成文本显示出来。</li><li>hdfs dfs -rm &lt;hdfs文件&gt; —-删除文件或空目录</li><li>hdfs dfs -rmr &lt;hdfs文件&gt; —-递归删除文件或空目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//查看文件目录状态，-ls之后必须指明需要查看的目录</span><br><span class="line">hdfs dfs -ls /hdfsdir/file1</span><br><span class="line">hdfs dfs -ls hdfs://node1:8020/hdfsdir/file1</span><br><span class="line">//建立新目录</span><br><span class="line">hdfs dfs -mkdir /hdfsdir/dir1</span><br><span class="line">//从本地文件系统向HDFS复制文件。-put、-copyFromLocal。</span><br><span class="line">hdfs dfs -put localfile/hdfsdir/file1</span><br><span class="line">hdfs dfs -put -f localfile1 localfile2/hadoopdir</span><br><span class="line">//从HDFS向本地复制文件。-get、-copyToLocal。</span><br><span class="line">hdfs dfs -get /hdfsdir/hdfsfile localfile</span><br></pre></td></tr></table></figure><h2 id="以web方式查看文件系统"><a href="#以web方式查看文件系统" class="headerlink" title="以web方式查看文件系统"></a>以web方式查看文件系统</h2><p>访问<a href="http://namenode:50070/explorer.html,%E9%80%89%E6%8B%A9%22browse">http://namenode:50070/explorer.html,选择&quot;browse</a> the file system”选项，可以对HDFS的目录结构进行查看。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p><h1 id="YARN的由来"><a href="#YARN的由来" class="headerlink" title="YARN的由来"></a>YARN的由来</h1><p>在YARN出来之前，其实在Hadoop体系里面，负责资源管理和作业控制的是MRv1（Hadoop 1.0）体系中的JobTracker在承担，但是MRv1体系其实有其缺点，如下：</p><ul><li><p><strong>可靠性差 &#x2F; 单点故障</strong></p><ul><li>JobTracker 既做资源管理，又做任务调度，任务太重，易产生单点故障</li></ul></li><li><p><strong>资源利用率低</strong></p><ul><li>MRv1 资源描述模型过于简单，仅把 Task 数量作为资源分配依据，没有考虑任务本身的性能消耗差异</li><li>强制把资源分成 Map Task Slot 和 Reduce Task Slot，且不允许它们之 间共享，常常会导致一种槽位资源紧张而另外一种闲置(比如一个作业刚刚提交时， 只会运行 Map Task，此时 Reduce Slot 闲置)。</li></ul></li><li><p><strong>扩展性差</strong> ： 在MRv1中，JobTracker是个重量级组件，集中了资源管理分配、作业控制两大核心功能，随着集群规模的增大，JobTracker处理各种RPC请求负载过重，这也是系统的最大瓶颈，严重制约了Hadoop集群的扩展性。</p></li></ul><p>为了克服以上几个缺点，Apache 开始尝试对 Hadoop 进行升级改造，进而诞生了更加 先进的下一代 MapReduce 计算框架 MRv2。正是由于 <strong>MRv2 将资源管理功能抽象成了一个 独立的通用系统 YARN，直接导致下一代 MapReduce 的核心从单一的计算框架 MapReduce转移为通用的资源管理系统 YARN</strong>。</p><p>YARN将 JobTracker 中的资源管理和作业控制功能分 开， 分 别 由 组件ResourceManager 和 ApplicationMaster 实 现， 其 中，ResourceManager 负责所有应用程序的资源分配，而 ApplicationMaster 仅负责管理一个应用程序，基于 YARN，用户可以运行各种类型的应用程序(不再像 1.0 那样仅局限于 MapReduce 一类应用)，从离线计算的 MapReduce 到在线计算 (流式处理)的 Storm 等。</p><h1 id="YARN的基本设计思想"><a href="#YARN的基本设计思想" class="headerlink" title="YARN的基本设计思想"></a>YARN的基本设计思想</h1><p>在 Hadoop 1.0 中，<strong>JobTracker</strong> 由 <strong>资源管理</strong>(由 TaskScheduler 模块实现) 和 <strong>作业控制</strong>(由 JobTracker 中多个模块共同实现)两部分组成。当前 Hadoop MapReduce 之所以在可扩展性、资源利用率和多框架支持等方面存在不足，正是由于 Hadoop 对 JobTracker 赋予的功能过多而造成负载过重。此外，从设计角度上看，Hadoop 未能够将资源管理相关的功能与应用程序相关的功能分开，造成 Hadoop 难以支持多种计算框架。</p><p>下一代 MapReduce 框架的基本设计思想是将 JobTracker 的两个主要功能，即资源管理和作业控制(包括作业监控、容错等)，分拆成两独立的进程。资源管理进程与具体应用程序无关，它负责整个集群的资源(内存、CPU、磁盘等)管理，而作业控制进程则是直接与应用程序相关的模块，且每个作业控制进程只负责管理一个作业。这样， 通过将原有 JobTracker 中与应用程序相关和无关的模块分开，不仅减轻了 JobTracker 负载， 也使得 Hadoop 支持更多的计算框架。</p><h1 id="YARN-的基本架构"><a href="#YARN-的基本架构" class="headerlink" title="YARN 的基本架构"></a>YARN 的基本架构</h1><h2 id="基本架构图"><a href="#基本架构图" class="headerlink" title="基本架构图"></a>基本架构图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616213808951.png" alt="image-20240616213808951" style="zoom:85%;" /><p>Yarn 在整体上看还是采用了和Hadoop1.x一样的Master&#x2F;Slave结构（横向扩展混杂Slave&#x2F;Slave结构），在整个Yarn资源管理系统当中，ResourceManager作为Master，各个节点的NodeManager作为Slave。各个节点上NodeManager的资源由ResourceManager统计进行管理和调度。当应用程序提交后，会有一个单独的ApplicationMaster来对该应用程序进行跟踪和管理，同时该ApplicationMaster还会为该应用程序向ResourceManager申请资源，并要求NodeManager启动该应用程序占用一定资源的任务。由于不同的 ApplicationMaster 被分布到不同的节点上，因此它们之间不会相互影响。</p><h2 id="基本组件介绍"><a href="#基本组件介绍" class="headerlink" title="基本组件介绍"></a>基本组件介绍</h2><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>ResourceManager是Yarn的核心组件，主要由任务调度器（Resource Scheduler）和应用程序管理器（Applications Manager）组成。其主要功能是负责系统资源的管理和分配。</p><ul><li><h4 id="任务调度器-Resource-Scheduler"><a href="#任务调度器-Resource-Scheduler" class="headerlink" title="任务调度器(Resource Scheduler)"></a>任务调度器(Resource Scheduler)</h4></li></ul><p>调度器根据容量、队列等限制条件(如每个队列分配一定的资源，最多执行一定数量的作业等)，将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是 一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪 应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务， 这些均交由应用程序相关的 ApplicationMaster 完成。调度器仅根据各个应用程序的资源需 求进行资源分配，而资源分配单位用一个抽象概念“资源容器”(Resource Container，简 称 Container)表示，Container 是一个动态资源分配单位，它将内存、CPU、磁盘、网络等 资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件， 用户可根据自己的需要设计新的调度器，YARN 提供了多种直接可用的调度器，比如 Fair Scheduler 和 Capacity Scheduler 等。</p><ul><li><h4 id="应用程序管理器（Applications-Manager）"><a href="#应用程序管理器（Applications-Manager）" class="headerlink" title="应用程序管理器（Applications Manager）"></a>应用程序管理器（Applications Manager）</h4></li></ul><p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动 ApplicationMaster、监控 ApplicationMaster 运行状态并在失败时重新启动它等。</p><ul><li><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4></li></ul><p>ResourceManager中还包含了其他组件，如ResourceTrackerService用来直接处理心跳，NMLivelinessMonitor用来监控NodeManager，NodesListManager 提供NodeManager的黑白名单等等</p><h3 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h3><p>NM是每个子节点上的资源和任务管理器，一方面，它会定向通过心跳信息向RM汇报本节点上的资源使用情况和各个Container的运行情况；另一方面，它会接收并且处理来自AM的Container启动和停止的各种请求。它的能有点像Hadoop1.x中的TaskTracker。</p><ul><li><h4 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h4></li></ul><p>每当用户提交了一个应用程序就会为这个应用程序产生一个对应的ApplicationMaster，并且这个这个单独进程是在其中一个子节点上运行的。它的主要功能：为应用向ResourceManager申请资源、在job对Task实行调度、与NodeManager通信以启动或者停止任务、监控所有任务的运行情况，并且在任务失败的情下，重新为任务申请资源并且重启任务、负责推测任务的执行、当ApplicationMaster向ResourceManager注册后，ApplicationMaster可以提供客户端查询作业进度信息等。</p><ul><li><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4></li></ul><p>Container是Yarn中对系统资源的抽象，同时它也是系统资源分配的基本单位，它封装节点上多维度资源，其中包括CPU、内存、磁盘、网络等。Yarn会为每个任务分配一个Container，并且该任务只能够使用该Container中所描述的资源。值得关注的的是，Yarn中的Container和MRv1中的Slot是完全不同的，Container是一个动态的资源划分单位，它是根据实际提交的应用程序所需求的资源自动生成的，换句话说，Container其里边所描述的CPU、内存等资源是根据实际应用程序需求而变的。而Slot是一个静态的资源抽象单位，每一个同类型的Slot所描述的资源信息都是一样的。</p><h2 id="YARN-高可用"><a href="#YARN-高可用" class="headerlink" title="YARN 高可用"></a>YARN 高可用</h2><ul><li>引入 ZK</li><li>一个 Active RM， 多个 Standby RM</li><li>Active RM 宕机，Standby RM 通过 ZK 感知并竞选</li><li>也可手动切换</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221306795.png" alt="image-20240616221306795" style="zoom:80%;" /><h1 id="YARN-工作原理-流程"><a href="#YARN-工作原理-流程" class="headerlink" title="YARN 工作原理 &#x2F; 流程"></a>YARN 工作原理 &#x2F; 流程</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221044206.png" alt="image-20240616221044206"></p><ul><li>用户向Yarn提交应用程序，其中包括用户程序、相关文件、启动ApplicationMaster命令、ApplicationMaster程序等。</li><li>ResourceManager为该应用程序分配第一个Container，并且与Container所在的NodeManager通信，并且要求该NodeManager在这个Container中启动应用程序对应的ApplicationMaster。</li><li>ApplicationMaster首先会向ResourceManager注册，这样用户才可以直接通过ResourceManager查看到应用程序的运行状态，然后它将为该应用程序的各个任务申请资源，并监控它们的运行状态直到运行结束，即重复后面4~7步骤。</li><li>ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</li><li>一旦ApplicationMaster申请到资源后，便会与申请到的Container所对应的NodeManager进行通信，并且要求它在该Container中启动任务。</li><li>任务启动。NodeManager为要启动的任务配置好运行环境，包括环境变量、JAR包、二进制程序等，并且将启动命令写在一个脚本里，通过该脚本运行任务。</li><li>各个任务通过RPC协议向其对应的ApplicationMaster汇报自己的运行状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以再任务运行失败时重启任务。</li><li>应用程序运行完毕后，其对应的ApplicationMaster会向ResourceManager通信，要求注销和关闭自己。</li></ul><p><strong>【注】</strong>需要注意的是在整个工作流程当中，ResourceManager和NodeManager都是通过心跳保持联系的，NodeManager会通过心跳信息向ResourceManager汇报自己所在节点的资源使用情况。</p><h1 id="六、YARN通讯协议"><a href="#六、YARN通讯协议" class="headerlink" title="六、YARN通讯协议"></a>六、YARN通讯协议</h1><p>在 YARN 中，任何两个需相互通信的组件之间仅有一个 RPC 协 议，</p><p>而对于任何一个 RPC 协议，通信双方有一端是 Client，另一端为 Server，且 Client 总 是主动连接 Server 的</p><p>因此，YARN 实际上采用的是 拉式(pull-based)通信模型。</p><h2 id="RPC通信图"><a href="#RPC通信图" class="headerlink" title="RPC通信图"></a>RPC通信图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616214648502.png" alt="image-20240616214648502" style="zoom:67%;" /><p>上图中，箭头指向的组件是 RPC Server，而箭头尾部的组件是 RPC Client</p><h2 id="组件通讯协议描述"><a href="#组件通讯协议描述" class="headerlink" title="组件通讯协议描述"></a>组件通讯协议描述</h2><h3 id="ApplicationClientProtocol"><a href="#ApplicationClientProtocol" class="headerlink" title="ApplicationClientProtocol"></a>ApplicationClientProtocol</h3><p>JobClient(作业提交客户端)与 RM 之间的协议 ，JobClient 通过该 RPC 协议提交应用程序、查询应用程序状态等。</p><h3 id="ResourceManagerAdministrationProtocol"><a href="#ResourceManagerAdministrationProtocol" class="headerlink" title="ResourceManagerAdministrationProtocol"></a>ResourceManagerAdministrationProtocol</h3><p>Admin(管理员)与 RM 之间的通信协议，Admin 通过该 RPC 协议更新系统配置文件，比如节点黑白名单、用户队列权限等。</p><h3 id="ApplicationMasterProtocol"><a href="#ApplicationMasterProtocol" class="headerlink" title="ApplicationMasterProtocol"></a>ApplicationMasterProtocol</h3><p>AM 与 RM 之间的协议，AM 通过该 RPC 协议向 RM 注册和撤销自己，并为各个任务申请资源。</p><h3 id="ContainerManagementProtocol"><a href="#ContainerManagementProtocol" class="headerlink" title="ContainerManagementProtocol"></a>ContainerManagementProtocol</h3><p>AM 与 NM 之间的协议，AM 通过该 RPC 要求 NM 启动或者停止 Container，获取各个 Container 的使用状态等信息。</p><h3 id="ResourceTracker"><a href="#ResourceTracker" class="headerlink" title="ResourceTracker"></a>ResourceTracker</h3><p>NM 与 RM 之间的协议，NM 通过该 RPC 协议向 RM 注册，并 定时发送心跳信息汇报当前节点的资源使用情况和 Container 运行情况。</p><h1 id="YARN-资源调度策略"><a href="#YARN-资源调度策略" class="headerlink" title="YARN 资源调度策略"></a>YARN 资源调度策略</h1><p>目前，Hadoop 作业调度器主要有三种：FIFO、Capacity Scheduler 和 Fair Scheduler。Hadoop 版本 2.6.0-cdh5.14.2 默认的资源调度器是 Fair Scheduler。</p><h2 id="FIFO-Scheduler-（先进先出调度器）"><a href="#FIFO-Scheduler-（先进先出调度器）" class="headerlink" title="FIFO Scheduler （先进先出调度器）"></a>FIFO Scheduler （先进先出调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221647043.png" alt="image-20240616221647043" style="zoom:80%;" /><p>FIFO Scheduler 把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。</p><p>FIFO Scheduler 是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用 Capacity Scheduler 或 Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。</p><ul><li><p><strong>缺点</strong></p><ul><li><p>资源利用率低，无法交叉运行任务</p></li><li><p>灵活性差 —— 紧急任务无法插队</p></li></ul></li></ul><h2 id="Capacity-Scheduler-（容量调度器）"><a href="#Capacity-Scheduler-（容量调度器）" class="headerlink" title="Capacity Scheduler （容量调度器）"></a>Capacity Scheduler （容量调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221915860.png" alt="image-20240616221915860" style="zoom:80%;" /><ul><li><strong>核心思想</strong>： 提前做预算，在预算指导下分享集群资源</li><li><strong>调度策略</strong>：<ul><li>集群资源由多个队列共享</li><li>每个队列都要预设资源分配的比例</li><li>空闲资源优先分配给 “实际资源&#x2F;预算资源” 比例最低的队列</li><li>队列内采用 FIFO 策略</li></ul></li><li><strong>特点</strong>：<ul><li>层次化的队列设计 —— 子队列可使用父队列的资源</li><li>容量保证 —— 每个队列都要预设资源占比，防止资源独占</li><li>弹性分配 —— 空闲资源可以分配给任何队列，多个队列争用时，按比例进行平衡</li><li>支持动态管理 —— 可以动态调整队列的容量，权限等参数； 也可动态增加或暂停队列</li><li>访问控制 —— 用户只能向自己的队列中提交任务，不能访问其他队列</li><li>多租户 —— 多用户共享集群资源</li></ul></li></ul><h2 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616223048730.png" alt="image-20240616223048730" style="zoom:80%;" /><p>支持多队列，多用户，每个队列中的资源量可以配置，同一队列中的作业公平共享队列中所有资源。</p><p>比如有三个队列 queue1、Queue2、Queue3，每个队列中的 job 按照优先级分配资源，优先级越高分配的资源越多，但是每个 job 都会分配到资源以确保公平。在资源有限的情况下，每个 job 理想情况下获得的计算资源与实际获得的计算资源存在一种差距，这个差距就叫做差额。在同一个队列中，job 的资源缺额越大，越先获得资源优先执行。作业是按照缺额的高低来先后执行的。在 Fair调度器中，我们不需要预先占用一定的系统资源，Fair 调度器会为所有运行的 job动态的调整系统资源。</p><p>如下图所示，当第一个大 job 提交时，只有这一个 job 在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair 调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在学习<code>Hadoop</code>之前，先了解一下典型的大数据平台架构图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/238353d9269d48509d9616d14c017af1.png" alt="img"></p><p>可以看到Hadoop在大数据平台里处于一个技术核心的地位</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Hadoop定义"><a href="#Hadoop定义" class="headerlink" title="Hadoop定义"></a>Hadoop定义</h2><p>Hadoop 是一个开源的分布式计算框架，由 Apache Software Foundation 开发和维护。它主要用于处理和分析大数据。Hadoop 的核心设计理念是将计算任务分布到多个节点上，以实现高度可扩展性和容错性。</p><h2 id="Hadoop组成"><a href="#Hadoop组成" class="headerlink" title="Hadoop组成"></a>Hadoop组成</h2><p>Hadoop 大数据技术生态，具体包含组件如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dbcf67baa6664a94b32f226f19e5066a.png" alt="90e2e8544f5a44fa91d4f70d57b7c0a1.png"></p><ul><li><strong>Hadoop HDFS</strong>（核心）：Hadoop 分布式存储系统；</li><li><strong>Yarn</strong>（核心）：Hadoop 2.x版本开始才有的资源管理系统；</li><li><strong>MapReduce</strong>（核心）：并行处理框架；</li><li><strong>HBase</strong>：基于HDFS的列式存储数据库，它是一种 NoSQL 数据库，非常适用于存储海量的稀疏的数据集；</li><li><strong>Hive</strong>：Apache Hive是一个数据仓库基础工具，它适用于处理结构化数据。它提供了简单的 sql 查询功能，可以将sql语句转换为 MapReduce任务进行运行；</li><li><strong>Pig</strong>：它是一种高级脚本语言。利用它不需要开发Java代码就可以写出复杂的数据处理程序；</li><li><strong>Flume</strong>：它可以从不同数据源高效实时的收集海量日志数据；</li><li><strong>Sqoop</strong>：适用于在 Hadoop 和关系数据库之间抽取数据；</li><li><strong>Oozie</strong>：这是一种 Java Web 系统，用于Hadoop任务的调度，例如设置任务的执行时间和执行频率等；</li><li><strong>Zookeeper</strong>：用于管理配置信息，命名空间。提供分布式同步和组服务；</li><li><strong>Mahout</strong>：可扩展的机器学习算法库。</li></ul><p>其中：<strong>HDFS</strong>、<strong>MapReduce</strong>、<strong>YARN</strong> 是核心组件。</p><h2 id="Hadoop优势"><a href="#Hadoop优势" class="headerlink" title="Hadoop优势"></a>Hadoop优势</h2><p>Hadoop 是一个用于 分布式存储 和 处理大数据 的开源框架，它具有以下几个优势：</p><h4 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h4><p>Hadoop 可以在成百上千台机器之间分配和处理数据，具有很高的可伸缩性。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>Hadoop 在处理数据时具备自动故障恢复的能力。如果某一台机器出现问题，Hadoop 会自动将该节点上的数据复制到其他节点上，确保数据的可靠性和不中断性。</p><h4 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h4><p>与传统的大型关系数据库相比，Hadoop 成本更低，因为它运行在廉价的硬件上。</p><h4 id="处理多种类型的数据"><a href="#处理多种类型的数据" class="headerlink" title="处理多种类型的数据"></a>处理多种类型的数据</h4><p>Hadoop 可以处理不同类型的数据，包括 结构化数据 半结构化数据 （如JSON）和 非结构化 数据（例如文本、图片、视频和音频等。）</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
          <category> hadoop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 核心知识点总结</title>
      <link href="/2024/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><hr><h3 id="一、内存模型与结构"><a href="#一、内存模型与结构" class="headerlink" title="一、内存模型与结构"></a><strong>一、内存模型与结构</strong></h3><ol><li>详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？</li><li>堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？</li><li>什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？</li><li>元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？</li><li>字符串常量池在JDK 1.7及之后版本的位置变化及原因？</li><li>什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？</li><li>对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？</li><li>内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？</li></ol><hr><h3 id="二、垃圾回收（GC）"><a href="#二、垃圾回收（GC）" class="headerlink" title="二、垃圾回收（GC）"></a><strong>二、垃圾回收（GC）</strong></h3><ol><li>列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？</li><li>如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？</li><li>强引用、软引用、弱引用、虚引用的区别及使用场景？</li><li>CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？</li><li>G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？</li><li>ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？</li><li>什么情况下会触发Full GC？如何避免频繁Full GC？</li><li>Minor GC时出现“晋升失败”（Promotion Failed）的原因及解决方案？</li><li>什么是卡表（Card Table）？如何解决跨代引用问题？</li><li>动态年龄判定（-XX:MaxTenuringThreshold）和空间分配担保机制？</li></ol><hr><h3 id="三、类加载机制"><a href="#三、类加载机制" class="headerlink" title="三、类加载机制"></a><strong>三、类加载机制</strong></h3><ol><li>类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？</li><li>双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？</li><li>如何自定义类加载器？应用场景（热部署、模块化隔离）？</li><li>为什么说Java的类加载是“懒加载”（Lazy Loading）？</li><li>类初始化触发条件（new、反射、主类、子类初始化等）？</li><li>接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？</li></ol><hr><h3 id="四、JVM性能调优"><a href="#四、JVM性能调优" class="headerlink" title="四、JVM性能调优"></a><strong>四、JVM性能调优</strong></h3><ol><li>常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？</li><li>如何通过GC日志分析频繁GC或内存泄漏问题？</li><li>什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？</li><li>解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？</li><li>如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？</li><li>逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？</li><li>方法内联（Inlining）的条件及对性能的影响？</li></ol><hr><h3 id="五、JMM（Java内存模型）与并发"><a href="#五、JMM（Java内存模型）与并发" class="headerlink" title="五、JMM（Java内存模型）与并发"></a><strong>五、JMM（Java内存模型）与并发</strong></h3><ol><li>JMM如何定义主内存与工作内存的交互（8种原子操作）？</li><li>volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？</li><li>happens-before原则的具体规则及应用场景？</li><li>什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？</li><li>什么是伪共享（False Sharing）？如何通过@Contended或填充解决？</li><li>CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？</li></ol><hr><h3 id="六、监控与故障排查"><a href="#六、监控与故障排查" class="headerlink" title="六、监控与故障排查"></a><strong>六、监控与故障排查</strong></h3><ol><li>如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？</li><li>MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？</li><li>如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？</li><li>解释JVM的SafePoint（安全点）机制及其对GC的影响？</li><li>什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？</li><li>如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？</li></ol><hr><h3 id="七、高级与扩展"><a href="#七、高级与扩展" class="headerlink" title="七、高级与扩展"></a><strong>七、高级与扩展</strong></h3><ol><li>JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？</li><li>解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？</li><li>如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？</li><li>什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？</li><li>JVM对协程（Loom项目）的支持及与线程的对比？</li><li>容器化（Docker）环境下JVM内存参数设置的注意事项？</li></ol><hr><h3 id="八、实战场景"><a href="#八、实战场景" class="headerlink" title="八、实战场景"></a><strong>八、实战场景</strong></h3><ol><li>如果线上服务出现频繁Full GC，你会如何逐步排查？</li><li>如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？</li><li>高并发场景下，如何通过JVM参数优化减少GC停顿时间？</li><li>如何模拟并分析Metaspace的OOM问题？</li><li>在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？</li></ol><hr><h1 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h1><hr><h3 id="一、内存模型与结构-1"><a href="#一、内存模型与结构-1" class="headerlink" title="一、内存模型与结构"></a><strong>一、内存模型与结构</strong></h3><h4 id="1-详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？"><a href="#1-详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？" class="headerlink" title="1. 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？"></a>1. 详细描述JVM内存结构（堆、栈、方法区、本地方法栈、程序计数器的作用及线程隔离性）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>堆（Heap）</strong>：存储所有对象实例和数组，线程共享，是GC主战场，分新生代（Eden、Survivor区）和老年代。  </li><li><strong>虚拟机栈（JVM Stack）</strong>：线程私有，存储方法调用的栈帧（局部变量表、操作数栈、动态链接、方法出口），栈深度过大导致<code>StackOverflowError</code>，无法扩展时<code>OutOfMemoryError</code>。  </li><li><strong>方法区（Method Area）</strong>：JDK 8后称“元空间”，存储类信息、常量、静态变量等，线程共享，OOM触发条件为元空间不足。  </li><li><strong>本地方法栈（Native Method Stack）</strong>：为Native方法（如C&#x2F;C++代码）服务，可能抛出<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。  </li><li><strong>程序计数器（Program Counter Register）</strong>：记录当前线程执行指令的位置，唯一无OOM的区域，线程私有。</li></ul><hr><h4 id="2-堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？"><a href="#2-堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？" class="headerlink" title="2. 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？"></a>2. 堆内存分代机制的设计目的是什么？新生代和老年代的比例及动态调整机制？</h4><p><strong>答案</strong>：  </p><ul><li><strong>设计目的</strong>：根据对象存活时间差异优化GC效率。新生代（对象存活率低）使用复制算法快速回收，老年代（对象存活率高）使用标记-整理&#x2F;清除算法。  </li><li><strong>比例</strong>：默认 <code>-XX:NewRatio=2</code>（老年代:新生代&#x3D;2:1），新生代占堆1&#x2F;3。可通过 <code>-Xmn</code> 指定新生代固定大小（如 <code>-Xmn512m</code>），动态调整由JVM根据GC频率和对象晋升速率自适应优化。</li></ul><hr><h4 id="3-什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？"><a href="#3-什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？" class="headerlink" title="3. 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？"></a>3. 什么是直接内存（堆外内存）？使用场景及与堆内存的优劣对比？</h4><p><strong>答案</strong>：  </p><ul><li><strong>定义</strong>：通过<code>ByteBuffer.allocateDirect()</code>分配的本地内存，不受JVM堆限制，由操作系统管理。  </li><li><strong>使用场景</strong>：  <ul><li>NIO网络传输、大文件读写（避免堆内外拷贝）。  </li><li>高频临时数据缓存（如Netty的零拷贝）。</li></ul></li><li><strong>优点</strong>：  <ul><li>减少GC压力，提升I&#x2F;O性能。  </li><li>突破堆内存限制，支持更大数据量。</li></ul></li><li><strong>缺点</strong>：  <ul><li>需手动释放（依赖<code>Cleaner</code>机制，可能因未调用<code>DirectByteBuffer</code>的<code>clean()</code>方法导致内存泄漏）。  </li><li>分配速度慢于堆内存，过量使用可能触发Native OOM。</li></ul></li></ul><hr><h4 id="4-元空间（Metaspace）与永久代（PermGen）的区别？为什么Java-8要移除永久代？"><a href="#4-元空间（Metaspace）与永久代（PermGen）的区别？为什么Java-8要移除永久代？" class="headerlink" title="4. 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？"></a>4. 元空间（Metaspace）与永久代（PermGen）的区别？为什么Java 8要移除永久代？</h4><p><strong>答案</strong>：  </p><ul><li><strong>区别</strong>：  <table><thead><tr><th><strong>特性</strong></th><th><strong>永久代（PermGen）</strong></th><th><strong>元空间（Metaspace）</strong></th></tr></thead><tbody><tr><td><strong>存储位置</strong></td><td>JVM堆内</td><td>本地内存（Native Memory）</td></tr><tr><td><strong>大小限制</strong></td><td>固定（<code>-XX:MaxPermSize</code>）</td><td>动态扩展（默认无上限）</td></tr><tr><td><strong>GC机制</strong></td><td>Full GC时回收</td><td>由Metaspace的垃圾回收器管理</td></tr><tr><td><strong>OOM风险</strong></td><td>易因类加载过多触发OOM</td><td>内存不足时触发Native OOM</td></tr></tbody></table></li><li><strong>移除PermGen的原因</strong>：  <ul><li>简化JVM内存模型，避免字符串常量池和类元数据共存导致PermGen OOM。  </li><li>本地内存管理更灵活，支持动态扩展。</li></ul></li></ul><hr><h4 id="5-字符串常量池在JDK-1-7及之后版本的位置变化及原因？"><a href="#5-字符串常量池在JDK-1-7及之后版本的位置变化及原因？" class="headerlink" title="5. 字符串常量池在JDK 1.7及之后版本的位置变化及原因？"></a>5. 字符串常量池在JDK 1.7及之后版本的位置变化及原因？</h4><p><strong>答案</strong>：  </p><ul><li><strong>JDK 1.6及之前</strong>：位于PermGen中，易因字符串过多触发PermGen OOM。  </li><li><strong>JDK 1.7及之后</strong>：字符串常量池移至堆内存，原因：  <ul><li>堆的GC机制更灵活，减少OOM风险。  </li><li>字符串可被GC回收，避免内存泄漏。</li></ul></li></ul><hr><h4 id="6-什么是TLAB（Thread-Local-Allocation-Buffer）？如何避免多线程内存分配竞争？"><a href="#6-什么是TLAB（Thread-Local-Allocation-Buffer）？如何避免多线程内存分配竞争？" class="headerlink" title="6. 什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？"></a>6. 什么是TLAB（Thread Local Allocation Buffer）？如何避免多线程内存分配竞争？</h4><p><strong>答案</strong>：  </p><ul><li><strong>TLAB</strong>：为每个线程预先分配一小块Eden区内存（默认约Eden的1%），线程优先在TLAB中分配对象，避免全局锁竞争。  </li><li><strong>参数控制</strong>：  <ul><li><code>-XX:+UseTLAB</code>：启用TLAB（默认开启）。  </li><li><code>-XX:TLABSize</code>：指定TLAB初始大小。  </li><li><code>-XX:ResizeTLAB</code>：允许JVM动态调整TLAB大小。</li></ul></li></ul><hr><h4 id="7-对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？"><a href="#7-对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？" class="headerlink" title="7. 对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？"></a>7. 对象内存布局（对象头、实例数据、对齐填充）及如何计算对象大小？</h4><p><strong>答案</strong>：  </p><ul><li><strong>对象头（Header）</strong>：  <ul><li><strong>Mark Word</strong>：存储哈希码、锁状态、GC分代年龄等（64位系统占8字节）。  </li><li><strong>类指针（Class Pointer）</strong>：指向类元数据（开启压缩指针占4字节，否则8字节）。  </li><li><strong>数组长度</strong>（仅数组对象）：4字节。</li></ul></li><li><strong>实例数据（Instance Data）</strong>：对象的字段值，按类型对齐（如int占4字节）。  </li><li><strong>对齐填充（Padding）</strong>：保证对象大小为8字节的整数倍。  </li><li><strong>计算工具</strong>：  <ul><li><code>jol-core</code>库：<code>ClassLayout.parseClass(Class.class).toPrintable()</code>。  </li><li><code>Instrumentation.getObjectSize()</code>方法。</li></ul></li></ul><hr><h4 id="8-内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？"><a href="#8-内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？" class="headerlink" title="8. 内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？"></a>8. 内存溢出（OOM）的常见类型（堆、栈、方法区、直接内存）及触发场景？</h4><p><strong>答案</strong>：  </p><ul><li><strong>堆OOM（OutOfMemoryError: Java heap space）</strong>：  <ul><li>场景：对象过多（如缓存未清理）、内存泄漏（如静态集合持有对象）。  </li><li>解决：调大堆（<code>-Xmx</code>），分析内存泄漏（MAT工具）。</li></ul></li><li><strong>栈OOM（OutOfMemoryError: Unable to create new native thread &#x2F; StackOverflowError）</strong>：  <ul><li>场景：递归调用过深、线程数过多（<code>-Xss</code>调整栈大小）。</li></ul></li><li><strong>元空间OOM（OutOfMemoryError: Metaspace）</strong>：  <ul><li>场景：动态生成大量类（如CGLib代理）、未卸载类加载器。  </li><li>解决：调大元空间（<code>-XX:MaxMetaspaceSize</code>），检查类加载逻辑。</li></ul></li><li><strong>直接内存OOM（OutOfMemoryError: Direct buffer memory）</strong>：  <ul><li>场景：过量分配<code>DirectByteBuffer</code>未释放。  </li><li>解决：限制直接内存（<code>-XX:MaxDirectMemorySize</code>），显式调用<code>cleaner.clean()</code>。</li></ul></li></ul><hr><h3 id="二、垃圾回收（GC）-1"><a href="#二、垃圾回收（GC）-1" class="headerlink" title="二、垃圾回收（GC）"></a><strong>二、垃圾回收（GC）</strong></h3><h4 id="1-列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？"><a href="#1-列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？" class="headerlink" title="1. 列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？"></a>1. 列举常见的垃圾回收算法及其优缺点（标记-清除、标记-整理、复制算法）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>标记-清除（Mark-Sweep）</strong>：  <ul><li><strong>流程</strong>：标记存活对象→清除未标记对象。  </li><li><strong>优点</strong>：实现简单。  </li><li><strong>缺点</strong>：内存碎片化，大对象分配困难。</li></ul></li><li><strong>复制算法（Copying）</strong>：  <ul><li><strong>流程</strong>：将存活对象从Eden和From Survivor复制到To Survivor。  </li><li><strong>优点</strong>：无碎片，适合新生代（对象存活率低）。  </li><li><strong>缺点</strong>：内存利用率低（需预留Survivor区）。</li></ul></li><li><strong>标记-整理（Mark-Compact）</strong>：  <ul><li><strong>流程</strong>：标记存活对象→向一端移动→清理边界外内存。  </li><li><strong>优点</strong>：无碎片，适合老年代。  </li><li><strong>缺点</strong>：移动对象成本高，STW时间长。</li></ul></li></ul><hr><h4 id="2-如何判断对象是否可回收（引用计数法、可达性分析）？GC-Roots包括哪些对象？"><a href="#2-如何判断对象是否可回收（引用计数法、可达性分析）？GC-Roots包括哪些对象？" class="headerlink" title="2. 如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？"></a>2. 如何判断对象是否可回收（引用计数法、可达性分析）？GC Roots包括哪些对象？</h4><p><strong>答案</strong>：  </p><ul><li><strong>引用计数法</strong>：记录对象被引用次数，为0时回收。缺点：无法解决循环引用（如A→B→A）。  </li><li><strong>可达性分析</strong>：从GC Roots出发，不可达的对象判定为可回收（JVM实际采用）。  </li><li><strong>GC Roots对象</strong>：  <ul><li>虚拟机栈中局部变量引用的对象。  </li><li>方法区中类静态变量引用的对象。  </li><li>方法区中常量引用的对象（如字符串常量池）。  </li><li>本地方法栈中JNI引用的Native对象。  </li><li>活跃线程对象（如Thread）。</li></ul></li></ul><hr><h4 id="3-强引用、软引用、弱引用、虚引用的区别及使用场景？"><a href="#3-强引用、软引用、弱引用、虚引用的区别及使用场景？" class="headerlink" title="3. 强引用、软引用、弱引用、虚引用的区别及使用场景？"></a>3. 强引用、软引用、弱引用、虚引用的区别及使用场景？</h4><p><strong>答案</strong>：  </p><ul><li><strong>强引用（Strong Reference）</strong>：  <ul><li>定义：<code>Object obj = new Object()</code>。  </li><li>回收条件：永不回收（除非无强引用）。  </li><li>场景：普遍对象引用。</li></ul></li><li><strong>软引用（SoftReference）</strong>：  <ul><li>回收条件：内存不足时回收。  </li><li>场景：缓存（如图片缓存）。</li></ul></li><li><strong>弱引用（WeakReference）</strong>：  <ul><li>回收条件：GC时立即回收。  </li><li>场景：<code>WeakHashMap</code>（缓存键值对，键无强引用时自动删除）。</li></ul></li><li><strong>虚引用（PhantomReference）</strong>：  <ul><li>回收条件：无法通过虚引用访问对象，仅用于跟踪对象回收状态。  </li><li>场景：管理堆外内存（如<code>DirectByteBuffer</code>回收通知）。</li></ul></li></ul><hr><h4 id="4-CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？"><a href="#4-CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？" class="headerlink" title="4. CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？"></a>4. CMS收集器的工作流程（初始标记、并发标记、重新标记、并发清除）？如何解决“浮动垃圾”问题？</h4><p><strong>答案</strong>：  </p><ul><li><strong>工作流程</strong>：  <ol><li><strong>初始标记（Initial Mark，STW）</strong>：标记GC Roots直接关联的对象。  </li><li><strong>并发标记（Concurrent Mark）</strong>：遍历对象图，标记存活对象。  </li><li><strong>重新标记（Remark，STW）</strong>：修正并发标记期间变动的对象（使用增量更新或原始快照）。  </li><li><strong>并发清除（Concurrent Sweep）</strong>：清除未标记对象。</li></ol></li><li><strong>浮动垃圾（Floating Garbage）</strong>：  <ul><li>成因：并发标记阶段用户线程产生的新垃圾。  </li><li>解决：预留空间（通过<code>-XX:CMSInitiatingOccupancyFraction</code>设置触发CMS的阈值，默认92%）。</li></ul></li></ul><hr><h4 id="5-G1收集器的核心设计（Region分区、SATB、Mixed-GC）？与CMS的对比？"><a href="#5-G1收集器的核心设计（Region分区、SATB、Mixed-GC）？与CMS的对比？" class="headerlink" title="5. G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？"></a>5. G1收集器的核心设计（Region分区、SATB、Mixed GC）？与CMS的对比？</h4><p><strong>答案</strong>：  </p><ul><li><strong>核心设计</strong>：  <ul><li><strong>Region分区</strong>：将堆划分为多个等大小Region（1MB~32MB），可属于新生代或老年代。  </li><li><strong>SATB（Snapshot-At-The-Beginning）</strong>：标记开始时存活对象的快照，解决并发标记期间对象状态变化问题。  </li><li><strong>Mixed GC</strong>：同时回收新生代和部分老年代Region（根据回收价值排序）。</li></ul></li><li><strong>对比CMS</strong>：  <table><thead><tr><th><strong>特性</strong></th><th><strong>CMS</strong></th><th><strong>G1</strong></th></tr></thead><tbody><tr><td><strong>内存结构</strong></td><td>分代（连续内存）</td><td>Region分区（离散内存）</td></tr><tr><td><strong>碎片处理</strong></td><td>不整理（碎片问题）</td><td>整体整理（无碎片）</td></tr><tr><td><strong>停顿目标</strong></td><td>低延迟但不可控</td><td>可控停顿（<code>-XX:MaxGCPauseMillis</code>）</td></tr><tr><td><strong>适用场景</strong></td><td>中小堆（&lt;4GB）</td><td>大堆（&gt;4GB）</td></tr></tbody></table></li></ul><hr><h4 id="6-ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？"><a href="#6-ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？" class="headerlink" title="6. ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？"></a>6. ZGC和Shenandoah收集器的特点（颜色指针、读屏障、低延迟）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>ZGC</strong>：  <ul><li><strong>颜色指针（Colored Pointers）</strong>：利用指针元数据标记对象状态（可达、重定位等）。  </li><li><strong>读屏障（Load Barrier）</strong>：在访问对象时触发屏障，处理并发阶段的对象状态。  </li><li><strong>目标</strong>：亚毫秒级停顿（&lt;10ms），支持TB级堆内存。</li></ul></li><li><strong>Shenandoah</strong>：  <ul><li><strong>并发压缩</strong>：在用户线程运行时移动对象，减少STW时间。  </li><li><strong>Brooks指针</strong>：每个对象附加转发指针，处理并发访问。  </li><li><strong>目标</strong>：低停顿（&lt;10ms），适合大堆和实时系统。</li></ul></li></ul><hr><h4 id="7-什么情况下会触发Full-GC？如何避免频繁Full-GC？"><a href="#7-什么情况下会触发Full-GC？如何避免频繁Full-GC？" class="headerlink" title="7. 什么情况下会触发Full GC？如何避免频繁Full GC？"></a>7. 什么情况下会触发Full GC？如何避免频繁Full GC？</h4><p><strong>答案</strong>：  </p><ul><li><strong>触发条件</strong>：  <ol><li><strong>老年代空间不足</strong>：对象晋升失败或大对象直接分配老年代失败。  </li><li><strong>元空间不足</strong>：加载过多类或未卸载类加载器。  </li><li><strong>显式调用</strong>：<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>。  </li><li><strong>空间分配担保失败</strong>：Minor GC前检查老年代剩余空间是否足够（需开启<code>-XX:-HandlePromotionFailure</code>）。  </li><li><strong>CMS并发模式失败</strong>：CMS回收速度跟不上对象分配速度。</li></ol></li><li><strong>避免方法</strong>：  <ul><li>调大堆内存（<code>-Xmx</code>）和元空间（<code>-XX:MaxMetaspaceSize</code>）。  </li><li>优化对象生命周期（减少大对象、缓存失效策略）。  </li><li>选择低延迟收集器（G1、ZGC）。  </li><li>关闭显式GC（<code>-XX:+DisableExplicitGC</code>）。</li></ul></li></ul><p>以下是剩余部分的完整答案：</p><hr><h3 id="三、类加载机制-1"><a href="#三、类加载机制-1" class="headerlink" title="三、类加载机制"></a><strong>三、类加载机制</strong></h3><h4 id="1-类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？"><a href="#1-类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？" class="headerlink" title="1. 类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？"></a>1. 类加载过程（加载、验证、准备、解析、初始化）各阶段的任务？</h4><p><strong>答案</strong>：  </p><ul><li><strong>加载（Loading）</strong>：  <ul><li>通过类全限定名获取二进制字节流。  </li><li>将字节流转换为方法区的运行时数据结构。  </li><li>在堆中生成<code>Class</code>对象作为访问入口。</li></ul></li><li><strong>验证（Verification）</strong>：  <ul><li>检查字节码是否符合JVM规范（文件格式、元数据、字节码、符号引用验证）。</li></ul></li><li><strong>准备（Preparation）</strong>：  <ul><li>为类变量（static变量）分配内存并设置初始值（零值，如<code>0</code>、<code>null</code>）。  </li><li>常量（final static）直接赋实际值。</li></ul></li><li><strong>解析（Resolution）</strong>：  <ul><li>将符号引用（类、方法、字段名）转换为直接引用（内存地址）。</li></ul></li><li><strong>初始化（Initialization）</strong>：  <ul><li>执行类构造器<code>&lt;clinit&gt;()</code>（静态变量赋值和静态代码块）。</li></ul></li></ul><hr><h4 id="2-双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？"><a href="#2-双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？" class="headerlink" title="2. 双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？"></a>2. 双亲委派模型的实现原理及如何打破双亲委派（如JDBC、Tomcat类加载器设计）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>原理</strong>：  <ul><li>类加载请求先委派父加载器处理，只有父加载器无法加载时，子加载器才尝试加载。  </li><li>层级结构：<strong>Bootstrap → Extension → Application → 自定义加载器</strong>。</li></ul></li><li><strong>打破双亲委派</strong>：  <ul><li><strong>场景1</strong>：JDBC通过<code>ServiceLoader</code>（SPI机制）使用线程上下文类加载器（<code>Thread.currentThread().getContextClassLoader()</code>）。  </li><li><strong>场景2</strong>：Tomcat为每个Web应用配置独立的<code>WebAppClassLoader</code>，优先加载自身类，避免应用间类冲突。</li></ul></li></ul><hr><h4 id="3-如何自定义类加载器？应用场景（热部署、模块化隔离）？"><a href="#3-如何自定义类加载器？应用场景（热部署、模块化隔离）？" class="headerlink" title="3. 如何自定义类加载器？应用场景（热部署、模块化隔离）？"></a>3. 如何自定义类加载器？应用场景（热部署、模块化隔离）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>实现步骤</strong>：  <ol><li>继承<code>ClassLoader</code>类。  </li><li>重写<code>findClass()</code>方法（从自定义路径读取字节码，调用<code>defineClass()</code>生成Class对象）。</li></ol></li><li><strong>应用场景</strong>：  <ul><li>热部署：动态加载修改后的类（如Spring DevTools）。  </li><li>模块化隔离：不同模块使用独立类加载器（如OSGi、Tomcat多应用隔离）。</li></ul></li></ul><hr><h4 id="4-为什么说Java的类加载是“懒加载”（Lazy-Loading）？"><a href="#4-为什么说Java的类加载是“懒加载”（Lazy-Loading）？" class="headerlink" title="4. 为什么说Java的类加载是“懒加载”（Lazy Loading）？"></a>4. 为什么说Java的类加载是“懒加载”（Lazy Loading）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>定义</strong>：类在首次使用时（如<code>new</code>、调用静态方法）才被加载，而非JVM启动时加载所有类。  </li><li><strong>优点</strong>：减少启动时间和内存占用。</li></ul><hr><h4 id="5-类初始化触发条件（new、反射、主类、子类初始化等）？"><a href="#5-类初始化触发条件（new、反射、主类、子类初始化等）？" class="headerlink" title="5. 类初始化触发条件（new、反射、主类、子类初始化等）？"></a>5. 类初始化触发条件（new、反射、主类、子类初始化等）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>触发条件</strong>：  <ol><li><code>new</code>实例化对象。  </li><li>访问或修改类的静态变量（final常量除外）。  </li><li>调用类的静态方法。  </li><li>反射调用（<code>Class.forName()</code>）。  </li><li>初始化子类时，父类需先初始化。  </li><li>JVM启动时的主类（包含<code>main()</code>方法的类）。</li></ol></li></ul><hr><h4 id="6-接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？"><a href="#6-接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？" class="headerlink" title="6. 接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？"></a>6. 接口和类的加载顺序区别？静态代码块和构造代码块的执行顺序？</h4><p><strong>答案</strong>：  </p><ul><li><strong>接口加载</strong>：  <ul><li>接口初始化时，不要求父接口全部初始化（除非使用父接口的常量）。</li></ul></li><li><strong>类加载顺序</strong>：  <ol><li>父类静态代码 → 子类静态代码 → 父类构造代码 → 父类构造器 → 子类构造代码 → 子类构造器。</li></ol></li><li><strong>执行顺序</strong>：  <ul><li><strong>静态代码块</strong>：类初始化时执行一次。  </li><li><strong>构造代码块</strong>：每次实例化对象时执行（在构造器之前）。</li></ul></li></ul><hr><h3 id="四、JVM性能调优-1"><a href="#四、JVM性能调优-1" class="headerlink" title="四、JVM性能调优"></a><strong>四、JVM性能调优</strong></h3><h4 id="1-常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？"><a href="#1-常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？" class="headerlink" title="1. 常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？"></a>1. 常见的JVM调优参数（堆大小、年轻代比例、SurvivorRatio、GC日志等）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>堆内存</strong>：  <ul><li><code>-Xms</code>：初始堆大小（如<code>-Xms512m</code>）。  </li><li><code>-Xmx</code>：最大堆大小（通常设与<code>-Xms</code>相同，避免动态扩容）。</li></ul></li><li><strong>新生代</strong>：  <ul><li><code>-Xmn</code>：新生代大小（如<code>-Xmn256m</code>）。  </li><li><code>-XX:NewRatio</code>：老年代与新生代比例（默认2）。  </li><li><code>-XX:SurvivorRatio</code>：Eden与Survivor区的比例（默认8，即Eden:Survivor&#x3D;8:1:1）。</li></ul></li><li><strong>GC日志</strong>：  <ul><li><code>-Xloggc:/path/gc.log</code>：输出GC日志。  </li><li><code>-XX:+PrintGCDetails</code>：打印GC详细信息。  </li><li><code>-XX:+UseGCLogFileRotation</code>：启用日志轮转。</li></ul></li></ul><hr><h4 id="2-如何通过GC日志分析频繁GC或内存泄漏问题？"><a href="#2-如何通过GC日志分析频繁GC或内存泄漏问题？" class="headerlink" title="2. 如何通过GC日志分析频繁GC或内存泄漏问题？"></a>2. 如何通过GC日志分析频繁GC或内存泄漏问题？</h4><p><strong>答案</strong>：  </p><ul><li><strong>分析步骤</strong>：  <ol><li>观察Full GC频率：频繁Full GC可能内存泄漏。  </li><li>查看堆内存占用：老年代使用率持续上升且不下降。  </li><li>检查对象晋升：Minor GC后对象频繁晋升到老年代。</li></ol></li><li><strong>工具</strong>：  <ul><li><strong>GCEasy</strong>：在线GC日志分析工具。  </li><li><strong>MAT</strong>：分析堆转储文件，定位大对象或GC Roots路径。</li></ul></li></ul><hr><h4 id="3-什么情况下需要调整新生代与老年代的比例（-XX-NewRatio）？"><a href="#3-什么情况下需要调整新生代与老年代的比例（-XX-NewRatio）？" class="headerlink" title="3. 什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？"></a>3. 什么情况下需要调整新生代与老年代的比例（-XX:NewRatio）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>场景</strong>：  <ol><li>短期对象过多：增大新生代（减少对象晋升）。  </li><li>长期存活对象过多：增大老年代（减少Full GC频率）。</li></ol></li></ul><hr><h4 id="4-解释-XX-UseCompressedOops和-XX-UseCompressedClassPointers的作用？"><a href="#4-解释-XX-UseCompressedOops和-XX-UseCompressedClassPointers的作用？" class="headerlink" title="4. 解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？"></a>4. 解释-XX:+UseCompressedOops和-XX:+UseCompressedClassPointers的作用？</h4><p><strong>答案</strong>：  </p><ul><li><strong>UseCompressedOops</strong>：启用压缩普通对象指针（32位表示，堆内存&lt;32GB时默认开启）。  </li><li><strong>UseCompressedClassPointers</strong>：启用压缩类指针（依赖UseCompressedOops）。  </li><li><strong>效果</strong>：减少内存占用（64位JVM中对象引用从8字节压缩为4字节）。</li></ul><hr><h4 id="5-如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？"><a href="#5-如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？" class="headerlink" title="5. 如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？"></a>5. 如何设置合理的堆大小避免频繁GC？如何根据系统负载估算内存需求？</h4><p><strong>答案</strong>：  </p><ul><li><strong>设置原则</strong>：  <ul><li>初始堆（<code>-Xms</code>）与最大堆（<code>-Xmx</code>）相同，避免动态调整。  </li><li>根据系统物理内存的1&#x2F;4<del>1&#x2F;2分配堆（如64GB内存，堆设16GB</del>32GB）。</li></ul></li><li><strong>估算方法</strong>：  <ol><li>监控运行峰值：使用<code>jstat -gcutil</code>观察老年代使用率。  </li><li>预留30%缓冲：避免堆满触发Full GC。</li></ol></li></ul><hr><h4 id="6-逃逸分析的作用及如何通过-XX-DoEscapeAnalysis优化代码？"><a href="#6-逃逸分析的作用及如何通过-XX-DoEscapeAnalysis优化代码？" class="headerlink" title="6. 逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？"></a>6. 逃逸分析的作用及如何通过-XX:+DoEscapeAnalysis优化代码？</h4><p><strong>答案</strong>：  </p><ul><li><strong>逃逸分析</strong>：判断对象是否在方法外部被引用（未逃逸的对象可优化）。  </li><li><strong>优化手段</strong>：  <ul><li><strong>栈上分配</strong>：未逃逸对象直接在栈上分配（随栈帧销毁回收）。  </li><li><strong>标量替换</strong>：将对象拆分为基本类型（如<code>Point</code>的x、y字段直接分配）。  </li><li><strong>锁消除</strong>：对线程私有对象移除同步锁。</li></ul></li><li><strong>参数</strong>：<code>-XX:+DoEscapeAnalysis</code>（默认开启）。</li></ul><hr><h4 id="7-方法内联（Inlining）的条件及对性能的影响？"><a href="#7-方法内联（Inlining）的条件及对性能的影响？" class="headerlink" title="7. 方法内联（Inlining）的条件及对性能的影响？"></a>7. 方法内联（Inlining）的条件及对性能的影响？</h4><p><strong>答案</strong>：  </p><ul><li><strong>条件</strong>：  <ul><li>方法体小（如getter&#x2F;setter）。  </li><li>频繁调用（热点方法）。  </li><li>无虚方法（未被重写）。</li></ul></li><li><strong>影响</strong>：  <ul><li>减少方法调用开销，提升执行速度。  </li><li>可能增加代码体积（需权衡）。</li></ul></li></ul><hr><h3 id="五、JMM（Java内存模型）与并发-1"><a href="#五、JMM（Java内存模型）与并发-1" class="headerlink" title="五、JMM（Java内存模型）与并发"></a><strong>五、JMM（Java内存模型）与并发</strong></h3><h4 id="1-JMM如何定义主内存与工作内存的交互（8种原子操作）？"><a href="#1-JMM如何定义主内存与工作内存的交互（8种原子操作）？" class="headerlink" title="1. JMM如何定义主内存与工作内存的交互（8种原子操作）？"></a>1. JMM如何定义主内存与工作内存的交互（8种原子操作）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>8种操作</strong>：  <ul><li><code>lock</code>（锁定主内存变量） → <code>read</code>（读取） → <code>load</code>（载入工作内存） →  </li><li><code>use</code>（使用） → <code>assign</code>（赋值） → <code>store</code>（存储） → <code>write</code>（写入主内存） → <code>unlock</code>（解锁）。</li></ul></li></ul><hr><h4 id="2-volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？"><a href="#2-volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？" class="headerlink" title="2. volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？"></a>2. volatile关键字的内存语义（可见性、禁止指令重排序）？与synchronized的区别？</h4><p><strong>答案</strong>：  </p><ul><li><strong>语义</strong>：  <ul><li><strong>可见性</strong>：写操作立即刷新到主内存，读操作从主内存读取。  </li><li><strong>禁止重排序</strong>：通过内存屏障实现。</li></ul></li><li><strong>与synchronized区别</strong>：  <ul><li><code>volatile</code>仅保证可见性和有序性，不保证原子性。  </li><li><code>synchronized</code>保证原子性、可见性和有序性。</li></ul></li></ul><hr><h4 id="3-happens-before原则的具体规则及应用场景？"><a href="#3-happens-before原则的具体规则及应用场景？" class="headerlink" title="3. happens-before原则的具体规则及应用场景？"></a>3. happens-before原则的具体规则及应用场景？</h4><p><strong>答案</strong>：  </p><ul><li><strong>规则</strong>：  <ol><li>程序顺序规则：同一线程内顺序执行。  </li><li>锁规则：解锁操作先于后续加锁。  </li><li><code>volatile</code>规则：写操作先于后续读操作。  </li><li>传递性：A先于B，B先于C → A先于C。</li></ol></li><li><strong>应用</strong>：多线程环境下保证操作顺序性（如单例模式的双重检查锁）。</li></ul><hr><h4 id="4-什么是内存屏障（Memory-Barrier）？JVM如何实现volatile的语义？"><a href="#4-什么是内存屏障（Memory-Barrier）？JVM如何实现volatile的语义？" class="headerlink" title="4. 什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？"></a>4. 什么是内存屏障（Memory Barrier）？JVM如何实现volatile的语义？</h4><p><strong>答案</strong>：  </p><ul><li><strong>内存屏障</strong>：CPU指令，禁止指令重排序，强制刷新缓存。  </li><li><strong>volatile实现</strong>：  <ul><li>写操作后插入<code>StoreStore</code>屏障和<code>StoreLoad</code>屏障。  </li><li>读操作前插入<code>LoadLoad</code>屏障和<code>LoadStore</code>屏障。</li></ul></li></ul><hr><h4 id="5-什么是伪共享（False-Sharing）？如何通过-Contended或填充解决？"><a href="#5-什么是伪共享（False-Sharing）？如何通过-Contended或填充解决？" class="headerlink" title="5. 什么是伪共享（False Sharing）？如何通过@Contended或填充解决？"></a>5. 什么是伪共享（False Sharing）？如何通过@Contended或填充解决？</h4><p><strong>答案</strong>：  </p><ul><li><strong>伪共享</strong>：不同线程修改同一缓存行中的不同变量，导致缓存行无效，性能下降。  </li><li><strong>解决</strong>：  <ul><li><strong>填充</strong>：在变量间添加无用字段（如<code>long p1, p2, p3;</code>）。  </li><li><strong>@Contended</strong>：JVM自动填充（需<code>-XX:-RestrictContended</code>）。</li></ul></li></ul><hr><h4 id="6-CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？"><a href="#6-CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？" class="headerlink" title="6. CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？"></a>6. CAS操作的底层实现（Unsafe类、CPU指令）？ABA问题及解决方案？</h4><p><strong>答案</strong>：  </p><ul><li><strong>实现</strong>：  <ul><li><code>Unsafe</code>类的<code>compareAndSwapInt()</code>方法。  </li><li>底层调用CPU的<code>cmpxchg</code>指令。</li></ul></li><li><strong>ABA问题</strong>：变量值从A→B→A，CAS误认为未变化。  </li><li><strong>解决</strong>：使用版本号（如<code>AtomicStampedReference</code>）。</li></ul><hr><h3 id="六、监控与故障排查-1"><a href="#六、监控与故障排查-1" class="headerlink" title="六、监控与故障排查"></a><strong>六、监控与故障排查</strong></h3><h4 id="1-如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？"><a href="#1-如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？" class="headerlink" title="1. 如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？"></a>1. 如何通过jstat、jmap、jstack排查内存泄漏或线程死锁？</h4><p><strong>答案</strong>：  </p><ul><li><strong>jstat</strong>：  <ul><li><code>jstat -gcutil &lt;pid&gt;</code>：查看各分区内存使用率和GC次数。</li></ul></li><li><strong>jmap</strong>：  <ul><li><code>jmap -heap &lt;pid&gt;</code>：查看堆配置。  </li><li><code>jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</code>：生成堆转储文件。</li></ul></li><li><strong>jstack</strong>：  <ul><li><code>jstack &lt;pid&gt;</code>：抓取线程快照，分析死锁（查找<code>BLOCKED</code>状态和锁持有链）。</li></ul></li></ul><hr><h4 id="2-MAT（Memory-Analyzer-Tool）分析堆转储文件的常用技巧？"><a href="#2-MAT（Memory-Analyzer-Tool）分析堆转储文件的常用技巧？" class="headerlink" title="2. MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？"></a>2. MAT（Memory Analyzer Tool）分析堆转储文件的常用技巧？</h4><p><strong>答案</strong>：  </p><ul><li><strong>步骤</strong>：  <ol><li>查找大对象：<code>Dominator Tree</code>视图。  </li><li>分析GC Roots：<code>Path to GC Roots</code>排除弱&#x2F;软引用。  </li><li>检查重复类：<code>Duplicate Classes</code>视图（类加载器泄漏）。</li></ol></li></ul><hr><h4 id="3-如何快速定位CPU飙高或线程阻塞问题（结合top-Hp、jstack）？"><a href="#3-如何快速定位CPU飙高或线程阻塞问题（结合top-Hp、jstack）？" class="headerlink" title="3. 如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？"></a>3. 如何快速定位CPU飙高或线程阻塞问题（结合top -Hp、jstack）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>步骤</strong>：  <ol><li><code>top -Hp &lt;pid&gt;</code>：找到高CPU占用的线程ID（十进制）。  </li><li>将线程ID转为十六进制（如<code>printf &quot;%x\n&quot; 12345</code> → <code>3039</code>）。  </li><li><code>jstack &lt;pid&gt;</code>：查找对应线程的堆栈信息（如<code>nid=0x3039</code>）。</li></ol></li></ul><hr><h4 id="4-解释JVM的SafePoint（安全点）机制及其对GC的影响？"><a href="#4-解释JVM的SafePoint（安全点）机制及其对GC的影响？" class="headerlink" title="4. 解释JVM的SafePoint（安全点）机制及其对GC的影响？"></a>4. 解释JVM的SafePoint（安全点）机制及其对GC的影响？</h4><p><strong>答案</strong>：  </p><ul><li><strong>安全点</strong>：线程执行到特定位置（如方法调用、循环跳转）时可暂停，用于GC、代码优化等。  </li><li><strong>影响</strong>：  <ul><li>所有线程需到达安全点才能执行STW操作（如GC）。  </li><li>长时间未进入安全点的线程可能导致GC停顿时间延长。</li></ul></li></ul><hr><h4 id="5-什么是OOM-Killer？Linux系统下如何避免JVM进程被误杀？"><a href="#5-什么是OOM-Killer？Linux系统下如何避免JVM进程被误杀？" class="headerlink" title="5. 什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？"></a>5. 什么是OOM Killer？Linux系统下如何避免JVM进程被误杀？</h4><p><strong>答案</strong>：  </p><ul><li><strong>OOM Killer</strong>：Linux内核在系统内存不足时强制终止进程。  </li><li><strong>避免方法</strong>：  <ol><li>限制JVM堆大小（<code>-Xmx</code>），留出系统内存。  </li><li>调整进程OOM优先级（<code>-XX:+UseLargePages</code>或<code>echo -17 &gt; /proc/&lt;pid&gt;/oom_adj</code>）。</li></ol></li></ul><hr><h4 id="6-如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？"><a href="#6-如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？" class="headerlink" title="6. 如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？"></a>6. 如何通过Arthas在线诊断JVM问题（动态修改日志级别、监控方法执行）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>常用命令</strong>：  <ul><li><code>watch com.example.Service methodName &quot;&#123;params, returnObj&#125;&quot;</code>：监控方法入参和返回值。  </li><li><code>trace *.ClassName methodName</code>：统计方法调用耗时。  </li><li><code>logger --name ROOT --level debug</code>：动态调整日志级别。</li></ul></li></ul><hr><h3 id="七、高级与扩展-1"><a href="#七、高级与扩展-1" class="headerlink" title="七、高级与扩展"></a><strong>七、高级与扩展</strong></h3><h4 id="1-JIT编译器的工作机制（解释执行-vs-编译执行）？分层编译（C1-C2）？"><a href="#1-JIT编译器的工作机制（解释执行-vs-编译执行）？分层编译（C1-C2）？" class="headerlink" title="1. JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？"></a>1. JIT编译器的工作机制（解释执行 vs. 编译执行）？分层编译（C1&#x2F;C2）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>解释执行</strong>：逐行解释字节码，启动快但执行慢。  </li><li><strong>编译执行</strong>：将热点代码编译为本地机器码（JIT）。  </li><li><strong>分层编译</strong>：  <ul><li><strong>C1（Client Compiler）</strong>：快速编译，优化较少（如方法内联）。  </li><li><strong>C2（Server Compiler）</strong>：深度优化，耗时较长（如逃逸分析）。</li></ul></li></ul><hr><h4 id="2-解释JVM的逃逸分析及栈上分配（Stack-Allocation）优化？"><a href="#2-解释JVM的逃逸分析及栈上分配（Stack-Allocation）优化？" class="headerlink" title="2. 解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？"></a>2. 解释JVM的逃逸分析及栈上分配（Stack Allocation）优化？</h4><p><strong>答案</strong>：  </p><ul><li><strong>逃逸分析</strong>：判断对象是否在方法外部被引用。  </li><li><strong>栈上分配</strong>：未逃逸的对象直接在栈上分配，随栈帧销毁自动回收，减少GC压力。</li></ul><hr><h4 id="3-如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？"><a href="#3-如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？" class="headerlink" title="3. 如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？"></a>3. 如何实现方法区的垃圾回收（如废弃常量、无用的类卸载条件）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>回收条件</strong>：  <ol><li>类的所有实例已被回收。  </li><li>类对应的<code>Class</code>对象无引用。  </li><li>类加载器已被回收（如Tomcat热部署时卸载旧类加载器）。</li></ol></li></ul><hr><h4 id="4-什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？"><a href="#4-什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？" class="headerlink" title="4. 什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？"></a>4. 什么是偏向锁、轻量级锁、重量级锁？锁升级的过程？</h4><p><strong>答案</strong>：  </p><ul><li><strong>偏向锁</strong>：标记线程ID，无竞争时直接访问。  </li><li><strong>轻量级锁</strong>：CAS竞争，失败后膨胀为重量级锁。  </li><li><strong>重量级锁</strong>：基于操作系统互斥量（Mutex），线程阻塞。  </li><li><strong>升级过程</strong>：无锁 → 偏向锁 → 轻量级锁 → 重量级锁。</li></ul><hr><h4 id="5-JVM对协程（Loom项目）的支持及与线程的对比？"><a href="#5-JVM对协程（Loom项目）的支持及与线程的对比？" class="headerlink" title="5. JVM对协程（Loom项目）的支持及与线程的对比？"></a>5. JVM对协程（Loom项目）的支持及与线程的对比？</h4><p><strong>答案</strong>：  </p><ul><li><strong>协程（虚拟线程）</strong>：  <ul><li>轻量级（由JVM调度，非操作系统线程），支持百万级并发。  </li><li>适用I&#x2F;O密集型任务（如网络请求）。</li></ul></li><li><strong>对比线程</strong>：  <ul><li>线程：上下文切换成本高，受操作系统限制。  </li><li>协程：切换由JVM管理，资源消耗低。</li></ul></li></ul><hr><h4 id="6-容器化（Docker）环境下JVM内存参数设置的注意事项？"><a href="#6-容器化（Docker）环境下JVM内存参数设置的注意事项？" class="headerlink" title="6. 容器化（Docker）环境下JVM内存参数设置的注意事项？"></a>6. 容器化（Docker）环境下JVM内存参数设置的注意事项？</h4><p><strong>答案</strong>：  </p><ul><li><strong>问题</strong>：JVM默认读取物理机内存，而非容器限制。  </li><li><strong>解决</strong>：  <ul><li>使用<code>-XX:+UseContainerSupport</code>（JDK 8u191+默认开启）。  </li><li>显式设置堆大小（<code>-Xmx</code>不超过容器内存的50%~70%）。</li></ul></li></ul><hr><h3 id="八、实战场景-1"><a href="#八、实战场景-1" class="headerlink" title="八、实战场景"></a><strong>八、实战场景</strong></h3><h4 id="1-如果线上服务出现频繁Full-GC，你会如何逐步排查？"><a href="#1-如果线上服务出现频繁Full-GC，你会如何逐步排查？" class="headerlink" title="1. 如果线上服务出现频繁Full GC，你会如何逐步排查？"></a>1. 如果线上服务出现频繁Full GC，你会如何逐步排查？</h4><p><strong>答案</strong>：  </p><ol><li><strong>查看GC日志</strong>：确认Full GC触发原因（老年代不足、元空间不足等）。  </li><li><strong>分析堆转储</strong>：使用MAT找出大对象或内存泄漏。  </li><li><strong>检查代码</strong>：排查静态集合、未关闭资源、大对象分配。  </li><li><strong>调整参数</strong>：增加堆大小、优化新生代比例、切换收集器（如G1）。</li></ol><hr><h4 id="2-如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？"><a href="#2-如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？" class="headerlink" title="2. 如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？"></a>2. 如何设计一个避免内存泄漏的缓存系统（如WeakHashMap、LRU策略）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>方案</strong>：  <ol><li><strong>软引用缓存</strong>：<code>SoftReference</code>在内存不足时自动回收。  </li><li><strong>LRU策略</strong>：<code>LinkedHashMap</code>重写<code>removeEldestEntry()</code>。  </li><li><strong>WeakHashMap</strong>：键为弱引用，自动清理无引用键值对。</li></ol></li></ul><hr><h4 id="3-高并发场景下，如何通过JVM参数优化减少GC停顿时间？"><a href="#3-高并发场景下，如何通过JVM参数优化减少GC停顿时间？" class="headerlink" title="3. 高并发场景下，如何通过JVM参数优化减少GC停顿时间？"></a>3. 高并发场景下，如何通过JVM参数优化减少GC停顿时间？</h4><p><strong>答案</strong>：  </p><ul><li><strong>参数调整</strong>：  <ul><li>使用低延迟收集器（G1、ZGC）。  </li><li>增大堆内存和元空间。  </li><li>设置<code>-XX:MaxGCPauseMillis</code>（G1目标停顿时间）。</li></ul></li></ul><hr><h4 id="4-如何模拟并分析Metaspace的OOM问题？"><a href="#4-如何模拟并分析Metaspace的OOM问题？" class="headerlink" title="4. 如何模拟并分析Metaspace的OOM问题？"></a>4. 如何模拟并分析Metaspace的OOM问题？</h4><p><strong>答案</strong>：  </p><ul><li><strong>模拟方法</strong>：  <ol><li>动态生成大量类（如CGLib代理）。  </li><li>限制元空间：<code>-XX:MaxMetaspaceSize=50m</code>。</li></ol></li><li><strong>分析</strong>：通过<code>jstat -gcmetacapacity</code>监控元空间使用率。</li></ul><hr><h4 id="5-在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？"><a href="#5-在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？" class="headerlink" title="5. 在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？"></a>5. 在多线程环境下，如何通过JMM保证线程安全（结合volatile、final、synchronized）？</h4><p><strong>答案</strong>：  </p><ul><li><strong>volatile</strong>：保证可见性（如状态标志位）。  </li><li><strong>final</strong>：不可变对象（如初始化后字段不可修改）。  </li><li><strong>synchronized</strong>：原子性操作（如计数器递增）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 调优总结</title>
      <link href="/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1、调优原则"><a href="#1、调优原则" class="headerlink" title="1、调优原则"></a>1、调优原则</h1><p>JVM调优听起来很高大上，但是要认识到，<strong>JVM 调优应该是 Java 性能优化的最后一颗子弹</strong>。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20210410233715.png" alt="Java项目需要调优吗"></p><p>JVM的自动内存管理本来就是为了将开发人员从内存管理的泥潭里拉出来。</p><p>即使不得不进行JVM调优，也绝对不能拍脑门就去调整参数，一定要全面监控，详细分析性能数据。</p><h1 id="2、JVM调优的时机"><a href="#2、JVM调优的时机" class="headerlink" title="2、JVM调优的时机"></a>2、JVM调优的时机</h1><ul><li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li><li>Full GC 次数频繁；</li><li>GC 停顿时间过长（超过1秒）；</li><li>应用出现OutOfMemory 等内存异常；</li><li>应用中有使用本地缓存且占用大量内存空间；</li><li>系统吞吐量与响应性能不高或下降。</li></ul><h1 id="3、JVM调优的目标"><a href="#3、JVM调优的目标" class="headerlink" title="3、JVM调优的目标"></a>3、JVM调优的目标</h1><p><strong>吞吐量</strong>、<strong>延迟</strong>、**内存占用 ** 三者类似CAP，构成了一个不可能三角，只能选择其中两个进行调优，不可三者兼得。</p><ul><li>延迟：GC低停顿和GC低频率；</li><li>低内存占用；</li><li>高吞吐量;</li></ul><p>选择了其中两个，必然会会以牺牲另一个为代价。</p><p>下面展示了一些JVM调优的量化目标参考实例：</p><ul><li>Heap 内存使用率 &lt;&#x3D; 70%;</li><li>Old generation内存使用率&lt;&#x3D; 70%;</li><li>avgpause &lt;&#x3D; 1秒;</li><li>Full gc 次数0 或 avg pause interval &gt;&#x3D; 24小时 ;</li></ul><p>注意：不同应用的JVM调优量化目标是不一样的。</p><h1 id="4、JVM调优的步骤"><a href="#4、JVM调优的步骤" class="headerlink" title="4、JVM调优的步骤"></a>4、JVM调优的步骤</h1><p>一般情况下，JVM调优可通过以下步骤进行：</p><ul><li>分析系统系统运行情况：分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li><li>确定 JVM 调优量化目标；</li><li>确定 JVM 调优参数（根据历史JVM参数来调整）；</li><li>依次确定调优内存、延迟、吞吐量等指标；</li><li>对比观察调优前后的差异；</li><li>不断的分析和调整，直到找到合适的 JVM 参数配置；</li><li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li></ul><p>以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。</p><p>![JVM调优步骤](<a href="https://gitee.com/sanfene/picgo/raw/master/JVM%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF-%E7%AC%AC">https://gitee.com/sanfene/picgo/raw/master/JVM进阶之路-第</a> 2 页.png)</p><h1 id="5、JVM参数"><a href="#5、JVM参数" class="headerlink" title="5、JVM参数"></a>5、JVM参数</h1><p>下面来看一下JDK的JVM参数。</p><h2 id="5-1、基本参数"><a href="#5-1、基本参数" class="headerlink" title="5.1、基本参数"></a>5.1、基本参数</h2><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-Xms</td><td>初始堆大小</td><td>内存的1&#x2F;64</td><td>默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.</td></tr><tr><td>-Xmx</td><td>最大堆大小</td><td>内存的1&#x2F;4</td><td>默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制</td></tr><tr><td>-Xmn</td><td>年轻代大小</td><td></td><td><strong>注意</strong>：此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。 整个堆大小&#x3D;年轻代大小 + 年老代大小 + 持久代大小. 增大年轻代后,将会减小年老代大小.此值对系统性能影响较大,Sun官方推荐配置为整个堆的3&#x2F;8</td></tr><tr><td>-Xss</td><td>每个线程的堆栈大小</td><td></td><td>JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右 一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。（校长） 和threadstacksize选项解释很类似,官方文档似乎没有解释,在论坛中有这样一句话:”” -Xss is translated in a VM flag named ThreadStackSize” 一般设置这个值就可以了。</td></tr><tr><td>-XX:NewRatio</td><td>年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代)</td><td></td><td>-XX:NewRatio&#x3D;4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1&#x2F;5 Xms&#x3D;Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden区与Survivor区的大小比值</td><td></td><td>设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1&#x2F;10</td></tr><tr><td>-XX:NewSize</td><td>设置年轻代大小</td><td></td><td></td></tr><tr><td>-XX:MaxNewSize</td><td>年轻代最大值</td><td></td><td></td></tr><tr><td>-<em>XX:ThreadStackSize</em></td><td>Thread Stack Size</td><td></td><td>(0 means use default stack size) [Sparc: 512; Solaris x86: 320 (was 256 prior in 5.0 and earlier); Sparc 64 bit: 1024; Linux amd64: 1024 (was 0 in 5.0 and earlier); all others 0.]</td></tr><tr><td>-XX:LargePageSizeInBytes</td><td>内存页的大小不可设置过大， 会影响Perm的大小</td><td></td><td>&#x3D;128m</td></tr><tr><td>-XX:+UseFastAccessorMethods</td><td>原始类型的快速优化</td><td></td><td></td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>垃圾最大年龄</td><td></td><td>如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率 该参数只有在串行GC时才有效.</td></tr><tr><td>-XX:+AggressiveOpts</td><td>加快编译</td><td></td><td></td></tr><tr><td>-XX:+UseBiasedLocking</td><td>锁机制的性能改善</td><td></td><td></td></tr><tr><td>-Xnoclassgc</td><td>禁用垃圾回收</td><td></td><td></td></tr><tr><td>-XX:SoftRefLRUPolicyMSPerMB</td><td>每兆堆空闲空间中SoftReference的存活时间</td><td>1s</td><td>softly reachable objects will remain alive for some amount of time after the last time they were referenced. The default value is one second of lifetime per free megabyte in the heap</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>对象超过多大是直接在旧生代分配</td><td>0</td><td>单位字节 新生代采用Parallel Scavenge GC时无效 另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.</td></tr><tr><td>-XX:TLABWasteTargetPercent</td><td>TLAB占eden区的百分比</td><td>1%</td><td></td></tr><tr><td>-XX:+<em>CollectGen0First</em></td><td>FullGC时是否先YGC</td><td>false</td><td></td></tr></tbody></table><p><strong>Jdk8版本的重要特有参数</strong></p><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-XX:MetaspaceSize</td><td>元空间大小</td><td></td><td>Jdk8版本</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>最大元空间</td><td></td><td>Jdk8版本</td></tr></tbody></table><h2 id="5-2、并行收集器相关参数"><a href="#5-2、并行收集器相关参数" class="headerlink" title="5.2、并行收集器相关参数"></a>5.2、并行收集器相关参数</h2><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-XX:+UseParallelGC</td><td>Full GC采用parallel MSC (此项待验证)</td><td></td><td>选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)</td></tr><tr><td>-XX:+UseParNewGC</td><td>设置年轻代为并行收集</td><td></td><td>可与CMS收集同时使用 JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值</td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td></td><td>此值最好配置与处理器数目相等 同样适用于CMS</td></tr><tr><td>-XX:+UseParallelOldGC</td><td>年老代垃圾收集方式为并行收集(Parallel Compacting)</td><td></td><td>这个是JAVA 6出现的参数选项</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>每次年轻代垃圾回收的最长时间(最大暂停时间)</td><td></td><td>如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>自动选择年轻代区大小和相应的Survivor区比例</td><td></td><td>设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.</td></tr><tr><td>-XX:GCTimeRatio</td><td>设置垃圾回收时间占程序运行时间的百分比</td><td></td><td>公式为1&#x2F;(1+n)</td></tr><tr><td>-XX:+<em>ScavengeBeforeFullGC</em></td><td>Full GC前调用YGC</td><td>true</td><td>Do young generation GC prior to a full GC. (Introduced in 1.4.1.)</td></tr></tbody></table><h2 id="5-3、CMS相关参数"><a href="#5-3、CMS相关参数" class="headerlink" title="5.3、CMS相关参数"></a>5.3、CMS相关参数</h2><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-XX:+UseConcMarkSweepGC</td><td>使用CMS内存收集</td><td></td><td>测试中配置这个以后,-XX:NewRatio&#x3D;4的配置失效了,原因不明.所以,此时年轻代大小最好用-Xmn设置.???</td></tr><tr><td>-XX:+AggressiveHeap</td><td></td><td></td><td>试图是使用大量的物理内存 长时间大内存使用的优化，能检查计算资源（内存， 处理器数量） 至少需要256MB内存 大量的CPU／内存， （在1.4.1在4CPU的机器上已经显示有提升）</td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction</td><td>多少次后进行内存压缩</td><td></td><td>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理.</td></tr><tr><td>-XX:+CMSParallelRemarkEnabled</td><td>降低标记停顿</td><td></td><td></td></tr><tr><td>-XX+UseCMSCompactAtFullCollection</td><td>在FULL GC的时候， 对年老代的压缩</td><td></td><td>CMS是不会移动内存的， 因此， 这个非常容易产生碎片， 导致内存不够用， 因此， 内存的压缩这个时候就会被启用。 增加这个参数是个好习惯。 可能会影响性能,但是可以消除碎片</td></tr><tr><td>-XX:+UseCMSInitiatingOccupancyOnly</td><td>使用手动定义初始化定义开始CMS收集</td><td></td><td>禁止hostspot自行触发CMS GC</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction&#x3D;70</td><td>使用cms作为垃圾回收 使用70％后开始CMS收集</td><td>92</td><td>为了保证不出现promotion failed(见下面介绍)错误,该值的设置需要满足以下公式<strong>CMSInitiatingOccupancyFraction计算公式</strong></td></tr><tr><td>-XX:CMSInitiatingPermOccupancyFraction</td><td>设置Perm Gen使用到达多少比率时触发</td><td>92</td><td></td></tr><tr><td>-XX:+CMSIncrementalMode</td><td>设置为增量模式</td><td></td><td>用于单CPU情况</td></tr><tr><td>-XX:+CMSClassUnloadingEnabled</td><td></td><td></td><td></td></tr></tbody></table><h2 id="5-4、辅助信息"><a href="#5-4、辅助信息" class="headerlink" title="5.4、辅助信息"></a>5.4、辅助信息</h2><table><thead><tr><th><strong>参数名称</strong></th><th><strong>含义</strong></th><th><strong>默认值</strong></th><th></th></tr></thead><tbody><tr><td>-XX:+PrintGC</td><td></td><td></td><td>输出形式: [GC 118250K-&gt;113543K(130112K), 0.0094143 secs] [Full GC 121376K-&gt;10414K(130112K), 0.0650971 secs]</td></tr><tr><td>-XX:+PrintGCDetails</td><td></td><td></td><td>输出形式:[GC [DefNew: 8614K-&gt;781K(9088K), 0.0123035 secs] 118250K-&gt;113543K(130112K), 0.0124633 secs] [GC [DefNew: 8614K-&gt;8614K(9088K), 0.0000665 secs][Tenured: 112761K-&gt;10414K(121024K), 0.0433488 secs] 121376K-&gt;10414K(130112K), 0.0436268 secs]</td></tr><tr><td>-XX:+PrintGCTimeStamps</td><td></td><td></td><td></td></tr><tr><td>-XX:+PrintGC:PrintGCTimeStamps</td><td></td><td></td><td>可与-XX:+PrintGC -XX:+PrintGCDetails混合使用 输出形式:11.851: [GC 98328K-&gt;93620K(130112K), 0.0082960 secs]</td></tr><tr><td>-XX:+PrintGCApplicationStoppedTime</td><td>打印垃圾回收期间程序暂停的时间.可与上面混合使用</td><td></td><td>输出形式:Total time for which application threads were stopped: 0.0468229 seconds</td></tr><tr><td>-XX:+PrintGCApplicationConcurrentTime</td><td>打印每次垃圾回收前,程序未中断的执行时间.可与上面混合使用</td><td></td><td>输出形式:Application time: 0.5291524 seconds</td></tr><tr><td>-XX:+PrintHeapAtGC</td><td>打印GC前后的详细堆栈信息</td><td></td><td></td></tr><tr><td>-Xloggc:filename</td><td>把相关日志信息记录到文件以便分析. 与上面几个配合使用</td><td></td><td></td></tr><tr><td>-XX:+PrintClassHistogram</td><td>garbage collects before printing the histogram.</td><td></td><td></td></tr><tr><td>-XX:+PrintTLAB</td><td>查看TLAB空间的使用情况</td><td></td><td></td></tr><tr><td>XX:+PrintTenuringDistribution</td><td>查看每次minor GC后新的存活周期的阈值</td><td></td><td>Desired survivor size 1048576 bytes, new threshold 7 (max 15) new threshold 7即标识新的存活周期的阈值为7。</td></tr></tbody></table><h1 id="6、主要工具"><a href="#6、主要工具" class="headerlink" title="6、主要工具"></a>6、主要工具</h1><h2 id="6-1、JDK工具"><a href="#6-1、JDK工具" class="headerlink" title="6.1、JDK工具"></a>6.1、JDK工具</h2><p>JDK自带了很多性能监控工具，我们可以用这些工具来监测系统和排查内存性能问题。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/856154-20201010094123520-1650593645.png" alt="JDK自带工具"></p><h2 id="6-2、Linux-命令行工具"><a href="#6-2、Linux-命令行工具" class="headerlink" title="6.2、Linux 命令行工具"></a>6.2、Linux 命令行工具</h2><p>进行性能监控和问题排查的时候，常常是结合操作系统本身的命令行工具来进行。</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>top</td><td>实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息</td></tr><tr><td>vmstat</td><td>对操作系统的虚拟内存、进程、CPU活动进行监控</td></tr><tr><td>pidstat</td><td>监控指定进程的上下文切换</td></tr><tr><td>iostat</td><td>监控磁盘IO</td></tr></tbody></table><p>其它还有一些第三方的监控工具，同样是性能分析和故障排查的利器，如<strong>MAT</strong>、<strong>GChisto</strong>、<strong>JProfiler</strong>、<strong>arthas</strong>。</p><h1 id="7、常用调优策略"><a href="#7、常用调优策略" class="headerlink" title="7、常用调优策略"></a>7、常用调优策略</h1><p>这里还是要提一下，及时确定要进行JVM调优，也不要陷入“知见障”，进行分析之后，发现可以通过优化程序提升性能，仍然首选优化程序。</p><h2 id="7-1、选择合适的垃圾回收器"><a href="#7-1、选择合适的垃圾回收器" class="headerlink" title="7.1、选择合适的垃圾回收器"></a>7.1、选择合适的垃圾回收器</h2><p>CPU单核，那么毫无疑问Serial 垃圾收集器是你唯一的选择。</p><p>CPU多核，关注吞吐量 ，那么选择PS+PO组合。</p><p>CPU多核，关注用户停顿时间，JDK版本1.6或者1.7，那么选择CMS。</p><p>CPU多核，关注用户停顿时间，JDK1.8及以上，JVM可用内存6G以上，那么选择G1。</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Serial垃圾收集器（新生代）</span></span><br><span class="line">开启：-XX:+UseSerialGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置PS+PO,新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</span></span><br><span class="line">开启 -XX:+UseParallelOldGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//CMS垃圾收集器（老年代）</span></span><br><span class="line">开启 -XX:+UseConcMarkSweepGC</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置G1垃圾收集器</span></span><br><span class="line">开启 -XX:+UseG1GC</span><br></pre></td></tr></table></figure><h2 id="7-2、调整内存大小"><a href="#7-2、调整内存大小" class="headerlink" title="7.2、调整内存大小"></a>7.2、调整内存大小</h2><p>现象：垃圾收集频率非常频繁。</p><p>原因：如果内存太小，就会导致频繁的需要进行垃圾收集才能释放出足够的空间来创建新的对象，所以增加堆内存大小的效果是非常显而易见的。</p><p>注意：如果垃圾收集次数非常频繁，但是每次能回收的对象非常少，那么这个时候并非内存太小，而可能是内存泄露导致对象无法回收，从而造成频繁GC。</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置堆初始值</span></span><br><span class="line">指令<span class="number">1</span>：-Xms2g</span><br><span class="line">指令<span class="number">2</span>：-XX:InitialHeapSize=2048m</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置堆区最大值</span></span><br><span class="line">指令<span class="number">1</span>：`-Xmx2g` </span><br><span class="line">指令<span class="number">2</span>： -XX:MaxHeapSize=2048m</span><br><span class="line"></span><br><span class="line"><span class="comment">//新生代内存配置</span></span><br><span class="line">指令<span class="number">1</span>：-Xmn512m</span><br><span class="line">指令<span class="number">2</span>：-XX:MaxNewSize=512m</span><br></pre></td></tr></table></figure><h2 id="7-3、设置符合预期的停顿时间"><a href="#7-3、设置符合预期的停顿时间" class="headerlink" title="7.3、设置符合预期的停顿时间"></a>7.3、设置符合预期的停顿时间</h2><p>现象：程序间接性的卡顿</p><p>原因：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，那么垃圾收集时间就会不稳定。</p><p>注意：不要设置不切实际的停顿时间，单次时间越短也意味着需要更多的GC次数才能回收完原有数量的垃圾.</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GC停顿时间，垃圾收集器会尝试用各种手段达到这个时间</span></span><br><span class="line">-XX:MaxGCPauseMillis </span><br></pre></td></tr></table></figure><h2 id="7-4、调整内存区域大小比率"><a href="#7-4、调整内存区域大小比率" class="headerlink" title="7.4、调整内存区域大小比率"></a>7.4、调整内存区域大小比率</h2><p>现象：某一个区域的GC频繁，其他都正常。</p><p>原因：如果对应区域空间不足，导致需要频繁GC来释放空间，在JVM堆内存无法增加的情况下，可以调整对应区域的大小比率。</p><p>注意：也许并非空间不足，而是因为内存泄造成内存无法回收。从而导致GC频繁。</p><p>参数配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//survivor区和Eden区大小比率</span></span><br><span class="line">指令：-XX:SurvivorRatio=<span class="number">6</span>  <span class="comment">//S区和Eden区占新生代比率为1:6,两个S区2:6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//新生代和老年代的占比</span></span><br><span class="line">-XX:NewRatio=<span class="number">4</span>  <span class="comment">//表示新生代:老年代 = 1:4 即老年代占整个堆的4/5；默认值=2</span></span><br></pre></td></tr></table></figure><h2 id="7-5、调整对象升老年代的年龄"><a href="#7-5、调整对象升老年代的年龄" class="headerlink" title="7.5、调整对象升老年代的年龄"></a>7.5、调整对象升老年代的年龄</h2><p>现象：老年代频繁GC，每次回收的对象很多。</p><p>原因：如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时候可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁GC问题。</p><p>注意：增加了年龄之后，这些对象在新生代的时间会变长可能导致新生代的GC频率增加，并且频繁复制这些对象新生的GC时间也可能变长。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入老年代最小的GC年龄,年轻代对象转换为老年代对象最小年龄值，默认值7</span></span><br><span class="line"> -XX:InitialTenuringThreshol=<span class="number">7</span> </span><br></pre></td></tr></table></figure><h2 id="7-6、调整大对象的标准"><a href="#7-6、调整大对象的标准" class="headerlink" title="7.6、调整大对象的标准"></a>7.6、调整大对象的标准</h2><p>现象：老年代频繁GC，每次回收的对象很多,而且单个对象的体积都比较大。</p><p>原因：如果大量的大对象直接分配到老年代，导致老年代容易被填满而造成频繁GC，可设置对象直接进入老年代的标准。</p><p>注意：这些大对象进入新生代后可能会使新生代的GC频率和时间增加。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新生代可容纳的最大对象,大于则直接会分配到老年代，0代表没有限制。</span></span><br><span class="line"> -XX:PretenureSizeThreshold=<span class="number">1000000</span> </span><br></pre></td></tr></table></figure><h2 id="7-7、调整GC的触发时机"><a href="#7-7、调整GC的触发时机" class="headerlink" title="7.7、调整GC的触发时机"></a>7.7、调整GC的触发时机</h2><p>现象：CMS，G1 经常 Full GC，程序卡顿严重。</p><p>原因：G1和CMS 部分GC阶段是并发进行的，业务线程和垃圾收集线程一起工作，也就说明垃圾收集的过程中业务线程会生成新的对象，所以在GC的时候需要预留一部分内存空间来容纳新产生的对象，如果这个时候内存空间不足以容纳新产生的对象，那么JVM就会停止并发收集暂停所有业务线程（STW）来保证垃圾收集的正常运行。这个时候可以调整GC触发的时机（比如在老年代占用60%就触发GC），这样就可以预留足够的空间来让业务线程创建的对象有足够的空间分配。</p><p>注意：提早触发GC会增加老年代GC的频率。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用多少比例的老年代后开始CMS收集，默认是68%，如果频繁发生SerialOld卡顿，应该调小</span></span><br><span class="line">-XX:CMSInitiatingOccupancyFraction</span><br><span class="line"></span><br><span class="line"><span class="comment">//G1混合垃圾回收周期中要包括的旧区域设置占用率阈值。默认占用率为 65%</span></span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent=<span class="number">65</span> </span><br></pre></td></tr></table></figure><h2 id="7-8、调整-JVM本地内存大小"><a href="#7-8、调整-JVM本地内存大小" class="headerlink" title="7.8、调整 JVM本地内存大小"></a>7.8、调整 JVM本地内存大小</h2><p>现象：GC的次数、时间和回收的对象都正常，堆内存空间充足，但是报OOM</p><p>原因： JVM除了堆内存之外还有一块堆外内存，这片内存也叫本地内存，可是这块内存区域不足了并不会主动触发GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报OOM异常。</p><p>注意： 本地内存异常的时候除了上面的现象之外，异常信息可能是OutOfMemoryError：Direct buffer memory。 解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发GC（System.gc()）。</p><p>配置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:MaxDirectMemorySize</span><br></pre></td></tr></table></figure><h1 id="8、JVM调优实例"><a href="#8、JVM调优实例" class="headerlink" title="8、JVM调优实例"></a>8、JVM调优实例</h1><p>以下是整理自网络的一些JVM调优实例：</p><h2 id="8-1、网站流量浏览量暴增后，网站反应页面响很慢"><a href="#8-1、网站流量浏览量暴增后，网站反应页面响很慢" class="headerlink" title="8.1、网站流量浏览量暴增后，网站反应页面响很慢"></a>8.1、网站流量浏览量暴增后，网站反应页面响很慢</h2><p>1、问题推测：在测试环境测速度比较快，但是一到生产就变慢，所以推测可能是因为垃圾收集导致的业务线程停顿。</p><p>2、定位：为了确认推测的正确性，在线上通过jstat -gc 指令 看到JVM进行GC 次数频率非常高，GC所占用的时间非常长，所以基本推断就是因为GC频率非常高，所以导致业务线程经常停顿，从而造成网页反应很慢。</p><p>3、解决方案：因为网页访问量很高，所以对象创建速度非常快，导致堆内存容易填满从而频繁GC，所以这里问题在于新生代内存太小，所以这里可以增加JVM内存就行了，所以初步从原来的2G内存增加到16G内存。</p><p>4、第二个问题：增加内存后的确平常的请求比较快了，但是又出现了另外一个问题，就是不定期的会间断性的卡顿，而且单次卡顿的时间要比之前要长很多。</p><p>5、问题推测：练习到是之前的优化加大了内存，所以推测可能是因为内存加大了，从而导致单次GC的时间变长从而导致间接性的卡顿。</p><p>6、定位：还是通过jstat -gc 指令 查看到 的确FGC次数并不是很高，但是花费在FGC上的时间是非常高的,根据GC日志 查看到单次FGC的时间有达到几十秒的。</p><p>7、解决方案： 因为JVM默认使用的是PS+PO的组合，PS+PO垃圾标记和收集阶段都是STW，所以内存加大了之后，需要进行垃圾回收的时间就变长了，所以这里要想避免单次GC时间过长，所以需要更换并发类的收集器，因为当前的JDK版本为1.7，所以最后选择CMS垃圾收集器，根据之前垃圾收集情况设置了一个预期的停顿的时间，上线后网站再也没有了卡顿问题。</p><h2 id="8-2、后台导出数据引发的OOM"><a href="#8-2、后台导出数据引发的OOM" class="headerlink" title="8.2、后台导出数据引发的OOM"></a>8.2、后台导出数据引发的OOM</h2><p><strong>问题描述：</strong>公司的后台系统，偶发性的引发OOM异常，堆内存溢出。</p><p>1、因为是偶发性的，所以第一次简单的认为就是堆内存不足导致，所以单方面的加大了堆内存从4G调整到8G。</p><p>2、但是问题依然没有解决，只能从堆内存信息下手，通过开启了-XX:+HeapDumpOnOutOfMemoryError参数 获得堆内存的dump文件。</p><p>3、VisualVM 对 堆dump文件进行分析，通过VisualVM查看到占用内存最大的对象是String对象，本来想跟踪着String对象找到其引用的地方，但dump文件太大，跟踪进去的时候总是卡死，而String对象占用比较多也比较正常，最开始也没有认定就是这里的问题，于是就从线程信息里面找突破点。</p><p>4、通过线程进行分析，先找到了几个正在运行的业务线程，然后逐一跟进业务线程看了下代码，发现有个引起我注意的方法，导出订单信息。</p><p>5、因为订单信息导出这个方法可能会有几万的数据量，首先要从数据库里面查询出来订单信息，然后把订单信息生成excel，这个过程会产生大量的String对象。</p><p>6、为了验证自己的猜想，于是准备登录后台去测试下，结果在测试的过程中发现到处订单的按钮前端居然没有做点击后按钮置灰交互事件，结果按钮可以一直点，因为导出订单数据本来就非常慢，使用的人员可能发现点击后很久后页面都没反应，结果就一直点，结果就大量的请求进入到后台，堆内存产生了大量的订单对象和EXCEL对象，而且方法执行非常慢，导致这一段时间内这些对象都无法被回收，所以最终导致内存溢出。</p><p>7、知道了问题就容易解决了，最终没有调整任何JVM参数，只是在前端的导出订单按钮上加上了置灰状态，等后端响应之后按钮才可以进行点击，然后减少了查询订单信息的非必要字段来减少生成对象的体积，然后问题就解决了。</p><h2 id="8-3、单个缓存数据过大导致的系统CPU飚高"><a href="#8-3、单个缓存数据过大导致的系统CPU飚高" class="headerlink" title="8.3、单个缓存数据过大导致的系统CPU飚高"></a>8.3、单个缓存数据过大导致的系统CPU飚高</h2><p>1、系统发布后发现CPU一直飚高到600%，发现这个问题后首先要做的是定位到是哪个应用占用CPU高，通过top 找到了对应的一个java应用占用CPU资源600%。</p><p>2、如果是应用的CPU飚高，那么基本上可以定位可能是锁资源竞争，或者是频繁GC造成的。</p><p>3、所以准备首先从GC的情况排查，如果GC正常的话再从线程的角度排查，首先使用jstat -gc PID 指令打印出GC的信息，结果得到得到的GC 统计信息有明显的异常，应用在运行了才几分钟的情况下GC的时间就占用了482秒，那么问这很明显就是频繁GC导致的CPU飚高。</p><p>4、定位到了是GC的问题，那么下一步就是找到频繁GC的原因了，所以可以从两方面定位了，可能是哪个地方频繁创建对象，或者就是有内存泄露导致内存回收不掉。</p><p>5、根据这个思路决定把堆内存信息dump下来看一下，使用jmap -dump 指令把堆内存信息dump下来（堆内存空间大的慎用这个指令否则容易导致会影响应用，因为我们的堆内存空间才2G所以也就没考虑这个问题了）。</p><p>6、把堆内存信息dump下来后，就使用visualVM进行离线分析了，首先从占用内存最多的对象中查找，结果排名第三看到一个业务VO占用堆内存约10%的空间，很明显这个对象是有问题的。</p><p>7、通过业务对象找到了对应的业务代码，通过代码的分析找到了一个可疑之处，这个业务对象是查看新闻资讯信息生成的对象，由于想提升查询的效率，所以把新闻资讯保存到了redis缓存里面，每次调用资讯接口都是从缓存里面获取。</p><p>8、把新闻保存到redis缓存里面这个方式是没有问题的，有问题的是新闻的50000多条数据都是保存在一个key里面，这样就导致每次调用查询新闻接口都会从redis里面把50000多条数据都拿出来，再做筛选分页拿出10条返回给前端。50000多条数据也就意味着会产生50000多个对象，每个对象280个字节左右，50000个对象就有13.3M，这就意味着只要查看一次新闻信息就会产生至少13.3M的对象，那么并发请求量只要到10，那么每秒钟都会产生133M的对象，而这种大对象会被直接分配到老年代，这样的话一个2G大小的老年代内存，只需要几秒就会塞满，从而触发GC。</p><p>9、知道了问题所在后那么就容易解决了，问题是因为单个缓存过大造成的，那么只需要把缓存减小就行了，这里只需要把缓存以页的粒度进行缓存就行了，每个key缓存10条作为返回给前端1页的数据，这样的话每次查询新闻信息只会从缓存拿出10条数据，就避免了此问题的 产生。</p><h2 id="8-4、CPU经常100-问题定位"><a href="#8-4、CPU经常100-问题定位" class="headerlink" title="8.4、CPU经常100% 问题定位"></a>8.4、CPU经常100% 问题定位</h2><p>问题分析：CPU高一定是某个程序长期占用了CPU资源。</p><p>1、所以先需要找出那个进行占用CPU高。</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top  列出系统各个进程的资源占用情况。</span><br></pre></td></tr></table></figure><p>2、然后根据找到对应进行里哪个线程占用CPU高。</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -Hp 进程ID   列出对应进程里面的线程占用资源情况</span><br></pre></td></tr></table></figure><p>3、找到对应线程ID后，再打印出对应线程的堆栈信息</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%x\n&quot;  PID    把线程ID转换为16进制。</span><br><span class="line"> jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。</span><br></pre></td></tr></table></figure><p>4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查看是否有线程长时间的watting 或blocked</span><br><span class="line"> 如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</span><br></pre></td></tr></table></figure><h2 id="8-5、内存飚高问题定位"><a href="#8-5、内存飚高问题定位" class="headerlink" title="8.5、内存飚高问题定位"></a>8.5、内存飚高问题定位</h2><p>分析： 内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。</p><p>1、先观察垃圾回收的情况</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。</span><br><span class="line">  </span><br><span class="line">jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。</span><br></pre></td></tr></table></figure><p>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。</p><p>2、导出堆内存文件快照</p><p>复制代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=/home/myheapdump.hprof PID  dump堆内存信息到文件。</span><br></pre></td></tr></table></figure><p>3、使用visualVM对dump文件进行离线分析,找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</p><h2 id="8-6、数据分析平台系统频繁-Full-GC"><a href="#8-6、数据分析平台系统频繁-Full-GC" class="headerlink" title="8.6、数据分析平台系统频繁 Full GC"></a>8.6、数据分析平台系统频繁 Full GC</h2><p>平台主要对用户在 App 中行为进行定时分析统计，并支持报表导出，使用 CMS GC 算法。</p><p>数据分析师在使用中发现系统页面打开经常卡顿，通过 jstat 命令发现系统每次 Young GC 后大约有 10% 的存活对象进入老年代。</p><p>原来是因为 Survivor 区空间设置过小，每次 Young GC 后存活对象在 Survivor 区域放不下，提前进入老年代。</p><p>通过调大 Survivor 区，使得 Survivor 区可以容纳 Young GC 后存活对象，对象在 Survivor 区经历多次 Young GC 达到年龄阈值才进入老年代。</p><p>调整之后每次 Young GC 后进入老年代的存活对象稳定运行时仅几百 Kb，Full GC 频率大大降低。</p><h2 id="8-7、业务对接网关-OOM"><a href="#8-7、业务对接网关-OOM" class="headerlink" title="8.7、业务对接网关 OOM"></a>8.7、业务对接网关 OOM</h2><p>网关主要消费 Kafka 数据，进行数据处理计算然后转发到另外的 Kafka 队列，系统运行几个小时候出现 OOM，重启系统几个小时之后又 OOM。</p><p>通过 jmap 导出堆内存，在 eclipse MAT 工具分析才找出原因：代码中将某个业务 Kafka 的 topic 数据进行日志异步打印，该业务数据量较大，大量对象堆积在内存中等待被打印，导致 OOM。</p><h2 id="8-8、鉴权系统频繁长时间-Full-GC"><a href="#8-8、鉴权系统频繁长时间-Full-GC" class="headerlink" title="8.8、鉴权系统频繁长时间 Full GC"></a>8.8、鉴权系统频繁长时间 Full GC</h2><p>系统对外提供各种账号鉴权服务，使用时发现系统经常服务不可用，通过 Zabbix 的监控平台监控发现系统频繁发生长时间 Full GC，且触发时老年代的堆内存通常并没有占满，发现原来是业务代码中调用了 System.gc()。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
            <tag> 调优 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM 核心知识点总结</title>
      <link href="/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>#一、基本概念</p><h2 id="1-1-OpenJDK"><a href="#1-1-OpenJDK" class="headerlink" title="1.1 OpenJDK"></a>1.1 OpenJDK</h2><p>自 1996 年 <code>JDK 1.0</code> 发布以来，Sun 公司在大版本上发行了 <code>JDK 1.1</code>、<code>JDK 1.2</code>、<code>JDK 1.3</code>、<code>JDK 1.4</code>、<code>JDK 5</code>，<code>JDK 6</code> ，这些版本的 JDK 都可以统称为 SunJDK 。</p><p>之后，在 2006 年的 JavaOne 大会上，Sun 公司宣布将 Java 开源，在随后的一年多里，它陆续将 JDK 的各个部分在 GPL v2（GNU General Public License，version 2）协议下开源，并建立了 OpenJDK 组织来对这些代码进行独立的管理，这就是 OpenJDK 的来源，此时的 OpenJDK 拥有当时 sunJDK 7 的几乎全部代码。</p><h2 id="1-2-OracleJDK"><a href="#1-2-OracleJDK" class="headerlink" title="1.2 OracleJDK"></a>1.2 OracleJDK</h2><p>JDK 7 的开发期间，Sun 公司市值一路下跌，无力推进 JDK 7 的开发， JDK 7 的发布也一直被推迟。</p><p>之后，在 2009 年 Sun 被 Oracle 收购，为解决 JDK 7 长期跳票的问题，Oracle 将 JDK 7 中大部分未能完成的项目推迟到 JDK 8 ，并于 2011 年发布了JDK 7，在这之后由 Oracle 公司正常发行的 JDK 版本就由 SunJDK 改称为 Oracle JDK。</p><p>在 2017 年 JDK 9 发布后，Oracle 公司宣布：以后 JDK 将会在每年的 3 月和 9 月各发布一个大版本，即半年发行一个大版本，目的是为了避免众多功能被捆绑到一个 JDK 版本上而引发的无法交付的风险。</p><p>在 JDK 11 发布后，Oracle 同步调整了 JDK 的商业授权，宣布从 JDK 11 起，将以前的商业特性全部开源给 OpenJDK ，这样 OpenJDK 11 和 OracleJDK 11 的代码和功能，在本质上就完全相同了。</p><p>同时还宣布以后会发行两个版本的 JDK ：</p><ul><li>一个是在 GPLv2 + CE 协议下由 Oracle 开源的 OpenJDK；</li><li>一个是在 OTN 协议下正常发行的 OracleJDK。</li></ul><p>两者共享大部分源码，在功能上几乎一致。唯一的区别是 Oracle OpenJDK 可以在开发、测试或者生产环境中使用，但只有半年的更新支持；而 OracleJDK 对个人免费，但在生产环境中商用收费，可以有三年时间的更新支持。</p><h2 id="1-3-HotSpot-VM"><a href="#1-3-HotSpot-VM" class="headerlink" title="1.3 HotSpot VM"></a>1.3 HotSpot VM</h2><p>HotSpot VM 是 Sun&#x2F;Oracle JDK 和 OpenJDK 中默认的虚拟机，也是目前使用最广泛的虚拟机。</p><p>最初由 Longview Technologies 公司设计发明，该公司在 1997 年被 Sun 公司收购，而 Sun 公司在 06 年开源 SunJDK 时也将 HotSpot 虚拟机一并开了源。</p><p>Oracle 收购 Sun 以后，建立了 HotRockit 项目，并将其收购的另外一家公司（BEA）的 JRockit 虚拟机中的优秀特性集成到 HotSpot 中</p><p>HotSpot 在这个过程里移除掉永久代，并吸收了 JRockit 的 Java Mission Control 监控工具等功能。</p><p>到 JDK 8 发行时，采用的就是集两者之长的 HotSpot VM。</p><hr><h1 id="二、JVM-组成"><a href="#二、JVM-组成" class="headerlink" title="二、JVM 组成"></a>二、JVM 组成</h1><h2 id="2-1-JVM的总体架构"><a href="#2-1-JVM的总体架构" class="headerlink" title="2.1 JVM的总体架构"></a>2.1 JVM的总体架构</h2><p>如下图所示， JVM的总体架构可以分为以下几个主要部分：</p><ol><li><strong>类加载器（Class Loader）</strong></li><li><strong>运行时数据区（Runtime Data Area）</strong></li><li><strong>执行引擎（Execution Engine）</strong></li><li><strong>本地接口（Native Interface）</strong></li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250214004159875.png" alt="image-20250214004159875"></p><h2 id="2-2-类加载子系统"><a href="#2-2-类加载子系统" class="headerlink" title="2.2 类加载子系统"></a>2.2 类加载子系统</h2><p>类加载子系统主要包含一系列的类加载器 —— 负责加载<code>.class</code>文件到 JVM 的内存中，并将其转换为<code>java.lang.Class</code>的实例。</p><hr><h2 id="2-3-执行引擎（Execution-Engine）"><a href="#2-3-执行引擎（Execution-Engine）" class="headerlink" title="2.3 执行引擎（Execution Engine）"></a>2.3 执行引擎（Execution Engine）</h2><p>执行引擎负责执行字节码指令。它包括以下几个部分：</p><ul><li><strong>解释器（Interpreter）</strong>：<ul><li>逐条解释执行字节码指令。</li><li>适合执行不频繁的代码。</li></ul></li><li><strong>即时编译器（Just-In-Time Compiler，JIT）</strong>：<ul><li>将热点代码（频繁执行的代码）编译为本地机器码，提高执行效率。</li><li>常见的JIT编译器包括C1（Client Compiler）和C2（Server Compiler）。</li></ul></li><li><strong>垃圾回收器（Garbage Collector）</strong>：<ul><li>负责自动管理堆内存，回收不再使用的对象。</li><li>常见的垃圾回收器包括Serial GC、Parallel GC、CMS GC、G1 GC等。</li></ul></li></ul><hr><h3 id="2-4-本地接口（Native-Interface）"><a href="#2-4-本地接口（Native-Interface）" class="headerlink" title="2.4 本地接口（Native Interface）"></a>2.4 本地接口（Native Interface）</h3><p>本地接口允许Java代码调用本地方法（如C&#x2F;C++编写的代码）。它包括：</p><ul><li><strong>JNI（Java Native Interface）</strong>：<ul><li>提供了一种机制，允许Java代码调用本地方法。</li><li>本地方法可以访问操作系统资源或执行性能敏感的操作。</li></ul></li><li><strong>JNA（Java Native Access）</strong>：<ul><li>提供了一种更简单的方式来访问本地库，无需编写JNI代码。</li></ul></li></ul><h2 id="2-5-运行时数据区"><a href="#2-5-运行时数据区" class="headerlink" title="2.5 运行时数据区"></a>2.5 运行时数据区</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250213215907962.png" alt="image-20250213215907962"></p><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><ul><li><p>线程私有</p></li><li><p>一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。</p></li><li><p>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，</p><ul><li>分支、循环、跳转、异常处理、线程恢复等基础功能都需要该计数器来完成。</li></ul></li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><ul><li><p>虚拟机栈（Java Virtual Machine Stack）也是线程私有，</p></li><li><p>描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧，用于存储以下信息</p><ul><li>局部变量表、</li><li>操作数栈、</li><li>动态连接、</li><li>方法出口</li></ul></li><li><p>方法从调用到结束就对应着一个栈帧从入栈到出栈的过程。在《Java 虚拟机规范》中，对该内存区域规定了两类异常：</p><ul><li><p>如果线程请求的栈深度大于虚拟机所允许的栈深度，将抛出 <code>StackOverflowError</code> 异常；</p></li><li><p>如果 Java 虚拟机栈的容量允许动态扩展，当栈扩展时如果无法申请到足够的内存会抛出 <code>OutOfMemoryError</code> 异常。</p></li></ul></li></ul><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈类似，其区别在于：Java 虚拟机栈是为虚拟机执行 Java 方法（也就是字节码）服务的，而本地方法栈则是为 JVM 使用到的<strong>本地（Native）方法</strong>服务。</p><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><ul><li><p>堆（Java Heap）是虚拟机所管理的最大一块内存空间，<strong>用于存放对象实例</strong>。</p></li><li><p>堆被<strong>所有线程所共享</strong></p></li><li><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。</p></li><li><p>Java 堆可以被实现成固定大小的，也可以是可扩展的。</p><ul><li><p>当前大多数主流的虚拟机都是按照可扩展来实现的，即可以通过最大值参数 <code>-Xmx</code> 和最小值参数 <code>-Xms</code> 进行设定。</p></li><li><p>如果 Java 堆中没有足够的内存来完成对象实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p></li></ul></li></ul><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>方法区也被称为 “非堆”，目的是与 Java 堆进行区分。《Java 虚拟机规范》规定，如果方法区无法满足新的内存分配需求时，将会抛出 <code>OutOfMemoryError</code> 异常。</p><ul><li><p><strong>各个线程共享</strong> 的内存区域，</p></li><li><p>用于存储以下内容</p><ul><li>已被虚拟机加载的类信息、</li><li>常量、</li><li>静态变量、</li><li>JIT 编译后的代码缓存等数据。</li></ul></li><li><p>JDK 8 以后的方法区实现 由 <strong>永久代（Permanent Generation）</strong> 转为 <strong>元空间（Metaspace）</strong>。</p><ul><li><p>运行时常量池（Runtime Constant Pool）用于存放常量池表（Constant Pool Table），池表中存放了编译期生成的各种符号字面量和符号引用。</p></li><li><p>JDK 8 以后的运行时常量池在元空间中。</p></li></ul></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p><p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。</p><p>堆外内存就是把内存对象分配在堆外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响</p><hr><h1 id="三、对象"><a href="#三、对象" class="headerlink" title="三、对象"></a>三、对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1、-对象创建方式"><a href="#1、-对象创建方式" class="headerlink" title="1、 对象创建方式"></a>1、 对象创建方式</h3><h4 id="1-1-使用new关键字"><a href="#1-1-使用new关键字" class="headerlink" title="1.1 使用new关键字"></a><strong>1.1 使用<code>new</code>关键字</strong></h4><p>这是最常见的对象创建方式。通过<code>new</code>关键字调用类的构造器来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure><ul><li><strong>原理</strong>：<ul><li><code>new</code>关键字会触发JVM进行对象的内存分配，并调用构造器进行初始化。</li><li>如果类的构造器是无参构造器，JVM会自动调用父类的无参构造器（如果存在）。</li></ul></li></ul><h4 id="1-2-使用反射"><a href="#1-2-使用反射" class="headerlink" title="1.2 使用反射"></a><strong>1.2 使用反射</strong></h4><p>反射可以动态地创建对象，通过<code>Class</code>类的<code>newInstance()</code>方法或<code>Constructor</code>类的<code>newInstance()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure><ul><li><strong>原理</strong>：<ul><li><code>newInstance()</code>方法会调用类的无参构造器。</li><li><code>Constructor.newInstance()</code>方法可以指定构造器的参数。</li></ul></li></ul><h4 id="1-3-使用克隆（Clone）"><a href="#1-3-使用克隆（Clone）" class="headerlink" title="1.3 使用克隆（Clone）"></a><strong>1.3 使用克隆（Clone）</strong></h4><p>通过实现<code>Cloneable</code>接口并重写<code>clone()</code>方法，可以创建对象的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> (MyClass) original.clone();</span><br></pre></td></tr></table></figure><ul><li><strong>原理</strong>：<ul><li><code>clone()</code>方法会创建对象的浅拷贝。</li><li>如果需要深拷贝，需要手动实现深拷贝逻辑。</li></ul></li></ul><h4 id="1-4-使用反序列化"><a href="#1-4-使用反序列化" class="headerlink" title="1.4 使用反序列化"></a><strong>1.4 使用反序列化</strong></h4><p>通过序列化和反序列化，可以创建对象的副本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.ser&quot;</span>));</span><br><span class="line">oos.writeObject(myObject);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) ois.readObject();</span><br></pre></td></tr></table></figure><ul><li><strong>原理</strong>：<ul><li>序列化将对象状态写入字节流。</li><li>反序列化从字节流中读取对象状态，创建对象的副本。</li></ul></li></ul><h3 id="2、-Java对象的创建过程"><a href="#2、-Java对象的创建过程" class="headerlink" title="2、 Java对象的创建过程"></a><strong>2、 Java对象的创建过程</strong></h3><p>对象的创建过程涉及类加载、内存分配、对象初始化等多个步骤。以下是详细的创建过程：</p><h4 id="2-1-类加载"><a href="#2-1-类加载" class="headerlink" title="2.1 类加载"></a><strong>2.1 类加载</strong></h4><p>在创建对象之前，JVM需要加载类到内存中：</p><ol><li><strong>加载</strong>：<ul><li>JVM通过类加载器（如启动类加载器、扩展类加载器、应用类加载器）加载<code>.class</code>文件到内存。</li></ul></li><li><strong>链接</strong>：<ul><li><strong>验证</strong>：检查字节码的正确性。</li><li><strong>准备</strong>：为类的静态变量分配内存。</li><li><strong>解析</strong>：将符号引用转换为直接引用。</li></ul></li><li><strong>初始化</strong>：<ul><li>执行类的静态代码块和静态变量初始化。</li></ul></li></ol><h4 id="2-2-内存分配"><a href="#2-2-内存分配" class="headerlink" title="2.2 内存分配"></a><strong>2.2 内存分配</strong></h4><p>在堆内存中为对象分配内存：</p><ol><li><strong>分配内存</strong>：<ul><li>JVM在堆内存中分配一块足够大的内存空间。</li><li>如果内存不足，会触发垃圾回收器回收内存。</li><li>如果回收后仍不足，会抛出<code>OutOfMemoryError</code>。</li></ul></li><li><strong>内存布局</strong>：<ul><li>对象内存布局包括对象头（存储对象的元数据和锁信息）、实例数据（存储对象的字段值）和对齐填充（确保对象内存对齐）。</li></ul></li></ol><h4 id="2-3-初始化对象"><a href="#2-3-初始化对象" class="headerlink" title="2.3 初始化对象"></a><strong>2.3 初始化对象</strong></h4><p>对象的初始化过程：</p><ol><li><strong>零初始化</strong>：<ul><li>JVM将对象的实例字段初始化为默认值（如数字类型初始化为0，引用类型初始化为<code>null</code>）。</li></ul></li><li><strong>字段初始化</strong>：<ul><li>执行字段的显式初始化（如<code>private int x = 10;</code>）。</li></ul></li><li><strong>构造器初始化</strong>：<ul><li>调用构造器进行对象的初始化。</li><li>如果类有父类，会先调用父类的构造器。</li></ul></li></ol><h2 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h2><p>在 HotSpot 中，对象在堆内存中的存储布局可以划分为以下三个部分：</p><h4 id="1-对象头-Header"><a href="#1-对象头-Header" class="headerlink" title="1. 对象头 (Header)"></a>1. 对象头 (Header)</h4><p>对象头包括两部分信息：</p><ul><li><strong>Mark Word</strong>：对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，</li><li><strong>类型指针</strong>：对象指向它类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。需要说明的是，并非所有的虚拟机都必须要在对象数据上保留类型指针，这取决于对象的访问定位方式。</li></ul><h4 id="2-实例数据-Instance-Data"><a href="#2-实例数据-Instance-Data" class="headerlink" title="2. 实例数据 (Instance Data)"></a>2. 实例数据 (Instance Data)</h4><p>即我们在代码中定义的各种类型的字段，无论是从父类继承而来，还是子类中定义的都需要记录。</p><h4 id="3-对齐填充-Padding"><a href="#3-对齐填充-Padding" class="headerlink" title="3. 对齐填充 (Padding)"></a>3. 对齐填充 (Padding)</h4><p>主要起占位符的作用。HotSpot 要求对象起始地址必须是 8 字节的整倍数，即间接要求了任何对象的大小都必须是 8 字节的整倍数。对象头部分在设计上就是 8 字节的整倍数，如果对象的实例数据不是 8 字节的整倍数，则由对齐填充进行补全。</p><h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>对象创建后，Java 程序就可以通过栈上的 <code>reference</code>（也就是引用）来操作堆上的具体对象。</p><p>《Java 虚拟机规范》规定 <code>reference</code> 是一个指向对象的引用，但并未规定其具体实现方式。主流的方式方式有以下两种：</p><ul><li><strong>句柄访问</strong>：Java 堆将划分出一块内存来作为句柄池， <code>reference</code> 中存储的是对象的句柄地址，而句柄则包含了对象实例数据和类型数据的地址信息。</li><li><strong>指针访问</strong>：<code>reference</code> 中存储的直接就是对象地址，而对象的类型数据则由上文介绍的对象头中的类型指针来指定。</li></ul><p>通过句柄访问对象：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f6b5eb22-a5af-40c0-8c80-00fdd6d16b1d.png" alt="img"></p><p>通过直接指针访问对象：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f696f4a8-af51-4e28-9d72-c2f6b1e5b3db.png" alt="img"></p><p><strong>句柄访问的优点在于对象移动时（垃圾收集时移动对象是非常普遍的行为）只需要改变句柄中实例数据的指针，而 <code>reference</code> 本身并不需要修改；</strong></p><p>指针访问则反之，由于其 <code>reference</code> 中存储的直接就是对象地址，所以当对象移动时， <code>reference</code> 需要被修改。但针对只需要访问对象本身的场景，指针访问则可以减少一次定位开销。由于对象访问是一项非常频繁的操作，所以这类减少的效果会非常显著，基于这个原因，<strong>HotSpot 主要使用的是指针访问的方式</strong>。</p><hr><h1 id="四、垃圾收集机制"><a href="#四、垃圾收集机制" class="headerlink" title="四、垃圾收集机制"></a>四、垃圾收集机制</h1><p>在 JVM 内存模型中，程序计数器、虚拟机栈、本地方法栈这 3 个区域都是线程私有的，会随着线程的结束而销毁，因此在这 3 个区域当中，无需过多考虑垃圾回收问题。垃圾回收问题主要发生在 Java 堆上。</p><p>在 Java 堆上，垃圾回收的主要内容是死亡的对象（不可能再被任何途径使用的对象）。</p><p>判断对象是否死亡有以下两种方法：</p><p>##4.1  引用计数法</p><ul><li>无法处理循环引用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB</span><br><span class="line">objB.instance = objA    </span><br><span class="line">objA = null;</span><br><span class="line">objB = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><p>如上所示，此时两个对象已经不能再被访问，但其互相持有对对方的引用，如果采用引用计数法，则两个对象都无法被回收。</p><h2 id="4-2-可达性分析"><a href="#4-2-可达性分析" class="headerlink" title="4.2 可达性分析"></a>4.2 可达性分析</h2><p>可达性分析是通过一系列被称为 <code>GC Roots</code> 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为引用链（Reference Chain），如果某个对象到 <code>GC Roots</code> 间没有任何引用链相连，这代表 <code>GC Roots</code> 到该对象不可达， 此时证明该对象不可能再被使用。</p><p>在 Java 语言中，固定可作为 <code>GC Roots</code> 的对象包括以下几种：</p><ul><li>在<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；</li><li>在方法区（元空间）中<strong>类静态变量引用的对象</strong>，譬如 Java 类中引用类型的静态变量；</li><li>在方法区（元空间）中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用；</li><li>在本地方法栈中的 JNI（Native 方法）引用的对象；</li><li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（如 NullPointException，OutOfMemoryError 等）及系统类加载器；</li><li>所有被同步锁（synchronized 关键字）持有的对象；</li></ul><p>除了这些固定的 <code>GC Roots</code> 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域的不同，还可能会有其他对象 “临时性” 地加入，共同构成完整的 <code>GC Roots</code> 集合。</p><h2 id="4-3-对象引用"><a href="#4-3-对象引用" class="headerlink" title="4.3 对象引用"></a>4.3 对象引用</h2><p>可达性分析是基于引用链进行判断的，在 JDK 1.2 之后，Java 将引用关系分为以下四类：</p><h3 id="1、强引用-Strongly-Reference"><a href="#1、强引用-Strongly-Reference" class="headerlink" title="1、强引用 (Strongly Reference)"></a>1、强引用 (Strongly Reference)</h3><p>最传统的引用，如 <code>Object obj = new Object()</code> 。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p><h3 id="2、软引用-Soft-Reference"><a href="#2、软引用-Soft-Reference" class="headerlink" title="2、软引用 (Soft Reference)"></a>2、软引用 (Soft Reference)</h3><p>用于描述一些还有用，但非必须的对象。</p><p>只被软引用关联着的对象，在系统将要发生内存溢出之前，会被列入回收范围内进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p><h3 id="3、弱引用-Weak-Reference"><a href="#3、弱引用-Weak-Reference" class="headerlink" title="3、弱引用 (Weak Reference)"></a>3、弱引用 (Weak Reference)</h3><p>弱引用关联的对象只能生存到下一次垃圾收集发生时，无论当前内存是否足够，弱引用对象都会被回收。</p><h3 id="4、虚引用-Phantom-Reference"><a href="#4、虚引用-Phantom-Reference" class="headerlink" title="4、虚引用 (Phantom Reference)"></a>4、虚引用 (Phantom Reference)</h3><h4 id="虚引用的特点"><a href="#虚引用的特点" class="headerlink" title="虚引用的特点"></a><strong>虚引用的特点</strong></h4><ol><li><strong>无法获取对象实例</strong>：虚引用的 <code>get()</code> 方法总是返回 <code>null</code>，无法通过虚引用来直接访问对象。</li><li><strong>配合引用队列使用</strong>：虚引用必须与 <code>ReferenceQueue</code> 结合使用。当虚引用指向的对象被垃圾回收时，虚引用会被加入到关联的引用队列中。</li><li><strong>不影响对象生命周期</strong>：虚引用的存在不会阻止垃圾回收器回收对象。</li></ol><h4 id="虚引用的典型使用场景"><a href="#虚引用的典型使用场景" class="headerlink" title="虚引用的典型使用场景"></a><strong>虚引用的典型使用场景</strong></h4><ol><li><strong>资源清理</strong>：<ul><li>虚引用常用于在对象被回收时执行清理操作，例如释放文件句柄、关闭网络连接或释放其他系统资源。</li><li>例如，在 <code>DirectByteBuffer</code> 中，虚引用用于在对象被回收时释放直接内存。</li></ul></li><li><strong>对象生命周期监控</strong>：<ul><li>虚引用可以用于监控对象的生命周期。当对象被垃圾回收时，通过监听引用队列可以触发相应的通知或日志记录。</li></ul></li><li><strong>内存管理与缓存清理</strong>：<ul><li>在缓存系统中，虚引用可以用于监控缓存对象的生命周期。当缓存对象被回收时，可以触发清理操作，避免内存泄漏。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建虚引用，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟资源清理操作</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cleanupThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;?&gt; reference = (PhantomReference&lt;?&gt;) queue.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;对象被回收，执行清理操作: &quot;</span> + reference);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cleanupThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        cleanupThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消强引用，使对象可被回收</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待一段时间，确保垃圾回收完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-对象真正死亡"><a href="#4-4-对象真正死亡" class="headerlink" title="4.4 对象真正死亡"></a>4.4 对象真正死亡</h2><p>要真正宣告一个对象死亡，需要经过至少两次标记过程：</p><p>①、如果对象在进行可达性分析后发现 <code>GC Roots</code> 不可达，将会进行第一次标记；</p><p>②、随后进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalized()</code> 方法。</p><p>如果对象没有覆盖 <code>finalized()</code> 方法，或者 <code>finalized()</code> 已经被虚拟机调用过，这两种情况都会视为没有必要执行。</p><p>如果判定结果是有必要执行，此时对象会被放入名为 <code>F-Queue</code> 的队列，等待 Finalizer 线程执行其 <code>finalized()</code> 方法。</p><p>在这个过程中，收集器会进行第二次小规模的标记，如果对象在 <code>finalized()</code> 方法中重新将自己与引用链上的任何一个对象进行了关联，如将自己（<code>this</code> 关键字）赋值给某个类变量或者对象的成员变量，此时它就实现了自我拯救，则第二次标记会将其移除 “即将回收” 的集合，否则该对象就将被真正回收，走向死亡。</p><h2 id="4-5-垃圾收集算法"><a href="#4-5-垃圾收集算法" class="headerlink" title="4.5 垃圾收集算法"></a>4.5 垃圾收集算法</h2><h3 id="1、分代收集理论"><a href="#1、分代收集理论" class="headerlink" title="1、分代收集理论"></a>1、分代收集理论</h3><p>当前大多数虚拟机都遵循 “分代收集” 的理论进行设计，它建立在强弱两个分代假说下：</p><ul><li><strong>弱分代假说 (Weak Generational Hypothesis)</strong> ：绝大多数对象都是朝生夕灭的。</li><li><strong>强分代假说 (Strong Generational Hypothesis)</strong> ：熬过越多次垃圾收集过程的对象就越难以消亡。</li><li><strong>跨带引用假说 (Intergenerational Reference Hypothesis)</strong> ：基于上面两条假说还可以得出的一条隐含推论：存在相互引用关系的两个对象，应该倾向于同时生存或者同时消亡。</li></ul><p>强弱分代假说奠定了垃圾收集器的设计原则：<strong>收集器应该将 Java 堆划分出不同的区域</strong>，然后将回收对象依据其年龄（年龄就是对象经历垃圾收集的次数）分配到不同的区域中进行存储。</p><p>之后如果一个区域中的对象都是朝生夕灭的，那么收集器只需要关注少量对象的存活而不是去标记那些大量将要被回收的对象，此时就能以较小的代价获取较大的空间。</p><p>最后再将难以消亡的对象集中到一块，根据强分代假说，它们是很难消亡的，因此虚拟机可以使用较低的频率进行回收，这就兼顾了时间和内存空间的开销。</p><p>###2、回收类型</p><p>根据分代收集理论，收集范围可以分为以下几种类型：</p><p>①、<strong>部分收集 (Partial GC)</strong> ：具体分为：</p><ul><li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li><li><strong>整堆收集 (Full GC)</strong> ：收集整个 Java 堆和方法区。</li></ul><h3 id="3、标记-清除算法"><a href="#3、标记-清除算法" class="headerlink" title="3、标记-清除算法"></a>3、标记-清除算法</h3><p>它是最基础的垃圾收集算法，收集过程分为两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；也可以反过来，标记存活对象，统一回收所有未被标记的对象。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-7d489254-f1e0-4feb-bd4a-af129767a787.png" alt="img"></p><p>它主要有以下两个缺点：</p><ul><li>执行效率不稳定：如果 Java 堆上包含大量需要回收的对象，则需要进行大量标记和清除动作；</li><li>内存空间碎片化：标记清除后会产生大量不连续的空间，从而导致无法为大对象分配足够的连续内存。</li></ul><h3 id="4、标记-复制算法"><a href="#4、标记-复制算法" class="headerlink" title="4、标记-复制算法"></a>4、标记-复制算法</h3><p>标记-复制算法基于 ”半区复制“ 算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块的内存使用完了，就将还存活着的对象复制到另外一块，然后再把已经使用过的那块内存空间一次性清理掉。其优点在于避免了内存空间碎片化的问题，其缺点如下：</p><ul><li>如果内存中多数对象都是存活的，这种算法将产生大量的复制开销；</li><li>浪费内存空间，内存空间变为了原有的一半。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f4572b93-f7f3-41cc-9901-93816e79c789.png" alt="img"></p><p>基于新生代 “朝生夕灭” 的特点，大多数虚拟机都不会按照 1:1 的比例来进行内存划分，例如 HotSpot 会将内存空间划分为一块较大的 <code>Eden</code> 和两块较小的 <code>Survivor</code> 空间，它们之间的比例是 8:1:1 。</p><p>每次分配时只会使用 <code>Eden</code> 和其中的一块 <code>Survivor</code> ，发生垃圾回收时，只需要将存活的对象一次性复制到另外一块 <code>Survivor</code> 上，这样只有 10% 的内存空间会被浪费掉。</p><p>当 <code>Survivor</code> 空间不足以容纳一次 <code>Minor GC</code> 时，此时由其他内存区域（通常是老年代）来进行分配担保。</p><h3 id="5、标记-整理算法"><a href="#5、标记-整理算法" class="headerlink" title="5、标记-整理算法"></a>5、标记-整理算法</h3><p>标记-整理算法是在标记完成后，让所有存活对象都向内存的一端移动，然后直接清理掉边界以外的内存。</p><p>其优点在于可以避免内存空间碎片化的问题，也可以充分利用内存空间；其缺点在于根据所使用的收集器的不同，在移动存活对象时可能要全程暂停用户程序：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-e674c49f-c55b-4eba-95ea-34be62d55a78.png" alt="img"></p><h1 id="五、垃圾收集器"><a href="#五、垃圾收集器" class="headerlink" title="五、垃圾收集器"></a>五、垃圾收集器</h1><p>HotSpot 中一共存在七款经典的垃圾收集器：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-1fa20f99-d203-42d6-982c-f1bd66a0c929.png" alt="img"></p><h2 id="5-1-Serial-收集器"><a href="#5-1-Serial-收集器" class="headerlink" title="5.1 Serial 收集器"></a>5.1 Serial 收集器</h2><p>Serial 收集器是最基础、历史最悠久的收集器，它是一个单线程收集器，在进行垃圾回收时，必须暂停其他所有的工作线程，直到收集结束，这是其主要缺点。</p><p>它的优点在于单线程避免了多线程复杂的上下文切换，因此在单线程环境下收集效率非常高，由于这个优点，迄今为止，其仍然是 HotSpot 虚拟机在客户端模式下默认的新生代收集器：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/serial-garbage-collector.png" alt="Serial 收集器"></p><h2 id="5-2-ParNew-收集器"><a href="#5-2-ParNew-收集器" class="headerlink" title="5.2 ParNew 收集器"></a>5.2 ParNew 收集器</h2><p>它是 Serial 收集器的多线程版本，可以使用多条线程进行垃圾回收：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250213235426748.png" alt="image-20250213235426748"></p><h2 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器"></a>5.3 Parallel Scavenge 收集器</h2><p>Parallel Scavenge 也是新生代收集器，基于 标记-复制 算法进行实现，它的目标是达到一个可控的吞吐量。这里的吞吐量指的是处理器运行用户代码的时间与处理器总消耗时间的比值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 运行用户代码时间 \ (运行用户代码时间 + 运行垃圾收集时间)</span><br></pre></td></tr></table></figure><p>Parallel Scavenge 收集器提供两个参数用于精确控制吞吐量：</p><p>①、<code>-XX:MaxGCPauseMillis</code>：控制最大垃圾收集时间，假设需要回收的垃圾总量不变，那么降低垃圾收集的时间就会导致收集频率变高，所以需要将其设置为合适的值，不能一味减小。</p><p>②、<code>-XX:MaxGCTimeRatio</code>：直接用于设置吞吐量大小，它是一个大于 0 小于 100 的整数。假设把它设置为 19，表示此时允许的最大垃圾收集时间占总时间的 5%（即 1&#x2F;(1+19) ）；默认值为 99 ，即允许最大 1%（ 1&#x2F;(1+99) ）的垃圾收集时间。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250214000748151.png" alt="image-20250214000748151"></p><h2 id="5-4-Serial-Old-收集器"><a href="#5-4-Serial-Old-收集器" class="headerlink" title="5.4 Serial Old 收集器"></a>5.4 Serial Old 收集器</h2><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：</p><ul><li>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</li><li>另一种用途是<strong>作为 CMS 收集器的后备方案</strong>。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/serial-garbage-collector.png" alt="Serial 收集器"></p><h2 id="5-5-Paralled-Old-收集器"><a href="#5-5-Paralled-Old-收集器" class="headerlink" title="5.5 Paralled Old 收集器"></a>5.5 Paralled Old 收集器</h2><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p><h2 id="5-6-CMS-（Concurrent-Mark-Sweep）收集器"><a href="#5-6-CMS-（Concurrent-Mark-Sweep）收集器" class="headerlink" title="5.6 CMS （Concurrent Mark Sweep）收集器"></a>5.6 CMS （Concurrent Mark Sweep）收集器</h2><ul><li><p><strong>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p></li><li><p><strong>CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p></li><li><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><p><strong>初始标记：</strong> 短暂停顿，标记直接与 root 相连的对象（根对象）；</p></li><li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p></li><li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p></li><li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/cms-garbage-collector.png" alt="CMS 收集器"></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p><h2 id="5-7-Garbage-First-收集器"><a href="#5-7-Garbage-First-收集器" class="headerlink" title="5.7 Garbage First 收集器"></a>5.7 Garbage First 收集器</h2><ul><li><p>G1 是一款面向服务器的垃圾收集器，主要<strong>针对配备多颗处理器及大容量内存的机器</strong>。以<strong>极高概率满足 GC 停顿时间要求</strong>的同时， 还<strong>具备高吞吐量</strong>性能特征。</p></li><li><p>G1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p><ul><li><p><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p></li><li><p><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</p></li><li><p><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p></li><li><p><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</p></li></ul></li><li><p>使用 G1  时的内存管理：</p><ul><li>G1 虽然也遵循分代收集理论，但不再以固定大小和固定数量来划分分代区域，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region）。<ul><li>每一个 Region 都可以根据不同的需求来扮演新生代的 <code>Eden</code> 空间、<code>Survivor</code> 空间或者老年代空间，收集器会根据其扮演角色的不同而采用不同的收集策略。</li><li>此外，如下图所示 ，有一些 Region 使用 H 进行标注，它代表 Humongous，表示这些 Region 用于存储大对象（humongous object，H-obj），即大小大于等于 region 一半的对象。</li></ul></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-e0f5da26-6e46-4f9d-bfcc-0842cc7079e7.png" alt="img"></p><ul><li><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><p><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</p></li><li><p><strong>并发标记</strong>：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</p></li><li><p><strong>最终标记</strong>： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。</p></li><li><p><strong>筛选回收</strong>：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/g1-garbage-collector.png" alt="G1 收集器"></p></li></ul></li><li><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p></li><li><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p></li></ul><h2 id="5-8-内存分配原则"><a href="#5-8-内存分配原则" class="headerlink" title="5.8 内存分配原则"></a>5.8 内存分配原则</h2><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代的 <code>Eden</code> 区中进行分配，当 <code>Eden</code> 区没有足够空间时，虚拟机将进行一次 Minor GC。</p><h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象就是指需要大量连续内存空间的 Java 对象，最典型的就是超长的字符串或者元素数量很多的数组，它们将直接进入老年代。</p><p>主要是因为如果在新生代分配，因为其需要大量连续的内存空间，可能会导致提前触发垃圾回收；并且由于新生代的垃圾回收本身就很频繁，此时复制大对象也需要额外的性能开销。</p><h4 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h4><p>虚拟机会给每个对象在其对象头中定义一个年龄计数器。对象通常在 <code>Eden</code> 区中诞生，如果经历第一次 Minor GC 后仍然存活，并且能够被 Survivor 容纳的话，该对象就会被移动到 Survivor 中，并将其年龄加 1。</p><p>对象在 Survivor 中每经过一次 Minor GC，年龄就加 1，当年龄达到一定程度后（由 <code>-XX:MaxTenuringThreshold</code> 设置，默认值为 15）就会进入老年代中。</p><h4 id="4-动态年龄判断"><a href="#4-动态年龄判断" class="headerlink" title="4. 动态年龄判断"></a>4. 动态年龄判断</h4><p>如果在 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代，而无需等待年龄到达 <code>-XX:MaxTenuringThreshold</code> 设置的值。</p><h4 id="5-空间担保分配"><a href="#5-空间担保分配" class="headerlink" title="5. 空间担保分配"></a>5. 空间担保分配</h4><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么这一次的 Minor GC 可以确认是安全的。</p><p>如果不成立，虚拟机会查看 <code>-XX:HandlePromotionFailure</code> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于或者 <code>-XX:HandlePromotionFailure</code> 的值设置不允许冒险，那么就要改为进行一次 Full GC 。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/whereis-the-object-8.png" alt="img"></p><h2 id="5-9-垃圾收集器选择与开启"><a href="#5-9-垃圾收集器选择与开启" class="headerlink" title="5.9 垃圾收集器选择与开启"></a>5.9 垃圾收集器选择与开启</h2><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a><strong>1. Serial收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseSerialGC</code></li><li><strong>新生代</strong>：Serial（复制算法）</li><li><strong>老年代</strong>：Serial Old（标记-整理算法）</li><li><strong>特点</strong>：单线程收集器，适合单核CPU或小内存应用。</li></ul><h3 id="2-Parallel-Scavenge收集器"><a href="#2-Parallel-Scavenge收集器" class="headerlink" title="2. Parallel Scavenge收集器"></a><strong>2. Parallel Scavenge收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseParallelGC</code></li><li><strong>新生代</strong>：Parallel Scavenge（复制算法）</li><li><strong>老年代</strong>：默认为Serial Old，但通常会自动启用Parallel Old。</li><li><strong>特点</strong>：多线程收集器，适合多核CPU，关注吞吐量。</li></ul><h3 id="3-Parallel-Old收集器"><a href="#3-Parallel-Old收集器" class="headerlink" title="3. Parallel Old收集器"></a><strong>3. Parallel Old收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseParallelOldGC</code></li><li><strong>新生代</strong>：Parallel Scavenge（复制算法）</li><li><strong>老年代</strong>：Parallel Old（标记-整理算法）</li><li><strong>特点</strong>：与Parallel Scavenge配合使用，适合多核CPU。</li></ul><h3 id="4-ParNew收集器"><a href="#4-ParNew收集器" class="headerlink" title="4. ParNew收集器"></a><strong>4. ParNew收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseParNewGC</code></li><li><strong>新生代</strong>：ParNew（复制算法）</li><li><strong>老年代</strong>：默认为Serial Old，但通常会自动启用CMS。</li><li><strong>特点</strong>：多线程收集器，适合多核CPU，适合与CMS配合使用。</li></ul><h3 id="5-CMS收集器"><a href="#5-CMS收集器" class="headerlink" title="5. CMS收集器"></a><strong>5. CMS收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseConcMarkSweepGC</code></li><li><strong>新生代</strong>：ParNew（复制算法）</li><li><strong>老年代</strong>：CMS（并发标记-清除算法）</li><li><strong>特点</strong>：并发收集器，适合低延迟需求，但可能产生内存碎片。</li></ul><h3 id="6-G1收集器"><a href="#6-G1收集器" class="headerlink" title="6. G1收集器"></a><strong>6. G1收集器</strong></h3><ul><li><strong>指令</strong>：<code>-XX:+UseG1GC</code></li><li><strong>新生代和老年代</strong>：G1（复制算法和标记-整理算法）</li><li><strong>特点</strong>：分区收集器，适合大堆内存，兼顾吞吐量和低延迟。</li></ul><h3 id="7-Serial-Old收集器"><a href="#7-Serial-Old收集器" class="headerlink" title="7. Serial Old收集器"></a><strong>7. Serial Old收集器</strong></h3><ul><li><strong>指令</strong>：无单独启用指令，通常作为其他收集器的后备方案。</li><li><strong>新生代</strong>：与Serial或Parallel Scavenge配合使用。</li><li><strong>老年代</strong>：Serial Old（标记-整理算法）</li><li><strong>特点</strong>：单线程收集器，适合单核CPU或小内存应用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>Serial</strong>：适合单核CPU或小内存应用。</li><li><strong>Parallel Scavenge + Parallel Old</strong>：适合多核CPU，关注吞吐量。</li><li><strong>ParNew + CMS</strong>：适合多核CPU，低延迟需求。</li><li><strong>G1</strong>：适合大堆内存，兼顾吞吐量和低延迟。</li><li><strong>Serial Old</strong>：通常作为后备方案，适合单核CPU或小内存应用。</li></ul><p>这些垃圾收集器各有特点，选择合适的收集器需要根据应用的具体需求和运行环境来决定。</p><hr><h1 id="六、类加载机制"><a href="#六、类加载机制" class="headerlink" title="六、类加载机制"></a>六、类加载机制</h1><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称为虚拟机的类加载机制。</p><h2 id="6-1-类加载时机"><a href="#6-1-类加载时机" class="headerlink" title="6.1 类加载时机"></a>6.1 类加载时机</h2><p>一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、卸载、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析三个部分统称为连接：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/class-load-20231031202641.png" alt="img" style="zoom:67%;" /><h2 id="6-2-类加载过程"><a href="#6-2-类加载过程" class="headerlink" title="6.2 类加载过程"></a>6.2 类加载过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>在加载阶段，虚拟机需要完成以下三件事：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流 ；</li><li>将这个字节流所代表的静态存储结构转换为运行时数据结构；</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为这个类的各种数据的访问入口。</li></ul><p>《Java 虚拟机规范》并没有限制从何处获取二进制流，因此可以从 JAR 包、WAR 包获取，也可以从 JSP 生成的 Class 文件等处获取。</p><h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的约束要求，从而保证虚拟机自身的安全。</p><p>验证阶段大致会完成下面四项验证：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/class-loading-process-verification.png" alt="验证阶段示意图"></p><h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ul><li>这时候进行内存分配的仅包括类变量（ 也即静态变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），<ul><li><strong>特殊情况</strong>：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111</li></ul></li></ul><h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程：</p><ul><li><strong>符号引用</strong>：符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li><strong>直接引用</strong>：直接引用是指可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。</li></ul><p>整个解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行解析。</p><p>《深入理解 Java 虚拟机》7.3.4 节第三版对符号引用和直接引用的解释如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p><h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段就是执行类构造器的 <code>&lt;clinit&gt;()</code> 方法的过程，该方法具有以下特点：</p><ul><li><code>&lt;clinit&gt;()</code> 方法由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生，编译器收集顺序由语句在源文件中出现的顺序决定。</li><li><code>&lt;clinit&gt;()</code> 方法与类的构造方法（即在虚拟机视角中的实例构造器 <code>&lt;init&gt;()</code>方法）不同，它不需要显示的调用父类的构造器，Java 虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li><li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优先于子类变量的赋值操作。</li><li><code>&lt;clinit&gt;()</code> 方法对于类或者接口不是必须的，如果一个类中没有静态语句块，也没有对变量进行赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</li><li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。</li><li>Java 虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待。</li></ul><h2 id="6-3-类加载器"><a href="#6-3-类加载器" class="headerlink" title="6.3 类加载器"></a>6.3 类加载器</h2><p>能够通过一个类的全限定名来获取描述该类的二进制字节流的工具称为类加载器。</p><p>每一个类加载器都拥有一个独立的类名空间，因此对于任意一个类，都必须由加载它的类加载器和这个类本身来共同确立其在 Java 虚拟机中的唯一性。</p><p>这意味着要想比较两个类是否相等，必须在同一类加载器加载的前提下；如果两个类的类加载器不同，则它们一定不相等。</p><h2 id="6-4-双亲委派模型"><a href="#6-4-双亲委派模型" class="headerlink" title="6.4 双亲委派模型"></a>6.4 双亲委派模型</h2><p>从 Java 虚拟机角度而言，类加载器可以分为以下两类：</p><ul><li><strong>启动类加载器</strong> ：启动类加载器（Bootstrap ClassLoader）由 C++ 语言实现（以 HotSpot 为例），它是虚拟机自身的一部分；</li><li><strong>其他所有类的类加载器</strong> ：由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自 <code>java.lang.ClassLoader</code> 。</li></ul><p>从开发人员角度而言，类加载器可以分为以下三类：</p><ul><li><strong>启动类加载器 (Boostrap Class Loader)</strong> ：负责把存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中，或被 <code>-Xbootclasspath</code> 参数所指定的路径中存放的能被 Java 虚拟机识别的类库加载到虚拟机的内存中；</li><li><strong>扩展类加载器 (Extension Class Loader)</strong> ：负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中，或被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库。</li><li><strong>应用程序类加载器 (Application Class Loader)</strong> ：负责加载用户类路径（ClassPath）上的所有的类库。</li></ul><p>JDK 9 之前的 Java 应用都是由这三种类加载器相互配合来完成加载：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-c1fcdc37-4e5a-4ed3-94b1-ad4afa2dba7c.png" alt="img"></p><p>上图所示的各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型”，“双亲委派模型” 要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，需要注意的是这里的加载器之间的父子关系一般不是以继承关系来实现的，而是使用组合关系来复用父类加载器的代码。</p><p>双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p><p>基于双亲委派模型可以保证程序中的类在各种类加载器环境中都是同一个类，否则就有可能出现一个程序中存在两个不同的 <code>java.lang.Object</code> 的情况。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 代理模式</title>
      <link href="/2024/05/18/Java%20%E5%9F%BA%E7%A1%80/Java%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/05/18/Java%20%E5%9F%BA%E7%A1%80/Java%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-代理模式"><a href="#Java-代理模式" class="headerlink" title="Java 代理模式"></a>Java 代理模式</h1><h2 id="一、代理模式介绍"><a href="#一、代理模式介绍" class="headerlink" title="一、代理模式介绍"></a>一、代理模式介绍</h2><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</p><p>简言之，代理模式就是设置一个中间代理来控制访问原目标对象，以达到增强原对象的功能和简化访问方式。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250304010307171.png" alt="image-20250304010307171"></p><p>举个例子，我们生活中经常到火车站去买车票，但是人一多的话，就会非常拥挤，于是就有了代售点，我们能从代售点买车票了。这其中就是代理模式的体现，代售点代理了火车站对象，提供购买车票的方法。</p><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>这种代理方式需要代理对象和目标对象实现一样的接口。</p><ul><li><p>优点：可以在不修改目标对象的前提下扩展目标对象的功能。</p></li><li><p>缺点：</p><ol><li>冗余。由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。</li><li>不易维护。一旦接口增加方法，目标对象与代理对象都要进行修改。</li></ol></li></ul><p><strong>【举例】：保存用户功能的静态代理实现</strong></p><ul><li>接口类： IUserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>目标对象：UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>静态代理对象：UserDapProxy （<em>需要实现IUserDao接口！</em>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoProxy</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IUserDao target;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoProxy</span><span class="params">(IUserDao target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);<span class="comment">//扩展了额外功能</span></span><br><span class="line">        target.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类：TestProxy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticUserProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testStaticProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        <span class="type">UserDaoProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoProxy</span>(target);</span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">提交事务</span><br></pre></td></tr></table></figure><h2 id="三、动态代理"><a href="#三、动态代理" class="headerlink" title="三、动态代理"></a>三、动态代理</h2><p>动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><ul><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li><li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li></ul><p><strong>特点：</strong><br>动态代理对象不需要实现接口，但是要求目标对象必须实现接口，否则不能使用动态代理。</p><p>JDK中生成代理对象主要涉及的类有</p><ul><li><code>java.lang.reflect Proxy</code>，主要方法为</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title class_">Object</span> <span class="title function_">newProxyInstance</span>(<span class="title class_">ClassLoader</span> loader,  <span class="comment">//指定当前目标对象使用类加载器</span></span><br><span class="line"><span class="title class_">Class</span>&lt;?&gt;[] interfaces,    <span class="comment">//目标对象实现的接口的类型</span></span><br><span class="line"> <span class="title class_">InvocationHandler</span> h      <span class="comment">//事件处理器</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">//返回一个指定接口的代理类实例，该接口可以将方法调用指派到指定的调用处理程序。</span></span><br></pre></td></tr></table></figure><ul><li><code>java.lang.reflect InvocationHandler</code>，主要方法为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span><br><span class="line"><span class="comment">// 在代理实例上处理方法调用并返回结果。</span></span><br></pre></td></tr></table></figure><p><strong>【举例】：保存用户功能的动态代理实现</strong></p><ul><li>接口类： IUserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>目标对象：UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span> <span class="keyword">implements</span> <span class="title class_">IUserDao</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态代理对象：UserProxyFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">// 维护一个目标对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 执行目标对象方法</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;提交事务&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类：TestProxy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDynamicProxy</span> <span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        System.out.println(target.getClass());  <span class="comment">//输出目标对象信息</span></span><br><span class="line">        <span class="type">IUserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (IUserDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        System.out.println(proxy.getClass());  <span class="comment">//输出代理对象信息</span></span><br><span class="line">        proxy.save();  <span class="comment">//执行代理方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class com.proxy.UserDao</span><br><span class="line">class com.sun.proxy.<span class="variable">$Proxy4</span></span><br><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">提交事务</span><br></pre></td></tr></table></figure><h2 id="四、cglib代理"><a href="#四、cglib代理" class="headerlink" title="四、cglib代理"></a>四、cglib代理</h2><blockquote><p>cglib is a powerful, high performance and quality Code Generation Library. It can extend JAVA classes and implement interfaces at runtime.</p></blockquote><p>cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><p><strong>cglib特点</strong></p><ul><li>JDK的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。<br>如果想代理没有实现接口的类，就可以使用CGLIB实现。</li><li>CGLIB是一个强大的高性能的代码生成包，它可以在运行期扩展Java类与实现Java接口。<br>它广泛的被许多AOP的框架使用，例如Spring AOP和dynaop，为他们提供方法的interception（拦截）。</li><li>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>不鼓励直接使用ASM，因为它需要你对JVM内部结构包括class文件的格式和指令集都很熟悉。</li></ul><p>cglib与动态代理最大的<strong>区别</strong>就是</p><ul><li>使用动态代理的对象必须实现一个或多个接口</li><li>使用cglib代理的对象则无需实现接口，达到代理类无侵入。</li></ul><p>使用cglib需要引入cglib的jar包，如果你已经有spring-core的jar包，则无需引入，因为spring中包含了cglib。</p><ul><li>cglib的Maven坐标</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>举例：保存用户功能的动态代理实现</p></blockquote><ul><li>目标对象：UserDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;保存数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理对象：ProxyFactory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//维护一个目标对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyFactory</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为目标对象生成代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//工具类</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类</span></span><br><span class="line">        en.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        en.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建子类对象代理</span></span><br><span class="line">        <span class="keyword">return</span> en.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开启事务&quot;</span>);</span><br><span class="line">        <span class="comment">// 执行目标对象的方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭事务&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类：TestProxy</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestProxy</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCglibProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//目标对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDao</span>();</span><br><span class="line">        System.out.println(target.getClass());</span><br><span class="line">        <span class="comment">//代理对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserDao) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(target).getProxyInstance();</span><br><span class="line">        System.out.println(proxy.getClass());</span><br><span class="line">        <span class="comment">//执行代理对象方法</span></span><br><span class="line">        proxy.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class com.cglib.UserDao</span><br><span class="line">class com.cglib.UserDao$$EnhancerByCGLIB$<span class="variable">$552188b6</span></span><br><span class="line">开启事务</span><br><span class="line">保存数据</span><br><span class="line">关闭事务</span><br></pre></td></tr></table></figure><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ol><li>静态代理实现较简单，只要代理对象对目标对象进行包装，即可实现增强功能，但静态代理只能为一个目标对象服务，如果目标对象过多，则会产生很多代理类。</li><li>JDK动态代理需要目标对象实现业务接口，代理类只需实现InvocationHandler接口。</li><li>动态代理生成的类为 lass com.sun.proxy.$Proxy4，cglib代理生成的类为class com.cglib.UserDao$$EnhancerByCGLIB$$552188b6。</li><li>静态代理在编译时产生class字节码文件，可以直接使用，效率高。</li><li>动态代理必须实现InvocationHandler接口，通过反射代理方法，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。</li><li>cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 管道</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="匿名管道-IPC"><a href="#匿名管道-IPC" class="headerlink" title="匿名管道 IPC"></a>匿名管道 IPC</h3><h4 id="管道创建"><a href="#管道创建" class="headerlink" title="管道创建"></a>管道创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span> <span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"> <span class="comment">// 返回:成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>fd 为 文件描述符数组，是函数的核心返回值， fd[0] 指向管道 读端 ， fd[1]指向管道写端，也即 fd[1] 是 fd[0] 的输入</p><h4 id="管道实现进程间通信"><a href="#管道实现进程间通信" class="headerlink" title="管道实现进程间通信"></a>管道实现进程间通信</h4><p>（1）父进程创建管道，得到两个⽂件描述符指向管道的两端</p><p>（2）父进程 fork 出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 </p><p>（3）父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要在 fork 之前创建管道 ， 这样子进程与父进程 对应相同的管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//read会阻塞，进行读取数据</span></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s ,pid:%d \n&quot;</span>,buf,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//子进程 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;Hello ,I am child &quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 共享内存</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存基本概念"><a href="#共享内存基本概念" class="headerlink" title="共享内存基本概念"></a>共享内存基本概念</h1><p>共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的互斥访问，可以使用信号量。</p><h1 id="共享内存实现方式"><a href="#共享内存实现方式" class="headerlink" title="共享内存实现方式"></a>共享内存实现方式</h1><p>共享内存通常是各种 IPC 之中效率最高的方式。Linux 之中实现共享内存的方式通常有如下几类：</p><ul><li><strong>mmap</strong> 内存共享映射 （通常用于父子进程之间的内存共享，存在一定局限性，且用到更多的原因是其 零拷贝IO 的特性）</li><li>**System V **的共享内存</li><li><strong>POSIX</strong> 共享内存</li></ul><p>平时讨论主要的共享内存是后面两者，但是 System V 和 POSIX 的共享内存，底层都是基于内存文件系统 <strong>tmpfs</strong> 实现的，二者的主要区别是在接口设计上，</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将多个进程的地址空间映射到同一个物理内存，从而多个进程都能使用这块物理内存；从而可以用来实现不同进程间的数据共享，也即进程之间的通信</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2b5437ee0d9c422ea100773c6cc5523f.png" alt="img"></p><h3 id="shm-共享内存接口函数"><a href="#shm-共享内存接口函数" class="headerlink" title="shm 共享内存接口函数"></a>shm 共享内存接口函数</h3><h4 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="shmget-—-创建共享内存"><a href="#shmget-—-创建共享内存" class="headerlink" title="shmget() — 创建共享内存"></a>shmget() — 创建共享内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong>： 由 ftok 生成的 key 标识，标识系统的唯一 IPC 资源。</p><p><strong>size</strong>： 需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。</p><p><strong>shmflg</strong>： 如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。</p><p>**[返回值]**： 成功时返回一个新建或已经存在的的共享内存标识符，取决于 shmflg 的参数。失败返回 -1 并设置错误码。</p><h4 id="shmat-—-挂接共享内存"><a href="#shmat-—-挂接共享内存" class="headerlink" title="shmat() — 挂接共享内存"></a>shmat() — 挂接共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong> ： <code>shmget()</code>返回的共享内存标识。</p><p><strong>shm_addr</strong> ： 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p><strong>shm_flg</strong> ： 一组标志位，通常为0。</p><p><strong>[返回值]</strong> ： 成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的 <code>shmid_ds</code> 结构中的 <code>shm_nattch</code> 计数器加1（类似于引用计数）；出错返回-1。</p><h4 id="shmdt-—-去关联共享内存"><a href="#shmdt-—-去关联共享内存" class="headerlink" title="shmdt() — 去关联共享内存"></a>shmdt() — 去关联共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shmaddr</strong>： <code>shmat()</code>返回的地址。</p><p>**[返回值]**： 调用成功时返回0，失败时返回-1.</p><h4 id="shmctl-—-控制共享内存（仅删除）"><a href="#shmctl-—-控制共享内存（仅删除）" class="headerlink" title="shmctl() — 控制共享内存（仅删除）"></a>shmctl() — 控制共享内存（仅删除）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong>： <code>shmget()</code> 返回的共享内存标识符。</p><p><strong>command</strong>： 指定的执行操作，设置为<code>IPC_RMID</code>时表示可以删除共享内存。</p><p><strong>buf</strong>：  填 null 即可</p><p>**[返回值]**：成功返回0，失败返回-1。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><h3 id="MMAP-原理"><a href="#MMAP-原理" class="headerlink" title="MMAP 原理"></a>MMAP 原理</h3><ul><li><p>MMAP 本质是把 文件内容 映射到一段内存上 (准确说是虚拟内存上),  </p></li><li><p>因此通过对这段内存的读取和修改, 即可实现对文件的读取和修改,</p></li><li><p><code>mmap()</code> <strong>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存</strong>。</p></li><li><p>文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用 (read,write) 去操作。</p></li></ul><h4 id="MMAP-零拷贝原理："><a href="#MMAP-零拷贝原理：" class="headerlink" title="MMAP 零拷贝原理："></a>MMAP 零拷贝原理：</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240512223136171.png" alt="image-20240512223136171" style="zoom:67%;" /><h4 id="MMAP-共享内存原理："><a href="#MMAP-共享内存原理：" class="headerlink" title="MMAP 共享内存原理："></a>MMAP 共享内存原理：</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1723697-e4822f4555069606.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 信号量</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h1><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值 0 和 1 的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少，本文只介绍二元信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code>和<code>V(sv)</code>,他们的行为是这样的：</p><p>**P(sv)**：如果 sv 的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行</p><p>**V(sv)**：如果有其他进程因等待 sv 而被挂起，就让它恢复运行，如果没有进程因等待 sv 而挂起，就给它加 1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Linux的信号量机制"><a href="#Linux的信号量机制" class="headerlink" title="Linux的信号量机制"></a>Linux的信号量机制</h2><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<code>sys/sem.h</code>中。</p><h3 id="semget-—-信号量创建"><a href="#semget-—-信号量创建" class="headerlink" title="semget() — 信号量创建"></a>semget() — 信号量创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>key</strong>： 整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用 <code>semget()</code> 函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有 <code>semget()</code> 函数才直接使用信号量键，所有其他的信号量函数使用由 <code>semget()</code> 函数返回的信号量标识符。如果多个程序使用相同的 key 值，key 将负责协调工作。</p></li><li><p><strong>num_sems</strong>： 指定需要的信号量数目，它的值几乎总是1。</p></li><li><p><strong>sem_flags</strong>： 一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值 IPC_CREAT 做按位或操作。设置了 IPC_CREAT 标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而  IPC_EXCL 则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code> 函数成功返回一个相应信号标识符（非零），失败返回-1.</p><h3 id="semop-—-改变信号量的值"><a href="#semop-—-改变信号量的值" class="headerlink" title="semop() — 改变信号量的值"></a>semop() — 改变信号量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_opa, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_id</code> 是由 <code>semget()</code> 返回的信号量标识符，<code>sembuf</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> sem_num; <span class="comment">// 除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="type">short</span> sem_op;  <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                   <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">// 通常为SEM_UNDO,使操作系统跟踪信号，</span></span><br><span class="line">                   <span class="comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="semctl-—-修改信号量信息"><a href="#semctl-—-修改信号量信息" class="headerlink" title="semctl() — 修改信号量信息"></a>semctl() — 修改信号量信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_id: semget() 返回的 sem Id</li><li>sem_num: 指定需要的信号量数目，它的值几乎总是1</li><li>command: 通常是下面两个值中的其中一个:<ul><li>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</li><li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符</li></ul></li></ul><p>如果有第四个参数，它通常是一个 <code>union semum</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用信号量实现多进程并发安全"><a href="#用信号量实现多进程并发安全" class="headerlink" title="用信号量实现多进程并发安全"></a>用信号量实现多进程并发安全</h1><h2 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h2><p><strong>进程互斥</strong>：不同进程之间的代码，A进程执行到部分代码字段 时，其他进程不能执行自身特定的代码字段，仅A进程将该字段执行完毕，其他程序才能继续执行</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 信号量机制实现互斥 */</span><br><span class="line">semaphore mutex = 1; // 初始化信号量</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);   // 使用临界资源前需要加锁</span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   // 使用临界资源后需要解锁</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);  </span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h2><p><strong>进程同步</strong>： 散布在不同进程之间的若干程序片段，它们的运行必须严格按照一定的先后次序来运行，这种次序依赖于要完成的任务。比如数据的收发，必须发送方发送了接收方才能收</p><p>用例： 保证代码 4 必须在代码 1,2 之后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程</title>
      <link href="/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/11183270-40bf3033d3e24a39.png" alt="img"></p><p>JVM 线程对主存中的共享变量进行修改时，必须先将共享变量读到自身工作内存中（实际就是CPU Cache），并在工作内存中进行修改，最后再刷回主存。</p><p>（CPU Cache： 缓解 内存 和 CPU 速度相差过大问题， 但 Cache 引入势必造成一致性问题）</p><h2 id="内存交互操作（保证原子性）"><a href="#内存交互操作（保证原子性）" class="headerlink" title="内存交互操作（保证原子性）"></a>内存交互操作（保证原子性）</h2><ul><li><strong>read</strong>： 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li><strong>load</strong>： 把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use</strong>： 把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign</strong>： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li><strong>store</strong>： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li><strong>write</strong>： 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li><li><strong>lock</strong>： 作用于主内存的变量，把一个变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li></ul><h3 id="相关规则"><a href="#相关规则" class="headerlink" title="相关规则"></a>相关规则</h3><ul><li>read &#x2F; load 和 store &#x2F; write  操作必须成对按序使用</li><li>变量 assign 之后必须存在 stire&#x2F;write 将其写回主存</li><li>加载完但未执行 assign 的变量 ，不允许重新写回主存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个线程 lock 了一个变量，后续该线程 且 仅有该线程能继续 lock 该变量； 直至调用相同 次数 unlock ，完成解锁</li><li>变量被 lock ，所有工作内存中的副本将被清除，因此执行引擎使用该变量前，必须重新 load 或 assign 以初始化变量的值</li><li>只能 unlock 被当前线程 lock 了的变量</li><li>对一个变量进行 unlock 操作之前，必须把此变量同步回主内存</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>烂八股：</p><ul><li><strong>保证可见性</strong>： 线程对 volatile 变量修改后，强制将其刷回主存，并使其他 CPU 中的对应缓存行失效（MESI 和 内存屏障的作用）</li><li><strong>禁止指令重排：</strong> 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果 （阿里开发手册中关于 DCL 单例中的说明）</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从汇编角度看，volatile 的作用基于 lock 前缀指令 —— 在线程对缓存行内变量执行写操作时，发出一个 lock 指令，锁住总线&#x2F;或缓存行，同时让 其他cpu中的缓存行失效，并将修改后的数据强制写回主存</p><h2 id="volatile-int-i-错误原因分析："><a href="#volatile-int-i-错误原因分析：" class="headerlink" title="volatile int i++ 错误原因分析："></a>volatile int i++ 错误原因分析：</h2><p>i++ 非原子性操作，</p><ul><li>读取 i</li><li>i 自增</li><li>回写 i</li></ul><p>volatile 可以保证第二 和 第三步 会合并成一个原子操作</p><p>但若两个 thread 读取操作发生在 peer 的改值操作之前，还是不能保证线程安全</p><p><strong>【参考】</strong></p><ul><li><a href="https://www.cnblogs.com/badboys/p/12695183.html">volatile与lock前缀指令 - 干饭人~ - 博客园 (cnblogs.com)</a></li></ul><h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Synchronized  是 java 中用来实现 线程同步&#x2F;互斥 编程的一个关键字，可以用来修饰</p><ul><li>实例方法 —— 锁住当前对象</li><li>静态方法 —— 锁住当前类对象</li><li>代码块 —— 静态代码块，锁住当前类对象； 普通代码块，锁住当前对象</li></ul><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>无论是哪种使用方法，<code>synchronized</code> 底层都是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 两个 jvm 指令实现的</p><p>而 <code>monitorenter</code> 和 <code>monitorexit</code> 则是基于 <code>markworkd 及 </code>objectmonitor&#96; 实现</p><h3 id="markword-对象头"><a href="#markword-对象头" class="headerlink" title="markword &#x2F; 对象头"></a>markword &#x2F; 对象头</h3><h4 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h4><ul><li>对象头</li><li>实例数据</li><li>对其填充字节</li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul><li>Markword</li><li>类指针</li><li>数组长度（仅数组对象有）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/aa.png" alt="aa"></p><h2 id="Synchronized-锁升级"><a href="#Synchronized-锁升级" class="headerlink" title="Synchronized 锁升级"></a>Synchronized 锁升级</h2><ol><li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li><li>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在 Markword 的偏向线程 ID 里存储当前线程的操作系统线程 ID，偏向锁标识位是1，锁标识位是01。<ul><li>从jdk1.6之后，JVM有两个默认参数是开启的，-XX:+UseBiasedLocking（表示启用偏向锁，想要关闭偏向锁，可添加JVM参数：-XX:-UseBiasedLocking），-XX:BiasedLockingStartupDelay&#x3D;4000（表示JVM启动4秒后打开偏向锁，也可以自定义这个延迟时间，如果设置成0，那么JVM启动就打开偏向锁）。</li><li>此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。</li><li>另外需要注意的是，由于硬件资源的不断升级，获取锁的成本随之下降，jdk15版本后默认关闭了偏向锁。<br>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前）有线程访问共享资源则直接由无锁升级为轻量级锁，</li></ul></li><li>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<ul><li>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。</li></ul></li><li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的 mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter 指令插入到同步代码块在编译后的开始位置，monitorexit 指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240528011826870.png" alt="image-20240528011826870"></p><h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/932045510502514689.png" alt="932045510502514689"></p><p><strong>【参考】</strong></p><ul><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现–概论 · Issue #12 · farmerjohngit&#x2F;myblog (github.com)</a></li></ul><h1 id="乐观锁-与-悲观锁"><a href="#乐观锁-与-悲观锁" class="headerlink" title="乐观锁 与 悲观锁"></a>乐观锁 与 悲观锁</h1><p>~ 是并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><p>悲观锁和乐观锁是实现并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>悲观锁 的 线程安全控制策略 适用于 并发写操作较多的场景，</li><li>悲观锁 在加锁期间，其他线程无法访问被锁定的资源，从而保证了数据的完整性。</li><li>悲观锁 需要频繁地进行加锁和解锁操作，开销较大。</li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>乐观锁适用于并发读操作较多的场景，因为读操作不涉及到数据的修改，不需要加锁。</li><li>乐观锁在更新数据时，只有在提交更新操作时才对数据进行版本检查，减少了加锁和解锁的开销。</li><li>乐观锁可能需要进行重试，以处理并发修改引起的冲突。</li></ul><p>乐观锁常用 <strong>CAS</strong> 或 **版本号 ** 机制 进行实现</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ， 即 仅比较通过才会进行设值， CAS 是乐观锁的主要实现方式之一</p><p>CAS 依赖于操作系统原语，更底层则依赖于 硬件指令集，即 CAS 最终由 硬件保证操作的原子性</p><h3 id="JAVA-CAS"><a href="#JAVA-CAS" class="headerlink" title="JAVA CAS"></a>JAVA CAS</h3><p>java cas 相关实现依赖于 Unsafe 类提供的一系列 JNI 接口</p><h3 id="CAS-相关问题"><a href="#CAS-相关问题" class="headerlink" title="CAS 相关问题"></a>CAS 相关问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><ul><li><p>CAS 操作成功，并不意味着值在 cas 所处指令序列的 值读取 与 CAS 设值 之间没有发生过 变更</p></li><li><p>解决：在变量前面追加上<strong>版本号或者时间戳</strong></p></li></ul><h4 id="自旋空转"><a href="#自旋空转" class="headerlink" title="自旋空转"></a>自旋空转</h4><p><strong>说明</strong>： CAS 经常会用自旋操作来进行重试，即不成功就一直循环直至成功为止。但若如果长时间不成功，会给 CPU 造成较大负担</p><p><strong>解决</strong>：参考 synchronized 引入适应性自旋，或限制自旋次数</p><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>两个线程各自锁住一个资源，并无限期等待&#x2F;请求 对方锁住的资源，导致两个线程相互等待，导致程序无限期卡死</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601020943517.png" alt="image-20240601020943517"></p><h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul><li><p><strong>互斥使用</strong>，即当资源被一个线程占用时，别的线程不能使用</p></li><li><p><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</p></li></ul><ul><li><strong>请求和保持</strong>，当资源请求者在请求其他资源的同时保持对原因资源的占有</li><li><strong>循环等待</strong>，多个线程存在环路的锁依赖关系而永远等待下去，例如T1占有T2的资源，T2占有T3的资源，T3占有T1的资源，这种情况可能会形成一个等待环路</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>从死锁条件着手，破坏其中一个即可（互斥是基本需求，不能破坏）</p><p>实际常用的有：</p><ul><li>一次性申请所有资源</li><li>各方按相同顺序申请资源</li><li>给申请资源的等待时间设置限制</li><li>无法实现前面几种，还可以升级锁粒度，用一个大的锁控制全局互斥</li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul><li>jstack 进程号<ul><li>指令运行结果会提示 相应 进程存在死锁问题</li><li>可先用 jps -l 查看所有java 进程</li></ul></li><li>使用图形化工具 jconsole.exe 或 jvisualvm.exe 会自动检测死锁</li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程</title>
      <link href="/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux线程概念"><a href="#一、Linux线程概念" class="headerlink" title="一、Linux线程概念"></a>一、Linux线程概念</h1><h2 id="1、什么是线程"><a href="#1、什么是线程" class="headerlink" title="1、什么是线程"></a>1、什么是线程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509040108318.png" alt="image-20240509040108318"></p><p>首先从 <strong>进程</strong> 讲起，一个进程有自己对应的 PCB，虚拟地址空间，页表以及映射的物理内存，也即 <code>进程 = 内核数据结构 + 进程对应的代码和数据</code>。</p><p>对于<strong>虚存</strong>：虚拟内存决定了进程能够看到的”资源”。因为每一个进程都有对应的虚拟内存，所以进程具有独立性，从而进程需要通信的前提是看到同一份资源。</p><p>通过 fork 创建子进程的时候，会将父进程的PCB的内容，进程地址空间和页表都给子进程拷贝一份。</p><p><code>而如果创建多个 PCB，并将这些 PCB 使用同一个进程地址空间和页表，这样就可以看到同一份资源了，这就是线程。</code></p><p>因此可以将 线程 理解为 进程 内的一个执行流，线程在进程内运行，线程在进程的地址空间内运行，拥有该进程的一部分资源。</p><p>也即 线程是 CPU 调度的基本单位。进程 则是承担系统资源的基本实体，内部可以有一个或多个执行流。因为我们可以通过虚拟地址空间+页表的方式对进程的资源进行划分，单个”进程”(线程)执行粒度，一定要比之前的进程要细。</p><p>如果 OS 要专门设计线程的概念，就需要对线程进行管理，也就需要先描述，再组织，即一定要为线程设计专门的数据结构表示线程对象TCB。但是线程和进程一样都需要被执行，被调度(id,状态，优先级，上下文，栈…)，二者十分相似，所以单纯从线程调度角度，线程和进程有很多的地方是重叠的。所以Linux工程师不想给”线程”专门设计对应的数据结构，而是直接复用PCB，用 PCB 用来表示 Linux 内部的”线程”, 所以在Linux中，进程我们称为轻量级进程。而 windows 有单独的TCB结构</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>.Linux 内核中没有真正意义是线程，Linux是用进程的 PCB 来进行模拟，是一种完全属于自己的一套线程方案</p></li><li><p>站在 CPU视角，每一个PCB，都可以称之为轻量级进程</p></li><li><p>Linux 线程是 CPU 调度的基本单位，而进程是承担资源分配的基本单位</p></li><li><p>进程用来整体申请资源，线程用来伸手向进程要资源</p></li><li><p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”</p></li><li><p>一切进程至少都有一个执行线程</p></li><li><p>线程在进程内部运行，本质是在进程地址空间内运行</p></li><li><p>在 Linux 系统中，在 CPU 眼中，看到的 PCB 都要比传统的进程更加轻量化</p></li><li><p>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</p></li></ol><p>Linux内核中没有真正意义是线程，所以Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口，但是操作系统只认线程，用户(程序员)也只认线程，所以Linux在软件层提供了一个原生的线程库。</p><p>任何 Linux 操作系统，都必须默认携带这个原生线程库–用户级线程库</p><p>线程创建用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是新线程, 我正在运行! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> n = pthread_create(&amp;tid, nullptr, start_routine, (<span class="type">void</span> *)<span class="string">&quot;thread one&quot;</span>);</span><br><span class="line">    assert(<span class="number">0</span> == n);</span><br><span class="line">    (<span class="type">void</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是主线程, 我正在运行!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多<ul><li>进程：切换页表 &amp;&amp; 虚拟地址空间 &amp;&amp; 切换PCB &amp;&amp;上下文切换</li><li>线程：切换PCB &amp;&amp;上下文切换</li></ul></li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I&#x2F;O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I&#x2F;O密集型应用，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能损失</strong> —— 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><strong>健壮性降低</strong> —— 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><strong>缺乏访问控制</strong> —— 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><strong>编程难度提高</strong> —— 编写与调试一个多线程程序比单线程程序困难得多</li></ol><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃，<strong>因为信号在整体发给进程的</strong></p><p>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</p><h1 id="二、线程控制"><a href="#二、线程控制" class="headerlink" title="二、线程控制"></a>二、线程控制</h1><h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><h4 id="创建线程函数接口-–-pthread-create"><a href="#创建线程函数接口-–-pthread-create" class="headerlink" title="创建线程函数接口 – pthread_create"></a>创建线程函数接口 – pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建一个新的线程</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// thread_label: 线程标识符</span></span><br><span class="line"><span class="comment">// attr:设置线程的属性，attr为NULL表示使用默认属性</span></span><br><span class="line"><span class="comment">// start_routine:是个函数地址，线程启动后要执行的函数</span></span><br><span class="line"><span class="comment">// arg:传给线程启动函数的参数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread_label, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread_label 实际上是进程地址空间上的一个地址</li><li>用户线程、用户进程、内核线程 关系后续补充</li></ul><h2 id="2-线程终止"><a href="#2-线程终止" class="headerlink" title="2. 线程终止"></a>2. 线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法</p><ul><li>从线程函数 return。这种方法对主线程不适用，因为从 main 函数 return 相当于调用 exit。</li><li>线程调用 pthread_ exit 终止自己。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value_ptr:value_ptr不要指向一个局部变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure><ul><li>一个线程可以调用 pthread_ cancel 终止同一进程中的另一个线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread:线程ID</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS 详解</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>Java 自带的各种同步工具类的 基石</p><p>将临界资源抽象成一个 <code>volatile int stat</code>，并通过 cas 操作进行加减锁</p><p>此外，AQS 设计了一个 FIFO 的线程等待 （双向）队列，用以帮助并发竞争的线程间 进行 阻塞、唤醒等功能</p><p>而且，提供基础的 排它锁、共享锁设计基础， 实现类可在此基础上进一步补充 公平、非公平机制，实现常用锁功能和特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span>/Setter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁相关"><a href="#写锁相关" class="headerlink" title="写锁相关"></a>写锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>acquire 由 实现类的 lock() 调用，调用前 及 tryAcquire 具体实现中可自定义 公平&#x2F;非公平策略</li></ul><h2 id="共享锁相关"><a href="#共享锁相关" class="headerlink" title="共享锁相关"></a>共享锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">// 由子类实现</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 找到前继节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);<span class="comment">// 由子类实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平-与-非公平-写锁-–-以-ReentrantLock-为例"><a href="#公平-与-非公平-写锁-–-以-ReentrantLock-为例" class="headerlink" title="公平 与 非公平 写锁 – 以 ReentrantLock 为例"></a>公平 与 非公平 写锁 – 以 ReentrantLock 为例</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li><h4 id="fair-lock"><a href="#fair-lock" class="headerlink" title="fair lock"></a>fair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="unfair-lock"><a href="#unfair-lock" class="headerlink" title="unfair lock"></a>unfair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 总结</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="作用-使用场景"><a href="#作用-使用场景" class="headerlink" title="作用 &#x2F; 使用场景"></a>作用 &#x2F; 使用场景</h2><ul><li>线程隔离</li><li>同一 &#x2F; 父子 线程内跨方法传参</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>废话不多说，直接看代码</p><p>先是 ThreadLocal 类本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>ThreadLocal</code> 设值是找到当前线程的 <code>ThreadLocalMap</code> 对象，并以 <code>ThreadLocal</code> 对象自身为 key，以传入值为 value 添加 entry </p><p>所以再看 <code>Thread</code>  中的相关定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 对象实际是 <code>ThreadLocal</code> 的 静态内部类，看一下类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal Map</code> 还包含几个核心方法——<code>getEntry</code>、<code>set()</code>、<code>remove()</code>， 其总体实现逻辑与 常规 Map 没什么太大差别，这里就不展开细讲了</p><p>这里主要讲一下 <code>ThreadLocalMap</code> 中这个 <code>WeakReference</code>， 这也是 ThreadLocal 常被诟病的内存泄漏的问题分析基石</p><h2 id="ThreadLocal-内存泄漏问题分析"><a href="#ThreadLocal-内存泄漏问题分析" class="headerlink" title="ThreadLocal 内存泄漏问题分析"></a>ThreadLocal 内存泄漏问题分析</h2><ul><li><code>Entry</code> 继承自 <code>ThreadLocal&lt;?&gt;</code> 的弱引用， 而 <code>Entry</code> 构造时，父类构造函数调用传入的是参数是 key 也即 <code>ThreadLocal</code> 对象，而 <code>super()</code> 调用过程也就是 弱引用的创建过程，因此，<code>ThreadLocal</code> 中的弱引用实际是 <code>Entry</code> -&gt; <code>ThreadLocal</code> (key) 的弱引用</li><li>而实际上存在 <code>thread</code> -&gt; <code>threadLocalMap</code> -&gt; <code>Entry[]</code> -&gt; <code>entry</code> -&gt; <code>value</code> 的强引用链</li></ul><p>所以在以下场景中，<code>threadlocal</code> 会有内存泄漏问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        createThreadLocal();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601012342860.png" alt="image-20240601012342860"></p><h3 id="ThreadLocal-中-弱引用的作用"><a href="#ThreadLocal-中-弱引用的作用" class="headerlink" title="ThreadLocal 中 弱引用的作用"></a>ThreadLocal 中 弱引用的作用</h3><p>到这，弱引用的作用就比较清楚了</p><ul><li>可以保证 <code>threadLocal</code> 对象本身 可以在 GC 时被正常回收</li><li>但 <code>Value</code> 实际上还是强引用可达，因此并不能被 GC 自动回收，可能还是会造成内存泄漏</li></ul><h3 id="ThreadLocal-如何防止内存泄漏"><a href="#ThreadLocal-如何防止内存泄漏" class="headerlink" title="ThreadLocal 如何防止内存泄漏"></a>ThreadLocal 如何防止内存泄漏</h3><ul><li>使用完手动 <code>remove()</code></li></ul><h2 id="JAVA-引用类型"><a href="#JAVA-引用类型" class="headerlink" title="JAVA 引用类型"></a>JAVA 引用类型</h2><ul><li>强引用 —— 无论内存是否充足，均不回收</li><li>软引用 —— GC 时内存充足不回收，不充足时会回收<ul><li>意思是内存充足也会发生GC ?   手动触发 <code>System.gc()</code> ?</li></ul></li><li>弱引用 —— 无论内存是否充足，只要发生 GC ，都会将其回收</li><li>虚引用 —— 普通开发中几乎不会用到，一般在 GC 过程当中有使用<ul><li>参考： <a href="https://www.cnblogs.com/mfrank/p/9837070.html">你不可不知的Java引用类型之——虚引用 - 弗兰克的猫 - 博客园 (cnblogs.com)</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程基础</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul><li>进程可以理解为程序的一次执行过程，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>现代操作系统对于进程会分配独立的 内存地址空间和其他系统资源（IO）</li><li>对 Java 而言，<code>main()</code> 函数启动时其实就是启动了一个 JVM 的进程，而 <code>main()</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul><li>线程是依托于进程的一个指令执行序列</li><li>一个进程可以产生多个线程</li><li>linux中，线程又叫做轻量级进程（light-weight process LWP），也有PCB，创建线程使用的底层函数和进程底层一样，都是clone，但没有独立的地址空间；而进程有独立地址空间，拥有PCB。</li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>包含关系</strong>：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>资源开销</strong>：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><strong>管道 pipe</strong><ul><li><strong>管道概念</strong>：<ul><li>管道是一种半双工的通信方式，用以传输字节流</li><li>本质是内核中基于环形队列设计的一段缓冲区，对应着两个文件描述符，一个赋予读权限，一个赋予写权限</li><li>数据只能单向流动，一端写和一端读</li></ul></li><li><strong>分类</strong><ul><li><strong>匿名管道</strong>： 只能在父子或亲缘进程间使用</li><li><strong>命名管道</strong>：允许非情缘关系进程间进行通信</li></ul></li></ul></li></ul><ul><li><strong>消息队列</strong>：本质是 OS 内核中维护的一个 尾插头读 的链表，<ul><li>与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息</li></ul></li><li><strong>共享存储</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<ul><li><strong>优点</strong>：其他IPC一般涉及数据拷贝、传输，而共享内存不需要，因此 CPU、内存负载更低，同时提高了处理速度</li><li><strong>缺点</strong>：会引入并发安全问题，需引入信号量等机制，确保线程安全性</li><li><strong>实现方式</strong>：有 mmap 和 shmget 两种</li></ul></li><li><strong>信号量</strong>：信号量本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</li><li><strong>套接字</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li><strong>信号</strong>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul><h2 id="进程互斥-与-同步"><a href="#进程互斥-与-同步" class="headerlink" title="进程互斥 与 同步"></a>进程互斥 与 同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>在操作系统中，进程是占有资源的最小单位。对于某些资源来说，可能有多个进程需要占用，但是为了保障操作系统和指令的正常执行，有些资源在同一时间只能被其中一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p><p>典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p><p> 对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p><p>  对于临界区的访问过程分为四个部分：</p><ol><li><strong>进入区</strong>:  查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li><li><strong>临界区</strong>:  在临界区做操作</li><li><strong>退出区</strong>:  清除临界区被占用的标志</li><li><strong>剩余区</strong>：进程与临界区不相关部分的代码</li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>多进程完成某个任务时，进程之间 部分指令 或 代码块 的执行需按照指定先后关系按序执行</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>并行的多个进程 访问临界资源，在其中一个进程A进入临界区后，其他线程在进入临界区前必须阻塞等待进程 A 退出临界区</p><h1 id="CPU-Cache-一致性"><a href="#CPU-Cache-一致性" class="headerlink" title="CPU Cache 一致性"></a>CPU Cache 一致性</h1><p>在单核 CPU 中，只需要考虑 Cache 与 内存 的一致性。但是在多核 CPU 中，由于每个核心都有一份独占的 Cache，就会存在一个核心修改数据后，两个核心 Cache 数据不一致的问题。因此， CPU 缓存一致性问题应该从 2 个维度理解：</p><ul><li><strong>纵向：Cache 与 内存 的一致性问题：</strong> 在修改 Cache 数据后，如何同步回内存？</li><li><strong>横向：多核心 Cache 的一致性问题：</strong> 在一个核心修改 Cache 数据后，如何同步给其他核心 Cache？</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511022424797.png" alt="image-20240511022424797" style="zoom:50%;" /><h2 id="单核场景-cache-与-内存数据一致性"><a href="#单核场景-cache-与-内存数据一致性" class="headerlink" title="单核场景 cache 与 内存数据一致性"></a>单核场景 cache 与 内存数据一致性</h2><ul><li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li><li><strong>写回</strong>：数据在被写入到 CPU 缓存时不会立即同步到内存，而是暂时保存在缓存中。只有在缓存行被替换出缓存（缓存算法对其进行淘汰）时，才会将该缓存行的数据写回到内存中。</li></ul><h2 id="多核场景-cache-一致性"><a href="#多核场景-cache-一致性" class="headerlink" title="多核场景 cache 一致性"></a>多核场景 cache 一致性</h2><h3 id="多核-cache-一致性保证条件"><a href="#多核-cache-一致性保证条件" class="headerlink" title="多核 cache 一致性保证条件"></a>多核 cache 一致性保证条件</h3><ul><li><strong>写传播</strong> —— 某个core 修改某个变量后，其他 core 需要及时感知</li><li>**串行化 ** —— 某个 core 的连续操作，对其他 core 而言，观察到的顺序一致</li></ul><h3 id="cache-一致性协议基石"><a href="#cache-一致性协议基石" class="headerlink" title="cache 一致性协议基石"></a>cache 一致性协议基石</h3><ul><li><strong>写传播 - 总线嗅探：</strong> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。要实现写传播，其实就是将所有的读写操作广播到所有 CPU 核心，而其它 CPU 核心时刻监听总线上的广播，再修改本地的数据；</li><li><strong>事务串行化 - 总线仲裁：</strong> 总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。</li></ul><h2 id="MESI-协议-（默认生效）"><a href="#MESI-协议-（默认生效）" class="headerlink" title="MESI 协议 （默认生效）"></a><strong>MESI 协议</strong> （默认生效）</h2><p>MESI 对应 CPU Cache 中的四种状态</p><ul><li><strong>M</strong>: modified</li><li><strong>E</strong>: Exclusive</li><li><strong>S</strong>: Share</li><li><strong>I</strong>: invalid</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015059650.png" alt="image-20240511015059650" style="zoom:60%;" /><p>由于 修改等操作 需其他 CPU 进行ACK ，影响速率，因此引入 Store Buffer 和 Invalid Queue</p><p>CPU A 修改某个值时，直接将值写入 Store Buffer，并向其他 CPU 失效队列投递 invalid 通知，Invalid 通知成功（兑入对应invalid queue） 再将 store buffer 值 写入 cache</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015623898.png" alt="image-20240511015623898" style="zoom:50%;" /><p>store buffer 和 invalid queue 加快了程序运行速度，但 也带来了问题 —— CPU 间 数据强一致性为了最终一致 &#x2F; 弱一致</p><h2 id="内存屏障解决-有序性问题"><a href="#内存屏障解决-有序性问题" class="headerlink" title="内存屏障解决 有序性问题"></a>内存屏障解决 有序性问题</h2><h3 id="编译器内存屏障"><a href="#编译器内存屏障" class="headerlink" title="编译器内存屏障"></a>编译器内存屏障</h3><p>Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成——内存屏障调用前后指令不乱序执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="CPU-内存屏障"><a href="#CPU-内存屏障" class="headerlink" title="CPU 内存屏障"></a>CPU 内存屏障</h3><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>先看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;   </span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若某一时刻， CPU0 cache 占有 变量 b&#x3D;0，准备执行 func0()， CPU1 cache 占有变量 a&#x3D;0， 准备执行 func1()； 且后续执行流程如下：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>CPU 0 继续执行赋值语句 b&#x3D;1，由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line。</li><li>CPU 1执行 while (b &#x3D;&#x3D; 0) 循环，由于 b 不在CPU 1 的 cache 中，因此，CPU发送一个 read message 到总线上，尝试从其他 cpu 的 localcache 或者 memory 中读取数据。</li><li>CPU 0 收到 read message，将最新的 b 值 1 回送给 CPU1，同时将 b cacheline的状态设定为 S。</li><li>CPU 1 收到了来自 CPU 0 的 read response，将 b 变量最新值 1 值写入自己的 cacheline，状态修改为shared。</li><li>由于 b 值等于 1 ，CPU 1跳出while (b &#x3D;&#x3D; 0)的循环，继续执行。</li><li>CPU 1 执行 assert(a &#x3D;&#x3D; 1)，这时候 CPU1 中的local cache中还是旧的a值，因此assert(a &#x3D;&#x3D; 1)失败。<strong>程序异常</strong></li></ol><p>为避免缓存不一致问题引起的 异常结果， 可在 a&#x3D;1 的赋值操作之后加上写内存屏障，此时 ：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>cpu0 完成 a&#x3D;1 复制操作之后，遇到写内存屏障，执行 flush store buffer</li><li>cpu0 阻塞等待 store buffer 中所有记录 得到 ACK</li><li>cpu1 cache line 收到 a 变量 invalid 消息，并自动 ACK</li><li><strong>cpu1 完成 invalid  queue 处理，修改 local cache 中 cacheline a&#x3D;1 状态为 I</strong></li><li>cpu0 阻塞结束，继续执行 b&#x3D;1 赋值， 由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line</li><li>若不考虑 cpu1 的 invalid queue 主动 ack，则cpu1 判断 a&#x3D;&#x3D;1 时，将发现cache line 中的 缓存已失效，需重新从总线获取，此时 assert t通过</li></ol><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>仍以上例说明，由于 cpu1 存在 invalid queue ，会自动回复 ACK，所以：</p><ul><li>若 cpu1 未及时完成 invalid queue 处理， 则 CPU1 后续执行 a&#x3D;&#x3D;1 判断时，会判断 cache 中 有cacheline 命中，因此仍有可能失败</li></ul><p>因此，为确保 invalid queue 数据及时处理</p><ul><li>进一步在 assert(a&#x3D;&#x3D;1) 之前加上 读内存屏障</li></ul><p>读内存屏障作用为——cpu 下一次读取操作前，必须 flush invalid queue</p><p>因此，以上例子在无锁添加下，可通过以下改造确保程序运行正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  smp_mb();  <span class="comment">// 写内存屏障</span></span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  smp_rmb();<span class="comment">// 读内存屏障</span></span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发安全性基础"><a href="#并发安全性基础" class="headerlink" title="并发安全性基础"></a>并发安全性基础</h1><ul><li><strong>原子性</strong> —— 一个线程的一组操作要么未执行，要么全部执行，即使中间因线程调度而中断，其总体执行结果与一次性执行完毕的结果无异，本质就是 多线程&#x2F;进程 对临界资源的互斥访问</li><li><strong>可见性</strong> —— 多个线程修改同一个共享变量时，一个线程修改后，其他线程能马上获得修改后的值</li><li><strong>有序性</strong> —— 即程序执行的顺序按照代码的先后顺序执行</li></ul><h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><h2 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h2><p>指令重排是计算机编译器或处理器为了提高性能而对指令执行顺序进行的一种优化手段。</p><p>在多核和多线程的计算机系统中，指令重排的目标是通过优化执行顺序来提高指令级别的并行度，充分发挥计算资源，加速程序的执行</p><h2 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><h3 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h3><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p><h3 id="指令级并行的重排序"><a href="#指令级并行的重排序" class="headerlink" title="指令级并行的重排序"></a>指令级并行的重排序</h3><p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><h3 id="内存系统的重排"><a href="#内存系统的重排" class="headerlink" title="内存系统的重排"></a>内存系统的重排</h3><p>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>也即源代码从编译到最终运行之间可能涉及的重排序流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240526135057956.png" alt="image-20240526135057956"></p><h2 id="指令重排的准则-（以-java-为例）"><a href="#指令重排的准则-（以-java-为例）" class="headerlink" title="指令重排的准则 （以 java 为例）"></a>指令重排的准则 （以 java 为例）</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><h4 id="语义"><a href="#语义" class="headerlink" title="语义:"></a><strong>语义:</strong></h4><p><strong>不管怎么重排序</strong> ，程序在单线程情况下的运行结果不能改变。</p><p>编译器、runtime和处理器都必须遵守as-if-serial语 义。</p><p>为了遵守 as-if-serial ，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。</p><p>但是，如果操作之间不存在数据依赖关系，这些操作就可 能被编译器和处理器重排序。但这种重排序可能在多线程情况下引入问题</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><h4 id="程序顺序原则"><a href="#程序顺序原则" class="headerlink" title="程序顺序原则"></a>程序顺序原则</h4><p>　　即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p><h4 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则"></a>锁规则</h4><p>　　解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</p><h4 id="volatile规则"><a href="#volatile规则" class="headerlink" title="volatile规则"></a>volatile规则</h4><p>　　volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，<strong>都强迫从主内存中读该变量的 值</strong>，而<strong>当该变量发生变化时，又会强迫将最新的值刷新到主内存</strong>，任何时刻，不同的 线程总是能够看到该变量的最新值。</p><h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>　　线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>　　A先于B ，B先于C 那么A必然先于C</p><h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p>　　线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p>　　对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>　　对象的构造函数执行，结束先于finalize()方法 </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 并发编程 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li>继承Thread 类</li><li>实现 Runable 接口</li><li>实现 callable 接口</li><li>使用线程池</li></ul><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>此外，严格来说，Java 其实只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h2 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h2><ul><li><p><strong>wait()</strong></p><ul><li>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，</li><li>会释放对象的锁</li></ul></li><li><p><strong>sleep()</strong></p><ul><li>sleep 导致当前线程休眠，sleep(long)会导致线程进入TIMED-WATING 状态</li><li>不会释放锁</li></ul></li><li><p><strong>yield()</strong></p><ul><li>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。</li><li>不释放锁</li></ul></li><li><p><strong>join()</strong></p><ul><li>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位，这个线程本身并不会因此而改变状态(如阻塞，终止等)。</li></ul></li><li><p><strong>interrupt()</strong></p><ul><li>将一个阻塞状态线程的中断标志位置位，并使其中断&#x2F;抛出异常，抛出异常后 清楚中断标记位</li><li></li></ul></li></ul><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1383841-20190624155001636-644135935.jpg" alt="img"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java线程可以具有不同的优先级，用于告诉操作系统在竞争CPU时间片时应该优先考虑哪个线程。线程的优先级范围从1到10，默认优先级是5。您可以使用setPriority()方法设置线程的优先级，范围从1（最低优先级）到10（最高优先级）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><h2 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h2><p><strong>池化思想</strong>： 频繁创建销毁的东西，尽量设计成一个可以预分配、使用后归还、且可重复使用的模式，并交由一个管理器进行统一管理，以负责可复用对象的初始化、申请和归还处理；</p><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="使用-Executors-工具"><a href="#使用-Executors-工具" class="headerlink" title="使用 Executors 工具"></a>使用 Executors 工具</h3><ul><li><p>Executors.newFixedThreadPool</p></li><li><p>Executors.newSingleThreadExecutor</p></li><li><p>Executors.newCachedThreadPool</p></li><li><p>Executors.newScheduledThreadPool</p></li><li><p>Executors.newSingleThreadScheduledExecutor</p></li></ul><h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><h4 id="通用线程池-——-ThreadPoolExecutor"><a href="#通用线程池-——-ThreadPoolExecutor" class="headerlink" title="通用线程池 —— ThreadPoolExecutor"></a>通用线程池 —— ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a><strong>参数列表</strong></h5><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize： 最大线程数</li><li>keepAliveTime： 超出核心线程数的线程闲置后，最大存活时间</li><li>unit： 最大存活时间对应时间单位</li><li>workQueue： 任务队列</li><li>threadFactory： 线程工厂（可以配置线程命名、优先级等）</li><li>handler： 拒绝策略（可以集成 prometheus 实现埋点上报）<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240607015733333.png" alt="image-20240607015733333"><ul><li>AbortPolicy —— 不执行，并抛出异常</li><li>CallerRunPolicy —— 调用者执行</li><li>DiscardPolicy —— 不执行，也不抛出异常</li><li>DiscardOldestPolicy —— 不抛出异常，换掉最旧的任务</li></ul></li></ul><h4 id="延时任务线程池-——-ScheduledThreadPoolExecutor"><a href="#延时任务线程池-——-ScheduledThreadPoolExecutor" class="headerlink" title="延时任务线程池 —— ScheduledThreadPoolExecutor"></a>延时任务线程池 —— ScheduledThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞队列为无界队列</li></ul><h2 id="线程池参数设置"><a href="#线程池参数设置" class="headerlink" title="线程池参数设置"></a>线程池参数设置</h2><h3 id="核心线程数大小"><a href="#核心线程数大小" class="headerlink" title="核心线程数大小"></a>核心线程数大小</h3><ul><li>corePoolSize：<ul><li>CPU 密集型： CPU 核数 + 1</li><li>IO 密集型:  CPU 核数 * 2</li></ul></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p>无界队列</p><ul><li>LinkedBlockingQueue</li></ul></li><li><p>有界队列</p><ul><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 并发编程 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，<code>Collection</code> 接口派生三个子接口 <code>List</code> <code>Set</code> <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240506003529811.png" alt="image-20240506003529811"></p><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>: 底层 Object 数组</li><li><code>Vector</code>: 底层 Object 数组</li><li><code>LinkedList</code>: 底层双向链表</li></ul></li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code> : 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆</li><li><code>DelayQueue</code>:&#96;PriorityQueue&#96;&#96;</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值<ul><li><code>HashMap</code>：数组 + 链表 + 红黑树</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-Array（数组）的区别"><a href="#ArrayList-和-Array（数组）的区别" class="headerlink" title="ArrayList 和 Array（数组）的区别"></a>ArrayList 和 Array（数组）的区别</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h2 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h2><h3 id="插入——add-："><a href="#插入——add-：" class="headerlink" title="插入——add()："></a>插入——add()：</h3><ul><li>头插：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾插：<ul><li>当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul></li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul><li><strong>头部删除</strong>：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li><strong>尾部删除</strong>：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li><strong>指定位置删除</strong>：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)</li></ul><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;</h2><p>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><p>ArrayList 的扩容是创建一个<strong>1.5 倍</strong>的新数组，然后把原数组的值拷贝过去。</p><h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>不推荐使用</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>写时复制技术，可以保障读写并发安全性</li></ul><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><ul><li>代理对象，额外创建mutex ，执行相关操作时，对mutex 加锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><h4 id="Queue-相关API"><a href="#Queue-相关API" class="headerlink" title="Queue 相关API"></a>Queue 相关API</h4><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><h4 id="Deque-相关API"><a href="#Deque-相关API" class="headerlink" title="Deque 相关API"></a>Deque 相关API</h4><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>此外，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-对比"><a href="#ArrayDeque-与-LinkedList-对比" class="headerlink" title="ArrayDeque 与 LinkedList 对比"></a>ArrayDeque 与 LinkedList 对比</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个<code>queue</code>的子接口。<code>BlockingQueue</code> 定义了阻塞式等待的插入和拿取操作（也可指定超时时间）</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制</li><li>读写&#x2F;生产消费 使用一把锁</li><li>提前分配内存，可能存在内存浪费，但是会快些</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>基于链表实现的阻塞队列</li><li>读写锁分离</li><li>无内存浪费，但是需要动态申请堆内存，会慢些</li></ul><h4 id="其他阻塞队列"><a href="#其他阻塞队列" class="headerlink" title="其他阻塞队列"></a>其他阻塞队列</h4><ul><li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p></li><li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p></li><li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的hash表，已不建议使用</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ul><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="&#x3D;&#x3D;HashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>&#x3D;&#x3D;<strong>数组 + 链表 + 红黑树</strong>&#x3D;&#x3D; （1.8 以后）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509021422847.png" alt="image-20240509021422847"></p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>默认长度： 16</li><li>最大长度： 2^30</li><li>负载因子： 0.75</li><li>链表树化阈值： 8</li><li>红黑树退化阈值： 6</li><li>链表树化时数组长度阈值： 64</li><li>node 数组扩容倍数： 2</li></ul><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509022413104.png" alt="image-20240509022413104"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><h4 id="常用的hash冲突解决办法"><a href="#常用的hash冲突解决办法" class="headerlink" title="常用的hash冲突解决办法"></a>常用的hash冲突解决办法</h4><ul><li>再哈希，直至找到空槽</li><li>开放地址法，寻找下一个空槽<ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数</li></ul></li><li>拉链法——也即JDK 1.8 HashMap 所采用方法</li></ul></li><li><h4 id="为什么-node-数组长度要是-2的幂次方"><a href="#为什么-node-数组长度要是-2的幂次方" class="headerlink" title="为什么 node 数组长度要是 2的幂次方"></a>为什么 node 数组长度要是 2的幂次方</h4><ul><li><strong>两点原因： 插入时定下标快，扩容时重新确定下标块</strong><ul><li>hash 过多，内存放不下，进而</li><li>一般通过 hash（或再映射）对数组长区域确定下标</li><li>而用 2 的整数次幂为长度，余运算可以转为位运算，计算更快</li><li>此外，初始数组在没有把握的情况下，不宜设得过大，因此存在数组的后续扩容操作</li><li>以2的整数次幂为长度，且以 2 做扩容倍数时，可以方便的确定原数组链表内所有节点在扩容后的位置</li></ul></li></ul></li><li><h4 id="为什么选-0-75-为扩容因子"><a href="#为什么选-0-75-为扩容因子" class="headerlink" title="为什么选 0.75 为扩容因子"></a>为什么选 0.75 为扩容因子</h4></li><li><p>由加载因子的定义，其取值范围是 (0, 1]。</p></li><li><p>还有一个因素是为了提升扩容效率。因为<code>HashMap</code>的容量（<code>size</code>属性，构造函数中的<code>initialCapacity</code>变量）有一个要求：它一定是 2 的幂 （4,8,16，……）。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。</p></li><li><p>经验</p><ul><li>如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。</li><li>如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。</li></ul></li><li><h4 id="死循环问题"><a href="#死循环问题" class="headerlink" title="死循环问题"></a>死循环问题</h4><ul><li>1.8 之后改为尾插法不存在此问题， 1.7 及之前，头插法可能导致此问题</li></ul></li><li><h4 id="Hash-扰动"><a href="#Hash-扰动" class="headerlink" title="Hash 扰动"></a>Hash 扰动</h4><ul><li><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>一般数组长度可能不会太长，扰动后可使高16位也能参与下标计算，可在一定程度上缓解 hash 碰撞，使 key 分布更均衡</li><li>同时位运算消耗较低</li></ul></li><li><h4 id="为什么采用-红黑树-而不是-AVL-树"><a href="#为什么采用-红黑树-而不是-AVL-树" class="headerlink" title="为什么采用 红黑树 而不是 AVL 树"></a>为什么采用 红黑树 而不是 AVL 树</h4><ul><li><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p></li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>JDK1.7 的 采用 <strong>分段的数组+链表</strong> 实现， 每一个分段类似于一个子 Map ，一般也称 segment</li><li>JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，</li></ul><h3 id="线程安全性保障原理"><a href="#线程安全性保障原理" class="headerlink" title="&#x3D;&#x3D;线程安全性保障原理&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>线程安全性保障原理</strong>&#x3D;&#x3D;</h3><ul><li>JDK1.7 时，针对 segment 加锁</li><li>JDK 1.8 时数据结构跟 <code>HashMap</code> 1.8 的结构一样。并采用 <code>Node + CAS + synchronized</code> 来保证并发安全，同时降低了锁粒度，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</li><li>并发度层面 JDK 1.7 时最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap-中-key-和-value-不能为-null"><a href="#ConcurrentHashMap-中-key-和-value-不能为-null" class="headerlink" title="ConcurrentHashMap 中 key 和 value 不能为 null"></a>ConcurrentHashMap 中 key 和 value 不能为 null</h3><p><strong>原因</strong>： 主要是为了避免二义性。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-语言特点"><a href="#1-Java-语言特点" class="headerlink" title="1.    Java 语言特点"></a>1.    Java 语言特点</h2><ul><li><strong>面向对象</strong></li><li><strong>平台无关</strong></li><li><strong>支持多线程</strong><br>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li><li><strong>编译与解释并存</strong></li></ul><h2 id="2-JDK、JRE、JVM-关系"><a href="#2-JDK、JRE、JVM-关系" class="headerlink" title="2.    JDK、JRE、JVM 关系"></a>2.    JDK、JRE、JVM 关系</h2><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。</p><p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p><p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><h2 id="3-什么是字节码"><a href="#3-什么是字节码" class="headerlink" title="3.    什么是字节码"></a>3.    什么是字节码</h2><p>字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p>Java 跨平台特性其实就是为不同平台提供不同的 JVM，JVM 基于平台特性调整字节码解释实现，从而使得字节码在不同平台均可运行</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505211415926.png" alt="image-20240505211415926" style="zoom:67%;" /><h2 id="4-什么是面向对象"><a href="#4-什么是面向对象" class="headerlink" title="4.    什么是面向对象"></a>4.    什么是面向对象</h2><p><strong>面向对象是一种 相对面向过程 而言的编程范式</strong></p><p><strong>面向过程</strong>程序设计是具体化的，流程化的；面向过程的代码设计通过着手于事物的实现流程，根据已有条件如何一步一步生成结果。</p><p>因此，基于面向过程思路所涉及的代码通常不便于扩展和代码复用，此外，面向过程的思路在处理复杂问题时，编程难度将显著增加。</p><p>而<strong>面向对象</strong>程序设计是模型化的，把对象作为基本单位，将问题抽象建模为一系列对象之间的交互，使得程序易于理解、维护。具有相同行为和属性的对象泛化为类的实例。此外，面向对象具有三大特性——封装、继承与多态</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1    封装"></a>4.1    封装</h4><p><strong>概念</strong>：将一些属性和相关方法封装在一个对象中，对外隐藏内部实现细节。内部具体实现，外界不需要关心，而只需要根据”内部提供的接口“去使用就可以。</p><p><strong>好处</strong>：</p><ul><li><p>使用起来更加方便</p></li><li><p>保证数据的安全，针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改）</p></li><li><p>利于代码维护：如果后期功能实现逻辑需要调整，则保持接口名不变，修改实现代码即可，外界不需要做任何代码修改。</p></li></ul><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2    继承"></a>4.2    继承</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。</p><p>可提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p><h4 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3    多态"></a>4.3    多态</h4><p>同一个方法，在不同的对象上有不同的表现形式</p><p><strong>多态的要点：</strong></p><ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol><h2 id="5-访问权限"><a href="#5-访问权限" class="headerlink" title="5.    访问权限"></a>5.    访问权限</h2><ul><li><strong><code>default</code></strong> （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong><code>private</code></strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong><code>public</code></strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong><code>protected</code></strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="6-final-关键字"><a href="#6-final-关键字" class="headerlink" title="6.    final 关键字"></a>6.    final 关键字</h2><ul><li>当 <code>final</code> 修饰一个类时，表明这个类不能被继承。比如，<code>String</code> 类、<code>Integer</code> 类和其他包装类都是用 <code>final</code> 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（<code>@Override</code>）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 <code>final</code> 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。<ul><li>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；</li><li>如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。</li></ul></li></ul><h2 id="7-引用数据类型-、基本数据类型-与-包装类"><a href="#7-引用数据类型-、基本数据类型-与-包装类" class="headerlink" title="7.    引用数据类型 、基本数据类型 与 包装类"></a>7.    引用数据类型 、基本数据类型 与 包装类</h2><h4 id="7-1-引用数据类型"><a href="#7-1-引用数据类型" class="headerlink" title="7.1    引用数据类型"></a>7.1    引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="7-2-基本数据类型"><a href="#7-2-基本数据类型" class="headerlink" title="7.2    基本数据类型"></a>7.2    基本数据类型</h4><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1 比特</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h4 id="7-3-包装类"><a href="#7-3-包装类" class="headerlink" title="7.3    包装类"></a>7.3    包装类</h4><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，而几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h5 id="7-3-1-包装类常量池-缓存"><a href="#7-3-1-包装类常量池-缓存" class="headerlink" title="7.3.1    包装类常量池(缓存)"></a>7.3.1    包装类常量池(缓存)</h5><p>byte、int、long 类型 均缓存有 -128~127 的值在常量池中</p><p>char 缓存所有char</p><h2 id="8-Java-拷贝机制"><a href="#8-Java-拷贝机制" class="headerlink" title="8.    Java 拷贝机制"></a>8.    Java 拷贝机制</h2><ul><li><strong>浅拷贝</strong>：值类型拷贝，引用类型指向同一对象</li><li><strong>深拷贝</strong>：值类型拷贝，引用类型则拷贝了一个新对象，且引用类型内部按此规则递归</li></ul><h4 id="8-1-cloneable-接口与-clone"><a href="#8-1-cloneable-接口与-clone" class="headerlink" title="8.1    cloneable 接口与 clone()"></a>8.1    cloneable 接口与 clone()</h4><p><code>clone()</code> 默认浅拷贝， 且相应对象若未实现 <code>cloneable</code> 接口，会抛出异常</p><h4 id="8-2-如何实现-深拷贝"><a href="#8-2-如何实现-深拷贝" class="headerlink" title="8.2    如何实现 深拷贝"></a>8.2    如何实现 深拷贝</h4><ul><li>自定义拷贝构造函数（递归）</li><li>递归实现 <code>cloneable</code> 接口并重写 <code>clone()</code> 方法</li><li>序列化</li></ul><h2 id="9-String-相关"><a href="#9-String-相关" class="headerlink" title="9.    String 相关"></a>9.    String 相关</h2><h4 id="9-1-String、StringBuffer、StringBuilder"><a href="#9-1-String、StringBuffer、StringBuilder" class="headerlink" title="9.1    String、StringBuffer、StringBuilder"></a>9.1    String、StringBuffer、StringBuilder</h4><p><code>String</code> 是不可变的（自然线程安全）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，且 <code>StringBuffer</code> 对字符串的操作方法都添加了同步锁，因此性能安全，但同时影响了性能</p><h4 id="9-2-String-为什么不可变"><a href="#9-2-String-为什么不可变" class="headerlink" title="9.2    String 为什么不可变"></a>9.2    String 为什么不可变</h4><ul><li>String 类中 核心数组 被final修饰，此外，String 类中未提供修改 数组内元素的方法</li><li>String 类自身也是 final 的，可以避免子类提供数组修改方法</li></ul><h4 id="9-3-String-为什么要设计成不可变的"><a href="#9-3-String-为什么要设计成不可变的" class="headerlink" title="9.3    String 为什么要设计成不可变的"></a>9.3    String 为什么要设计成不可变的</h4><ul><li><strong>安全</strong> —— String 类型经常用来做参数，比如 url、pwd 之类的</li><li><strong>允许缓存 HashCode</strong> —— Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存</li><li><strong>字符串常量池需要</strong></li></ul><h2 id="10-Object"><a href="#10-Object" class="headerlink" title="10.    Object"></a>10.    Object</h2><h4 id="10-1-常用方法"><a href="#10-1-常用方法" class="headerlink" title="10.1    常用方法"></a>10.1    常用方法</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505224438372.png" alt="image-20240505224438372"></p><h4 id="10-2-和-equals"><a href="#10-2-和-equals" class="headerlink" title="10.2    &#x3D;&#x3D; 和 equals"></a>10.2    &#x3D;&#x3D; 和 equals</h4><ul><li>&#x3D;&#x3D; 判断值类型是否相等，引用类型是否指向同一对象</li><li><code>equals</code> 默认情况下与 &#x3D;&#x3D; 等价，重写后可能不等价</li></ul><h4 id="10-3-为什么重写-equals-时必须重写-hashCode-方法"><a href="#10-3-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="10.3    为什么重写 equals() 时必须重写 hashCode() 方法"></a>10.3    为什么重写 equals() 时必须重写 hashCode() 方法</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>导致 HashMap 可能存入两个逻辑相等的对象</p><h2 id="11-序列化、反序列化"><a href="#11-序列化、反序列化" class="headerlink" title="11.    序列化、反序列化"></a>11.    序列化、反序列化</h2><h4 id="11-1-什么是序列化、反序列化"><a href="#11-1-什么是序列化、反序列化" class="headerlink" title="11.1    什么是序列化、反序列化"></a>11.1    什么是序列化、反序列化</h4><ul><li>序列化：把 Java 对象转换为字节序列的过程</li><li>反序列：把字节序列恢复为 Java 对象的过程</li></ul><h4 id="11-2-注意点"><a href="#11-2-注意点" class="headerlink" title="11.2    注意点"></a>11.2    注意点</h4><ul><li>static 静态变量和 transient 修饰的字段是不会被序列化的</li><li>serialVersionUID问题</li><li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li><li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li></ul><h4 id="11-3-不推荐使用-JDK-自带的序列化"><a href="#11-3-不推荐使用-JDK-自带的序列化" class="headerlink" title="11.3    不推荐使用 JDK 自带的序列化"></a>11.3    不推荐使用 JDK 自带的序列化</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.    异常"></a>12.    异常</h2><h4 id="12-1-异常层级"><a href="#12-1-异常层级" class="headerlink" title="12.1    异常层级"></a>12.1    异常层级</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505230455539.png" alt="image-20240505230455539"></p><ul><li>**<code>Throwable</code>**：是 java 中所有异常和错误的超类,其两个子类为 <strong><code>Error</code></strong>(错误) 和 <strong><code>Exception</code></strong>(异常)<ul><li><strong>Error</strong>： 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</li><li>**<code>Exception</code>**： 是程序本身可以捕获并且可以处理的异常。其中可分为运行时异常（RuntimeException）和非运行时异常，也叫做受检异常<ul><li>**运行时异常(不受检异常)**： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li><li>**非运行时异常(受检异常)**： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</li></ul></li></ul></li></ul><h4 id="12-1-try-with-finally"><a href="#12-1-try-with-finally" class="headerlink" title="12.1    try - with - finally"></a>12.1    try - with - finally</h4><ul><li><p>无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p></li><li><p>不要在 finally 语句块中使用 return， 因为当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略</p></li><li><p>finally 语句在 线程被杀死、JVM 关闭等情况时也不一定会执行</p></li><li><p>对必须关闭的资源，推荐使用 <code>try with resources</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注解"><a href="#13-注解" class="headerlink" title="13.    注解"></a>13.    注解</h2><h4 id="13-1-注解作用"><a href="#13-1-注解作用" class="headerlink" title="13.1    注解作用"></a>13.1    注解作用</h4><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，并可添加根据注解内容而执行的特定逻辑。</p><h4 id="13-2-注解类型"><a href="#13-2-注解类型" class="headerlink" title="13.2    注解类型"></a>13.2    注解类型</h4><ul><li><p>元注解</p><ul><li>@Retention</li><li>@Documented</li><li>@Target</li><li>@Inherited</li><li>@Repeatable</li></ul></li><li><p>内置普通注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SupressWarnings</li><li>@SafeVarargs</li></ul></li><li><p>自定义注解</p></li></ul><h4 id="13-3-其他"><a href="#13-3-其他" class="headerlink" title="13.3    其他"></a>13.3    其他</h4><ul><li>注解也是一个类，可以添加属性，并设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Coder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GRQ&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">language</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">company</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;China_Company&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 数据结构深入分析</title>
      <link href="/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-数据结构深入分析"><a href="#Redis-数据结构深入分析" class="headerlink" title="Redis 数据结构深入分析"></a>Redis 数据结构深入分析</h1><p>本文主要介绍 Redis 的数据结构，包括总体的结构模型，常用的基础数据结构 以及 对应的 底层数据结构，其中基本数据结构与底层数据结构之间的映射表如下，可见每种数据结构都有多种的内部编码实现，且 Redis 实际会在合适的场景选择合适的内部编码。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922093317769-1818232862.png" alt="img"></p><h2 id="一、结构模型基础"><a href="#一、结构模型基础" class="headerlink" title="一、结构模型基础"></a>一、结构模型基础</h2><p>我们在上面了解到了关于键的基本数据结构。而我们Redis中的所有value都是以object的形式存在的。其通用结构结构源码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> [type] <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> [encoding] <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> [lru] REDIS_LRU_BITS;</span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>（1）type指的就是我们的基本数据结构，如string，list等其他类型；</p><p>（2）encoding指的是这些结构内部类型的具体实现方式，如string可以用int来实现也可以用char[]来实现；list可以用ziplist或者链表来实现；</p><p>（3）lru表示本对象的空转时长，用于有限内存下长时间不访问的对象清理；</p><p>（4）refcount对象引用计数，用于GC；</p><p>（5）ptr指向以encoding方式实现这个对象实际实现者的地址，如String对象对应的SDS（<em>Simple Dynamic String</em> 结构）地址。</p><p>示意图如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922095552955-1765467256.png" alt="img"></p><h2 id="二、-String类型"><a href="#二、-String类型" class="headerlink" title="二、 String类型"></a>二、 String类型</h2><p>关于string内部结构，上面也介绍了主要是以三种编码形式来组成的，分别是int，raw，embstr。这里int主要是用来存放整形值的字符串，embstr用来存放字符串的短字符串（大小不超过44个字节），raw存放字符的长字符串（大小不超过44个字节）。</p><h3 id="SDS结构"><a href="#SDS结构" class="headerlink" title="SDS结构"></a>SDS结构</h3><p>我们在上面介绍了关于键的基本结构redisObject，但其实在我们的String中还用着另外一种结构，也就是我们的SDS结构（<em>Simple Dynamic String</em> 结构）。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922153617467-1478669101.png" alt="img"></p><p>从源码的文件里面可以看见，同样一组结构Redis使用泛型定义了好多次。那么为什么不直接用int类型呢？这里呢主要是因为当字符串比较短的时候，len和alloc可以使用byte和short来表示，Redis为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</p><p><strong>为什么不直接使用C字符串呢？</strong></p><p>我们为什么要重新在定义一个SDS的动态字符串的结构？其实呢这主要是为了从Redis对字符串安全性和效率以及功能方面的要求。C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 <code>&#39;\0&#39;</code>。而在Redis中<code>\0</code>可能会被判定为提前结束而识别不了字符串。通过分析可以发现，总共有以下一些缺点：</p><p>（1）获取字符串长度为O(n)，因为C字符串需要去遍历。</p><p>（2）不能很好的杜绝缓冲区溢出&#x2F;内存泄漏的问题，因为原因同上，进行字符串拼接等其他操作获取长度的时候易出现问题。</p><p>（3）C字符串只能保存文本数据，因为必须符合某种编码（如ASCLL）。像一些<code>\0</code>就不易处理。</p><p>表格区别汇总如下。</p><table><thead><tr><th align="left">C字符串</th><th align="left">SDS</th></tr></thead><tbody><tr><td align="left">获取字符串长度的复杂度为O(N)</td><td align="left">获取字符串长度的复杂度为O(1)</td></tr><tr><td align="left">API是不安全的，可能会造成缓冲区溢出</td><td align="left">API是安全的，不会造成缓冲区溢出</td></tr><tr><td align="left">修改字符串长度N次必然需要执行N次内存重分配</td><td align="left">修改字符串长度N次最多需要执行N次内存重分配</td></tr><tr><td align="left">只能保存文本数据</td><td align="left">可以保存文本或者二进制数据</td></tr><tr><td align="left">可以使用所有&lt;string.h&gt;库中的函数</td><td align="left">可以使用一部分&lt;string.h&gt;库中的函数</td></tr></tbody></table><h3 id="raw与embstr的区别"><a href="#raw与embstr的区别" class="headerlink" title="raw与embstr的区别"></a>raw与embstr的区别</h3><p>（1）redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改。</p><p>（2）采用内存分配方式不同，虽然raw和embstr编码方式都是使用redisObject结构和sdshdr结构。但是raw编码方式采用两次分配内存的方式，分别创建redisObject和sdshdr，而embstr编码方式则是采用一次分配，分配一个连续的空间给redisObject和sdshdr。（embstr一次性分配内存的方式：1，使得分配空间的次数减少。2、释放内存也只需要一次。3、在连续的内存块中，利用了缓存的优点。）</p><h3 id="String的应用场景"><a href="#String的应用场景" class="headerlink" title="String的应用场景"></a>String的应用场景</h3><p><strong>（1）缓存功能</strong></p><p>字符串最经典的使用场景，redis最为缓存层，Mysql作为储存层，绝大部分请求数据都是 redis中获取，由于redis具有支撑高并发特性，所以缓存通常能起到加速读写和降低后端压力的作用。</p><p><strong>（2）计数器</strong></p><p>许多应用都会使用redis作为计数的基础工具，因为redis的<code>INCR</code>命令具有原子性的自增操作，在并发下也可以保证一个线程安全的问题。如果我们常见的论坛，网站的点赞数或者视频播放数就是使用redis作为计数的基础组件。</p><p><strong>（3）共享session</strong></p><p>出于负载均衡的考虑，分布式服务会将用户信息的访问均衡到不同服务器上，这样可能我们用户在第一次访问和第二次访问的时候不是同一台服务器的话，session不同步，就会导致重新登录。为避免这个问题可以使用redis将用户session集中管理。（示意图如下）</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001092356031-822974235.png" alt="img"></p><p>当客户端第一次发送请求后，nginx将这个请求分发给服务器实例M ，然后将服务器实例M 产生的Session 放入Redis中，此时客户端、服务器实例M 和Redis中都会有一个相同的Session，当客户端发送第二次请求的时候，nginx将请求分发给服务器实例N （已知服务器实例N 中无Session），因为客户端自己携带了一个Session，那么服务器实例N就可以拿着客户端带来的Session中的ID去Redis中找到Session，找到这个Session后，就能正常执行之后的操作。</p><p><strong>（5）限流</strong></p><p>我们的redis处于安全考虑或者在高并发访问，都会进行一个限流或者限速。比如防止某个接口被频繁调用而崩溃或者像手机验证码验证，防止短信接口不被频繁访问。</p><p>我们常见的限流算法有很多，如令牌桶，漏桶，计数器，滑动窗口等。而用String的话，就可以使用计数器，我们如果要设置一个一分钟最多只能访问100次的限流接口，只要设置键的一分钟过期时间就行，然后在一分钟之内通过计数器来进行计数。关于具体的限流算法，我后面会继续更新补充一下这一块的知识点。(点击跳转，待补充)</p><h2 id="三、List类型"><a href="#三、List类型" class="headerlink" title="三、List类型"></a>三、List类型</h2><p>我们在最开始的图上面也介绍了，list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist。然后针对这两种的弊端又设计出了一个快速列表。关于双向链表，老数据结构不介绍了，这里重点介绍一下压缩列表和快速列表。</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><strong>ziplist</strong>是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储。但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，对象结构中ptr所指向的就是一个ziplist。整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。</p><p>ziplist的结构表如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001100507850-847200896.png" alt="img"></p><p>　　　　1、zlbytes:用于记录整个压缩列表占用的内存字节数</p><p>　　　　2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节</p><p>　　　　3、zllen：记录了压缩列表包含的节点数量。</p><p>　　　　4、entryX：要说列表包含的各个节点</p><p>　　　　5、zlend：用于标记压缩列表的末端</p><p><strong>为什么数据量大不使用ziplist？</strong></p><p>我们在上面也说到了，因为它的插入的时间复杂度是O(n)，而且插入一个新的元素就要调用realloc进行扩展内存。取决于内存分配器算法和当前的ziplist内存大小，realloc可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能直接原地扩展。而如果我们的数据量大的话，那么重新分配内存和拷贝内存就会有很大的消耗。所以ziplist不适合大型字符串，存储的元素也不宜过多。</p><h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p>其实这里如果看网上早期的博客很容易漏掉一个数据结构。我们的Redis早期版本list内部编码是ziplist或者linkedlist，但是这两者都有着自己的缺点。ziplist的数据量大不适合用，在上面也重点介绍了，而linkedlist的附加空间相对太高，prev和next指针就要占去16个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p><p>所以针对这两种编码数据结构，后续版本进行了改造了，诞生了quicklist。</p><p>quicklist是ziplist和linkedlist的混合体，它将linkedlist按段切分，每一段使用ziplist来紧凑存储，多个ziplist之间使用双指针串接起来。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001103326988-2044742495.png" alt="img"></p><p><strong>ziplist的长度</strong></p><p>quicklist内部默认单个ziplist长度为8k字节，超出了这个字节数，就会新起一个ziplist。关于长度可以使用<code>list-max-ziplist-size</code>来决定。</p><p><strong>压缩深度</strong></p><p>我们上面说到了quicklist下是用多个ziplist组成的，同时为了进一步节约空间，Redis还会对ziplist进行压缩存储，使用LZF算法压缩，可以选择压缩深度。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001111702607-948543746.png" alt="img"></p><p>quicklist默认的压缩深度是0，也就是不压缩。压缩的实际深度由配置参数<code>list-compress-depth</code>决定。为了支持快速的 <code>push/pop</code> 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p><p>关于压缩具体介绍可以参考这里👉<a href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&utm_medium=referral">点击跳转</a></p><h3 id="List的应用场景"><a href="#List的应用场景" class="headerlink" title="List的应用场景"></a>List的应用场景</h3><p><strong>（1）消息队列</strong></p><p>redis的<code>lpush+brpop</code>命令组合即可实现阻塞队列，生产者客户端是用<code>lupsh</code>从列表左侧插入元素，多个消费者客户端使用<code>brpop</code>命令阻塞时的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001112341182-215857925.png" alt="img"></p><p><strong>（2）最新列表</strong></p><p>list类型的<code>lpush</code>命令和<code>lrange</code>命令能实现最新列表的功能，每次通过<code>lpush</code>命令往列表里插入新的元素，然后通过<code>lrange</code>命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</p><p><strong>（3）排行榜</strong></p><p>适用于定时计算的排行榜。 list类型的<code>lrange</code>命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等排行榜。</p><h2 id="四、Hash类型"><a href="#四、Hash类型" class="headerlink" title="四、Hash类型"></a>四、Hash类型</h2><p>哈希类型的底层编码可以是ziplist也可以是我们的hashtable。ziplist在上面我们已经介绍了，这里我们着重介绍一下hashtable。</p><h3 id="HashTable结构"><a href="#HashTable结构" class="headerlink" title="HashTable结构"></a>HashTable结构</h3><p>我们的hashtable主要是通过dict来实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><p>可以看到我们每个dict结构里面都有两个hashtable。（ht[0]和ht[1]）</p><p>虽然dict结构有两个hashtable，但是通常情况下只有一个hashtable是有值的。但是在dict扩容缩容的时候，需要分配新的hashtable，然后进行渐近式搬迁，这时候两个hashtable存储的旧的hashtable和新的hashtable。搬迁结束后，旧hashtable删除，新的取而代之。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002105644237-1980970838.png" alt="img"></p><p>hashtable的结构和Java的HashMap几乎是一样的，都是通过分桶的方式来解决hash冲突的。第一维是数组，第二维是链表。而数组中存储的是第二维链表的第一个元素的指针。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002105929003-1083710349.png" alt="img"></p><h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕。</p><p>这里我们将说说扩容条件和缩容条件，然后再介绍一下rehash的过程。</p><p><strong>扩容条件</strong></p><p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p><p>这里不扩容主要是为了尽可能减少内存页过多分离，系统后需要更多的开销去回收内存。</p><p><strong>缩容条件</strong></p><p>当我们的hash表元素逐渐删除的越来越少的时候，第一维数组长度太长也不是太好。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p><p>这里不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p><p><strong>rehash步骤</strong></p><p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p><p>2、在几点钟（定时）维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p><p>3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p><p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p><p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash是只能对ht[0]进行使得h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p><p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。有安全迭代器可用, 安全迭代器保证, 在迭代起始时, 字典中的所有结点, 都会被迭代到, 即使在迭代过程中对字典有插入操作。</p><h3 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h3><p><strong>hash函数</strong></p><p>hashtable的性能取决于hash函数的质量，如果hash把key打散的比较均匀，就是一个好函数。redis默认的函数是siphash，不仅打散均匀而且性能还特别快。</p><p><strong>hash攻击</strong></p><p>hash攻击指的是如果我们的hash函数的打散不均匀的话，存在偏向性。那么黑客就有可能利用这种偏向性对服务器进行攻击，存在偏向性的hash函数在特定模式下的输入会导致hash第二维链表长度即为不均匀，导致查找速率急剧下降，从O(1)到O(n)。有限的服务器计算能力就会被hashtable的查找效率彻底拖垮。</p><h3 id="Hash的应用场景"><a href="#Hash的应用场景" class="headerlink" title="Hash的应用场景"></a>Hash的应用场景</h3><p>哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于<strong>用户信息</strong>，<strong>购物车</strong>等管理，但是哈希类型和关系型数据库有所不同，哈希类型是稀疏的，而关系型数据库是完全结构化的，关系型数据库可以做复杂的关系查询，而redis去模拟关系型复杂查询开发困难，维护成本高。</p><p>这里举一个实例，以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素</p><h2 id="五、Set类型"><a href="#五、Set类型" class="headerlink" title="五、Set类型"></a>五、Set类型</h2><p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合Set类型底层编码包括hashtable和inset。hashtable在上面介绍过了，我们就只介绍inset。</p><h3 id="inset的结构"><a href="#inset的结构" class="headerlink" title="inset的结构"></a>inset的结构</h3><p>intset底层本质是一个有序的、不重复的、整型的数组、支持不同类型整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>（1）encoding 的值可以是以下三个常量的其中一个 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><p>（2）length就是数组的实际长度。</p><p>（3）contents 数组是实际保存元素的地方，数组中的元素有以下两个特性：</p><ul><li>没有重复元素；</li><li>元素在数组中从小到大排列；</li></ul><p><strong>inset的查询</strong></p><p>intset是一个有序集合，查找元素的复杂度为O(logN)<strong>（采用二分法）</strong>，但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。是intset不支持降级操作。</p><p><strong>补充</strong></p><p>这里需要注意的是，这里的说inset是有序不要和我们zset搞混，zset是设置一个score来进行排序，而inset这里只是单纯的对整数进行升序而已。</p><h3 id="Set的应用场景"><a href="#Set的应用场景" class="headerlink" title="Set的应用场景"></a>Set的应用场景</h3><p>（1）交集，并集，差集。这里如交集可以用来如一个用户对娱乐 、体育比较感兴趣，另一个可能对新闻比较感兴趣，他们就有共同的标签，可以做互相推荐的功能，喜欢体育的人还喜欢娱乐。类似其他的功能都可以抽象一点去想象用法。</p><p>（2）随机数。这里可以使用<code>spop/srandmember</code>命令来获取随机数，可以做一个抽奖功能等。</p><p>（3）社交需求。类似<code>sadd/sinter</code>命令可以添加你有多少个朋友的共同好友等操作，类似可能认识的人。</p><h2 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h2><p>Zset有序集合和set集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数，作为排序的依据。 （有序集合中的元素不可以重复，但是csore可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。</p><p>简单来说，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p><p>zet的底层编码有两种数据结构，一个ziplist，一个是skiplist。这里因为ziplis也做了排序，所以也要简单再介绍一下。</p><h3 id="ziplist排序"><a href="#ziplist排序" class="headerlink" title="ziplist排序"></a>ziplist排序</h3><p>我们之前也介绍过了ziplist，底层就是压缩列表。这里我们为了实现排序，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p><p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放在靠近表尾的方向。可以参考示意图如下。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002160252776-1435470436.png" alt="img"></p><h3 id="skiplist跳表"><a href="#skiplist跳表" class="headerlink" title="skiplist跳表"></a>skiplist跳表</h3><p>关于skiplist比较复杂，这里我只简单介绍一下，具体可以参考  <a href="https://github.com/linmuhan/JavaGuide/blob/master/docs/database/Redis/redis-collection/Redis(2)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8.md">这篇文章</a>  ，可以全面了解这个数据结构。</p><p>skiplist是与dict结合使用的，结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure><p>head和tail分别指向头节点和尾节点，然后每个skiplistNode里面的结构又是分层的(即level数组)。每一列都代表一个节点，保存了member和score，按score从小到大排序。每个节点有不同的层数，这个层数是在生成节点的时候随机生成的数值。每一层都是一个指向后面某个节点的指针。这种结构使得跳跃表可以跨越很多节点来快速访问。<strong>（前进可以跳跃式的跳过几个节点，而后退只能后退一个节点，可以看看下面示意图可比较容易理解）。</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002173146736-216480070.png" alt="img"></p><p><strong>为什么不使用平衡树，而使用跳跃表？</strong></p><p>这里redis的设计者antirez也给出了原因，主要是从内存占用、对范围查找、实现难易程度来考虑的。</p><p>（1）在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p><p>（2）平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p><p>（3）从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1&#x2F;(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p&#x3D;1&#x2F;4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p><p><strong>为什么要使用skiplist与dict结合使用呢？</strong></p><p>这里需要我们去思考一下，为什么我们要两个混合着使用呢？</p><p>其实呢，我们可以分析一下就知道了。首先是我们的跳跃表，可以跨过多个节点进行查询，时间复杂度是O(lgn)左右，但是可以保持有序性。我们的dict是用hashtable实现，因为是哈希，所以查询是O(1)的大小，但是是无序性。</p><p>而我们使用两者混合，在进行分数索引的时候查询使用跳跃表，进行数据索引查找的时候，可以使用哈希的O(1)查找。设想如果没有字典, 如果想按数据查分数, 就必须进行遍历O(logn)。两套底层数据结构均只作为索引使用, 即不直接持有数据本身.。数据被封装在SDS中, 由跳跃表与字典共同持有，而数据的分数则由跳跃表结点直接持有(double类型数据), 由字典间接持有。</p><h3 id="Zset的应用场景"><a href="#Zset的应用场景" class="headerlink" title="Zset的应用场景"></a>Zset的应用场景</h3><p>Zset的使用场景和set很是类似，而且还可以我们上面String做不了的实时排行榜。</p><p><strong>（1）实时排行榜</strong></p><p>比如我们要做一个一小时热搜，我们可以把当前的时间戳作为zset的key，把帖子ID作为member，点击数评论数作为score，当score发生变化时更新score。然后可以利用<code>zrevrange</code>或<code>zrange</code>来来查到对应数量的在时间内的记录。</p><p><strong>（2）延时队列</strong></p><p>zset会按照score进行排序，如果score代表想要执行时间的时间戳。在某个时间将它插入zset集合中，它便会按照时间戳大小进行排序，也就是对执行时间前后进行排序。</p><p><strong>（3）限流</strong></p><p>滑动窗口是限流常见的一种策略。如果我们把一个用户的 ID 作为 key 来定义一个 zset ，member 或者 score 都为访问时的时间戳。我们只需统计某个 key 下在指定时间戳区间内的个数，就能得到这个用户滑动窗口内访问频次，与最大通过次数比较，来决定是否允许通过。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Redis的数据结构，这里介绍的其实也不是特别全。因为redis的一直在更新，而且很多知识点也不是一篇博客可以讲完，比如在redis5.0之后更新了紧凑列表listpack来替代了ziplist，但是因为ziplist应用在数据结构里面范围太大了，不太好更新，所以现在还没有取代，但是它却是比ziplist要好的存在，解决了ziplist存在问题。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常见问题</title>
      <link href="/2024/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"/>
      <url>/2024/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-常见问题"><a href="#Redis-常见问题" class="headerlink" title="Redis 常见问题"></a>Redis 常见问题</h1><h2 id="一、Redis基础概念"><a href="#一、Redis基础概念" class="headerlink" title="一、Redis基础概念"></a><strong>一、Redis基础概念</strong></h2><h3 id="1、-Redis-的持久化机制是什么？各自的优缺点？"><a href="#1、-Redis-的持久化机制是什么？各自的优缺点？" class="headerlink" title="1、 Redis 的持久化机制是什么？各自的优缺点？"></a>1、 Redis 的持久化机制是什么？各自的优缺点？</h3><p>Redis提供两种持久化机制 RDB 和 AOF 机制：</p><ul><li><strong>RDB（Redis DataBase）持久化方式</strong>：是指用数据集快照的方式记录 Redis 数据库的所有键值对<ul><li><strong>优点</strong>：<ul><li>只有一个文件 dump.rdb，方便持久化。</li><li>容灾性好，一个文件可以保存到安全的磁盘。</li><li>性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 Redis的高性能。</li><li>相对于数据集大时，比 AOF 的启动效率更高。</li></ul></li><li><strong>缺点</strong>：<ul><li>数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 Redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</li></ul></li></ul></li><li><strong>AOF（Append-only file）持久化方式</strong>：是指所有的命令行记录以 Redis 命令请求协议的格式完全持久化存储保存为 aof 文件<ul><li><strong>优点</strong>：<ul><li>数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。</li><li>通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li>AOF 机制的 <strong>rewrite 模式</strong>。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）</li></ul></li><li><strong>缺点：</strong><ul><li>AOF 文件比 RDB 文件大，且恢复速度慢。</li><li>数据集大的时候，比 RDB 启动效率低。</li></ul></li></ul></li></ul><h3 id="2、-Redis为什么读写性能高？单线程模型如何支撑高并发？"><a href="#2、-Redis为什么读写性能高？单线程模型如何支撑高并发？" class="headerlink" title="2、 Redis为什么读写性能高？单线程模型如何支撑高并发？"></a>2、 Redis为什么读写性能高？单线程模型如何支撑高并发？</h3><ul><li><strong>高性能原因</strong>：  <ol><li><strong>内存操作</strong>：数据存储在内存，读写速度快。  </li><li><strong>单线程模型</strong>：避免多线程上下文切换和锁竞争。  </li><li><strong>I&#x2F;O多路复用</strong>：通过epoll&#x2F;kqueue实现非阻塞网络通信，单线程处理大量连接。  </li><li><strong>高效数据结构</strong>：如跳跃表、压缩列表等优化存储。</li></ol></li><li><strong>单线程高并发</strong>：  <ul><li>虽然命令处理是单线程，但I&#x2F;O多路复用允许同时监听多个客户端请求，通过事件驱动处理，适合高并发低延迟场景。  </li><li><strong>Redis 6.0后支持多线程I&#x2F;O</strong>：仅处理网络读写，命令执行仍为单线程。</li></ul></li></ul><h3 id="3、-Redis的过期键删除策略有哪些？"><a href="#3、-Redis的过期键删除策略有哪些？" class="headerlink" title="3、 Redis的过期键删除策略有哪些？"></a>3、 Redis的过期键删除策略有哪些？</h3><p>Redis处理过期键的策略主要包括以下三种：</p><ol><li><strong>惰性删除（Lazy Deletion）</strong>： 仅在尝试访问一个键时，Redis会检查该键是否过期。如果过期，则在访问时删除键。<ul><li><strong>优点</strong>：不需要额外的后台资源，节省CPU开销。</li><li><strong>缺点</strong>：如果某些过期键长时间不被访问，它们会一直占用内存。</li></ul></li><li><strong>定期删除（Periodic Deletion）</strong>： 周期性地随机检查一部分设置了过期时间的键，如果发现过期键，则删除它们。<ul><li><strong>频率</strong>：由<code>hz</code>参数控制，默认每秒执行10次。每次操作中，Redis会从过期字典中抽样一定数量的键进行检查和删除。</li><li><strong>优点</strong>：保证大部分过期键能够及时被删除。</li><li><strong>缺点</strong>：如果过期键数量巨大，可能会造成删除不及时，增加内存压力。</li></ul></li><li><strong>内存淘汰策略</strong><ul><li><strong>触发条件</strong>：当内存使用量达到<code>maxmemory</code>设置的上限时，Redis会根据配置的淘汰策略（如LRU、LFU等）删除一部分键，包括未设置过期时间的键。</li><li><strong>作用</strong>：防止因过多未删除的过期键导致内存溢出。</li></ul></li></ol><p><strong>总结</strong></p><p>Redis通过惰性删除和定期删除相结合的方式，平衡了CPU和内存资源的消耗，同时通过内存淘汰策略防止内存溢出。这种混合策略在不同版本中不断优化，以适应不同的应用场景和性能需求。</p><h3 id="4、内存淘汰机制了解吗？"><a href="#4、内存淘汰机制了解吗？" class="headerlink" title="4、内存淘汰机制了解吗？"></a>4、内存淘汰机制了解吗？</h3><p>Redis的内存淘汰机制是当Redis实例的内存使用量达到配置的最大内存限制（<code>maxmemory</code>）时，根据设定的淘汰策略来移除部分键值对，从而释放内存。以下是Redis支持的主要内存淘汰策略及其特点：</p><ol><li><p><strong>noeviction</strong>： 不自动淘汰任何键，而是拒绝所有写入操作并返回错误。</p><ul><li><strong>适用场景</strong>：适用于不允许数据丢失的场景，但可能导致服务不可用。</li></ul></li><li><p><strong>allkeys-lru</strong>： 从所有键中淘汰最近最少使用的键（LRU算法），以释放内存。</p><ul><li><strong>适用场景</strong>：适用于缓存场景，优先保留热点数据。</li></ul></li><li><p><strong>volatile-lru</strong>： 仅从设置了过期时间的键中淘汰最近最少使用的键。</p><ul><li><strong>适用场景</strong>：适用于临时数据较多的场景，且希望优先淘汰即将过期的键。</li></ul></li><li><p><strong>allkeys-random</strong>： 随机淘汰任意键。</p><ul><li><strong>适用场景</strong>：适用于对数据一致性要求不高的场景。</li></ul></li><li><p><strong>volatile-random</strong>： 仅从设置了过期时间的键中随机淘汰。</p><ul><li><strong>适用场景</strong>：适用于临时数据较多的场景，且对淘汰顺序无要求。</li></ul></li><li><p><strong>volatile-ttl</strong>： 优先淘汰剩余生存时间（TTL）最短的键。</p><ul><li><strong>适用场景</strong>：适用于希望优先清理即将过期的键的场景。</li></ul></li><li><p><strong>volatile-lfu</strong>： 仅从设置了过期时间的键中淘汰访问频率最低的键。</p><ul><li><strong>适用场景</strong>：适用于希望保留热点数据的场景，且键有明确的过期时间。</li></ul></li><li><p><strong>allkeys-lfu</strong>： 从所有键中淘汰访问频率最低的键。</p><ul><li><strong>适用场景</strong>：适用于缓存场景，优先保留热点数据。</li></ul></li></ol><p><strong>【配置方法】</strong></p><ul><li><p><strong>动态设置</strong>：通过命令行动态修改淘汰策略，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli config <span class="built_in">set</span> maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>此方法无需重启Redis服务，但配置在重启后会丢失。</p></li><li><p><strong>配置文件设置</strong>：在<code>redis.conf</code>文件中添加或修改<code>maxmemory-policy</code>配置项，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><p>此方法需要重启Redis服务，但配置持久化。</p></li></ul><p><strong>【注意事项】</strong></p><ul><li><strong>内存限制</strong>：需要设置<code>maxmemory</code>参数来指定Redis的最大内存使用量，否则淘汰策略不会触发。</li><li><strong>淘汰算法</strong>：Redis的LRU和LFU算法并非完全精确，而是通过采样实现近似淘汰。</li></ul><p>通过合理配置内存淘汰策略，可以有效管理Redis的内存使用，确保系统在有限的资源下高效运行。</p><h2 id="二、Redis数据结构与使用场景"><a href="#二、Redis数据结构与使用场景" class="headerlink" title="二、Redis数据结构与使用场景"></a><strong>二、Redis数据结构与使用场景</strong></h2><h3 id="1、-Redis支持哪些数据结构？各自的应用场景是什么？"><a href="#1、-Redis支持哪些数据结构？各自的应用场景是什么？" class="headerlink" title="1、 Redis支持哪些数据结构？各自的应用场景是什么？"></a>1、 Redis支持哪些数据结构？各自的应用场景是什么？</h3><ol><li><strong>String</strong>：缓存、计数器（如文章阅读量）。  </li><li><strong>List</strong>：消息队列、最新消息列表（LPUSH+BRPOP）。  </li><li><strong>Hash</strong>：存储对象（如用户信息字段）。  </li><li><strong>Set</strong>：标签、好友关系（交集、并集运算）。  </li><li><strong>Sorted Set</strong>：排行榜、延迟队列（按分数排序）。  </li><li><strong>HyperLogLog</strong>：去重统计（如UV统计）。  </li><li><strong>Stream</strong>：消息队列（支持消费组、消息持久化）。  </li><li><strong>GEO</strong>：地理位置计算（如附近的人）。  </li><li><strong>BitMap</strong>：位操作（如签到统计）。</li></ol><h3 id="2、-如何用Redis实现分布式锁？需要注意哪些问题？"><a href="#2、-如何用Redis实现分布式锁？需要注意哪些问题？" class="headerlink" title="2、 如何用Redis实现分布式锁？需要注意哪些问题？"></a>2、 如何用Redis实现分布式锁？需要注意哪些问题？</h3><ul><li><p><strong>实现方式</strong>：  </p><ol><li><strong>SETNX + EXPIRE</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX EX 30  # 原子性设置锁和过期时间（Redis 2.6.12+）</span><br></pre></td></tr></table></figure></li><li><strong>RedLock算法</strong>：在多个Redis节点上获取锁，半数以上成功才算获取锁。</li></ol></li><li><p><strong>注意事项</strong>：  </p><ol><li><strong>原子性</strong>：设置锁和过期时间需保证原子操作（避免SETNX+EXPIRE非原子）。  </li><li><strong>锁续期</strong>：通过看门狗线程（如Redisson）自动续期，防止业务未完成锁过期。  </li><li><strong>释放锁</strong>：使用Lua脚本验证锁的归属（<code>if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then return redis.call(&quot;del&quot;,KEYS[1])</code>）。</li></ol></li><li><p><strong>拓展</strong>：  </p><ul><li><strong>Redisson</strong>：开源库实现了分布式锁，支持可重入锁、公平锁等特性。</li></ul></li></ul><h3 id="3、-Redis的HyperLogLog和布隆过滤器（Bloom-Filter）的原理与使用场景？"><a href="#3、-Redis的HyperLogLog和布隆过滤器（Bloom-Filter）的原理与使用场景？" class="headerlink" title="3、 Redis的HyperLogLog和布隆过滤器（Bloom Filter）的原理与使用场景？"></a>3、 Redis的HyperLogLog和布隆过滤器（Bloom Filter）的原理与使用场景？</h3><ul><li><strong>HyperLogLog</strong>：  <ul><li><strong>原理</strong>：基于概率算法统计基数（去重计数），误差率约0.81%。  </li><li><strong>场景</strong>：大规模数据去重统计（如UV统计），内存占用极低（12KB）。</li></ul></li><li><strong>布隆过滤器</strong>：  <ul><li><strong>原理</strong>：通过多个哈希函数将元素映射到位数组，可能存在误判（不存在一定准确，存在可能误判）。  </li><li><strong>场景</strong>：缓存穿透防护、爬虫URL去重。</li></ul></li><li><strong>对比</strong>：  <ul><li>HyperLogLog统计总数，布隆过滤器判断元素是否存在。</li></ul></li></ul><h3 id="4、-如何用Redis实现延迟队列或消息队列？"><a href="#4、-如何用Redis实现延迟队列或消息队列？" class="headerlink" title="4、 如何用Redis实现延迟队列或消息队列？"></a>4、 如何用Redis实现延迟队列或消息队列？</h3><ul><li><strong>延迟队列实现</strong>：  <ol><li><strong>Sorted Set</strong>：将消息的到期时间作为分数，使用<code>ZADD</code>添加，消费者轮询<code>ZRANGEBYSCORE</code>获取到期消息。  </li><li><strong>Redis Stream</strong>（推荐）：通过<code>XADD</code>添加消息，消费者用<code>XREADGROUP</code>按消费组处理，结合阻塞读取实现实时性。</li></ol></li><li><strong>消息队列对比</strong>：  <ul><li><strong>List（LPUSH+BRPOP）</strong>：简单但无ACK机制，消息可能丢失。  </li><li><strong>Stream</strong>：支持多消费者组、消息持久化、ACK确认，更可靠。</li></ul></li></ul><h3 id="5、-Redis的Sorted-Set底层实现原理是什么？如何实现排行榜功能？"><a href="#5、-Redis的Sorted-Set底层实现原理是什么？如何实现排行榜功能？" class="headerlink" title="5、 Redis的Sorted Set底层实现原理是什么？如何实现排行榜功能？"></a>5、 Redis的Sorted Set底层实现原理是什么？如何实现排行榜功能？</h3><ul><li><strong>底层结构</strong>：  <ul><li><strong>跳跃表（SkipList） + 哈希表</strong>：  <ol><li>跳跃表支持快速范围查询（如ZRANGE）。  </li><li>哈希表存储成员到分数的映射（O(1)时间复杂度查询分数）。</li></ol></li></ul></li><li><strong>排行榜实现</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZADD ranking 100 &quot;user1&quot;  # 添加用户分数</span><br><span class="line">ZREVRANGE ranking 0 9 WITHSCORES  # 获取前10名</span><br></pre></td></tr></table></figure></li></ul><h2 id="三、Redis持久化与高可用"><a href="#三、Redis持久化与高可用" class="headerlink" title="三、Redis持久化与高可用"></a><strong>三、Redis持久化与高可用</strong></h2><h3 id="1、-RDB和AOF持久化的区别及优缺点？"><a href="#1、-RDB和AOF持久化的区别及优缺点？" class="headerlink" title="1、 RDB和AOF持久化的区别及优缺点？"></a>1、 RDB和AOF持久化的区别及优缺点？</h3><ul><li><strong>RDB（快照）</strong>：  <ul><li><strong>原理</strong>：定时生成内存数据的二进制快照。  </li><li><strong>优点</strong>：文件小、恢复快、适合备份。  </li><li><strong>缺点</strong>：可能丢失最后一次快照后的数据。</li></ul></li><li><strong>AOF（追加日志）</strong>：  <ul><li><strong>原理</strong>：记录所有写命令（文本格式）。  </li><li><strong>优点</strong>：数据丢失少（可配置每秒同步）。  </li><li><strong>缺点</strong>：文件大、恢复慢、写入性能略低。</li></ul></li><li><strong>混合持久化</strong>（Redis 4.0+）：  <ul><li>AOF文件包含RDB头 + AOF增量操作，兼顾恢复速度和数据安全。</li></ul></li></ul><h3 id="2、AOF重写（AOF-Rewrite）的过程是怎样的？"><a href="#2、AOF重写（AOF-Rewrite）的过程是怎样的？" class="headerlink" title="2、AOF重写（AOF Rewrite）的过程是怎样的？"></a>2、AOF重写（AOF Rewrite）的过程是怎样的？</h3><ol><li><strong>触发条件</strong>：AOF文件大小超过阈值或手动执行<code>BGREWRITEAOF</code>。  </li><li><strong>重写过程</strong>：  <ul><li>Redis fork子进程，根据当前内存数据生成新的AOF文件。  </li><li>重写期间的新命令写入AOF缓冲区和重写缓冲区。  </li><li>子进程完成后，将重写缓冲区的命令追加到新AOF文件，替换旧文件。</li></ul></li><li><strong>优点</strong>：压缩AOF体积（如合并多个SET命令为最终状态）。</li></ol><h3 id="3、-Redis主从复制的原理和数据同步流程？"><a href="#3、-Redis主从复制的原理和数据同步流程？" class="headerlink" title="3、 Redis主从复制的原理和数据同步流程？"></a>3、 Redis主从复制的原理和数据同步流程？</h3><ul><li><strong>流程</strong>：  <ol><li><strong>全量同步</strong>：  <ul><li>从节点连接主节点，发送<code>PSYNC</code>命令。  </li><li>主节点生成RDB快照发送给从节点，同时缓存期间的写命令。  </li><li>从节点加载RDB后，主节点发送缓存的写命令。</li></ul></li><li><strong>增量同步</strong>：  <ul><li>主从断开重连后，从节点发送偏移量，主节点发送未同步的命令。</li></ul></li></ol></li><li><strong>核心机制</strong>：  <ul><li>主节点维护复制积压缓冲区（repl_backlog），支持断线后增量同步。</li></ul></li></ul><h3 id="4、-哨兵（Sentinel）模式的故障转移流程是怎样的？"><a href="#4、-哨兵（Sentinel）模式的故障转移流程是怎样的？" class="headerlink" title="4、 哨兵（Sentinel）模式的故障转移流程是怎样的？"></a>4、 哨兵（Sentinel）模式的故障转移流程是怎样的？</h3><ul><li><strong>答案</strong>  <ol><li><strong>主观下线</strong>：某个Sentinel认为主节点不可用（<code>PING</code>超时）。  </li><li><strong>客观下线</strong>：多个Sentinel确认主节点不可用。  </li><li><strong>选举Leader Sentinel</strong>：通过Raft算法选出一个Sentinel执行故障转移。  </li><li><strong>故障转移</strong>：  <ul><li>Leader Sentinel选择一个从节点升级为新主节点。  </li><li>通知其他从节点和新主节点同步数据。  </li><li>通知客户端切换主节点。</li></ul></li></ol></li></ul><h3 id="5、-Redis-Cluster集群如何实现数据分片（Slot分配）和扩容？"><a href="#5、-Redis-Cluster集群如何实现数据分片（Slot分配）和扩容？" class="headerlink" title="5、 Redis Cluster集群如何实现数据分片（Slot分配）和扩容？"></a>5、 Redis Cluster集群如何实现数据分片（Slot分配）和扩容？</h3><ul><li><strong>答案</strong>  <ul><li><strong>数据分片</strong>：  <ul><li>所有键根据CRC16算法计算哈希值，映射到16384个Slot。  </li><li>每个节点负责一部分Slot（如节点A负责0-5000，节点B负责5001-10000）。</li></ul></li><li><strong>扩容流程</strong>：  <ol><li>添加新节点，分配部分Slot到新节点。  </li><li>迁移数据：使用<code>CLUSTER SETSLOT</code>命令迁移Slot中的键（需客户端支持重定向）。  </li><li>更新集群元数据，所有节点同步新Slot分布。</li></ol></li></ul></li></ul><h3 id="6、-Redis-Cluster的节点间通信机制（Gossip协议）是什么？"><a href="#6、-Redis-Cluster的节点间通信机制（Gossip协议）是什么？" class="headerlink" title="6、 Redis Cluster的节点间通信机制（Gossip协议）是什么？"></a>6、 Redis Cluster的节点间通信机制（Gossip协议）是什么？</h3><ul><li><strong>答案</strong>  <ul><li><strong>Gossip协议</strong>：  <ul><li>节点间定期交换信息（如PING&#x2F;PONG消息），传播集群状态。  </li><li>消息包含节点状态、Slot分配、故障检测等。</li></ul></li><li><strong>优点</strong>：去中心化、容错性强。  </li><li><strong>缺点</strong>：信息同步延迟，可能短暂不一致。</li></ul></li></ul><h2 id="四、Redis事务与高级功能"><a href="#四、Redis事务与高级功能" class="headerlink" title="四、Redis事务与高级功能"></a><strong>四、Redis事务与高级功能</strong></h2><h3 id="1、-Redis事务（MULTI-EXEC）的ACID特性如何？与数据库事务有何区别？"><a href="#1、-Redis事务（MULTI-EXEC）的ACID特性如何？与数据库事务有何区别？" class="headerlink" title="1、 Redis事务（MULTI&#x2F;EXEC）的ACID特性如何？与数据库事务有何区别？"></a>1、 Redis事务（MULTI&#x2F;EXEC）的ACID特性如何？与数据库事务有何区别？</h3><ul><li><strong>答案</strong>  <ul><li><strong>ACID特性</strong>：  <ol><li><strong>原子性（Atomicity）</strong>：事务中的命令要么全部执行，要么全部不执行（但<strong>不支持回滚</strong>，语法错误会取消事务，运行时错误会继续执行）。  </li><li><strong>一致性（Consistency）</strong>：事务执行前后数据符合约束（如类型、数量）。  </li><li><strong>隔离性（Isolation）</strong>：单线程模型天然保证隔离性（无并发问题）。  </li><li><strong>持久性（Durability）</strong>：取决于持久化配置（AOF开启时支持）。</li></ol></li><li><strong>与数据库事务区别</strong>：  <ul><li>Redis事务无回滚机制，不保证数据强一致性，主要用于批量执行命令而非复杂事务。</li></ul></li></ul></li></ul><h3 id="2、-Redis管道（Pipeline）的作用是什么？如何提升性能？"><a href="#2、-Redis管道（Pipeline）的作用是什么？如何提升性能？" class="headerlink" title="2、 Redis管道（Pipeline）的作用是什么？如何提升性能？"></a>2、 Redis管道（Pipeline）的作用是什么？如何提升性能？</h3><ul><li><strong>答案</strong>  <ul><li><p><strong>作用</strong>：将多个命令一次性发送给Redis服务器，减少网络往返时间（RTT）。  </p></li><li><p><strong>性能提升</strong>：  </p><ol><li>客户端打包多个命令发送，服务器按顺序执行并返回结果。  </li><li>避免每条命令单独等待响应，吞吐量提升明显（适合批量操作）。</li></ol></li><li><p><strong>示例</strong>：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>();</span><br><span class="line"><span class="type">Pipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> jedis.pipelined();</span><br><span class="line">pipeline.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">pipeline.get(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">List&lt;Object&gt; results = pipeline.syncAndReturnAll();  <span class="comment">// 一次性获取所有结果</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、-Lua脚本在Redis中的作用和优势？如何保证原子性？"><a href="#3、-Lua脚本在Redis中的作用和优势？如何保证原子性？" class="headerlink" title="3、 Lua脚本在Redis中的作用和优势？如何保证原子性？"></a>3、 Lua脚本在Redis中的作用和优势？如何保证原子性？</h3><ul><li><strong>答案</strong>  <ul><li><strong>作用</strong>：将多个命令组合成一个脚本，在服务器端原子执行。  </li><li><strong>优势</strong>：  <ol><li><strong>原子性</strong>：脚本执行期间不会被其他命令打断。  </li><li><strong>减少网络开销</strong>：多个命令合并为一个请求。  </li><li><strong>复杂逻辑支持</strong>：如限流、秒杀库存扣减。</li></ol></li><li><strong>原子性保证</strong>：  <ul><li>Redis单线程执行Lua脚本，执行期间不会处理其他命令。</li></ul></li><li><strong>示例</strong>：  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 扣减库存（KEYS[1]=库存key，ARGV[1]=扣减数量）</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;GET&quot;</span>, KEYS[<span class="number">1</span>])) &gt;= <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&quot;DECRBY&quot;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">-- 成功</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  <span class="comment">-- 失败</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="五、缓存问题与解决方案"><a href="#五、缓存问题与解决方案" class="headerlink" title="五、缓存问题与解决方案"></a><strong>五、缓存问题与解决方案</strong></h2><h3 id="1、-缓存穿透、缓存雪崩、缓存击穿的区别及解决方案？"><a href="#1、-缓存穿透、缓存雪崩、缓存击穿的区别及解决方案？" class="headerlink" title="1、 缓存穿透、缓存雪崩、缓存击穿的区别及解决方案？"></a>1、 缓存穿透、缓存雪崩、缓存击穿的区别及解决方案？</h3><ul><li><strong>答案</strong>  <ul><li><strong>缓存穿透</strong>：  <ul><li><strong>问题</strong>：查询不存在的数据（如无效ID），绕过缓存直接查数据库。  </li><li><strong>解决</strong>：  <ol><li>布隆过滤器拦截无效请求。  </li><li>缓存空值并设置短过期时间（如<code>SET key_null &quot;&quot; EX 60</code>）。</li></ol></li></ul></li><li><strong>缓存雪崩</strong>：  <ul><li><strong>问题</strong>：大量缓存同时过期，请求直接压垮数据库。  </li><li><strong>解决</strong>：  <ol><li>随机化过期时间（如基础时间+随机偏移）。  </li><li>永不过期 + 异步更新缓存。</li></ol></li></ul></li><li><strong>缓存击穿</strong>：  <ul><li><strong>问题</strong>：热点Key突然过期，高并发查询数据库。  </li><li><strong>解决</strong>：  <ol><li>互斥锁（如Redis分布式锁），只允许一个线程重建缓存。  </li><li>逻辑过期：缓存不设置过期时间，由后台线程定期更新。</li></ol></li></ul></li></ul></li></ul><h3 id="2、-如何保证缓存与数据库的数据一致性（如双写一致性）？"><a href="#2、-如何保证缓存与数据库的数据一致性（如双写一致性）？" class="headerlink" title="2、 如何保证缓存与数据库的数据一致性（如双写一致性）？"></a>2、 如何保证缓存与数据库的数据一致性（如双写一致性）？</h3><ul><li><strong>答案</strong>  <ul><li><strong>策略</strong>：  <ol><li><strong>Cache Aside（旁路缓存）</strong>：  <ul><li>读：先查缓存，未命中则查数据库并回填缓存。  </li><li>写：先更新数据库，再删除缓存（防脏读）。</li></ul></li><li><strong>延迟双删</strong>：更新数据库后，删除缓存并延迟再删一次（防旧数据残留）。  </li><li><strong>订阅数据库Binlog</strong>：通过Canal等工具监听数据库变更，异步更新缓存。</li></ol></li><li><strong>注意</strong>：  <ul><li>强一致性难实现，通常接受短暂不一致（如金融场景需结合分布式事务）。</li></ul></li></ul></li></ul><h3 id="3、-延迟双删策略的原理和实现步骤？"><a href="#3、-延迟双删策略的原理和实现步骤？" class="headerlink" title="3、 延迟双删策略的原理和实现步骤？"></a>3、 延迟双删策略的原理和实现步骤？</h3><ul><li><strong>答案</strong>  <ul><li><p><strong>原理</strong>：在数据库更新后，先删除一次缓存，延迟一段时间后再删一次，防止旧数据因并发问题被重新写入缓存。  </p></li><li><p><strong>步骤</strong>：  </p><ol><li>更新数据库。  </li><li>删除缓存（第一次删除）。  </li><li>延迟一定时间（如500ms）。  </li><li>再次删除缓存（第二次删除）。</li></ol></li><li><p><strong>实现</strong>：  </p><ul><li>使用消息队列或定时任务触发第二次删除。  </li><li><strong>示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateData</span><span class="params">(Data data)</span> &#123;</span><br><span class="line">    updateDatabase(data);          <span class="comment">// 更新数据库</span></span><br><span class="line">    redis.del(data.getId());       <span class="comment">// 第一次删除</span></span><br><span class="line">    delayQueue.add(data.getId());  <span class="comment">// 延迟队列触发第二次删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="4、-如何处理热Key和大Key问题？对性能的影响是什么？"><a href="#4、-如何处理热Key和大Key问题？对性能的影响是什么？" class="headerlink" title="4、 如何处理热Key和大Key问题？对性能的影响是什么？"></a>4、 如何处理热Key和大Key问题？对性能的影响是什么？</h3><ul><li><strong>答案</strong>  <ul><li><strong>热Key（Hot Key）</strong>：  <ul><li><strong>问题</strong>：某Key被高频访问，导致单节点压力过大。  </li><li><strong>解决</strong>：  <ol><li>本地缓存（如Guava Cache）。  </li><li>分片：将Key拆分为多个子Key（如<code>hotkey:1</code>, <code>hotkey:2</code>）。  </li><li>读写分离：主节点写，从节点读。</li></ol></li></ul></li><li><strong>大Key（Big Key）</strong>：  <ul><li><strong>问题</strong>：Value过大（如10MB的Hash），阻塞网络和内存。  </li><li><strong>解决</strong>：  <ol><li>拆分：将Hash拆分为多个小Hash（如按ID分段）。  </li><li>压缩：使用Snappy等算法压缩Value。  </li><li>删除优化：异步删除（UNLINK命令）。</li></ol></li></ul></li></ul></li></ul><h2 id="六、性能优化与监控"><a href="#六、性能优化与监控" class="headerlink" title="六、性能优化与监控"></a><strong>六、性能优化与监控</strong></h2><h3 id="1、-Redis的慢查询日志如何配置与分析？"><a href="#1、-Redis的慢查询日志如何配置与分析？" class="headerlink" title="1、 Redis的慢查询日志如何配置与分析？"></a>1、 Redis的慢查询日志如何配置与分析？</h3><ul><li><strong>答案</strong>  <ul><li><strong>配置</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis.conf</span></span><br><span class="line">slowlog-log-slower-than 10000  <span class="comment"># 超过10ms的记录为慢查询</span></span><br><span class="line">slowlog-max-len 128           <span class="comment"># 最多保存128条日志</span></span><br></pre></td></tr></table></figure></li><li><strong>查看日志</strong>：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLOWLOG GET 10  # 获取最近10条慢查询</span><br></pre></td></tr></table></figure></li><li><strong>分析</strong>：  <ul><li>检查复杂命令（如KEYS、大范围ZRANGE）。  </li><li>优化方案：拆分大Key、避免全表扫描、使用Pipeline。</li></ul></li></ul></li></ul><h3 id="2、-Redis内存碎片产生原因及优化方法？"><a href="#2、-Redis内存碎片产生原因及优化方法？" class="headerlink" title="2、 Redis内存碎片产生原因及优化方法？"></a>2、 Redis内存碎片产生原因及优化方法？</h3><ul><li><strong>答案</strong>  <ul><li><strong>原因</strong>：频繁修改、删除数据导致内存空间不连续。  </li><li><strong>优化</strong>：  <ol><li><strong>重启</strong>：强制内存重新分配（极端情况）。  </li><li><strong>配置优化</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">activedefrag <span class="built_in">yes</span>               <span class="comment"># 开启自动碎片整理</span></span><br><span class="line">active-defrag-ignore-bytes 100mb  <span class="comment"># 碎片超过100MB时触发</span></span><br></pre></td></tr></table></figure></li><li><strong>避免频繁修改</strong>：如减少频繁的APPEND操作。</li></ol></li></ul></li></ul><h3 id="3、-Redis的并发竞争问题（如多客户端写同一个Key）如何解决？"><a href="#3、-Redis的并发竞争问题（如多客户端写同一个Key）如何解决？" class="headerlink" title="3、 Redis的并发竞争问题（如多客户端写同一个Key）如何解决？"></a>3、 Redis的并发竞争问题（如多客户端写同一个Key）如何解决？</h3><ul><li><strong>答案</strong>  <ul><li><strong>解决方案</strong>：  <ol><li><strong>分布式锁</strong>：如使用Redisson实现互斥写操作。  </li><li><strong>乐观锁</strong>：结合WATCH命令（监视Key变化，事务执行失败则重试）。  </li><li><strong>Lua脚本</strong>：将多命令原子执行。</li></ol></li><li><strong>示例</strong>：  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 乐观锁实现（WATCH + 事务）</span></span><br><span class="line">WATCH key</span><br><span class="line"><span class="keyword">local</span> value = redis.call(<span class="string">&quot;GET&quot;</span>, key)</span><br><span class="line">value = value + <span class="number">1</span></span><br><span class="line">MULTI</span><br><span class="line">redis.call(<span class="string">&quot;SET&quot;</span>, key, value)</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4、-Redis的网络模型（Reactor模式）和多路复用机制如何工作？"><a href="#4、-Redis的网络模型（Reactor模式）和多路复用机制如何工作？" class="headerlink" title="4、 Redis的网络模型（Reactor模式）和多路复用机制如何工作？"></a>4、 Redis的网络模型（Reactor模式）和多路复用机制如何工作？</h3><ul><li><strong>答案</strong>  <ul><li><strong>Reactor模式</strong>：  <ol><li><strong>事件分发器</strong>：通过epoll&#x2F;kqueue监听Socket事件。  </li><li><strong>事件处理器</strong>：将就绪事件分发给对应的处理函数。</li></ol></li><li><strong>多路复用</strong>：  <ul><li>单线程通过I&#x2F;O多路复用同时监听多个Socket，按事件类型（读&#x2F;写）分发给命令处理器。</li></ul></li><li><strong>Redis 6.0多线程</strong>：  <ul><li>网络I&#x2F;O由多线程处理（默认关闭），命令执行仍为单线程。</li></ul></li></ul></li></ul><h2 id="七、分布式场景与实战"><a href="#七、分布式场景与实战" class="headerlink" title="七、分布式场景与实战"></a><strong>七、分布式场景与实战</strong></h2><h3 id="1、-RedLock算法的实现原理及争议点是什么？"><a href="#1、-RedLock算法的实现原理及争议点是什么？" class="headerlink" title="1、 RedLock算法的实现原理及争议点是什么？"></a>1、 RedLock算法的实现原理及争议点是什么？</h3><ul><li><strong>答案</strong>  <ul><li><strong>原理</strong>：  <ol><li>客户端向多个Redis节点依次请求加锁（SETNX + 超时时间）。  </li><li>半数以上节点加锁成功，且总耗时小于锁超时时间，则认为加锁成功。</li></ol></li><li><strong>争议点</strong>：  <ol><li><strong>时钟漂移</strong>：节点间时钟不同步可能导致锁提前失效。  </li><li><strong>性能开销</strong>：需多次网络通信，高并发下可能性能下降。</li></ol></li><li><strong>替代方案</strong>：使用ZooKeeper或etcd实现更严格的分布式锁。</li></ul></li></ul><h3 id="2、-Redis如何实现分布式会话（Session）管理？"><a href="#2、-Redis如何实现分布式会话（Session）管理？" class="headerlink" title="2、 Redis如何实现分布式会话（Session）管理？"></a>2、 Redis如何实现分布式会话（Session）管理？</h3><ul><li><strong>答案</strong>  <ul><li><strong>实现</strong>：  <ol><li>用户登录后生成唯一Session ID，存储用户数据到Redis（如Hash结构）。  </li><li>Session ID返回给客户端（如Cookie中）。  </li><li>每次请求验证Session ID并延长过期时间。</li></ol></li><li><strong>优势</strong>：  <ul><li>支持水平扩展，避免单点故障。  </li><li>示例：Spring Session + Redis实现分布式Session。</li></ul></li></ul></li></ul><h3 id="3、-缓存更新策略了解哪些"><a href="#3、-缓存更新策略了解哪些" class="headerlink" title="3、 缓存更新策略了解哪些"></a>3、 缓存更新策略了解哪些</h3><ul><li><strong>答案</strong>  <ul><li><strong>Cache Aside</strong>：  <ul><li><strong>读</strong>：缓存命中直接返回，未命中查数据库并回填。  </li><li><strong>写</strong>：先更新数据库，再删除缓存。</li></ul></li><li><strong>Read Through</strong>：  <ul><li>由缓存服务自动加载数据库数据到缓存（如Guava Cache的LoadingCache）。</li></ul></li><li><strong>Write Through</strong>：  <ul><li>写操作同时更新缓存和数据库（需保证事务性）。</li></ul></li></ul></li></ul><h2 id="八、高级特性与源码"><a href="#八、高级特性与源码" class="headerlink" title="八、高级特性与源码"></a><strong>八、高级特性与源码</strong></h2><h3 id="1、-Redis-6-0多线程模型是如何设计的？与单线程的区别？"><a href="#1、-Redis-6-0多线程模型是如何设计的？与单线程的区别？" class="headerlink" title="1、 Redis 6.0多线程模型是如何设计的？与单线程的区别？"></a>1、 Redis 6.0多线程模型是如何设计的？与单线程的区别？</h3><ul><li><strong>答案</strong>  <ul><li><strong>设计</strong>：  <ol><li><strong>I&#x2F;O多线程</strong>：网络读写由多个线程处理（默认关闭，需配置<code>io-threads 4</code>）。  </li><li><strong>命令执行</strong>：仍为单线程，保证原子性。</li></ol></li><li><strong>区别</strong>：  <ul><li>单线程：所有操作由主线程串行处理。  </li><li>多线程：仅网络I&#x2F;O多线程，提升吞吐量（适合高并发场景）。</li></ul></li></ul></li></ul><h3 id="2、-Redis的惰性删除（Lazy-Free）机制是什么？"><a href="#2、-Redis的惰性删除（Lazy-Free）机制是什么？" class="headerlink" title="2、 Redis的惰性删除（Lazy Free）机制是什么？"></a>2、 Redis的惰性删除（Lazy Free）机制是什么？</h3><ul><li><strong>答案</strong>  <ul><li><strong>原理</strong>：异步删除大Key（UNLINK命令），将删除操作放入后台线程，避免阻塞主线程。 </li><li><strong>配置</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction <span class="built_in">yes</span>    <span class="comment"># 内存淘汰时异步删除</span></span><br><span class="line">lazyfree-lazy-expire <span class="built_in">yes</span>      <span class="comment"># 过期Key异步删除</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3、-Redis的持久化混合模式（RDB-AOF）如何配置？"><a href="#3、-Redis的持久化混合模式（RDB-AOF）如何配置？" class="headerlink" title="3、 Redis的持久化混合模式（RDB+AOF）如何配置？"></a>3、 Redis的持久化混合模式（RDB+AOF）如何配置？</h3><ul><li><strong>答案</strong>  <ul><li><strong>配置</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble <span class="built_in">yes</span>  <span class="comment"># 开启混合模式（AOF文件包含RDB头部）</span></span><br></pre></td></tr></table></figure></li><li><strong>效果</strong>：  <ul><li>定期生成RDB快照作为AOF文件头部，后续追加增量AOF命令。  </li><li>兼顾恢复速度和数据安全性。</li></ul></li></ul></li></ul><h2 id="九、运维与安全"><a href="#九、运维与安全" class="headerlink" title="九、运维与安全"></a><strong>九、运维与安全</strong></h2><h3 id="1、-Redis的常见性能监控指标有哪些（如QPS、内存使用率）？"><a href="#1、-Redis的常见性能监控指标有哪些（如QPS、内存使用率）？" class="headerlink" title="1、 Redis的常见性能监控指标有哪些（如QPS、内存使用率）？"></a>1、 Redis的常见性能监控指标有哪些（如QPS、内存使用率）？</h3><ul><li><strong>答案</strong>  <ul><li><strong>关键指标</strong>：  <ol><li><strong>QPS</strong>：<code>redis-cli info stats | grep instantaneous_ops_per_sec</code>。  </li><li><strong>内存使用率</strong>：<code>redis-cli info memory | grep used_memory_human</code>。  </li><li><strong>连接数</strong>：<code>redis-cli info clients | grep connected_clients</code>。  </li><li><strong>持久化状态</strong>：<code>redis-cli info persistence</code>（查看RDB&#x2F;AOF状态）。  </li><li><strong>复制延迟</strong>：<code>redis-cli info replication</code>（<code>master_repl_offset</code>与<code>slave_repl_offset</code>差值）。</li></ol></li></ul></li></ul><h3 id="2、-Redis如何实现数据备份与恢复？"><a href="#2、-Redis如何实现数据备份与恢复？" class="headerlink" title="2、 Redis如何实现数据备份与恢复？"></a>2、 Redis如何实现数据备份与恢复？</h3><ul><li><strong>答案</strong>  <ul><li><strong>备份</strong>：  <ol><li><strong>RDB快照</strong>：手动执行<code>SAVE</code>（阻塞）或<code>BGSAVE</code>（后台生成RDB文件）。  </li><li><strong>AOF文件</strong>：定期拷贝AOF文件到备份存储。</li></ol></li><li><strong>恢复</strong>：  <ol><li>将RDB文件放入Redis数据目录，重启Redis自动加载。  </li><li>使用<code>redis-check-aof</code>修复AOF文件后重启。</li></ol></li></ul></li></ul><h3 id="3、-Redis的安全防护措施（如密码认证、禁用高危命令）？"><a href="#3、-Redis的安全防护措施（如密码认证、禁用高危命令）？" class="headerlink" title="3、 Redis的安全防护措施（如密码认证、禁用高危命令）？"></a>3、 Redis的安全防护措施（如密码认证、禁用高危命令）？</h3><ul><li><strong>答案</strong>  <ul><li><strong>措施</strong>：  <ol><li><strong>密码认证</strong>：配置<code>requirepass yourpassword</code>。  </li><li><strong>禁用高危命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rename-command FLUSHALL <span class="string">&quot;&quot;</span>          <span class="comment"># 禁用FLUSHALL</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;NEW_CONFIG&quot;</span>  <span class="comment"># 重命名CONFIG命令</span></span><br></pre></td></tr></table></figure></li><li><strong>网络隔离</strong>：绑定内网IP（<code>bind 127.0.0.1</code>），配置防火墙。  </li><li><strong>权限控制</strong>：使用ACL（Redis 6.0+）限制用户权限。</li></ol></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 缓存与数据库一致性分析</title>
      <link href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E7%BC%93%E5%AD%98%20%E4%B8%8E%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E7%BC%93%E5%AD%98%20%E4%B8%8E%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="redis-缓存与数据库一致性-分析"><a href="#redis-缓存与数据库一致性-分析" class="headerlink" title="redis 缓存与数据库一致性 分析"></a>redis 缓存与数据库一致性 分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="谈谈分布式系统中的一致性"><a href="#谈谈分布式系统中的一致性" class="headerlink" title="谈谈分布式系统中的一致性"></a>谈谈分布式系统中的一致性</h2><p>分布式系统中的一致性指的是在多个节点上存储和处理数据时，确保系统中的数据在不同节点之间保持一致的特性。在分布式系统中，一致性通常可以分为以下几个类别：</p><ol><li><strong>强一致性</strong>： 布式系统中，双写一致性主要指在一个数据同时存在于缓存（如Redis）和持久化存储（如数据库）的情况下，任何一方的数据更新都必须确保另一方数据的同步更新，以保持双方数据的一致状态。这一问题的核心在于如何在并发环境下正确处理缓存与数据库的读写交互，防止数据出现不一致的情况。</li></ol><h3 id="典型场景分析"><a href="#典型场景分析" class="headerlink" title="典型场景分析"></a>典型场景分析</h3><ol><li><strong>写数据库后忘记更新缓存</strong>：<br>当直接对数据库进行更新操作而没有相应地更新缓存时，后续的读请求可能仍然从缓存中获取旧数据，导致数据的不一致。</li><li><strong>删除缓存后数据库更新失败：</strong><br>在某些场景下，为了保证数据新鲜度，会在更新数据库前先删除缓存。但如果数据库更新过程中出现异常导致更新失败，那么缓存将长时间处于空缺状态，新的查询将会直接命中数据库，加重数据库压力，并可能导致数据版本混乱。</li><li><strong>并发环境下读写操作的交错执行</strong>：<br>在高并发场景下，可能存在多个读写请求同时操作同一份数据的情况。比如，在删除缓存、写入数据库的过程中，新的读请求获取到了旧的数据库数据并放入缓存，此时就出现了数据不一致的现象。</li><li><strong>主从复制延迟与缓存失效时间窗口冲突</strong>：<br>对于具备主从复制功能的数据库集群，主库更新数据后，存在一定的延迟才将数据同步到从库。如果在此期间缓存刚好过期并重新从数据库加载数据，可能会从尚未完成同步的从库读取到旧数据，进而导致缓存与主库数据的不一致。</li></ol><p>数据不一致不仅会导致业务逻辑出错，还可能引发用户界面展示错误、交易状态不准确等问题，严重时甚至会影响系统的正常运行和用户体验。</p><h2 id="解决双写一致性问题的主要策略"><a href="#解决双写一致性问题的主要策略" class="headerlink" title="解决双写一致性问题的主要策略"></a>解决双写一致性问题的主要策略</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240409020515.png" alt="image.png"></p><p>在解决Redis缓存与数据库双写一致性问题上，有多种策略和模式。我们主要介绍以下几种主要的策略：</p><h3 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h3><p>Cache Aside Pattern 是一种在分布式系统中广泛采用的缓存和数据库协同工作策略，在这个模式中，数据以数据库为主存储，缓存作为提升读取效率的辅助手段。也是日常中比较常见的一种手段。其工作流程如下：<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240407234748.png" alt="image.png" style="zoom:67%;" /></p><p>由上图我们可以看出Cache Aside Pattern的工作原理：</p><ul><li><strong>读取操作</strong>：首先尝试从缓存中获取数据，如果缓存命中，则直接返回；否则，从数据库中读取数据并将其放入缓存，最后返回给客户端。</li><li><strong>更新操作</strong>：当需要更新数据时，首先更新数据库，然后再清除或使缓存中的对应数据失效。这样一来，后续的读请求将无法从缓存获取数据，从而迫使系统从数据库加载最新的数据并重新填充缓存。</li></ul><p>我们从更新操作上看会发现两个很有意思的问题：</p><h4 id="为什么操作缓存的时候是删除旧缓存而不是直接更新缓存？"><a href="#为什么操作缓存的时候是删除旧缓存而不是直接更新缓存？" class="headerlink" title="为什么操作缓存的时候是删除旧缓存而不是直接更新缓存？"></a><strong>为什么操作缓存的时候是删除旧缓存而不是直接更新缓存？</strong></h4><p>我们举例模拟下并发环境下的更新DB&amp;缓存：</p><ul><li>线程A先发起一个写操作，第一步先更新数据库，然后更新缓存</li><li>线程B再发起一个写操作，第二步更新了数据库，然后更新缓存<br>当以上两个线程的执行，如果严格先后顺序执行，那么对于更新缓存还是删除缓存去操作缓存都可以，但是如果两个线程同时执行时，由于网络或者其他原因，导致线程B先执行完更新缓存，然后线程A才会更新缓存。如下图：<img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240408224601.png" alt="image.png" style="zoom:67%;" /></li></ul><p>这时候缓存中保存的就是线程A的数据，而数据库中保存的是线程B的数据。这时候如果读取到的缓存就是脏数据。但是如果使用删除缓存取代更新缓存，那么就不会出现这个脏数据。这种方式可以简化并发控制、保证数据一致性、降低操作复杂度，并能更好地适应各种潜在的异常场景和缓存策略。尽管这种方法可能会增加一次数据库访问的成本，但在实际应用中，考虑到数据的一致性和系统的健壮性，这是值得付出的折衷。</p><p>并且在写多读少的情况下，数据很多时候并不会被读取到，但是一直被频繁的更新，这样也会浪费性能。实际上，写多的场景，用缓存也不是很划算。只有在读多写少的情况下使用缓存才会发挥更大的价值。</p><h4 id="为什么是先操作数据库再操作缓存？"><a href="#为什么是先操作数据库再操作缓存？" class="headerlink" title="为什么是先操作数据库再操作缓存？"></a><strong>为什么是先操作数据库再操作缓存？</strong></h4><p>在操作缓存时，为什么要先操作数据库而不是先操作缓存？我们同样举例模拟两个线程，线程A写入数据，先删除缓存在更新DB，线程B读取数据。流程如下：</p><ol><li>线程A发起一个写操作，第一步删除缓存</li><li>此时线程B发起一个读操作，缓存中没有，则继续读DB，读出来一个老数据</li><li>然后线程B把老数据放入缓存中</li><li>线程A更新DB数据</li></ol><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240408233213.png" alt="image.png" style="zoom:67%;" /><p>所以这样就会出现缓存中存储的是旧数据，而数据库中存储的是新数据，这样就出现脏数据，所以我们一般都采取先操作数据库，在操作缓存。这样后续的读请求从数据库获取最新数据并重新填充缓存。这样的设计降低了数据不一致的风险，提升了系统的可靠性。同时，这也符合CAP定理中对于一致性（Consistency）和可用性（Availability）权衡的要求，在很多场景下，数据一致性被优先考虑。</p><p>Cache Aside Pattern相对简单直观，容易理解和实现。只需要简单的判断和缓存失效逻辑即可，对已有系统的改动较小。并且由于缓存是按需加载的，所以不会浪费宝贵的缓存空间存储未被访问的数据，同时我们可以根据实际情况决定何时加载和清理缓存。</p><p>尽管Cache Aside Pattern在大多数情况下可以保证最终一致性，但它并不能保证强一致性。在数据库更新后的短暂时间内（还未开始操作缓存），如果有读请求发生，缓存中仍是旧数据，但是实际数据库中已是最新数据，造成短暂的数据不一致。在并发环境下，特别是在更新操作时，有可能在更新数据库和删除缓存之间的时间窗口内，新的读请求加载了旧数据到缓存，导致不一致。</p><h3 id="Read-Through-Write-Through（读写穿透）"><a href="#Read-Through-Write-Through（读写穿透）" class="headerlink" title="Read-Through&#x2F;Write-Through（读写穿透）"></a>Read-Through&#x2F;Write-Through（读写穿透）</h3><p>Read-Through 和 Write-Through 是两种与缓存相关的策略，它们主要用于缓存系统与持久化存储之间的数据交互，旨在确保缓存与底层数据存储的一致性。</p><h4 id="Read-Through（读穿透）"><a href="#Read-Through（读穿透）" class="headerlink" title="Read-Through（读穿透）"></a>Read-Through（读穿透）</h4><p>Read-Through 是一种在缓存中找不到数据时，自动从持久化存储中加载数据并回填到缓存中的策略。具体执行流程如下：</p><ul><li>客户端发起读请求到缓存系统。</li><li>缓存系统检查是否存在请求的数据。</li><li>如果数据不在缓存中，缓存系统会透明地向底层数据存储（如数据库）发起读请求。</li><li>数据库返回数据后，缓存系统将数据存储到缓存中，并将数据返回给客户端。</li><li>下次同样的读请求就可以直接从缓存中获取数据，提高了读取效率。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240409004738.png" alt="image.png"></p><p>整体简要流程类似<code>Cache Aside Pattern</code>，但在缓存未命中的情况下，Read-Through 策略会自动隐式地从数据库加载数据并填充到缓存中，而无需应用程序显式地进行数据库查询。</p><p>Cache Aside Pattern 更多地依赖于应用程序自己来管理缓存与数据库之间的数据流动，包括缓存填充、失效和更新。而Read-Through Pattern 则是在缓存系统内部实现了一个更加自动化的过程，使得应用程序无需关心数据是从缓存还是数据库中获取，以及如何保持两者的一致性。在Read-Through 中，缓存系统承担了更多的职责，实现了更紧密的缓存与数据库集成，从而简化了应用程序的设计和实现。</p><h4 id="Write-Through（写穿透）"><a href="#Write-Through（写穿透）" class="headerlink" title="Write-Through（写穿透）"></a>Write-Through（写穿透）</h4><p>Write-Through 是一种在缓存中更新数据时，同时将更新操作同步到持久化存储的策略。具体流程如下：</p><ul><li>当客户端向缓存系统发出写请求时，缓存系统首先更新缓存中的数据。</li><li>同时，缓存系统还会把这次更新操作同步到底层数据存储（如数据库）。</li><li>当数据在数据库中成功更新后，整个写操作才算完成。</li><li>这样，无论是从缓存还是直接从数据库读取，都能得到最新一致的数据。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240409004927.png" alt="image.png"></p><p>Read-Through 和 Write-Through 的共同目标是确保缓存与底层数据存储之间的一致性，并通过自动化的方式隐藏了缓存与持久化存储之间的交互细节，简化了客户端的处理逻辑。这两种策略经常一起使用，以提供无缝且一致的数据访问体验，特别适用于那些对数据一致性要求较高的应用场景。然而，需要注意的是，虽然它们有助于提高数据一致性，但在高并发或网络不稳定的情况下，仍然需要考虑并发控制和事务处理等问题，以防止数据不一致的情况发生。</p><h3 id="Write-behind-（异步缓存写入）"><a href="#Write-behind-（异步缓存写入）" class="headerlink" title="Write behind （异步缓存写入）"></a>Write behind （异步缓存写入）</h3><p>Write Behind（异步缓存写入），也称为 Write Back（回写）或 异步更新策略，是一种在处理缓存与持久化存储（如数据库）之间数据同步时的策略。在这种模式下，当数据在缓存中被更新时，并非立即同步更新到数据库，而是将更新操作暂存起来，随后以异步的方式批量地将缓存中的更改写入持久化存储。其流程如下：</p><ul><li>应用程序首先在缓存中执行数据更新操作，而不是直接更新数据库。</li><li>缓存系统会将此次更新操作记录下来，暂存于一个队列（如日志文件或内存队列）中，而不是立刻同步到数据库。</li><li>在后台有一个独立的进程或线程定期（或者当队列积累到一定大小时）从暂存队列中取出更新操作，然后批量地将这些更改写入数据库。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20240409005631.png" alt="image.png"></p><p>使用 Write Behind 策略时，由于更新并非即时同步到数据库，所以在异步处理完成之前，如果缓存或系统出现故障，可能会丢失部分更新操作。并且对于高度敏感且要求强一致性的数据，Write Behind 策略并不适用，因为它无法提供严格的事务性和实时一致性保证。Write Behind 适用于那些可以容忍一定延迟的数据一致性场景，通过牺牲一定程度的一致性换取更高的系统性能和扩展性。</p><h2 id="解决双写一致性问题的3种方案"><a href="#解决双写一致性问题的3种方案" class="headerlink" title="解决双写一致性问题的3种方案"></a>解决双写一致性问题的3种方案</h2><p>以上我们主要讲解了解决双写一致性问题的主要策略，但是每种策略都有一定的局限性，所以我们在实际运用中，还要结合一些其他策略去屏蔽上述策略的缺点。</p><h3 id="1-延时双删策略"><a href="#1-延时双删策略" class="headerlink" title="1. 延时双删策略"></a>1. 延时双删策略</h3><p>先说其他删除策略可能出现的问题，以此说明延时双删的必要性</p><ul><li>先删再更新</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250211230314525.png" alt="image-20250211230314525"></p><ul><li>先更新再删</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250211230413244.png" alt="image-20250211230413244"></p><ul><li>普通双删</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250211230437608.png" alt="image-20250211230437608"></p><ul><li>延时双删</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250211230511084.png" alt="image-20250211230511084"></p><h3 id="2-删除缓存重试机制"><a href="#2-删除缓存重试机制" class="headerlink" title="2. 删除缓存重试机制"></a>2. 删除缓存重试机制</h3><p>删除缓存重试机制是在删除缓存操作失败时，设定一个重试策略，确保缓存最终能被正确删除，以维持与数据库的一致性。</p><p>在执行数据库更新操作后，尝试删除关联的缓存项。如果首次删除缓存失败（例如网络波动、缓存服务暂时不可用等情况），系统进入重试逻辑，按照预先设定的策略（如指数退避、固定间隔重试等）进行多次尝试。直到缓存删除成功，或者达到最大重试次数为止。通过这种方式，即使在异常情况下也能尽量保证缓存与数据库的一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryableCacheService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000L))</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteCacheWithRetry</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        ((org.springframework.data.redis.cache.RedisCacheManager) cacheManager).getCache(<span class="string">&quot;myCache&quot;</span>).evict(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateAndDeleteCache</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// 更新数据库...</span></span><br><span class="line">        updateDatabase(key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试删除缓存，失败时自动重试</span></span><br><span class="line">        deleteCacheWithRetry(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新数据库的逻辑，此处仅示意</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateDatabase</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种重试方式确保缓存删除操作的成功执行，可以应对网络抖动等导致的临时性错误，提高数据一致性。但是可能占用额外的系统资源和时间，重试次数过多可能会阻塞其他操作。</p><h3 id="监听并读取biglog异步删除缓存"><a href="#监听并读取biglog异步删除缓存" class="headerlink" title="监听并读取biglog异步删除缓存"></a>监听并读取biglog异步删除缓存</h3><p>在数据库发生写操作时，将变更记录在binlog或类似的事务日志中，然后使用一个专门的异步服务或者监听器订阅binlog的变化（比如Canal），一旦检测到有数据更新，便根据binlog中的操作信息定位到受影响的缓存项。讲这些需要更新缓存的数据发送到消息队列，消费者处理消息队列中的事件，异步地删除或更新缓存中的对应数据，确保缓存与数据库保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinlogEventHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleBinlogEvent</span><span class="params">(BinlogEvent binlogEvent)</span> &#123;</span><br><span class="line">        <span class="comment">// 解析binlogEvent，获取需要更新缓存的key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> deriveCacheKeyFromBinlogEvent(binlogEvent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送到RocketMQ</span></span><br><span class="line">        rocketMQTemplate.asyncSend(<span class="string">&quot;cacheUpdateTopic&quot;</span>, cacheKey, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;</span><br><span class="line">                <span class="comment">// 发送成功处理</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;</span><br><span class="line">                <span class="comment">// 发送失败处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从binlog事件中获取缓存key的逻辑，这里仅为示意</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">deriveCacheKeyFromBinlogEvent</span><span class="params">(BinlogEvent binlogEvent)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RocketMQMessageListener(consumerGroup = &quot;myConsumerGroup&quot;, topic = &quot;cacheUpdateTopic&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheUpdateConsumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody());</span><br><span class="line">        redisTemplate.delete(cacheKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的好处是将缓存的更新操作与主业务流程解耦，避免阻塞主线程，同时还能处理数据库更新后由于网络问题或并发问题导致的缓存更新滞后情况。当然，实现这一策略相对复杂，需要对数据库的binlog机制有深入理解和定制开发。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在分布式系统中，为了保证缓存与数据库双写一致性，可以采用以下方案：</p><ol><li><strong>读取操作</strong>：<ul><li>先尝试从缓存读取数据，若缓存命中，则直接返回缓存中的数据。</li><li>若缓存未命中，则从数据库读取数据，并将数据放入缓存。</li></ul></li><li><strong>更新操作</strong>：<ul><li>在更新数据时，首先在数据库进行写入操作，确保主数据库数据的即时更新。</li><li>为了减少数据不一致窗口，采用异步方式处理缓存更新，具体做法是监听数据库的binlog事件，异步进行删除缓存。</li><li>在一主多从的场景下，为了确保数据一致性，需要等待所有从库的binlog事件都被处理后才删除缓存（确保全部从库均已更新）。</li></ul></li></ol><p>同时，还需注意以下要点：</p><ul><li>对于高并发环境，可能需要结合分布式锁、消息队列或缓存失效延时等技术，进一步确保并发写操作下的数据一致性。</li><li>异步处理binlog时，务必考虑异常处理机制和重试策略，确保binlog事件能够正确处理并执行缓存更新操作</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson 分布式锁原理</title>
      <link href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redisson%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/"/>
      <url>/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redisson%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Redisson-分布式锁原理"><a href="#Redisson-分布式锁原理" class="headerlink" title="Redisson 分布式锁原理"></a>Redisson 分布式锁原理</h1><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>使用redisson实现分布式锁的操作步骤，三部曲</p><ul><li>第一步： 获取锁 RLock redissonLock &#x3D; redisson.getLock(lockKey);</li><li>第二步： 加锁，实现锁续命功能 redissonLock.lock();</li><li>第三步：释放锁 redissonLock.unlock();</li></ul><hr><h2 id="Redisson分布式锁实现原理"><a href="#Redisson分布式锁实现原理" class="headerlink" title="Redisson分布式锁实现原理"></a>Redisson分布式锁实现原理</h2><p>熟悉了基本用法以后，我们来看下Redission实现分布式锁的原理，再理解了原理之后，后续梳理源码实现就更加得心应手了。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/39d951639fd6df2ace166d42baa30551.png" alt="img"></p><hr><h2 id="Redisson分布式锁源码分析"><a href="#Redisson分布式锁源码分析" class="headerlink" title="Redisson分布式锁源码分析"></a>Redisson分布式锁源码分析</h2><p>流程图如下</p><p>重点主要是依赖lua脚本的原子性，实现加锁和释放锁的功能</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/9e2c3d96f820f837aea8f0a7d81aa58c.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis 三大集群模式</title>
      <link href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E9%9B%86%E7%BE%A4/"/>
      <url>/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="详解Redis三大集群模式"><a href="#详解Redis三大集群模式" class="headerlink" title="详解Redis三大集群模式"></a>详解Redis三大集群模式</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/734446-20230423104553727-1171728881.png" alt="image"></p><h2 id="1-Redis集群简介"><a href="#1-Redis集群简介" class="headerlink" title="1. Redis集群简介"></a><strong>1. Redis集群简介</strong></h2><h3 id="1-1-什么是Redis集群"><a href="#1-1-什么是Redis集群" class="headerlink" title="1.1 什么是Redis集群"></a><strong>1.1 什么是Redis集群</strong></h3><p>Redis集群是一种通过将多个Redis节点连接在一起以实现高可用性、数据分片和负载均衡的技术。它允许Redis在不同节点上同时提供服务，提高整体性能和可靠性。根据搭建的方式和集群的特性，Redis集群主要有三种模式：主从复制模式（Master-Slave）、哨兵模式（Sentinel）和Cluster模式。</p><h3 id="1-2-Redis集群的作用和优势"><a href="#1-2-Redis集群的作用和优势" class="headerlink" title="1.2 Redis集群的作用和优势"></a><strong>1.2 Redis集群的作用和优势</strong></h3><ol><li><strong>高可用性</strong>：Redis集群可以在某个节点发生故障时，自动进行故障转移，保证服务的持续可用。</li><li><strong>负载均衡</strong>：Redis集群可以将客户端请求分发到不同的节点上，有效地分摊节点的压力，提高系统的整体性能。</li><li><strong>容灾恢复</strong>：通过主从复制或哨兵模式，Redis集群可以在主节点出现故障时，快速切换到从节点，实现业务的无缝切换。</li><li><strong>数据分片</strong>：在Cluster模式下，Redis集群可以将数据分散在不同的节点上，从而突破单节点内存限制，实现更大规模的数据存储。</li><li><strong>易于扩展</strong>：Redis集群可以根据业务需求和系统负载，动态地添加或移除节点，实现水平扩展。</li></ol><p>通过了解Redis集群的概念和优势，接下来将详细介绍三大集群模式的原理、配置、优缺点以及应用场景。</p><h2 id="2-主从复制模式（Master-Slave）"><a href="#2-主从复制模式（Master-Slave）" class="headerlink" title="2. 主从复制模式（Master-Slave）"></a><strong>2. 主从复制模式</strong>（Master-Slave）</h2><h3 id="2-1-主从复制原理"><a href="#2-1-主从复制原理" class="headerlink" title="2.1 主从复制原理"></a><strong>2.1 主从复制原理</strong></h3><p>主从复制是Redis的一种基本集群模式，它通过将一个Redis节点（主节点）的数据复制到一个或多个其他Redis节点（从节点）来实现数据的冗余和备份。</p><p>主节点负责处理客户端的写操作，同时从节点会实时同步主节点的数据。客户端可以从从节点读取数据，实现读写分离，提高系统性能。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/734446-20230423104604712-958561171.png" alt="image" style="zoom:67%;" /><h3 id="2-2-主从复制配置和实现"><a href="#2-2-主从复制配置和实现" class="headerlink" title="2.2 主从复制配置和实现"></a><strong>2.2 主从复制配置和实现</strong></h3><ol><li><p><strong>配置主节点</strong>：在主节点的redis.conf配置文件中，无需进行特殊配置，主节点默认监听所有客户端请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主节点默认端口号6379</span></span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure></li><li><p><strong>配置从节点</strong>：在从节点的redis.conf配置文件中，添加如下配置，指定主节点的地址和端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从节点设置端口号6380</span></span><br><span class="line">port 6380</span><br><span class="line"></span><br><span class="line"><span class="comment"># replicaof 主节点IP 主节点端口</span></span><br><span class="line">replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure><p>或者，通过Redis命令行在从节点上执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; replicaof 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li><li><p><strong>验证主从复制</strong>：在主节点上执行写操作，然后在从节点上进行读操作，检查数据是否一致。</p></li></ol><h3 id="2-3-主从复制的优缺点"><a href="#2-3-主从复制的优缺点" class="headerlink" title="2.3 主从复制的优缺点"></a><strong>2.3 主从复制的优缺点</strong></h3><p><strong>优点</strong>：</p><ol><li>配置简单，易于实现。</li><li>实现数据冗余，提高数据可靠性。</li><li>读写分离，提高系统性能。</li></ol><p><strong>缺点</strong>：</p><ol><li>主节点故障时，需要手动切换到从节点，故障恢复时间较长。</li><li>主节点承担所有写操作，可能成为性能瓶颈。</li><li>无法实现数据分片，受单节点内存限制。</li></ol><h3 id="2-4-主从复制场景应用"><a href="#2-4-主从复制场景应用" class="headerlink" title="2.4 主从复制场景应用"></a><strong>2.4 主从复制场景应用</strong></h3><p>主从复制模式适用于以下场景：</p><ol><li>数据备份和容灾恢复：通过从节点备份主节点的数据，实现数据冗余。</li><li>读写分离：将读操作分发到从节点，减轻主节点压力，提高系统性能。</li><li>在线升级和扩展：在不影响主节点的情况下，通过增加从节点来扩展系统的读取能力。</li></ol><p>总结：主从复制模式适合数据备份、读写分离和在线升级等场景，但在主节点故障时需要手动切换，不能自动实现故障转移。如果对高可用性要求较高，可以考虑使用哨兵模式或Cluster模式。</p><h2 id="3-哨兵模式（Sentinel）"><a href="#3-哨兵模式（Sentinel）" class="headerlink" title="3. 哨兵模式（Sentinel）"></a><strong>3. 哨兵模式</strong>（<strong>Sentinel）</strong></h2><h3 id="3-1-哨兵模式原理"><a href="#3-1-哨兵模式原理" class="headerlink" title="3.1 哨兵模式原理"></a><strong>3.1 哨兵模式原理</strong></h3><p>哨兵模式是在主从复制基础上加入了哨兵节点，实现了自动故障转移。哨兵节点是一种特殊的Redis节点，它会监控主节点和从节点的运行状态。当主节点发生故障时，哨兵节点会自动从从节点中选举出一个新的主节点，并通知其他从节点和客户端，实现故障转移。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/734446-20230423104619091-219085123.png" alt="image" style="zoom:67%;" /><h3 id="3-2-哨兵模式配置和实现"><a href="#3-2-哨兵模式配置和实现" class="headerlink" title="3.2 哨兵模式配置和实现"></a><strong>3.2 哨兵模式配置和实现</strong></h3><ol><li><p><strong>配置主从复制</strong>：首先按照主从复制模式的配置方法，搭建一个主从复制集群（上面已经讲过）。</p></li><li><p><strong>配置哨兵节点</strong>：在哨兵节点上创建一个新的哨兵配置文件（如：sentinel.conf），并添加如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel节点端口号</span></span><br><span class="line">port 26379</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel monitor 被监控主节点名称 主节点IP 主节点端口 quorum</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds 被监控主节点名称 毫秒数</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 60000</span><br><span class="line"></span><br><span class="line"><span class="comment"># sentinel failover-timeout 被监控主节点名称 毫秒数</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br></pre></td></tr></table></figure><p>其中，<code>quorum</code>是指触发故障转移所需的最小哨兵节点数。<code>down-after-milliseconds</code>表示主节点被判断为失效的时间。<code>failover-timeout</code>是故障转移超时时间。</p><blockquote><p>为什么只配置了sentinel监控主节点，没有配置监控从节点？<br>因为通过主节点，就可以找到从节点。</p></blockquote></li><li><p><strong>启动哨兵节点</strong>：使用如下命令启动哨兵节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; redis-sentinel /path/to/sentinel.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>验证哨兵模式</strong>：手动停止主节点，观察哨兵节点是否自动选举出新的主节点，并通知其他从节点和客户端。</p></li></ol><h3 id="3-3-哨兵模式的优缺点"><a href="#3-3-哨兵模式的优缺点" class="headerlink" title="3.3 哨兵模式的优缺点"></a><strong>3.3 哨兵模式的优缺点</strong></h3><p><strong>优点</strong>：</p><ol><li>自动故障转移，提高系统的高可用性。</li><li>具有主从复制模式的所有优点，如数据冗余和读写分离。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理相对复杂。</li><li>依然无法实现数据分片，受单节点内存限制。</li></ol><h3 id="3-4-哨兵模式场景应用"><a href="#3-4-哨兵模式场景应用" class="headerlink" title="3.4 哨兵模式场景应用"></a><strong>3.4 哨兵模式场景应用</strong></h3><p>哨兵模式适用于以下场景：</p><ol><li>高可用性要求较高的场景：通过自动故障转移，确保服务的持续可用。</li><li>数据备份和容灾恢复：在主从复制的基础上，提供自动故障转移功能。</li></ol><p>总结：哨兵模式在主从复制模式的基础上实现了自动故障转移，提高了系统的高可用性。然而，它仍然无法实现数据分片。如果需要实现数据分片和负载均衡，可以考虑使用Cluster模式。</p><h2 id="4-Cluster模式"><a href="#4-Cluster模式" class="headerlink" title="4. Cluster模式"></a><strong>4. Cluster模式</strong></h2><h3 id="4-1-Cluster模式原理"><a href="#4-1-Cluster模式原理" class="headerlink" title="4.1 Cluster模式原理"></a><strong>4.1 Cluster模式原理</strong></h3><p>Cluster模式是Redis的一种高级集群模式，它通过数据分片和分布式存储实现了负载均衡和高可用性。在Cluster模式下，Redis将所有的键值对数据分散在多个节点上。每个节点负责一部分数据，称为槽位。通过对数据的分片，Cluster模式可以突破单节点的内存限制，实现更大规模的数据存储。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/734446-20230423104631153-1328078427.png" alt="image"></p><h3 id="4-2-数据分片与槽位"><a href="#4-2-数据分片与槽位" class="headerlink" title="4.2 数据分片与槽位"></a><strong>4.2 数据分片与槽位</strong></h3><p>Redis Cluster将数据分为16384个槽位，每个节点负责管理一部分槽位。当客户端向Redis Cluster发送请求时，Cluster会根据键的哈希值将请求路由到相应的节点。具体来说，Redis Cluster使用CRC16算法计算键的哈希值，然后对16384取模，得到槽位编号。</p><h3 id="4-3-Cluster模式配置和实现"><a href="#4-3-Cluster模式配置和实现" class="headerlink" title="4.3 Cluster模式配置和实现"></a><strong>4.3 Cluster模式配置和实现</strong></h3><ol><li><p><strong>配置Redis节点</strong>：为每个节点创建一个redis.conf配置文件，并添加如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cluster节点端口号</span></span><br><span class="line">port 7001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点超时时间</span></span><br><span class="line">cluster-node-timeout 15000</span><br></pre></td></tr></table></figure></li></ol><p>像这样的配置，一共需要创建6个，我们做一个三主三从的集群。</p><ol><li><p><strong>启动Redis节点</strong>：使用如下命令启动6个节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; redis-server redis_7001.conf</span><br></pre></td></tr></table></figure></li><li><p><strong>创建Redis Cluster</strong>：使用Redis命令行工具执行如下命令创建Cluster：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><p><strong>cluster-replicas</strong> 表示从节点的数量，1代表每个主节点都有一个从节点。</p></li><li><p><strong>验证Cluster模式</strong>：向Cluster发送请求，观察请求是否正确路由到相应的节点。</p></li></ol><h3 id="4-4-Cluster模式的优缺点"><a href="#4-4-Cluster模式的优缺点" class="headerlink" title="4.4 Cluster模式的优缺点"></a><strong>4.4 Cluster模式的优缺点</strong></h3><p><strong>优点</strong>：</p><ol><li>数据分片，实现大规模数据存储。</li><li>负载均衡，提高系统性能。</li><li>自动故障转移，提高高可用性。</li></ol><p><strong>缺点</strong>：</p><ol><li>配置和管理较复杂。</li><li>一些复杂的多键操作可能受到限制。</li></ol><h3 id="4-5-Cluster模式场景应用"><a href="#4-5-Cluster模式场景应用" class="headerlink" title="4.5 Cluster模式场景应用"></a><strong>4.5 Cluster模式场景应用</strong></h3><p>Cluster模式适用于以下场景：</p><ol><li>大规模数据存储：通过数据分片，突破单节点内存限制。</li><li>高性能要求场景：通过负载均衡，提高系统性能。</li><li>高可用性要求场景：通过自动故障转移，确保服务的持续可用。</li></ol><p>总结：Cluster模式在提供高可用性的同时，实现了数据分片和负载均衡，适用于大规模数据存储和高性能要求的场景。然而，它的配置和管理相对复杂，且某些复杂的多键操作可能受到限制。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h2><p>本文详细介绍了Redis的三大集群模式：主从复制、哨兵模式和Cluster模式。每种模式都有其特点和应用场景，具体如下：</p><ol><li><strong>主从复制模式</strong>：适用于数据备份和读写分离场景，配置简单，但在主节点故障时需要手动切换。</li><li><strong>哨兵模式</strong>：在主从复制的基础上实现自动故障转移，提高高可用性，适用于高可用性要求较高的场景。</li><li><strong>Cluster模式</strong>：通过数据分片和负载均衡实现大规模数据存储和高性能，适用于大规模数据存储和高性能要求场景。</li></ol><p>在实际应用中，可以根据系统的需求和特点选择合适的Redis集群模式，以实现高可用性、高性能和大规模数据存储</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型设计模式</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型设计模式的主要关注点是“怎么创建对象”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建有相关的工厂来完成。就像我们去商城购买商品时，不需要知道商品是怎么深处出来的一样，因为它们由专业的厂商生产。</p><p>创建型模式分为以下几种：</p><ul><li>简单工厂模式：</li><li>单例（Singleton）模式：某个类只能生成一个实例，该实例提供一个全局访问店供外部获取该对象，其扩展时有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类型的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，有子类决定生产什么产品。</li><li>抽象工厂（Abstract Factory）模式：提供一个创建产品族的接口，其每个子类可以生产一些列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建从复杂对象。</li></ul><p>以上 5 种创建型模式，处理工厂方法模式属于（类）创建型模式，其他的全部属于（对象）创建模式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例（Singleton）模式的定义：指一个类只有一个实例，其该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示的内容不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1）单例类只有一个对象；</p><p>2）该单例对象必须由单例类自行创建；</p><p>3）单例类对外提供一个访问该单例的全局访问店。</p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><p>单例模式是设计模式中最简单的模式之一。通常，普通类的 结构函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法通过调用该类的构造函数，也就无法生成多个实例。这是该类自身必须定义一个静态私有实例，并向外提供一个讲台的公有函数用于创建或获取静态私有实例。</p><p>下面分析单例模式的实现。</p><p>单例模式有懒汉式和饿汉式两种实现形式。</p><h4 id="第一种：懒汉式"><a href="#第一种：懒汉式" class="headerlink" title="第一种：懒汉式"></a>第一种：懒汉式</h4><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getInstance 方法才去创建单例。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种：饿汉式单例"><a href="#第二种：饿汉式单例" class="headerlink" title="第二种：饿汉式单例"></a>第二种：饿汉式单例</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类 创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，以后线程安全的，可以直接用于多线程而不会出现问题。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的板子、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式志云与创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象有频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h3><p>原型模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。这种方式创建对象非常高效，根本无需指定对象创建的细节。例如，Windows 操作系统的安装通常比较耗时，如果复制就快了很多。</p><h3 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>原型模式包含以下主要角色：</p><p>① 抽象原型类：规定了具体原型对象必须实现的接口。</p><p>② 具体实现类：实现抽象原型类的 clone() 方法，它使可被复制的对象。</p><p>③ 访问类：使用具体原型类中的 clone() 方法来复制新对象。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候，</li><li><strong>对象的创建过程比较麻烦</strong>，但复制比较简单的时候。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="定义与特点-1"><a href="#定义与特点-1" class="headerlink" title="定义与特点"></a>定义与特点</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者。它使将一个复杂的对象分解为多个简单的对象，然后一步步构建而成。它将变与不变相分离，即产品的组成部分是不变得，但每一部分是可以灵活选择的。</p><h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><ol><li>各个具体建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于口直细节风险。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>产品的组成部分必须相同，这限制了其使用的范围。</li><li>如果产品的内部变化负责，该模式会增加很多的建造者类。</li></ol><p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零 部件的创建过程，但两者可以结合使用。</p><h3 id="结构与实现-1"><a href="#结构与实现-1" class="headerlink" title="结构与实现"></a>结构与实现</h3><p>建造者模式由产品、抽象建造者、具体建造者、指挥者等4个要素构成，现在我们来分析其基本结构和实现方法。</p><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>建造者模式的主要角色如下。</p><ol><li>产品角色：它是包含多个组成部件的复杂对象，有具体建造者来创建其各个部件。</li><li>抽象建造者：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六大设计原则</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则是面向对象设计中的一项基本准则，它有助于构建出更加健壮、可维护和可扩展的软件系统</p><p>单一职责原则强调的是软件实体（如类、模块、函数等）应当具有单一的职责，即一个类应该只负责一个功能领域中的相应职责。</p><h3 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h3><p>单一职责原则可以表述为：“一个类应该只有一个引起它变化的原因。”换句话说，如果一个类承担了多个职责，那么当其中一个职责发生变化时，可能会影响到其他职责的实现，从而导致类的修改变得复杂和频繁。</p><h3 id="单一职责原则的意义"><a href="#单一职责原则的意义" class="headerlink" title="单一职责原则的意义"></a>单一职责原则的意义</h3><ul><li><strong>提高可维护性</strong>：当一个类只负责单一的职责时，它的功能更明确，也更容易理解和维护。如果需要修改某一部分功能，可以定位到具体的类，而不会影响到其他无关的职责。</li><li><strong>降低耦合度</strong>：单一职责原则有助于降低类之间的耦合度，因为每个类只关注于自己的职责，减少了对其他类的依赖。</li><li><strong>提高可复用性</strong>：职责单一的类更容易被复用，因为它们的功能更纯粹，更不容易受到其他功能变化的影响。</li><li><strong>促进模块化设计</strong>：遵循单一职责原则可以促使开发者将系统划分为更小、更独立的模块，每个模块负责一个特定的职责，这有利于系统的扩展和重构。</li></ul><h3 id="如何判断职责是否单一"><a href="#如何判断职责是否单一" class="headerlink" title="如何判断职责是否单一"></a>如何判断职责是否单一</h3><p>判断一个类的职责是否单一，可以从以下几个角度考虑：</p><ul><li>变化的独立性：如果一个类的多个功能会因为不同的原因而变化，那么这些功能可能就不应该放在同一个类中。</li><li>功能的独立性：如果一个类的多个功能可以独立地被测试和复用，那么它们可能更适合被分离到不同的类中。</li><li>代码的可读性和可理解性：如果一个类的代码量过大，或者代码的逻辑复杂，以至于难以理解和维护，那么可能表明类的职责不够单一。</li></ul><h3 id="实践单一职责原则"><a href="#实践单一职责原则" class="headerlink" title="实践单一职责原则"></a>实践单一职责原则</h3><p>在实践中，遵循单一职责原则可能需要对现有的类进行重构，将职责分解到多个类中。例如，一个原本负责数据处理和界面显示的类，可以被拆分为一个专门的数据处理器类和一个专门的视图控制器类。这样，每个类只负责自己的核心职责，提高了整体系统的质量和可维护性。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则主张软件实体（如类、模块、函数等）应该对扩展开放（Open for extension），对修改关闭（Closed for modification）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>开闭原则可以这样表述：“软件实体应当在不修改的情况下就可以被扩展。”这意味着，当系统需要增加新的功能时，应该通过添加新的代码来实现，而不是修改已有的代码。这样做的目的是为了保持现有代码的稳定性和可维护性。</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>可维护性</strong>：遵循开闭原则的系统更容易维护，因为新的需求可以通过扩展现有功能来实现，而不需要修改原有代码，减少了引入新bug的风险。</li><li><strong>可扩展性</strong>：系统设计遵循开闭原则，意味着可以通过添加新的类或组件来轻松地扩展功能，而无需触及原有的代码。</li><li><strong>稳定性</strong>：开闭原则有助于保持系统的稳定性，因为已验证的代码不会因为新的需求而被修改，降低了系统崩溃的风险。</li><li><strong>灵活性</strong>：开闭原则鼓励使用抽象和多态，这使得系统设计更加灵活，能够更好地应对未来的变化。</li></ul><h3 id="实现开闭原则的方法"><a href="#实现开闭原则的方法" class="headerlink" title="实现开闭原则的方法"></a>实现开闭原则的方法</h3><p>要实现开闭原则，通常采用以下几种方法：</p><ul><li>使用抽象：通过定义抽象类或接口，为系统提供一个稳定的接口，具体的实现可以通过继承或实现接口的类来提供。</li><li>依赖注入：通过依赖注入，系统可以在运行时动态地提供具体实现，而无需修改代码。</li><li>策略模式：策略模式允许算法在运行时被替换，这样可以根据不同的情况使用不同的算法实现，而无需修改调用算法的代码。</li><li>工厂模式：工厂模式可以创建对象而不需要指定具体的类，这使得系统可以在不修改现有代码的情况下添加新的对象类型。</li></ul><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>尽管开闭原则提供了诸多优点，但在实际应用中也会遇到一些挑战。例如，过度抽象可能导致设计过于复杂，增加了理解和维护的成本。此外，设计时需要充分预见未来可能的变化，否则可能需要重新设计系统结构才能适应新的需求。<br>开闭原则是面向对象设计的重要基石，它鼓励设计者从一开始就考虑系统的可扩展性和可维护性，通过合理的设计来减少未来的修改成本，从而构建出更加健壮和灵活的软件系统。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则是关于继承和多态的正确使用，确保在使用继承时，子类可以替换其父类，并且程序的行为不会因此而改变。</p><p>里氏替换原则是面向对象设计中确保继承和多态正确使用的基石，它有助于构建出更加健壮、可复用和可扩展的软件系统。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>里氏替换原则可以这样表述：“如果S是T的子类型，则可以将对象s的任何地方替换成T类型的对象t，而程序的行为不会受到影响。”换句话说，任何期望接收T类型的地方，都能接受S类型的对象，而不会破坏程序的正确性。</p><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>保证继承的正确性</strong>：LSP确保了继承关系的正确使用，避免了因不当的继承而导致的程序行为改变。</li><li><strong>增强代码的可复用性</strong>：遵循LSP的子类可以安全地替换基类，从而提高了代码的可复用性。</li><li><strong>提高代码的健壮性</strong>：LSP有助于构建更加健壮的系统，因为子类不会破坏基类的契约，减少了错误的发生。</li><li><strong>促进多态的正确使用</strong>：LSP鼓励使用多态来实现代码的灵活性，而不是滥用继承来达到代码复用的目的。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>要遵循LSP，需要在设计和实现继承关系时注意以下几点：</p><ul><li>避免改变基类的预设行为：子类应该保留基类的公共接口行为，除非有明确的理由并且在文档中明确指出。</li><li>避免过度覆盖或重写：子类重写基类的方法时，应确保不会改变或破坏基类方法的语义。</li><li>设计良好的接口：基类或接口应该设计得足够通用，以适应多种可能的实现，同时避免过于宽泛导致的约束不足。</li><li>使用接口隔离原则（ISP）：确保子类不需要依赖于基类中不会使用的接口部分，这有助于更好地满足LSP。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一个基类Shape，它有一个area()方法计算形状的面积。根据LSP，任何使用Shape的地方，应该能够接受任何Shape的子类，如Circle或Rectangle，而不会改变程序的行为。</p><h3 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h3><p>在实际应用中，LSP有时会与代码的灵活性和复用性产生冲突。例如，严格遵循LSP可能限制了子类的自由度，使得某些特定的优化或定制变得困难。因此，在设计时需要权衡LSP与实际需求之间的关系，找到合适的平衡点。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，简称LoD），也称为最少知识原则（Least Knowledge Principle，简称LKP）。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>一个对象应当对其他对象有尽可能少的了解。</strong></p><p>具体而言，一个对象应该只与它的直接朋友通信，这里的“朋友”指的是：</p><ul><li>该对象自身；</li><li>该对象的参数；</li><li>该对象的成员对象；</li><li>该对象创建的对象；</li></ul><h3 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h3><ul><li>降低耦合度：通过限制对象之间的交互，迪米特法则有助于降低对象之间的耦合度，使得一个对象的修改不会轻易影响到其他对象。</li><li>提高可维护性：较少的依赖关系意味着代码更容易理解和维护，因为每个对象的职责和行为更加明确。</li><li>提高可测试性：对象之间较少的交互使得单元测试变得更加简单，因为不需要模拟太多的外部依赖。</li><li>促进模块化设计：迪米特法则鼓励模块化设计，每个模块只关注其直接相关的部分，这有助于构建出更加灵活和可扩展的系统。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>要遵循迪米特法则，可以采取以下一些做法：</p><ul><li>减少对象间的直接通信：避免一个对象直接访问另一个对象的内部状态，而是通过调用方法来进行通信。</li><li>使用中介者模式：当多个对象之间存在复杂的交互时，可以引入一个中介者对象来协调这些对象之间的通信。</li><li>利用依赖注入：通过依赖注入框架，可以减少对象之间的直接依赖，使得对象之间的关系更加松散。</li><li>避免深度的对象图遍历：一个对象不应该访问另一个对象的属性，再通过这个属性访问第三个对象的属性，以此类推，形成深度的对象图遍历。</li></ul><h3 id="挑战-2"><a href="#挑战-2" class="headerlink" title="挑战"></a>挑战</h3><p>虽然迪米特法则有助于降低耦合度，但在实际应用中也可能带来一些挑战。例如，过度的解耦可能导致代码结构过于复杂，或者增加代码的间接性，这有时会降低代码的直观性和性能。因此，在应用迪米特法则时，也需要权衡其带来的好处与可能的负面影响。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle，简称ISP），ISP 主张客户端不应该被强迫依赖于它不使用的方法，也就是说，不应该有“胖接口”（fat interfaces）的存在。</p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>使用多个专门的接口比使用单一的总接口要好。</p><p>也即意味着，一个类应该依赖于细粒度的接口，而不是依赖于一个包含了多个不相关功能的大接口。</p><h3 id="意义-3"><a href="#意义-3" class="headerlink" title="意义"></a>意义</h3><p>降低耦合度：ISP有助于降低类之间的耦合度，因为每个类只依赖于它真正需要的接口，而不是一个包含了多余方法的大接口。<br>提高灵活性：细粒度的接口使得系统更加灵活，因为可以更容易地添加、修改或删除接口而不影响到其他部分。<br>提高可维护性：当接口细化后，每个接口的职责更加明确，这有助于代码的可读性和可维护性。<br>避免强制依赖：ISP避免了类由于依赖于大接口而被迫实现它并不需要的所有方法，这减少了代码的冗余和复杂性。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>要遵循ISP，可以采取以下一些做法：<br>细化接口：将大型接口分解为多个小的、特定的接口，每个接口只包含一组相关的方法。<br>按需实现：类应该只实现它真正需要的接口，避免实现那些它永远不会使用的方法。<br>定制接口：为特定的类或子系统定制接口，这样可以确保接口中的方法都是必要的。<br>避免过度继承：在设计接口层次结构时，避免不必要的接口继承，因为这可能导致接口的膨胀。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>假设有一个“动物”接口，它包含了“吃”、“走”、“飞”和“游泳”等方法。但是，并非所有动物都会飞或游泳。按照ISP，可以将这个大接口分解为多个小接口，比如“飞行动物”接口、“水生动物”接口等，这样，鸟类可以实现“飞行动物”接口，鱼类可以实现“水生动物”接口，而哺乳动物则可以实现“陆生动物”接口。</p><h3 id="挑战-3"><a href="#挑战-3" class="headerlink" title="挑战"></a>挑战</h3><p>虽然ISP有助于提高系统的灵活性和可维护性，但过度的接口细分也可能导致接口数量的激增，从而增加系统的复杂性。因此，在应用ISP时，需要找到一个平衡点，既要避免“胖接口”，也要避免不必要的接口细分。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则（Dependency Inversion Principle，简称DIP）， DIP 强调了高层次模块与低层次模块之间的依赖关系，以及依赖于抽象而非具体实现的重要性。</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><h3 id="意义-4"><a href="#意义-4" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>降低耦合度</strong>：通过依赖于抽象，模块之间的耦合度降低，因为模块不再直接依赖于其他模块的具体实现。</li><li><strong>提高可维护性</strong>：当依赖于抽象时，修改或替换具体实现变得更加容易，而不会影响到依赖于这些实现的高层模块。</li><li><strong>增强灵活性</strong>：依赖倒置原则使得系统更加灵活，因为可以通过更改配置或依赖注入等方式轻松地切换不同的实现。</li><li><strong>促进模块化设计</strong>：依赖于抽象促进了模块化设计，每个模块专注于实现特定的抽象，而不需要关心其他模块的实现细节。</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>要遵循依赖倒置原则，可以采取以下一些做法：</p><ul><li><strong>使用抽象层</strong>：通过定义接口或抽象类作为高层模块与低层模块之间的桥梁，使得高层模块依赖于抽象，而低层模块提供具体的实现。</li><li><strong>依赖注入</strong>：通过构造函数、setter方法或静态工厂方法等方式，将具体实现传递给依赖于抽象的模块，而不是在模块内部创建这些实现。</li><li><strong>避免紧耦合</strong>：避免高层模块直接依赖于低层模块的具体实现，而是通过抽象接口或服务定位器等机制来获取所需的服务。</li><li>模块间通信：模块之间的通信应该通过抽象接口进行，而不是直接引用具体类，这样可以降低模块之间的耦合度。</li></ul><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>假设有一个日志记录模块，它可以记录各种信息。按照依赖倒置原则，日志记录模块不应该直接依赖于文件系统、数据库或其他具体存储方式，而是应该依赖于一个抽象的日志存储接口。这样，无论是将日志信息写入文件、数据库还是发送到远程服务器，只需要提供符合日志存储接口的具体实现即可，而不需要修改日志记录模块的代码。</p><h3 id="挑战-4"><a href="#挑战-4" class="headerlink" title="挑战"></a>挑战</h3><p>虽然依赖倒置原则有助于提高系统的灵活性和可维护性，但过度的抽象和依赖注入也可能导致代码结构变得复杂，增加理解和维护的难度。因此，在应用依赖倒置原则时，需要找到一个平衡点，既不过度抽象，也不过分依赖于具体实现。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述-——-代码设计"><a href="#设计模式概述-——-代码设计" class="headerlink" title="设计模式概述 —— 代码设计"></a>设计模式概述 —— 代码设计</h1><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>上来就讲破大天，不如先明确<strong>代码设计的核心诉求</strong>：</p><ul><li>安全性</li><li>正确性</li><li>高效性</li><li>可维护</li><li>易拓展</li></ul><p>围绕以上目标，历代开发者总结出的历史经验：</p><ul><li>设计原则 —— 心法</li><li>设计模式 —— 剑谱</li></ul><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><h3 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h3><ul><li><strong>Single Responsibility Principle：单一职责原则</strong></li><li><strong>Open Closed Principle：开闭原则</strong></li><li><strong>Liskov Substitution Principle：里氏替换原则</strong></li><li><strong>Law of Demeter：迪米特法则</strong></li><li><strong>Interface Segregation Principle：接口隔离原则</strong></li><li><strong>Dependence Inversion Principle：依赖倒置原则</strong></li></ul><p>把这六个原则的首字母联合起来（两个 L 算做一个）就是 SOLID （solid，稳定的），其代表的含义就是这六个原则结合使用的好处：建立稳定、灵活、健壮的设计。下面我们来分别看一下这六大设计原则。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240709223429759.png" alt="image-20240709223429759"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据目的"><a href="#根据目的" class="headerlink" title="根据目的"></a>根据目的</h4><ul><li>创建型</li><li>行为型</li><li>结构型</li></ul><h4 id="根据作用对象"><a href="#根据作用对象" class="headerlink" title="根据作用对象"></a>根据作用对象</h4><ul><li>类模式</li><li>对象模式</li></ul><table><thead><tr><th><strong>范围&#x2F;目的</strong></th><th><strong>创建型模式</strong></th><th><strong>结构型模式</strong></th><th><strong>行为型模式</strong></th></tr></thead><tbody><tr><td><strong>类模式</strong></td><td>工厂方法</td><td>（类）适配器</td><td>模板方法 <br />解释器</td></tr><tr><td><strong>对象模式</strong></td><td>单例<br /> 原型 <br />抽象工厂 <br />建造者</td><td>代理 <br />（对象）适配器 <br />桥接 <br />装饰 <br />外观 <br />享元 <br />组合</td><td>策略 <br />命令 <br />职责链 <br />状态 <br />观察者 <br />中介者 <br />迭代器 <br />访问者 <br />备忘录</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除以上的经验外，还有其他一些经验，也值得在代码设计或开发过程中进行使用</p><ul><li>模块拆分与设计</li><li>持续重构</li><li>文档注释</li><li>单元测试</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
