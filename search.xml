<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TCP 状态详解</title>
      <link href="/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-状态详解"><a href="#TCP-状态详解" class="headerlink" title="TCP 状态详解"></a>TCP 状态详解</h1><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2846604-6a8557619966204d.png" alt="img"></p><h2 id="TCP-状态梳理"><a href="#TCP-状态梳理" class="headerlink" title="TCP 状态梳理"></a>TCP 状态梳理</h2><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待来自远程TCP应用程序的请求</td></tr><tr><td>SYN_SENT</td><td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td></tr><tr><td>SYN-RECEIVED</td><td>该端点已经接收到连接请求并发送确认。 该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td></tr><tr><td>ESTABLISHED</td><td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td></tr><tr><td>FIN_WAIT_1</td><td>等待来自远程TCP的终止连接请求或终止请求的确认</td></tr><tr><td>FIN_WAIT_2</td><td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td></tr><tr><td>CLOSE_WAIT</td><td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td></tr><tr><td>CLOSING</td><td>等待来自远程TCP的连接终止请求确认</td></tr><tr><td>LAST_ACK</td><td>等待先前发送到远程TCP的连接终止请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td></tr></tbody></table><p><strong>牢记： TCP 到处都是坑</strong>， 现在就开始找坑</p><h2 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h2><ul><li><p>归属： 客户端独有</p></li><li><p>原因：</p><ul><li>网络延迟</li><li>服务器负载过高</li><li>防火墙有问题</li><li>中病毒——自动扫描其它机器</li></ul></li><li><p>限制</p><ul><li>超时后重传，重传间隔时间递增</li><li>限制最大重传次数</li></ul></li><li><p>linux syn 重试次数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syn_retries=6</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 6 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure></li></ul><h2 id="SYN-RECV"><a href="#SYN-RECV" class="headerlink" title="SYN_RECV"></a>SYN_RECV</h2><ul><li>归属： 服务端独有</li><li>原因：<ul><li>对端网络突然异常 ？</li><li>网络攻击 —— <strong>SYN 泛洪攻击</strong></li></ul></li><li>术语<ul><li>SYN_FLOOD 泛洪攻击</li><li>半连接队列 <ul><li>自然 还有一个全连接队列</li></ul></li></ul></li><li>SYN_FLOOD 防范<ul><li>扩展半连接队列上限<ul><li><code>net.ipv4.tcp_max_syn_backlog</code></li></ul></li><li>覆盖最早半连接记录</li><li>SYN Cookie</li></ul></li><li>非攻击导致 半连接队列高涨<ul><li>可考虑修改 <code>net.ipv4.tcp_synack_retries</code></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS 详解</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS-BASIC"><a href="#HDFS-BASIC" class="headerlink" title="HDFS BASIC"></a>HDFS BASIC</h1><p>  当需要存储的数据集的大小超过了一台独立的物理计算机的存储能力时，就需要对数据进行分区并存储到若干台计算机上去。管理网络中跨多台计算机存储的文件系统统称为<strong>分布式文件系统（distributed fileSystem）</strong>。</p><p>  分布式文件系统由于其跨计算机的特性，所以依赖于网络的传输，势必会比普通的本地文件系统更加复杂，比如：如何使得文件系统能够容忍节点的故障并且保证不丢失数据，这就是一个很大的挑战</p><h2 id="HDFS简介及其基本概念"><a href="#HDFS简介及其基本概念" class="headerlink" title="HDFS简介及其基本概念"></a>HDFS简介及其基本概念</h2><p>  HDFS（Hadoop Distributed File System）是hadoop生态系统的一个重要组成部分，是hadoop中的的存储组件，在整个Hadoop中的地位非同一般，是最基础的一部分，因为它涉及到数据存储，MapReduce等计算模型都要依赖于存储在HDFS中的数据。HDFS是一个分布式文件系统，以流式数据访问模式存储超大文件，将数据分块存储到一个商业硬件集群内的不同机器上。</p><p>  这里重点介绍其中涉及到的几个概念：</p><p>（1）<strong>超大文件</strong>。目前的hadoop集群能够存储几百TB甚至PB级的数据。</p><p>（2）<strong>流式数据访问</strong>。HDFS的访问模式是：<strong>一次写入，多次读取</strong>，更加关注的是读取整个数据集的整体时间。</p><p>（3）<strong>商用硬件。</strong>HDFS集群的设备不需要多么昂贵和特殊，只要是一些日常使用的普通硬件即可，正因为如此，hdfs节点故障的可能性还是很高的，所以<strong>必须要有机制来处理这种单点故障</strong>，保证数据的可靠。</p><p>（4）<strong>不支持低时间延迟的数据访问</strong>。hdfs关心的是高数据吞吐量，不适合那些要求低时间延迟数据访问的应用。</p><p>（5）<strong>单用户写入，不支持任意修改。</strong>hdfs的数据以读为主，只支持单个写入者，并且写操作总是以添加的形式在文末追加，不支持在任意位置进行修改。</p><h2 id="HDFS-整体架构"><a href="#HDFS-整体架构" class="headerlink" title="HDFS 整体架构"></a>HDFS 整体架构</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616194928432.png" alt="image-20240616194928432"></p><ul><li>主从 —— nameNode + DataNode</li><li>Namenode—— Active &#x2F; Standby ，高可用</li></ul><h2 id="BLOCK-数据块-与-DataNode"><a href="#BLOCK-数据块-与-DataNode" class="headerlink" title="BLOCK 数据块 与 DataNode"></a>BLOCK 数据块 与 DataNode</h2><ul><li>HDFS 最小存储单元</li><li>多BLOCK多副本<ul><li>文件被器分为若干个 Block， 每个Block 有多个副本（默认3）</li><li>BLock 以 DataNode 为存储单元，即一个DataNode 智能存储Block的一个副本</li><li>机架感知： 尽量将 副本存放到不同的几家上，以提高容灾能力</li><li>副本均匀分布： DataNode 的 BLock 副本数和访问负荷要比较接近，已实现负载均衡</li></ul></li><li>Block 大小<ul><li>默认 128M，可调整（若Block中数据实际大小 &lt; 设定值，则Block 大小 &#x3D; 实际数据大小）</li><li>如何调整Block大小<ul><li>目标： <ul><li>最小化寻址开销， 降到 1%以下</li><li>任务并发度 和 集群负载比较适中，作业运行速度较快</li></ul></li><li>块太小<ul><li>寻址时间占比过高</li><li>Map 任务太多，并发度高，导致集群负载过高，作业变慢</li></ul></li><li>块太大<ul><li>Map 任务少，并发度太低，导致集群负载过低，作业变慢</li></ul></li></ul></li></ul></li><li>Block 文件<ul><li>Block 文件是DataNode 本地磁盘中名为 “blk_blockId”  的Linux 文件<ul><li>DataNode 在启动时自动创建存储目录，无需格式化</li><li>DataNode 的 current 目录下的文件名都已 “blk_” 为前缀</li><li>Block 的元数据文件（*.meta） 由一个包含版本、类型信息的头文件和一系列校验值组成</li></ul></li></ul></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616200613192.png" alt="image-20240616200613192" style="zoom:73%;" /><h2 id="NameNode-与-元数据存储"><a href="#NameNode-与-元数据存储" class="headerlink" title="NameNode 与 元数据存储"></a>NameNode 与 元数据存储</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li>目录文件爱你的基本属性（名称、所有者等），Block 相关信息（如文件包含哪些 Block，Block 放在那些节点上）、DataNode 相关信息</li><li>主要存储在 内存 <ul><li>为确保集群数据安全，需要对数据进行落盘 <ul><li>Block 位于哪些 DataNode    会由 DataNode 进行上报</li><li>因此仅持久化 文件划分成了 哪些 Block 的信息</li></ul></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616201427764.png" alt="image-20240616201427764"></p><h3 id="内存元数据"><a href="#内存元数据" class="headerlink" title="内存元数据"></a>内存元数据</h3><ul><li>Active NameNode : 最新的元数据（fsimage + edits）</li><li>Standby NameNode： 通过QJM （默认60s ）同步AN 的元数据</li></ul><h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><ul><li>内存元数据持久化后形成的文件</li><li>edits （编辑日志文件）<ul><li>保存了最近一个 Checkpoint 检查点之后的所有变更操作</li><li>变更操作应先写 edits ， 再写内存</li><li>edits 文件名通过 “Transaction Id 前后缀” 标记所包含更新操作的范围</li></ul></li><li>fsimage （元数据检查点镜像文件）<ul><li>Standby NameNode 在 CheckPoint 检查点定期对内存中的元数据进行持久化，生成 fsimage 镜像文件</li><li>fsimage 的写入速度较慢，所以不可能对变更操作进行实时持久化</li><li>fsimage 文件名标记处最后一个变更操作的 TransactionId ，一下图为例， 只要在内存冲载入 fsimage_*19，然后在内存中执行 edits_improgress_*20 就可以还原出最新的元数据<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202407518.png" alt="image-20240616202407518"></li></ul></li></ul><h3 id="edits-fsimage-重写"><a href="#edits-fsimage-重写" class="headerlink" title="edits &#x2F; fsimage 重写"></a>edits &#x2F; fsimage 重写</h3><h4 id="Hadoop-1-X-实现方式"><a href="#Hadoop-1-X-实现方式" class="headerlink" title="Hadoop 1.X 实现方式"></a>Hadoop 1.X 实现方式</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202545245.png" alt="image-20240616202545245"></p><h4 id="Hadoop-2-X-实现方式"><a href="#Hadoop-2-X-实现方式" class="headerlink" title="Hadoop 2.X 实现方式"></a>Hadoop 2.X 实现方式</h4><ul><li>QJM 共享存储系统<ul><li>基于 Paxos 算法实现的 JournalNode 集群， 实现了 edits 的高可用存储和共享访问</li><li>最好部署奇数（2*n+1）个节点 ， 也即最多容忍 n 个节点宕机</li><li>过半节点写入成功，即代表写入成功</li></ul></li><li>基于 QJM 的 edits 持久化<ul><li>AN 将变更操作同步写入本地和 QJM 的 edits</li><li>在内存中继续执行该操作，并将结果反馈给 Client</li></ul></li><li>基于 QJM 的 fsimage 持久化<ul><li>在 checkpoint 检查点，SN 先将内存元数据变为只读来暂停 QJM edits 的定期同步，再讲元数据镜像到 fsimage 中</li><li>SN 将 fsimage 上传到 AN ，同时回复 QJM 定期同步</li><li>AN 根据 fsimage 的事务Id ，删除旧 edits ，实现瘦身</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202739569.png" alt="image-20240616202739569"></p><h2 id="HDFS-读写流程"><a href="#HDFS-读写流程" class="headerlink" title="HDFS 读写流程"></a>HDFS 读写流程</h2><h3 id="HDFS-写流程"><a href="#HDFS-写流程" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><p><strong>注意点</strong></p><ul><li>block 拆分由 client 完成</li><li>Block 逐个发送</li><li>备份写入以 pipeline 形式实现，并递归返回写入结果</li><li>Block 全部写入后，Client 上报 AN ,  AN 生成元数据</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616203557631.png" alt="image-20240616203557631"></p><h3 id="HDFS-写流程-1"><a href="#HDFS-写流程-1" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><ul><li>Block 对应DataNode 副本列表， AN 会以 距离远近进行排序</li><li>Block 逐个读取</li><li>副本建联，按AN 返回列表顺序进行尝试</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616204521373.png" alt="image-20240616204521373"></p><h2 id="HDFS-安全模式"><a href="#HDFS-安全模式" class="headerlink" title="HDFS 安全模式"></a>HDFS 安全模式</h2><h3 id="什么是安全模式"><a href="#什么是安全模式" class="headerlink" title="什么是安全模式"></a>什么是安全模式</h3><ul><li>安全模式 是 HDFS 的一种特殊状态，</li><li>进入 ~ 后， HDFS 只接受 读数据请求，不接收 增删改 数据请求</li><li>安全模式是 HDFS 确保BLock 数据安全的一种保护机制</li><li>AN 启动时，HDFS 进入安全模式， DataNode 主动向 AN 汇报Block 列表信息，直至 DataNode 上报数量达到阈值， AN 离开安全模式</li></ul><h3 id="何时离开安全模式"><a href="#何时离开安全模式" class="headerlink" title="何时离开安全模式"></a>何时离开安全模式</h3><ul><li>BLock 上报率： DataNode 上报的可用 Block 数量 &#x2F; NameNode 元数据记录的 Block 数量</li><li>阈值： 上报率 &gt;&#x3D; 0.999 （默认， 可调）</li><li>不建议手动强制退出安全模式</li></ul><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><ul><li>DataNode —— 是否有 DataNode 不能正常启动，手动重启</li><li>NameNode 内存或磁盘不足？</li></ul><h1 id="HDFS-架构设计思考"><a href="#HDFS-架构设计思考" class="headerlink" title="HDFS 架构设计思考"></a>HDFS 架构设计思考</h1><h2 id="HDFS-优劣势"><a href="#HDFS-优劣势" class="headerlink" title="HDFS 优劣势"></a>HDFS 优劣势</h2><h3 id="DHFS-架构设计优势"><a href="#DHFS-架构设计优势" class="headerlink" title="DHFS 架构设计优势"></a>DHFS 架构设计优势</h3><ul><li>高容错性</li><li>一定的扩展性</li><li>可支持海量数据的可靠读写</li></ul><h3 id="HDFS-劣势"><a href="#HDFS-劣势" class="headerlink" title="HDFS 劣势"></a>HDFS 劣势</h3><ul><li><p>NameNode 内存受限问题</p><ul><li>通过 Federation 机制进一步扩展<ul><li>实际是基于 “路径” 的联邦， 属于 基本业务层扩展<ul><li>路径划分不合理，仍有可能导致 单路径下存储压力过大，以及不同路径下存储压力严重不均衡的问题</li></ul></li></ul></li></ul></li><li><p>NameNode 单点故障问题</p><ul><li>对 NameNode 做高可用</li></ul></li></ul><h2 id="HDFS-NA-高可用架构"><a href="#HDFS-NA-高可用架构" class="headerlink" title="HDFS NA 高可用架构"></a>HDFS NA 高可用架构</h2><ul><li>以下给出了 一种 高可用架构实现参考<ul><li>实际还需要考虑 DataNode 对于 NA 的变更感知</li><li>以及 edits 的一致性问题</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210305888.png" alt="image-20240616210305888"></p><h1 id="HDFS-API"><a href="#HDFS-API" class="headerlink" title="HDFS API"></a>HDFS API</h1><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210654411.png" alt="image-20240616210654411" style="zoom:70%;" align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210915156.png" alt="image-20240616210915156" style="zoom:75%;"  align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616211122508.png" alt="image-20240616211122508" style="zoom:80%;" align="left"/>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="部署HDFS"><a href="#部署HDFS" class="headerlink" title="部署HDFS"></a>部署HDFS</h1><p>HDFS的基本操作可以分为集群管理和文件系统操作两种类型：</p><ul><li>集群管理：包括Namenodede 的格式化、集群的启动和停止、集群信息查看等。</li><li>文件系统：包括对目录、文件和权限等内容的操作。</li></ul><p>HDFS中的命令主要在sbin和bin目录下[一般要进行环境变量的设置]：</p><ul><li>sbin:集群控制脚本(.sh)。</li><li>bin:hadoop的文件系统命令和其他管理维护工具。</li></ul><h2 id="hadoop安装和维护的方式"><a href="#hadoop安装和维护的方式" class="headerlink" title="hadoop安装和维护的方式"></a>hadoop安装和维护的方式</h2><p>主要有2种方式：</p><ul><li>一是从开源软件的官网网站直接下载软件包。</li><li>二是利用集成化软件对Hadoop集群进行部署和维护。[集成化工具：amabri、cloudera manager、华为的FusionInsight]</li></ul><p>第一种方式缺点：</p><ul><li>配置优化难度</li><li>组件整合难度</li></ul><h2 id="部署HDFS的核心步骤和部署原则"><a href="#部署HDFS的核心步骤和部署原则" class="headerlink" title="部署HDFS的核心步骤和部署原则"></a>部署HDFS的核心步骤和部署原则</h2><h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><ul><li><p>hadoop系统的规模</p></li><li><p>组件和角色规划</p><ul><li>A.确定需要安装哪些组件：比如要实现Namenode的高可用性，就需要额外安装ZK组件。</li><li>B.确定组件中的不同角色分别安装在哪些节点上：比如需要几个Datanode，分别安装在哪些服务器上，Namenode是安装在独立服务器上，还是和某个Datanode共享一台服务器。</li><li>C.根据角色规划确定所需的服务器性能需求：比如namenode所在服务器可以适当加大内存，以适应fsimage的可能大小，并且安装多块硬盘，将元数据信息保存在多个硬盘路径上，防止单个硬盘发生故障。</li><li>D.节点扩增：计算和存储能力不够时，很多时候就通过节点数量解决。</li></ul></li><li><p>配置规划：Datanode和Namenode一般都可以配置多个存储路径。</p><ul><li>A.Datanode实现多硬盘均匀存储。</li><li>B.Namenode可以实现多副本备份。</li></ul></li></ul><h3 id="linux环境准备"><a href="#linux环境准备" class="headerlink" title="linux环境准备"></a>linux环境准备</h3><p>HDFS作为hadoop的核心组件，随Hadoop一起整体部署。</p><p>安装hadoop前的环境准备：</p><ol><li>配置java环境变量：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</li><li>hadoop部署在多台服务器上，主从节点之间、各节点之间可以通过TCP&#x2F;IP协议相互访问[通过设置DNS或hosts文件，使得主机名和IP地址绑定，实现通过主机名就能访问对方]</li><li>确保hadoop所需端口打开：hadoop以及各类配套模板需要使用大量网络端口，但是自带的防火墙软件，设置不当造成功能无法正确运行。</li><li>SSH接口免密登录</li><li>Hadoop以及分布式NoSQL数据库要求各个节点之间的时间同步：最常见的集群时间同步方案是部署NTP服务。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//确保hadoop所需端口打开，通过命令禁用并停止防火墙服务</span><br><span class="line">systemctl mask filewalld</span><br><span class="line">systemctl stop fillwalld</span><br></pre></td></tr></table></figure><h3 id="Hadoop的软件包部署"><a href="#Hadoop的软件包部署" class="headerlink" title="Hadoop的软件包部署"></a>Hadoop的软件包部署</h3><ul><li>sbin目录：存放HDFS和Yarn组件的集群控制命令。</li><li>bin目录：存放HDFS的文件系统命令行工具以及Yarn等组件的命令行工具。</li><li>etc&#x2F;hadoop目录：存放hadoop的配置文件。</li><li>share目录：存放hadoop的各类库包(Jar)。</li></ul><p>PS:分布式的时候，hadoop软件包需要解压缩，并复制到所有节点上，并且在每个节点上的存储位置都是相同的，并给予足够的用户访问权限。其次，进行系统配置。</p><h1 id="HDFS的基本配置"><a href="#HDFS的基本配置" class="headerlink" title="HDFS的基本配置"></a>HDFS的基本配置</h1><p>HDFS的配置文件：大多数默认是XML和TXT格式存在。配置文件默认存放在&#x2F;etc&#x2F;hadoop目录下。</p><p>HDFS中6个重要的配置文件：</p><ol><li><strong>core-site.xml</strong>: Hadoop全局的配置文件，也包含一些HDFS的宏观配置。</li><li><strong>dfs-site.xml</strong>: HDFS配置文件。</li><li><strong>yarn-site.xml</strong>: YARN配置文件。</li><li><strong>mapred-sie.xml</strong>: MapReduce配置文件。</li><li><strong>slaves</strong>: 从节点列表。</li><li><strong>hadoop-env.sh</strong>: 与运行脚本的环境变量相关的配置文件。</li></ol><h2 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//core-site.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>       </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--指定namenode的地址--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">description</span>&gt;</span>node1节点为该集群的Namenode,对应节点的端口是8020<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--用来指定使用hadoop时产生文件的存放目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/data/hadoop/hadoop-2.6.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="dfs-site-xml"><a href="#dfs-site-xml" class="headerlink" title="dfs-site.xml"></a>dfs-site.xml</h2><p><strong>dfs-site.xml</strong> 是HDFS的重要配置文件，其Namenode节点和Datanode节点相关的配置项不同。</p><p><strong>Namenode</strong>主要有3个配置项: <code>dfs.namenode.name.dir</code>、<code>dfs.blocksize</code>、<code>dfs.replication</code>。</p><p><strong>Datanode</strong>主要有1个配置项：<code>dfs.datanode.data.dir</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Namenode主要有3个配置项dfs.namenode.name.dir、dfs.blocksize、dfs.replication。</span><br><span class="line">//Datanode主要有1个配置项</span><br><span class="line">dfs.datanode.data.dir   </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                 </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>namenode的目录位置，对应的目录需要存在value里面的路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode的目录位置，对应的目录需要存在value里面的路径，可以是一个或多个用逗号分隔的本地路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="tag">&lt;<span class="name">description</span>&gt;</span>hdfs系统的副本数量    </span><br><span class="line">         <span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>备份namenode的http地址，master是主机名<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 </span><br></pre></td></tr></table></figure><h2 id="slave-xml"><a href="#slave-xml" class="headerlink" title="slave.xml"></a>slave.xml</h2><p>slaves:在Namenode节点还需要建立一个名为slaves的文本文件，里面记录Datanode的子节点机名，用换行分割。</p><h2 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h2><p>JAVA_HOME进行环境变量配置：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</p><h2 id="配置机架感知策略"><a href="#配置机架感知策略" class="headerlink" title="配置机架感知策略"></a>配置机架感知策略</h2><p>需要实现机架感知的配置内容，在core-site.xml中实现两个配置项。</p><p>net.topology.node.switch.mapping.imp:org.apache.hadoop.net.TableMapping,表示采用映射文件的方式实现机架映射。</p><p>net.topology.table.file.name:内容为映射文件的路径和名称。</p><h1 id="集群的启动和停止"><a href="#集群的启动和停止" class="headerlink" title="集群的启动和停止"></a>集群的启动和停止</h1><p>软件包sbin目录下的start-dfs.sh和stop-dfs.sh为HDFS的集群启动和停止命令。</p><p>单独启动或停止一个HDFS进程，或者对单独的角色进行控制命令：hadoop-daemon.sh start | stop namenode |datanode|secondarynamenode</p><p>其次可以通过查看<a href="http://namenode:50070/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AF%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%9B%86%E7%BE%A4ID%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">http://namenode:50070/查看系统的状态，比如该系统的启动时间、版本、集群ID等信息。</a></p><h2 id="使用和管理HDFS"><a href="#使用和管理HDFS" class="headerlink" title="使用和管理HDFS"></a>使用和管理HDFS</h2><p>作为文件系统，HDFS的使用主要指对<strong>文件的上传、下载和移动，以及查看内容、建立或删除目录</strong>等。</p><p>查看HDFS状态，主要指查看节点的健康状态，查看存储容量，查看分块信息等。</p><p>控制HDFS，主要指对系统进行初始化，增加或删除子节点，以及提高HDFS的可用性等。</p><h2 id="管理和操作命令"><a href="#管理和操作命令" class="headerlink" title="管理和操作命令"></a>管理和操作命令</h2><p>hdfs的命令行操作用命令hdfs实现，即命令行敲入：hdfs.hdfs命令文件放在Hadoop目录下的bin子目录中，包含了HDFS绝大多数的用户命令，不带任何参数地执行hdfs，可以看到所有可用的指令。</p><ol><li>dfs:HDFS的文件系统操作指令。</li><li>dfsadmin:HDFS的集群管理命令，比如：查看机架感知状态，可以执行hdfs dfsadmin-printTopology。</li><li>fsck:HDFS的集群检查工具。</li><li>namenode-format:主节点格式化指令。</li><li>balaner:数据平衡指令。</li></ol><h2 id="格式化Namenode"><a href="#格式化Namenode" class="headerlink" title="格式化Namenode"></a>格式化Namenode</h2><p>hdfs namenode -format</p><h2 id="Namenode的安全模式"><a href="#Namenode的安全模式" class="headerlink" title="Namenode的安全模式"></a>Namenode的安全模式</h2><p>当namenode启动时，需要将fsimage等信息读入内存，并且等待各个Datanode上报存储状态，在这个过程完成之前，叫安全模式。（safenode）</p><p>此时namenode为只读状态，只能读取不能写入，当足够数量的节点以及数据块处在健康状态时，系统会自动退出安全模式。</p><p>手动对安全模式进行管理：hdfs dfsadmin -safemode [enter | leave |get |wait]</p><h2 id="元数据恢复"><a href="#元数据恢复" class="headerlink" title="元数据恢复"></a>元数据恢复</h2><p>由于secondary namenode在进行元数据合并时，保存了元数据的副本信息，当Namenode发生损坏时，可以利用secondary namenode中的数据进行恢复。</p><ol><li>利用stop-dfs.sh命令停止整个集群</li><li>清空namenode原有的元数据信息，路径可以从配置项dfs.namenode.name.dir中获得。</li><li>如果secondary namenode和namenode没有部署在同一个节点上，需要将secondary namenode存储的副本信息复制到namenode,其路径和secondary namenode中的元数据副本的路径一致，可以从配置项dfs.namenode.checkpoint.dir中获得。</li><li>执行hadoop namenode-importCheckpoint,系统将检查副本数据，并将其复制到dfs.namenode.name.dir所指示的路径当中。</li></ol><h2 id="子节点添加与删除"><a href="#子节点添加与删除" class="headerlink" title="子节点添加与删除"></a>子节点添加与删除</h2><p>大数据业务要求数据被不断采集、不断积累，需要分布式存储和NoSQL数据库等实现方便的横向扩展（scale out）。HDFS可以很方便的进行Datanode节点添加和删除。</p><h3 id="1-静态添加-删除Datanode的方法"><a href="#1-静态添加-删除Datanode的方法" class="headerlink" title="1.静态添加&#x2F;删除Datanode的方法"></a>1.静态添加&#x2F;删除Datanode的方法</h3><ul><li>利用stop-dfs.sh命令停止整个集群</li><li>在namenode节点上的slaves配置文件中添加新的节点，或删掉旧的节点。添加新节点时，要确保新节点和其他节点之间主机名和IP地址可以相互访问，可以实现SSH无密码访问等。</li><li>利用start-dfs.sh重新启动集群，在新节点配置正确的情况下，会随命令启动Datanode角色，并和Namenode连接。</li><li>可以执行hdfs balancer命令，在节点之间进行手动的数据平衡。删除节点之后，namenode会自动检查副本数量，并选择新的节点存储不足的副本。</li></ul><h3 id="2-动态添加Datanode的方法"><a href="#2-动态添加Datanode的方法" class="headerlink" title="2.动态添加Datanode的方法"></a>2.动态添加Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>在namenode节点上的slaves配置文件中添加新的节点。</li><li>在新节点执行hadoop-daemon.sh start datanode ,启动Datanode角色</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表，Namenode会根据新列表和子节点建立联系。</li></ul><h3 id="3-动态删除Datanode的方法"><a href="#3-动态删除Datanode的方法" class="headerlink" title="3.动态删除Datanode的方法"></a>3.动态删除Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>提前在hdfs-site.xml中配置dfs.hosts.exclude属性，内容为一个本地文本文件的路径，该文件可以称为exclude文件，其结构和slave文件的相同，即为每行一个节点主机名的列表。 记录在exclude文件中的主机，会在刷新之后被记作禁用状态，并在界面上看到这个状态。</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表。</li><li>在节点写入exclude文件，并执行hdfs dfsadmin -refreshNodes，刷新节点列表。</li></ul><p>添加&#x2F;删除Datanode完成之后，可以通过两种手段查看结果。</p><ul><li>在命令行执行hdfs dfsadmin -report 查看节点列表信息。</li><li>通过web界面，切换到Datanodes标签，可以查看子节点的列表，in operation表示正在使用的节点，decommissinoning，表示目前禁用的节点。</li></ul><h2 id="HDFS文件系统操作"><a href="#HDFS文件系统操作" class="headerlink" title="HDFS文件系统操作"></a>HDFS文件系统操作</h2><p>可以通过执行hdfs dfs指令来进行各类操作，包括建立、删除目录、HDFS上的文件复制、移动和改名、本地文件系统和HDFS系统之间的文件相互复制等、文件的权限操作等。</p><ul><li>hdfs dfs -ls &#x2F;  —-查看文件目录状态</li><li>hdfs dfs -lsr &#x2F; —-递归查看hdfs的根目录下的内容的</li><li>hdfs dfs -mkdir &#x2F;d1 —-在hdfs上创建文件夹d1</li><li>hdfs dfs -put <linux source > <hdfs destination> —-把数据从linux[本地文件]上传到hdfs的特定路径中[HDFS文件或路径]</li><li>hdfs dfs -get <hdfs source> <linux destination>—-把数据从hdfs下载到linux的特定路径下</li><li>hdfs dfs -mv&#x2F;-cp <hdfs source > <hdfs destination>—在HDFS系统中进行文件移动或复制，参数为HDFS的源地址和目的地址。</li><li>hdfs dfs -text &lt;hdfs文件&gt; —将序列号文件转换成文本显示出来。</li><li>hdfs dfs -rm &lt;hdfs文件&gt; —-删除文件或空目录</li><li>hdfs dfs -rmr &lt;hdfs文件&gt; —-递归删除文件或空目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//查看文件目录状态，-ls之后必须指明需要查看的目录</span><br><span class="line">hdfs dfs -ls /hdfsdir/file1</span><br><span class="line">hdfs dfs -ls hdfs://node1:8020/hdfsdir/file1</span><br><span class="line">//建立新目录</span><br><span class="line">hdfs dfs -mkdir /hdfsdir/dir1</span><br><span class="line">//从本地文件系统向HDFS复制文件。-put、-copyFromLocal。</span><br><span class="line">hdfs dfs -put localfile/hdfsdir/file1</span><br><span class="line">hdfs dfs -put -f localfile1 localfile2/hadoopdir</span><br><span class="line">//从HDFS向本地复制文件。-get、-copyToLocal。</span><br><span class="line">hdfs dfs -get /hdfsdir/hdfsfile localfile</span><br></pre></td></tr></table></figure><h2 id="以web方式查看文件系统"><a href="#以web方式查看文件系统" class="headerlink" title="以web方式查看文件系统"></a>以web方式查看文件系统</h2><p>访问<a href="http://namenode:50070/explorer.html,%E9%80%89%E6%8B%A9%22browse">http://namenode:50070/explorer.html,选择&quot;browse</a> the file system”选项，可以对HDFS的目录结构进行查看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在学习<code>Hadoop</code>之前，先了解一下典型的大数据平台架构图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/238353d9269d48509d9616d14c017af1.png" alt="img"></p><p>可以看到Hadoop在大数据平台里处于一个技术核心的地位</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Hadoop定义"><a href="#Hadoop定义" class="headerlink" title="Hadoop定义"></a>Hadoop定义</h2><p>Hadoop 是一个开源的分布式计算框架，由 Apache Software Foundation 开发和维护。它主要用于处理和分析大数据。Hadoop 的核心设计理念是将计算任务分布到多个节点上，以实现高度可扩展性和容错性。</p><h2 id="Hadoop组成"><a href="#Hadoop组成" class="headerlink" title="Hadoop组成"></a>Hadoop组成</h2><p>Hadoop 大数据技术生态，具体包含组件如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dbcf67baa6664a94b32f226f19e5066a.png" alt="90e2e8544f5a44fa91d4f70d57b7c0a1.png"></p><ul><li><strong>Hadoop HDFS</strong>（核心）：Hadoop 分布式存储系统；</li><li><strong>Yarn</strong>（核心）：Hadoop 2.x版本开始才有的资源管理系统；</li><li><strong>MapReduce</strong>（核心）：并行处理框架；</li><li><strong>HBase</strong>：基于HDFS的列式存储数据库，它是一种 NoSQL 数据库，非常适用于存储海量的稀疏的数据集；</li><li><strong>Hive</strong>：Apache Hive是一个数据仓库基础工具，它适用于处理结构化数据。它提供了简单的 sql 查询功能，可以将sql语句转换为 MapReduce任务进行运行；</li><li><strong>Pig</strong>：它是一种高级脚本语言。利用它不需要开发Java代码就可以写出复杂的数据处理程序；</li><li><strong>Flume</strong>：它可以从不同数据源高效实时的收集海量日志数据；</li><li><strong>Sqoop</strong>：适用于在 Hadoop 和关系数据库之间抽取数据；</li><li><strong>Oozie</strong>：这是一种 Java Web 系统，用于Hadoop任务的调度，例如设置任务的执行时间和执行频率等；</li><li><strong>Zookeeper</strong>：用于管理配置信息，命名空间。提供分布式同步和组服务；</li><li><strong>Mahout</strong>：可扩展的机器学习算法库。</li></ul><p>其中：<strong>HDFS</strong>、<strong>MapReduce</strong>、<strong>YARN</strong> 是核心组件。</p><h2 id="Hadoop优势"><a href="#Hadoop优势" class="headerlink" title="Hadoop优势"></a>Hadoop优势</h2><p>Hadoop 是一个用于 分布式存储 和 处理大数据 的开源框架，它具有以下几个优势：</p><h4 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h4><p>Hadoop 可以在成百上千台机器之间分配和处理数据，具有很高的可伸缩性。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>Hadoop 在处理数据时具备自动故障恢复的能力。如果某一台机器出现问题，Hadoop 会自动将该节点上的数据复制到其他节点上，确保数据的可靠性和不中断性。</p><h4 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h4><p>与传统的大型关系数据库相比，Hadoop 成本更低，因为它运行在廉价的硬件上。</p><h4 id="处理多种类型的数据"><a href="#处理多种类型的数据" class="headerlink" title="处理多种类型的数据"></a>处理多种类型的数据</h4><p>Hadoop 可以处理不同类型的数据，包括 结构化数据 半结构化数据 （如JSON）和 非结构化 数据（例如文本、图片、视频和音频等。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p><h1 id="YARN的由来"><a href="#YARN的由来" class="headerlink" title="YARN的由来"></a>YARN的由来</h1><p>在YARN出来之前，其实在Hadoop体系里面，负责资源管理和作业控制的是MRv1（Hadoop 1.0）体系中的JobTracker在承担，但是MRv1体系其实有其缺点，如下：</p><ul><li><p><strong>可靠性差 &#x2F; 单点故障</strong></p><ul><li>JobTracker 既做资源管理，又做任务调度，任务太重，易产生单点故障</li></ul></li><li><p><strong>资源利用率低</strong></p><ul><li>MRv1 资源描述模型过于简单，仅把 Task 数量作为资源分配依据，没有考虑任务本身的性能消耗差异</li><li>强制把资源分成 Map Task Slot 和 Reduce Task Slot，且不允许它们之 间共享，常常会导致一种槽位资源紧张而另外一种闲置(比如一个作业刚刚提交时， 只会运行 Map Task，此时 Reduce Slot 闲置)。</li></ul></li><li><p><strong>扩展性差</strong> ： 在MRv1中，JobTracker是个重量级组件，集中了资源管理分配、作业控制两大核心功能，随着集群规模的增大，JobTracker处理各种RPC请求负载过重，这也是系统的最大瓶颈，严重制约了Hadoop集群的扩展性。</p></li></ul><p>为了克服以上几个缺点，Apache 开始尝试对 Hadoop 进行升级改造，进而诞生了更加 先进的下一代 MapReduce 计算框架 MRv2。正是由于 <strong>MRv2 将资源管理功能抽象成了一个 独立的通用系统 YARN，直接导致下一代 MapReduce 的核心从单一的计算框架 MapReduce转移为通用的资源管理系统 YARN</strong>。</p><p>YARN将 JobTracker 中的资源管理和作业控制功能分 开， 分 别 由 组件ResourceManager 和 ApplicationMaster 实 现， 其 中，ResourceManager 负责所有应用程序的资源分配，而 ApplicationMaster 仅负责管理一个应用程序，基于 YARN，用户可以运行各种类型的应用程序(不再像 1.0 那样仅局限于 MapReduce 一类应用)，从离线计算的 MapReduce 到在线计算 (流式处理)的 Storm 等。</p><h1 id="YARN的基本设计思想"><a href="#YARN的基本设计思想" class="headerlink" title="YARN的基本设计思想"></a>YARN的基本设计思想</h1><p>在 Hadoop 1.0 中，<strong>JobTracker</strong> 由 <strong>资源管理</strong>(由 TaskScheduler 模块实现) 和 <strong>作业控制</strong>(由 JobTracker 中多个模块共同实现)两部分组成。当前 Hadoop MapReduce 之所以在可扩展性、资源利用率和多框架支持等方面存在不足，正是由于 Hadoop 对 JobTracker 赋予的功能过多而造成负载过重。此外，从设计角度上看，Hadoop 未能够将资源管理相关的功能与应用程序相关的功能分开，造成 Hadoop 难以支持多种计算框架。</p><p>下一代 MapReduce 框架的基本设计思想是将 JobTracker 的两个主要功能，即资源管理和作业控制(包括作业监控、容错等)，分拆成两独立的进程。资源管理进程与具体应用程序无关，它负责整个集群的资源(内存、CPU、磁盘等)管理，而作业控制进程则是直接与应用程序相关的模块，且每个作业控制进程只负责管理一个作业。这样， 通过将原有 JobTracker 中与应用程序相关和无关的模块分开，不仅减轻了 JobTracker 负载， 也使得 Hadoop 支持更多的计算框架。</p><h1 id="YARN-的基本架构"><a href="#YARN-的基本架构" class="headerlink" title="YARN 的基本架构"></a>YARN 的基本架构</h1><h2 id="基本架构图"><a href="#基本架构图" class="headerlink" title="基本架构图"></a>基本架构图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616213808951.png" alt="image-20240616213808951" style="zoom:85%;" /><p>Yarn 在整体上看还是采用了和Hadoop1.x一样的Master&#x2F;Slave结构（横向扩展混杂Slave&#x2F;Slave结构），在整个Yarn资源管理系统当中，ResourceManager作为Master，各个节点的NodeManager作为Slave。各个节点上NodeManager的资源由ResourceManager统计进行管理和调度。当应用程序提交后，会有一个单独的ApplicationMaster来对该应用程序进行跟踪和管理，同时该ApplicationMaster还会为该应用程序向ResourceManager申请资源，并要求NodeManager启动该应用程序占用一定资源的任务。由于不同的 ApplicationMaster 被分布到不同的节点上，因此它们之间不会相互影响。</p><h2 id="基本组件介绍"><a href="#基本组件介绍" class="headerlink" title="基本组件介绍"></a>基本组件介绍</h2><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>ResourceManager是Yarn的核心组件，主要由任务调度器（Resource Scheduler）和应用程序管理器（Applications Manager）组成。其主要功能是负责系统资源的管理和分配。</p><ul><li><h4 id="任务调度器-Resource-Scheduler"><a href="#任务调度器-Resource-Scheduler" class="headerlink" title="任务调度器(Resource Scheduler)"></a>任务调度器(Resource Scheduler)</h4></li></ul><p>调度器根据容量、队列等限制条件(如每个队列分配一定的资源，最多执行一定数量的作业等)，将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是 一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪 应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务， 这些均交由应用程序相关的 ApplicationMaster 完成。调度器仅根据各个应用程序的资源需 求进行资源分配，而资源分配单位用一个抽象概念“资源容器”(Resource Container，简 称 Container)表示，Container 是一个动态资源分配单位，它将内存、CPU、磁盘、网络等 资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件， 用户可根据自己的需要设计新的调度器，YARN 提供了多种直接可用的调度器，比如 Fair Scheduler 和 Capacity Scheduler 等。</p><ul><li><h4 id="应用程序管理器（Applications-Manager）"><a href="#应用程序管理器（Applications-Manager）" class="headerlink" title="应用程序管理器（Applications Manager）"></a>应用程序管理器（Applications Manager）</h4></li></ul><p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动 ApplicationMaster、监控 ApplicationMaster 运行状态并在失败时重新启动它等。</p><ul><li><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4></li></ul><p>ResourceManager中还包含了其他组件，如ResourceTrackerService用来直接处理心跳，NMLivelinessMonitor用来监控NodeManager，NodesListManager 提供NodeManager的黑白名单等等</p><h3 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h3><p>NM是每个子节点上的资源和任务管理器，一方面，它会定向通过心跳信息向RM汇报本节点上的资源使用情况和各个Container的运行情况；另一方面，它会接收并且处理来自AM的Container启动和停止的各种请求。它的能有点像Hadoop1.x中的TaskTracker。</p><ul><li><h4 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h4></li></ul><p>每当用户提交了一个应用程序就会为这个应用程序产生一个对应的ApplicationMaster，并且这个这个单独进程是在其中一个子节点上运行的。它的主要功能：为应用向ResourceManager申请资源、在job对Task实行调度、与NodeManager通信以启动或者停止任务、监控所有任务的运行情况，并且在任务失败的情下，重新为任务申请资源并且重启任务、负责推测任务的执行、当ApplicationMaster向ResourceManager注册后，ApplicationMaster可以提供客户端查询作业进度信息等。</p><ul><li><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4></li></ul><p>Container是Yarn中对系统资源的抽象，同时它也是系统资源分配的基本单位，它封装节点上多维度资源，其中包括CPU、内存、磁盘、网络等。Yarn会为每个任务分配一个Container，并且该任务只能够使用该Container中所描述的资源。值得关注的的是，Yarn中的Container和MRv1中的Slot是完全不同的，Container是一个动态的资源划分单位，它是根据实际提交的应用程序所需求的资源自动生成的，换句话说，Container其里边所描述的CPU、内存等资源是根据实际应用程序需求而变的。而Slot是一个静态的资源抽象单位，每一个同类型的Slot所描述的资源信息都是一样的。</p><h2 id="YARN-高可用"><a href="#YARN-高可用" class="headerlink" title="YARN 高可用"></a>YARN 高可用</h2><ul><li>引入 ZK</li><li>一个 Active RM， 多个 Standby RM</li><li>Active RM 宕机，Standby RM 通过 ZK 感知并竞选</li><li>也可手动切换</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221306795.png" alt="image-20240616221306795" style="zoom:80%;" /><h1 id="YARN-工作原理-流程"><a href="#YARN-工作原理-流程" class="headerlink" title="YARN 工作原理 &#x2F; 流程"></a>YARN 工作原理 &#x2F; 流程</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221044206.png" alt="image-20240616221044206"></p><ul><li>用户向Yarn提交应用程序，其中包括用户程序、相关文件、启动ApplicationMaster命令、ApplicationMaster程序等。</li><li>ResourceManager为该应用程序分配第一个Container，并且与Container所在的NodeManager通信，并且要求该NodeManager在这个Container中启动应用程序对应的ApplicationMaster。</li><li>ApplicationMaster首先会向ResourceManager注册，这样用户才可以直接通过ResourceManager查看到应用程序的运行状态，然后它将为该应用程序的各个任务申请资源，并监控它们的运行状态直到运行结束，即重复后面4~7步骤。</li><li>ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</li><li>一旦ApplicationMaster申请到资源后，便会与申请到的Container所对应的NodeManager进行通信，并且要求它在该Container中启动任务。</li><li>任务启动。NodeManager为要启动的任务配置好运行环境，包括环境变量、JAR包、二进制程序等，并且将启动命令写在一个脚本里，通过该脚本运行任务。</li><li>各个任务通过RPC协议向其对应的ApplicationMaster汇报自己的运行状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以再任务运行失败时重启任务。</li><li>应用程序运行完毕后，其对应的ApplicationMaster会向ResourceManager通信，要求注销和关闭自己。</li></ul><p><strong>【注】</strong>需要注意的是在整个工作流程当中，ResourceManager和NodeManager都是通过心跳保持联系的，NodeManager会通过心跳信息向ResourceManager汇报自己所在节点的资源使用情况。</p><h1 id="六、YARN通讯协议"><a href="#六、YARN通讯协议" class="headerlink" title="六、YARN通讯协议"></a>六、YARN通讯协议</h1><p>在 YARN 中，任何两个需相互通信的组件之间仅有一个 RPC 协 议，</p><p>而对于任何一个 RPC 协议，通信双方有一端是 Client，另一端为 Server，且 Client 总 是主动连接 Server 的</p><p>因此，YARN 实际上采用的是 拉式(pull-based)通信模型。</p><h2 id="RPC通信图"><a href="#RPC通信图" class="headerlink" title="RPC通信图"></a>RPC通信图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616214648502.png" alt="image-20240616214648502" style="zoom:67%;" /><p>上图中，箭头指向的组件是 RPC Server，而箭头尾部的组件是 RPC Client</p><h2 id="组件通讯协议描述"><a href="#组件通讯协议描述" class="headerlink" title="组件通讯协议描述"></a>组件通讯协议描述</h2><h3 id="ApplicationClientProtocol"><a href="#ApplicationClientProtocol" class="headerlink" title="ApplicationClientProtocol"></a>ApplicationClientProtocol</h3><p>JobClient(作业提交客户端)与 RM 之间的协议 ，JobClient 通过该 RPC 协议提交应用程序、查询应用程序状态等。</p><h3 id="ResourceManagerAdministrationProtocol"><a href="#ResourceManagerAdministrationProtocol" class="headerlink" title="ResourceManagerAdministrationProtocol"></a>ResourceManagerAdministrationProtocol</h3><p>Admin(管理员)与 RM 之间的通信协议，Admin 通过该 RPC 协议更新系统配置文件，比如节点黑白名单、用户队列权限等。</p><h3 id="ApplicationMasterProtocol"><a href="#ApplicationMasterProtocol" class="headerlink" title="ApplicationMasterProtocol"></a>ApplicationMasterProtocol</h3><p>AM 与 RM 之间的协议，AM 通过该 RPC 协议向 RM 注册和撤销自己，并为各个任务申请资源。</p><h3 id="ContainerManagementProtocol"><a href="#ContainerManagementProtocol" class="headerlink" title="ContainerManagementProtocol"></a>ContainerManagementProtocol</h3><p>AM 与 NM 之间的协议，AM 通过该 RPC 要求 NM 启动或者停止 Container，获取各个 Container 的使用状态等信息。</p><h3 id="ResourceTracker"><a href="#ResourceTracker" class="headerlink" title="ResourceTracker"></a>ResourceTracker</h3><p>NM 与 RM 之间的协议，NM 通过该 RPC 协议向 RM 注册，并 定时发送心跳信息汇报当前节点的资源使用情况和 Container 运行情况。</p><h1 id="YARN-资源调度策略"><a href="#YARN-资源调度策略" class="headerlink" title="YARN 资源调度策略"></a>YARN 资源调度策略</h1><p>目前，Hadoop 作业调度器主要有三种：FIFO、Capacity Scheduler 和 Fair Scheduler。Hadoop 版本 2.6.0-cdh5.14.2 默认的资源调度器是 Fair Scheduler。</p><h2 id="FIFO-Scheduler-（先进先出调度器）"><a href="#FIFO-Scheduler-（先进先出调度器）" class="headerlink" title="FIFO Scheduler （先进先出调度器）"></a>FIFO Scheduler （先进先出调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221647043.png" alt="image-20240616221647043" style="zoom:80%;" /><p>FIFO Scheduler 把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。</p><p>FIFO Scheduler 是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用 Capacity Scheduler 或 Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。</p><ul><li><p><strong>缺点</strong></p><ul><li><p>资源利用率低，无法交叉运行任务</p></li><li><p>灵活性差 —— 紧急任务无法插队</p></li></ul></li></ul><h2 id="Capacity-Scheduler-（容量调度器）"><a href="#Capacity-Scheduler-（容量调度器）" class="headerlink" title="Capacity Scheduler （容量调度器）"></a>Capacity Scheduler （容量调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221915860.png" alt="image-20240616221915860" style="zoom:80%;" /><ul><li><strong>核心思想</strong>： 提前做预算，在预算指导下分享集群资源</li><li><strong>调度策略</strong>：<ul><li>集群资源由多个队列共享</li><li>每个队列都要预设资源分配的比例</li><li>空闲资源优先分配给 “实际资源&#x2F;预算资源” 比例最低的队列</li><li>队列内采用 FIFO 策略</li></ul></li><li><strong>特点</strong>：<ul><li>层次化的队列设计 —— 子队列可使用父队列的资源</li><li>容量保证 —— 每个队列都要预设资源占比，防止资源独占</li><li>弹性分配 —— 空闲资源可以分配给任何队列，多个队列争用时，按比例进行平衡</li><li>支持动态管理 —— 可以动态调整队列的容量，权限等参数； 也可动态增加或暂停队列</li><li>访问控制 —— 用户只能向自己的队列中提交任务，不能访问其他队列</li><li>多租户 —— 多用户共享集群资源</li></ul></li></ul><h2 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616223048730.png" alt="image-20240616223048730" style="zoom:80%;" /><p>支持多队列，多用户，每个队列中的资源量可以配置，同一队列中的作业公平共享队列中所有资源。</p><p>比如有三个队列 queue1、Queue2、Queue3，每个队列中的 job 按照优先级分配资源，优先级越高分配的资源越多，但是每个 job 都会分配到资源以确保公平。在资源有限的情况下，每个 job 理想情况下获得的计算资源与实际获得的计算资源存在一种差距，这个差距就叫做差额。在同一个队列中，job 的资源缺额越大，越先获得资源优先执行。作业是按照缺额的高低来先后执行的。在 Fair调度器中，我们不需要预先占用一定的系统资源，Fair 调度器会为所有运行的 job动态的调整系统资源。</p><p>如下图所示，当第一个大 job 提交时，只有这一个 job 在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair 调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据通用操作"><a href="#数据通用操作" class="headerlink" title="数据通用操作"></a>数据通用操作</h1><ul><li>采集</li><li>处理</li><li>存储</li><li>分析</li></ul><p>最后通过数据分析结果，进行预测、调优等等</p><h1 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h1><p>大数据（Big Data）是指在传统数据处理方法难以处理的情况下，需要新的处理模式来具有更强的决策力、洞察发现力和过程优化能力的海量、高增长率和多样化的信息资产。大数据的特征通常被概括为“4V”，即：</p><ul><li><strong>Volume（容量）</strong>：大数据的规模非常庞大，通常以 TB（太字节）、PB（拍字节）或 EB（艾字节）为单位，甚至更高。例如，2020 年全球互联网用户产生的数据量达到了 59ZB（泽字节），相当于每天产生 160 亿 GB 的数据。</li><li><strong>Velocity（速度）</strong>：大数据的产生和处理速度非常快，需要实时或近实时的响应。例如，社交媒体、电子商务、物联网等领域的数据流动非常快，需要快速分析和处理。</li><li><strong>Variety（多样性）</strong>：大数据的来源和类型非常多样，包括结构化的数据（如数据库表）、半结构化的数据（如 XML、JSON 等）和非结构化的数据（如文本、图像、音频、视频等）。例如，互联网上的用户行为数据、传感器数据、地理位置数据、社交网络数据等都属于大数据的范畴。</li><li><strong>Value（价值）</strong>：大数据的价值密度相对较低，需要通过有效的分析和挖掘才能发现其潜在的价值。例如，通过大数据分析，可以提高企业的竞争力、创新能力和效率，也可以为政府、社会和个人提供更好的服务和决策支持。</li></ul><h1 id="大数据主要技术"><a href="#大数据主要技术" class="headerlink" title="大数据主要技术"></a>大数据主要技术</h1><ul><li>数据收集</li><li>数据清洗 &#x2F; 预处理</li><li>数据存储</li><li>数据处理</li><li>数据分析</li><li>数据可视化</li></ul><p>其中最核心的当属</p><ul><li>分布式存储</li><li>分布式计算</li></ul><h1 id="大数据发展历程"><a href="#大数据发展历程" class="headerlink" title="大数据发展历程"></a>大数据发展历程</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/8742e6f91ce9d1dc878aa10ff7a2603b.png" alt="img"></p><p>大数据的概念并不是近年来才出现的，其发展历程可以追溯到上个世纪。根据不同的阶段，大数据的发展历程可以分为以下四个时期：</p><ul><li><h4 id="第一时期（1940-1970）：数据收集时期"><a href="#第一时期（1940-1970）：数据收集时期" class="headerlink" title="第一时期（1940-1970）：数据收集时期"></a>第一时期（1940-1970）：数据收集时期</h4><p>这一时期的主要特点是数据的产生和收集，以及数据的存储和管理。随着计算机技术的发展，数据的规模和类型也逐渐增加，出现了诸如</p><p>关系型数据库、层次型数据库、网络型数据库等不同的数据模型和系统。这一时期的代表性技术有： </p><ul><li><strong>磁带</strong>：磁带是一种早期的数据存储介质，利用磁性材料记录数据。磁带的优点是容量大、成本低，但缺点是读写速度慢、易损坏、不便于随机访问。</li><li><strong>磁盘</strong>：磁盘是一种改进的数据存储介质，利用磁性材料记录数据。磁盘的优点是读写速度快、可靠性高、便于随机访问，但缺点是容量小、成本高。</li><li><strong>关系型数据库</strong>：关系型数据库是一种基于关系模型的数据管理系统，利用二维表格存储和操作数据。关系型数据库的优点是结构清晰、逻辑简单、易于查询和维护，但缺点是不适合处理复杂和多样的数据类型。</li></ul></li><li><h4 id="第二时期（1970-1990）：数据分析时期"><a href="#第二时期（1970-1990）：数据分析时期" class="headerlink" title="第二时期（1970-1990）：数据分析时期"></a>第二时期（1970-1990）：数据分析时期</h4><p>这一时期的主要特点是数据的分析和挖掘，以及数据的应用和价值。随着数据的增长和多样化，出现了诸如数据仓库、数据挖掘、</p><p>数据可视化等不同的数据分析方法和技术。这一时期的代表性技术有： </p><ul><li><strong>数据仓库</strong>：数据仓库是一种用于支持决策的数据集成和分析系统，利用多维模型存储和操作数据。数据仓库的优点是能够提供历史和全面的数据视图，支持复杂和多维的数据分析，但缺点是构建和维护成本高，更新和实时性差。</li><li><strong>数据挖掘</strong>：数据挖掘是一种从大量数据中发现有用信息和知识的过程，利用统计、机器学习、人工智能等方法进行数据分析。数据挖掘的优点是能够揭示数据的规律和模式，提供预测和推荐的功能，但缺点是需要专业的知识和技能，存在一定的不确定性和误差。</li><li><strong>数据可视化</strong>：数据可视化是一种将数据转换为图形或图像的过程，利用视觉元素进行数据展示和交互。数据可视化的优点是能够提高数据的可理解性和吸引力，增强数据的沟通和表达，但缺点是需要考虑数据的完整性和准确性，避免产生误导和偏见。</li></ul></li><li><h4 id="第三时期（1990-2010）：大数据时代的到来"><a href="#第三时期（1990-2010）：大数据时代的到来" class="headerlink" title="第三时期（1990-2010）：大数据时代的到来"></a>第三时期（1990-2010）：大数据时代的到来</h4><p>这一时期的主要特点是数据的爆炸和挑战，以及大数据的概念和技术的诞生。随着互联网、物联网、移动通信等技术的发展，数据的产生速度和规模远远超过了传统数据处理方法的能力，数据的特征也变得更加复杂和多样，出现了大数据的概念和特征。为了应对大数据的挑战，Google 等公司提出了分布式文件系统 GFS、大数据分布式计算框架 MapReduce 和 NoSQL 数据库 BigTable 等技术，开创了大数据技术的先河。这一时期的代表性技术有： </p><ul><li><strong>云计算</strong>：云计算是一种基于互联网的数据处理模式，利用虚拟化技术提供可扩展的数据存储和计算服务。云计算的优点是能够降低数据处理的成本和复杂度，提高数据处理的效率和灵活性，但缺点是需要考虑数据的安全和隐私，以及网络的稳定和可靠。</li><li><strong>分布式系统</strong>：分布式系统是一种由多个独立的计算机组成的数据处理系统，利用网络通信协调和合作完成数据处理任务。分布式系统的优点是能够提高数据处理的性能和可靠性，支持大规模和分布式的数据处理，但缺点是需要解决数据的一致性和同步，以及系统的复杂性和开发难度。</li><li><strong>并行计算</strong>：并行计算是一种利用多个处理器同时执行数据处理任务的数据处理方法，利用并行算法和编程模型进行数据分解和合并。并行计算的优点是能够加速数据处理的速度和效果，支持复杂和高性能的数据处理，但缺点是需要考虑数据的划分和负载均衡，以及并行的可扩展性和可移植性。</li></ul></li><li><h4 id="第四时期（2010-至今）：大数据的发展与智能时期"><a href="#第四时期（2010-至今）：大数据的发展与智能时期" class="headerlink" title="第四时期（2010 至今）：大数据的发展与智能时期"></a>第四时期（2010 至今）：大数据的发展与智能时期</h4><p>这一时期的主要特点是数据的智能化和创新，以及数据的价值和影响。随着人工智能、机器学习、深度学习等技术的发展和应用，数据不仅可以被存储和分析，还可以被理解和利用，从而产生新的知识、服务和商业模式。这一时期的代表性技术和事件有：</p><ul><li><strong>分布式处理框架的发展</strong>：分布式处理框架是大数据处理的核心技术，用于将大规模的数据分解为小规模的任务，分配给多个节点并行执行，并将结果汇总返回。最早的分布式处理框架是 MapReduce，由 Google 提出，用于处理结构化和半结构化的数据。后来出现了更加灵活和高效的分布式处理框架，如 Spark、Flink、Storm 等，用于处理实时、流式、复杂的数据。</li><li><strong>非关系型数据库的兴起</strong>：非关系型数据库是一种不遵循关系模型的数据管理系统，用于存储和操作非结构化或半结构化的数据。非关系型数据库的优点是能够适应数据的多样性、动态性和分布性，提供高性能、高可用和高扩展的数据服务。非关系型数据库的类型有很多，如键值型、文档型、列族型、图形型等。一些著名的非关系型数据库有 MongoDB、Cassandra、Neo4j 等。</li><li><strong>云计算和大数据的融合</strong>：云计算为大数据提供了弹性、可扩展、低成本的数据存储和计算服务，大数据为云计算提供了海量、多样、高速的数据资源和分析需求。两者相互促进，形成了云计算和大数据的融合平台，如 Amazon Web Services、Microsoft Azure、Google Cloud Platform 等。</li><li><strong>机器学习和深度学习的应用</strong>：机器学习和深度学习是人工智能的重要分支，用于从数据中学习规律和模式，实现数据的分类、聚类、预测、推荐等功能。机器学习和深度学习的应用领域非常广泛，涉及搜索引擎、社交网络、电子商务、自然语言处理、计算机视觉、语音识别、自动驾驶等。一些著名的机器学习和深度学习的平台和框架有 TensorFlow、PyTorch、scikit-learn 等。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 共享内存</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存基本概念"><a href="#共享内存基本概念" class="headerlink" title="共享内存基本概念"></a>共享内存基本概念</h1><p>共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的互斥访问，可以使用信号量。</p><h1 id="共享内存实现方式"><a href="#共享内存实现方式" class="headerlink" title="共享内存实现方式"></a>共享内存实现方式</h1><p>共享内存通常是各种 IPC 之中效率最高的方式。Linux 之中实现共享内存的方式通常有如下几类：</p><ul><li><strong>mmap</strong> 内存共享映射 （通常用于父子进程之间的内存共享，存在一定局限性，且用到更多的原因是其 零拷贝IO 的特性）</li><li>**System V **的共享内存</li><li><strong>POSIX</strong> 共享内存</li></ul><p>平时讨论主要的共享内存是后面两者，但是 System V 和 POSIX 的共享内存，底层都是基于内存文件系统 <strong>tmpfs</strong> 实现的，二者的主要区别是在接口设计上，</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将多个进程的地址空间映射到同一个物理内存，从而多个进程都能使用这块物理内存；从而可以用来实现不同进程间的数据共享，也即进程之间的通信</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2b5437ee0d9c422ea100773c6cc5523f.png" alt="img"></p><h3 id="shm-共享内存接口函数"><a href="#shm-共享内存接口函数" class="headerlink" title="shm 共享内存接口函数"></a>shm 共享内存接口函数</h3><h4 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="shmget-—-创建共享内存"><a href="#shmget-—-创建共享内存" class="headerlink" title="shmget() — 创建共享内存"></a>shmget() — 创建共享内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong>： 由 ftok 生成的 key 标识，标识系统的唯一 IPC 资源。</p><p><strong>size</strong>： 需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。</p><p><strong>shmflg</strong>： 如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。</p><p>**[返回值]**： 成功时返回一个新建或已经存在的的共享内存标识符，取决于 shmflg 的参数。失败返回 -1 并设置错误码。</p><h4 id="shmat-—-挂接共享内存"><a href="#shmat-—-挂接共享内存" class="headerlink" title="shmat() — 挂接共享内存"></a>shmat() — 挂接共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong> ： <code>shmget()</code>返回的共享内存标识。</p><p><strong>shm_addr</strong> ： 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p><strong>shm_flg</strong> ： 一组标志位，通常为0。</p><p><strong>[返回值]</strong> ： 成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的 <code>shmid_ds</code> 结构中的 <code>shm_nattch</code> 计数器加1（类似于引用计数）；出错返回-1。</p><h4 id="shmdt-—-去关联共享内存"><a href="#shmdt-—-去关联共享内存" class="headerlink" title="shmdt() — 去关联共享内存"></a>shmdt() — 去关联共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shmaddr</strong>： <code>shmat()</code>返回的地址。</p><p>**[返回值]**： 调用成功时返回0，失败时返回-1.</p><h4 id="shmctl-—-控制共享内存（仅删除）"><a href="#shmctl-—-控制共享内存（仅删除）" class="headerlink" title="shmctl() — 控制共享内存（仅删除）"></a>shmctl() — 控制共享内存（仅删除）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong>： <code>shmget()</code> 返回的共享内存标识符。</p><p><strong>command</strong>： 指定的执行操作，设置为<code>IPC_RMID</code>时表示可以删除共享内存。</p><p><strong>buf</strong>：  填 null 即可</p><p>**[返回值]**：成功返回0，失败返回-1。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><h3 id="MMAP-原理"><a href="#MMAP-原理" class="headerlink" title="MMAP 原理"></a>MMAP 原理</h3><ul><li><p>MMAP 本质是把 文件内容 映射到一段内存上 (准确说是虚拟内存上),  </p></li><li><p>因此通过对这段内存的读取和修改, 即可实现对文件的读取和修改,</p></li><li><p><code>mmap()</code> <strong>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存</strong>。</p></li><li><p>文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用 (read,write) 去操作。</p></li></ul><h4 id="MMAP-零拷贝原理："><a href="#MMAP-零拷贝原理：" class="headerlink" title="MMAP 零拷贝原理："></a>MMAP 零拷贝原理：</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240512223136171.png" alt="image-20240512223136171" style="zoom:67%;" /><h4 id="MMAP-共享内存原理："><a href="#MMAP-共享内存原理：" class="headerlink" title="MMAP 共享内存原理："></a>MMAP 共享内存原理：</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1723697-e4822f4555069606.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 管道</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="匿名管道-IPC"><a href="#匿名管道-IPC" class="headerlink" title="匿名管道 IPC"></a>匿名管道 IPC</h3><h4 id="管道创建"><a href="#管道创建" class="headerlink" title="管道创建"></a>管道创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span> <span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"> <span class="comment">// 返回:成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>fd 为 文件描述符数组，是函数的核心返回值， fd[0] 指向管道 读端 ， fd[1]指向管道写端，也即 fd[1] 是 fd[0] 的输入</p><h4 id="管道实现进程间通信"><a href="#管道实现进程间通信" class="headerlink" title="管道实现进程间通信"></a>管道实现进程间通信</h4><p>（1）父进程创建管道，得到两个⽂件描述符指向管道的两端</p><p>（2）父进程 fork 出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 </p><p>（3）父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要在 fork 之前创建管道 ， 这样子进程与父进程 对应相同的管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//read会阻塞，进行读取数据</span></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s ,pid:%d \n&quot;</span>,buf,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//子进程 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;Hello ,I am child &quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 信号量</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h1><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值 0 和 1 的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少，本文只介绍二元信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code>和<code>V(sv)</code>,他们的行为是这样的：</p><p>**P(sv)**：如果 sv 的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行</p><p>**V(sv)**：如果有其他进程因等待 sv 而被挂起，就让它恢复运行，如果没有进程因等待 sv 而挂起，就给它加 1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Linux的信号量机制"><a href="#Linux的信号量机制" class="headerlink" title="Linux的信号量机制"></a>Linux的信号量机制</h2><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<code>sys/sem.h</code>中。</p><h3 id="semget-—-信号量创建"><a href="#semget-—-信号量创建" class="headerlink" title="semget() — 信号量创建"></a>semget() — 信号量创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>key</strong>： 整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用 <code>semget()</code> 函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有 <code>semget()</code> 函数才直接使用信号量键，所有其他的信号量函数使用由 <code>semget()</code> 函数返回的信号量标识符。如果多个程序使用相同的 key 值，key 将负责协调工作。</p></li><li><p><strong>num_sems</strong>： 指定需要的信号量数目，它的值几乎总是1。</p></li><li><p><strong>sem_flags</strong>： 一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值 IPC_CREAT 做按位或操作。设置了 IPC_CREAT 标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而  IPC_EXCL 则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code> 函数成功返回一个相应信号标识符（非零），失败返回-1.</p><h3 id="semop-—-改变信号量的值"><a href="#semop-—-改变信号量的值" class="headerlink" title="semop() — 改变信号量的值"></a>semop() — 改变信号量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_opa, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_id</code> 是由 <code>semget()</code> 返回的信号量标识符，<code>sembuf</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> sem_num; <span class="comment">// 除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="type">short</span> sem_op;  <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                   <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">// 通常为SEM_UNDO,使操作系统跟踪信号，</span></span><br><span class="line">                   <span class="comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="semctl-—-修改信号量信息"><a href="#semctl-—-修改信号量信息" class="headerlink" title="semctl() — 修改信号量信息"></a>semctl() — 修改信号量信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_id: semget() 返回的 sem Id</li><li>sem_num: 指定需要的信号量数目，它的值几乎总是1</li><li>command: 通常是下面两个值中的其中一个:<ul><li>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</li><li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符</li></ul></li></ul><p>如果有第四个参数，它通常是一个 <code>union semum</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用信号量实现多进程并发安全"><a href="#用信号量实现多进程并发安全" class="headerlink" title="用信号量实现多进程并发安全"></a>用信号量实现多进程并发安全</h1><h2 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h2><p><strong>进程互斥</strong>：不同进程之间的代码，A进程执行到部分代码字段 时，其他进程不能执行自身特定的代码字段，仅A进程将该字段执行完毕，其他程序才能继续执行</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 信号量机制实现互斥 */</span><br><span class="line">semaphore mutex = 1; // 初始化信号量</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);   // 使用临界资源前需要加锁</span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   // 使用临界资源后需要解锁</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);  </span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h2><p><strong>进程同步</strong>： 散布在不同进程之间的若干程序片段，它们的运行必须严格按照一定的先后次序来运行，这种次序依赖于要完成的任务。比如数据的收发，必须发送方发送了接收方才能收</p><p>用例： 保证代码 4 必须在代码 1,2 之后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程</title>
      <link href="/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/11183270-40bf3033d3e24a39.png" alt="img"></p><p>JVM 线程对主存中的共享变量进行修改时，必须先将共享变量读到自身工作内存中（实际就是CPU Cache），并在工作内存中进行修改，最后再刷回主存。</p><p>（CPU Cache： 缓解 内存 和 CPU 速度相差过大问题， 但 Cache 引入势必造成一致性问题）</p><h2 id="内存交互操作（保证原子性）"><a href="#内存交互操作（保证原子性）" class="headerlink" title="内存交互操作（保证原子性）"></a>内存交互操作（保证原子性）</h2><ul><li><strong>read</strong>： 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li><strong>load</strong>： 把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use</strong>： 把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign</strong>： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li><strong>store</strong>： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li><strong>write</strong>： 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li><li><strong>lock</strong>： 作用于主内存的变量，把一个变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li></ul><h3 id="相关规则"><a href="#相关规则" class="headerlink" title="相关规则"></a>相关规则</h3><ul><li>read &#x2F; load 和 store &#x2F; write  操作必须成对按序使用</li><li>变量 assign 之后必须存在 stire&#x2F;write 将其写回主存</li><li>加载完但未执行 assign 的变量 ，不允许重新写回主存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个线程 lock 了一个变量，后续该线程 且 仅有该线程能继续 lock 该变量； 直至调用相同 次数 unlock ，完成解锁</li><li>变量被 lock ，所有工作内存中的副本将被清除，因此执行引擎使用该变量前，必须重新 load 或 assign 以初始化变量的值</li><li>只能 unlock 被当前线程 lock 了的变量</li><li>对一个变量进行 unlock 操作之前，必须把此变量同步回主内存</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>烂八股：</p><ul><li><strong>保证可见性</strong>： 线程对 volatile 变量修改后，强制将其刷回主存，并使其他 CPU 中的对应缓存行失效（MESI 和 内存屏障的作用）</li><li><strong>禁止指令重排：</strong> 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果 （阿里开发手册中关于 DCL 单例中的说明）</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从汇编角度看，volatile 的作用基于 lock 前缀指令 —— 在线程对缓存行内变量执行写操作时，发出一个 lock 指令，锁住总线&#x2F;或缓存行，同时让 其他cpu中的缓存行失效，并将修改后的数据强制写回主存</p><h2 id="volatile-int-i-错误原因分析："><a href="#volatile-int-i-错误原因分析：" class="headerlink" title="volatile int i++ 错误原因分析："></a>volatile int i++ 错误原因分析：</h2><p>i++ 非原子性操作，</p><ul><li>读取 i</li><li>i 自增</li><li>回写 i</li></ul><p>volatile 可以保证第二 和 第三步 会合并成一个原子操作</p><p>但若两个 thread 读取操作发生在 peer 的改值操作之前，还是不能保证线程安全</p><p><strong>【参考】</strong></p><ul><li><a href="https://www.cnblogs.com/badboys/p/12695183.html">volatile与lock前缀指令 - 干饭人~ - 博客园 (cnblogs.com)</a></li></ul><h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Synchronized  是 java 中用来实现 线程同步&#x2F;互斥 编程的一个关键字，可以用来修饰</p><ul><li>实例方法 —— 锁住当前对象</li><li>静态方法 —— 锁住当前类对象</li><li>代码块 —— 静态代码块，锁住当前类对象； 普通代码块，锁住当前对象</li></ul><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>无论是哪种使用方法，<code>synchronized</code> 底层都是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 两个 jvm 指令实现的</p><p>而 <code>monitorenter</code> 和 <code>monitorexit</code> 则是基于 <code>markworkd 及 </code>objectmonitor&#96; 实现</p><h3 id="markword-对象头"><a href="#markword-对象头" class="headerlink" title="markword &#x2F; 对象头"></a>markword &#x2F; 对象头</h3><h4 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h4><ul><li>对象头</li><li>实例数据</li><li>对其填充字节</li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul><li>Markword</li><li>类指针</li><li>数组长度（仅数组对象有）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/aa.png" alt="aa"></p><h2 id="Synchronized-锁升级"><a href="#Synchronized-锁升级" class="headerlink" title="Synchronized 锁升级"></a>Synchronized 锁升级</h2><ol><li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li><li>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在 Markword 的偏向线程 ID 里存储当前线程的操作系统线程 ID，偏向锁标识位是1，锁标识位是01。<ul><li>从jdk1.6之后，JVM有两个默认参数是开启的，-XX:+UseBiasedLocking（表示启用偏向锁，想要关闭偏向锁，可添加JVM参数：-XX:-UseBiasedLocking），-XX:BiasedLockingStartupDelay&#x3D;4000（表示JVM启动4秒后打开偏向锁，也可以自定义这个延迟时间，如果设置成0，那么JVM启动就打开偏向锁）。</li><li>此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。</li><li>另外需要注意的是，由于硬件资源的不断升级，获取锁的成本随之下降，jdk15版本后默认关闭了偏向锁。<br>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前）有线程访问共享资源则直接由无锁升级为轻量级锁，</li></ul></li><li>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<ul><li>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。</li></ul></li><li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的 mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter 指令插入到同步代码块在编译后的开始位置，monitorexit 指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240528011826870.png" alt="image-20240528011826870"></p><h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/932045510502514689.png" alt="932045510502514689"></p><p><strong>【参考】</strong></p><ul><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现–概论 · Issue #12 · farmerjohngit&#x2F;myblog (github.com)</a></li></ul><h1 id="乐观锁-与-悲观锁"><a href="#乐观锁-与-悲观锁" class="headerlink" title="乐观锁 与 悲观锁"></a>乐观锁 与 悲观锁</h1><p>~ 是并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><p>悲观锁和乐观锁是实现并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>悲观锁 的 线程安全控制策略 适用于 并发写操作较多的场景，</li><li>悲观锁 在加锁期间，其他线程无法访问被锁定的资源，从而保证了数据的完整性。</li><li>悲观锁 需要频繁地进行加锁和解锁操作，开销较大。</li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>乐观锁适用于并发读操作较多的场景，因为读操作不涉及到数据的修改，不需要加锁。</li><li>乐观锁在更新数据时，只有在提交更新操作时才对数据进行版本检查，减少了加锁和解锁的开销。</li><li>乐观锁可能需要进行重试，以处理并发修改引起的冲突。</li></ul><p>乐观锁常用 <strong>CAS</strong> 或 **版本号 ** 机制 进行实现</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ， 即 仅比较通过才会进行设值， CAS 是乐观锁的主要实现方式之一</p><p>CAS 依赖于操作系统原语，更底层则依赖于 硬件指令集，即 CAS 最终由 硬件保证操作的原子性</p><h3 id="JAVA-CAS"><a href="#JAVA-CAS" class="headerlink" title="JAVA CAS"></a>JAVA CAS</h3><p>java cas 相关实现依赖于 Unsafe 类提供的一系列 JNI 接口</p><h3 id="CAS-相关问题"><a href="#CAS-相关问题" class="headerlink" title="CAS 相关问题"></a>CAS 相关问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><ul><li><p>CAS 操作成功，并不意味着值在 cas 所处指令序列的 值读取 与 CAS 设值 之间没有发生过 变更</p></li><li><p>解决：在变量前面追加上<strong>版本号或者时间戳</strong></p></li></ul><h4 id="自旋空转"><a href="#自旋空转" class="headerlink" title="自旋空转"></a>自旋空转</h4><p><strong>说明</strong>： CAS 经常会用自旋操作来进行重试，即不成功就一直循环直至成功为止。但若如果长时间不成功，会给 CPU 造成较大负担</p><p><strong>解决</strong>：参考 synchronized 引入适应性自旋，或限制自旋次数</p><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>两个线程各自锁住一个资源，并无限期等待&#x2F;请求 对方锁住的资源，导致两个线程相互等待，导致程序无限期卡死</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601020943517.png" alt="image-20240601020943517"></p><h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul><li><p><strong>互斥使用</strong>，即当资源被一个线程占用时，别的线程不能使用</p></li><li><p><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</p></li></ul><ul><li><strong>请求和保持</strong>，当资源请求者在请求其他资源的同时保持对原因资源的占有</li><li><strong>循环等待</strong>，多个线程存在环路的锁依赖关系而永远等待下去，例如T1占有T2的资源，T2占有T3的资源，T3占有T1的资源，这种情况可能会形成一个等待环路</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>从死锁条件着手，破坏其中一个即可（互斥是基本需求，不能破坏）</p><p>实际常用的有：</p><ul><li>一次性申请所有资源</li><li>各方按相同顺序申请资源</li><li>给申请资源的等待时间设置限制</li><li>无法实现前面几种，还可以升级锁粒度，用一个大的锁控制全局互斥</li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul><li>jstack 进程号<ul><li>指令运行结果会提示 相应 进程存在死锁问题</li><li>可先用 jps -l 查看所有java 进程</li></ul></li><li>使用图形化工具 jconsole.exe 或 jvisualvm.exe 会自动检测死锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程</title>
      <link href="/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux线程概念"><a href="#一、Linux线程概念" class="headerlink" title="一、Linux线程概念"></a>一、Linux线程概念</h1><h2 id="1、什么是线程"><a href="#1、什么是线程" class="headerlink" title="1、什么是线程"></a>1、什么是线程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509040108318.png" alt="image-20240509040108318"></p><p>首先从 <strong>进程</strong> 讲起，一个进程有自己对应的 PCB，虚拟地址空间，页表以及映射的物理内存，也即 <code>进程 = 内核数据结构 + 进程对应的代码和数据</code>。</p><p>对于<strong>虚存</strong>：虚拟内存决定了进程能够看到的”资源”。因为每一个进程都有对应的虚拟内存，所以进程具有独立性，从而进程需要通信的前提是看到同一份资源。</p><p>通过 fork 创建子进程的时候，会将父进程的PCB的内容，进程地址空间和页表都给子进程拷贝一份。</p><p><code>而如果创建多个 PCB，并将这些 PCB 使用同一个进程地址空间和页表，这样就可以看到同一份资源了，这就是线程。</code></p><p>因此可以将 线程 理解为 进程 内的一个执行流，线程在进程内运行，线程在进程的地址空间内运行，拥有该进程的一部分资源。</p><p>也即 线程是 CPU 调度的基本单位。进程 则是承担系统资源的基本实体，内部可以有一个或多个执行流。因为我们可以通过虚拟地址空间+页表的方式对进程的资源进行划分，单个”进程”(线程)执行粒度，一定要比之前的进程要细。</p><p>如果 OS 要专门设计线程的概念，就需要对线程进行管理，也就需要先描述，再组织，即一定要为线程设计专门的数据结构表示线程对象TCB。但是线程和进程一样都需要被执行，被调度(id,状态，优先级，上下文，栈…)，二者十分相似，所以单纯从线程调度角度，线程和进程有很多的地方是重叠的。所以Linux工程师不想给”线程”专门设计对应的数据结构，而是直接复用PCB，用 PCB 用来表示 Linux 内部的”线程”, 所以在Linux中，进程我们称为轻量级进程。而 windows 有单独的TCB结构</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>.Linux 内核中没有真正意义是线程，Linux是用进程的 PCB 来进行模拟，是一种完全属于自己的一套线程方案</p></li><li><p>站在 CPU视角，每一个PCB，都可以称之为轻量级进程</p></li><li><p>Linux 线程是 CPU 调度的基本单位，而进程是承担资源分配的基本单位</p></li><li><p>进程用来整体申请资源，线程用来伸手向进程要资源</p></li><li><p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”</p></li><li><p>一切进程至少都有一个执行线程</p></li><li><p>线程在进程内部运行，本质是在进程地址空间内运行</p></li><li><p>在 Linux 系统中，在 CPU 眼中，看到的 PCB 都要比传统的进程更加轻量化</p></li><li><p>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</p></li></ol><p>Linux内核中没有真正意义是线程，所以Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口，但是操作系统只认线程，用户(程序员)也只认线程，所以Linux在软件层提供了一个原生的线程库。</p><p>任何 Linux 操作系统，都必须默认携带这个原生线程库–用户级线程库</p><p>线程创建用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是新线程, 我正在运行! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> n = pthread_create(&amp;tid, nullptr, start_routine, (<span class="type">void</span> *)<span class="string">&quot;thread one&quot;</span>);</span><br><span class="line">    assert(<span class="number">0</span> == n);</span><br><span class="line">    (<span class="type">void</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是主线程, 我正在运行!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多<ul><li>进程：切换页表 &amp;&amp; 虚拟地址空间 &amp;&amp; 切换PCB &amp;&amp;上下文切换</li><li>线程：切换PCB &amp;&amp;上下文切换</li></ul></li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I&#x2F;O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I&#x2F;O密集型应用，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能损失</strong> —— 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><strong>健壮性降低</strong> —— 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><strong>缺乏访问控制</strong> —— 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><strong>编程难度提高</strong> —— 编写与调试一个多线程程序比单线程程序困难得多</li></ol><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃，<strong>因为信号在整体发给进程的</strong></p><p>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</p><h1 id="二、线程控制"><a href="#二、线程控制" class="headerlink" title="二、线程控制"></a>二、线程控制</h1><h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><h4 id="创建线程函数接口-–-pthread-create"><a href="#创建线程函数接口-–-pthread-create" class="headerlink" title="创建线程函数接口 – pthread_create"></a>创建线程函数接口 – pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建一个新的线程</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// thread_label: 线程标识符</span></span><br><span class="line"><span class="comment">// attr:设置线程的属性，attr为NULL表示使用默认属性</span></span><br><span class="line"><span class="comment">// start_routine:是个函数地址，线程启动后要执行的函数</span></span><br><span class="line"><span class="comment">// arg:传给线程启动函数的参数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread_label, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread_label 实际上是进程地址空间上的一个地址</li><li>用户线程、用户进程、内核线程 关系后续补充</li></ul><h2 id="2-线程终止"><a href="#2-线程终止" class="headerlink" title="2. 线程终止"></a>2. 线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法</p><ul><li>从线程函数 return。这种方法对主线程不适用，因为从 main 函数 return 相当于调用 exit。</li><li>线程调用 pthread_ exit 终止自己。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value_ptr:value_ptr不要指向一个局部变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure><ul><li>一个线程可以调用 pthread_ cancel 终止同一进程中的另一个线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread:线程ID</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程基础</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul><li>进程可以理解为程序的一次执行过程，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>现代操作系统对于进程会分配独立的 内存地址空间和其他系统资源（IO）</li><li>对 Java 而言，<code>main()</code> 函数启动时其实就是启动了一个 JVM 的进程，而 <code>main()</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul><li>线程是依托于进程的一个指令执行序列</li><li>一个进程可以产生多个线程</li><li>linux中，线程又叫做轻量级进程（light-weight process LWP），也有PCB，创建线程使用的底层函数和进程底层一样，都是clone，但没有独立的地址空间；而进程有独立地址空间，拥有PCB。</li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>包含关系</strong>：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>资源开销</strong>：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><strong>管道 pipe</strong><ul><li><strong>管道概念</strong>：<ul><li>管道是一种半双工的通信方式，用以传输字节流</li><li>本质是内核中基于环形队列设计的一段缓冲区，对应着两个文件描述符，一个赋予读权限，一个赋予写权限</li><li>数据只能单向流动，一端写和一端读</li></ul></li><li><strong>分类</strong><ul><li><strong>匿名管道</strong>： 只能在父子或亲缘进程间使用</li><li><strong>命名管道</strong>：允许非情缘关系进程间进行通信</li></ul></li></ul></li></ul><ul><li><strong>消息队列</strong>：本质是 OS 内核中维护的一个 尾插头读 的链表，<ul><li>与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息</li></ul></li><li><strong>共享存储</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<ul><li><strong>优点</strong>：其他IPC一般涉及数据拷贝、传输，而共享内存不需要，因此 CPU、内存负载更低，同时提高了处理速度</li><li><strong>缺点</strong>：会引入并发安全问题，需引入信号量等机制，确保线程安全性</li><li><strong>实现方式</strong>：有 mmap 和 shmget 两种</li></ul></li><li><strong>信号量</strong>：信号量本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</li><li><strong>套接字</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li><strong>信号</strong>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul><h2 id="进程互斥-与-同步"><a href="#进程互斥-与-同步" class="headerlink" title="进程互斥 与 同步"></a>进程互斥 与 同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>在操作系统中，进程是占有资源的最小单位。对于某些资源来说，可能有多个进程需要占用，但是为了保障操作系统和指令的正常执行，有些资源在同一时间只能被其中一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p><p>典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p><p> 对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p><p>  对于临界区的访问过程分为四个部分：</p><ol><li><strong>进入区</strong>:  查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li><li><strong>临界区</strong>:  在临界区做操作</li><li><strong>退出区</strong>:  清除临界区被占用的标志</li><li><strong>剩余区</strong>：进程与临界区不相关部分的代码</li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>多进程完成某个任务时，进程之间 部分指令 或 代码块 的执行需按照指定先后关系按序执行</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>并行的多个进程 访问临界资源，在其中一个进程A进入临界区后，其他线程在进入临界区前必须阻塞等待进程 A 退出临界区</p><h1 id="CPU-Cache-一致性"><a href="#CPU-Cache-一致性" class="headerlink" title="CPU Cache 一致性"></a>CPU Cache 一致性</h1><p>在单核 CPU 中，只需要考虑 Cache 与 内存 的一致性。但是在多核 CPU 中，由于每个核心都有一份独占的 Cache，就会存在一个核心修改数据后，两个核心 Cache 数据不一致的问题。因此， CPU 缓存一致性问题应该从 2 个维度理解：</p><ul><li><strong>纵向：Cache 与 内存 的一致性问题：</strong> 在修改 Cache 数据后，如何同步回内存？</li><li><strong>横向：多核心 Cache 的一致性问题：</strong> 在一个核心修改 Cache 数据后，如何同步给其他核心 Cache？</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511022424797.png" alt="image-20240511022424797" style="zoom:50%;" /><h2 id="单核场景-cache-与-内存数据一致性"><a href="#单核场景-cache-与-内存数据一致性" class="headerlink" title="单核场景 cache 与 内存数据一致性"></a>单核场景 cache 与 内存数据一致性</h2><ul><li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li><li><strong>写回</strong>：数据在被写入到 CPU 缓存时不会立即同步到内存，而是暂时保存在缓存中。只有在缓存行被替换出缓存（缓存算法对其进行淘汰）时，才会将该缓存行的数据写回到内存中。</li></ul><h2 id="多核场景-cache-一致性"><a href="#多核场景-cache-一致性" class="headerlink" title="多核场景 cache 一致性"></a>多核场景 cache 一致性</h2><h3 id="多核-cache-一致性保证条件"><a href="#多核-cache-一致性保证条件" class="headerlink" title="多核 cache 一致性保证条件"></a>多核 cache 一致性保证条件</h3><ul><li><strong>写传播</strong> —— 某个core 修改某个变量后，其他 core 需要及时感知</li><li>**串行化 ** —— 某个 core 的连续操作，对其他 core 而言，观察到的顺序一致</li></ul><h3 id="cache-一致性协议基石"><a href="#cache-一致性协议基石" class="headerlink" title="cache 一致性协议基石"></a>cache 一致性协议基石</h3><ul><li><strong>写传播 - 总线嗅探：</strong> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。要实现写传播，其实就是将所有的读写操作广播到所有 CPU 核心，而其它 CPU 核心时刻监听总线上的广播，再修改本地的数据；</li><li><strong>事务串行化 - 总线仲裁：</strong> 总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。</li></ul><h2 id="MESI-协议-（默认生效）"><a href="#MESI-协议-（默认生效）" class="headerlink" title="MESI 协议 （默认生效）"></a><strong>MESI 协议</strong> （默认生效）</h2><p>MESI 对应 CPU Cache 中的四种状态</p><ul><li><strong>M</strong>: modified</li><li><strong>E</strong>: Exclusive</li><li><strong>S</strong>: Share</li><li><strong>I</strong>: invalid</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015059650.png" alt="image-20240511015059650" style="zoom:60%;" /><p>由于 修改等操作 需其他 CPU 进行ACK ，影响速率，因此引入 Store Buffer 和 Invalid Queue</p><p>CPU A 修改某个值时，直接将值写入 Store Buffer，并向其他 CPU 失效队列投递 invalid 通知，Invalid 通知成功（兑入对应invalid queue） 再将 store buffer 值 写入 cache</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015623898.png" alt="image-20240511015623898" style="zoom:50%;" /><p>store buffer 和 invalid queue 加快了程序运行速度，但 也带来了问题 —— CPU 间 数据强一致性为了最终一致 &#x2F; 弱一致</p><h2 id="内存屏障解决-有序性问题"><a href="#内存屏障解决-有序性问题" class="headerlink" title="内存屏障解决 有序性问题"></a>内存屏障解决 有序性问题</h2><h3 id="编译器内存屏障"><a href="#编译器内存屏障" class="headerlink" title="编译器内存屏障"></a>编译器内存屏障</h3><p>Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成——内存屏障调用前后指令不乱序执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="CPU-内存屏障"><a href="#CPU-内存屏障" class="headerlink" title="CPU 内存屏障"></a>CPU 内存屏障</h3><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>先看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;   </span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若某一时刻， CPU0 cache 占有 变量 b&#x3D;0，准备执行 func0()， CPU1 cache 占有变量 a&#x3D;0， 准备执行 func1()； 且后续执行流程如下：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>CPU 0 继续执行赋值语句 b&#x3D;1，由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line。</li><li>CPU 1执行 while (b &#x3D;&#x3D; 0) 循环，由于 b 不在CPU 1 的 cache 中，因此，CPU发送一个 read message 到总线上，尝试从其他 cpu 的 localcache 或者 memory 中读取数据。</li><li>CPU 0 收到 read message，将最新的 b 值 1 回送给 CPU1，同时将 b cacheline的状态设定为 S。</li><li>CPU 1 收到了来自 CPU 0 的 read response，将 b 变量最新值 1 值写入自己的 cacheline，状态修改为shared。</li><li>由于 b 值等于 1 ，CPU 1跳出while (b &#x3D;&#x3D; 0)的循环，继续执行。</li><li>CPU 1 执行 assert(a &#x3D;&#x3D; 1)，这时候 CPU1 中的local cache中还是旧的a值，因此assert(a &#x3D;&#x3D; 1)失败。<strong>程序异常</strong></li></ol><p>为避免缓存不一致问题引起的 异常结果， 可在 a&#x3D;1 的赋值操作之后加上写内存屏障，此时 ：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>cpu0 完成 a&#x3D;1 复制操作之后，遇到写内存屏障，执行 flush store buffer</li><li>cpu0 阻塞等待 store buffer 中所有记录 得到 ACK</li><li>cpu1 cache line 收到 a 变量 invalid 消息，并自动 ACK</li><li><strong>cpu1 完成 invalid  queue 处理，修改 local cache 中 cacheline a&#x3D;1 状态为 I</strong></li><li>cpu0 阻塞结束，继续执行 b&#x3D;1 赋值， 由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line</li><li>若不考虑 cpu1 的 invalid queue 主动 ack，则cpu1 判断 a&#x3D;&#x3D;1 时，将发现cache line 中的 缓存已失效，需重新从总线获取，此时 assert t通过</li></ol><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>仍以上例说明，由于 cpu1 存在 invalid queue ，会自动回复 ACK，所以：</p><ul><li>若 cpu1 未及时完成 invalid queue 处理， 则 CPU1 后续执行 a&#x3D;&#x3D;1 判断时，会判断 cache 中 有cacheline 命中，因此仍有可能失败</li></ul><p>因此，为确保 invalid queue 数据及时处理</p><ul><li>进一步在 assert(a&#x3D;&#x3D;1) 之前加上 读内存屏障</li></ul><p>读内存屏障作用为——cpu 下一次读取操作前，必须 flush invalid queue</p><p>因此，以上例子在无锁添加下，可通过以下改造确保程序运行正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  smp_mb();  <span class="comment">// 写内存屏障</span></span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  smp_rmb();<span class="comment">// 读内存屏障</span></span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发安全性基础"><a href="#并发安全性基础" class="headerlink" title="并发安全性基础"></a>并发安全性基础</h1><ul><li><strong>原子性</strong> —— 一个线程的一组操作要么未执行，要么全部执行，即使中间因线程调度而中断，其总体执行结果与一次性执行完毕的结果无异，本质就是 多线程&#x2F;进程 对临界资源的互斥访问</li><li><strong>可见性</strong> —— 多个线程修改同一个共享变量时，一个线程修改后，其他线程能马上获得修改后的值</li><li><strong>有序性</strong> —— 即程序执行的顺序按照代码的先后顺序执行</li></ul><h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><h2 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h2><p>指令重排是计算机编译器或处理器为了提高性能而对指令执行顺序进行的一种优化手段。</p><p>在多核和多线程的计算机系统中，指令重排的目标是通过优化执行顺序来提高指令级别的并行度，充分发挥计算资源，加速程序的执行</p><h2 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><h3 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h3><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p><h3 id="指令级并行的重排序"><a href="#指令级并行的重排序" class="headerlink" title="指令级并行的重排序"></a>指令级并行的重排序</h3><p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><h3 id="内存系统的重排"><a href="#内存系统的重排" class="headerlink" title="内存系统的重排"></a>内存系统的重排</h3><p>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>也即源代码从编译到最终运行之间可能涉及的重排序流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240526135057956.png" alt="image-20240526135057956"></p><h2 id="指令重排的准则-（以-java-为例）"><a href="#指令重排的准则-（以-java-为例）" class="headerlink" title="指令重排的准则 （以 java 为例）"></a>指令重排的准则 （以 java 为例）</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><h4 id="语义"><a href="#语义" class="headerlink" title="语义:"></a><strong>语义:</strong></h4><p><strong>不管怎么重排序</strong> ，程序在单线程情况下的运行结果不能改变。</p><p>编译器、runtime和处理器都必须遵守as-if-serial语 义。</p><p>为了遵守 as-if-serial ，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。</p><p>但是，如果操作之间不存在数据依赖关系，这些操作就可 能被编译器和处理器重排序。但这种重排序可能在多线程情况下引入问题</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><h4 id="程序顺序原则"><a href="#程序顺序原则" class="headerlink" title="程序顺序原则"></a>程序顺序原则</h4><p>　　即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p><h4 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则"></a>锁规则</h4><p>　　解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</p><h4 id="volatile规则"><a href="#volatile规则" class="headerlink" title="volatile规则"></a>volatile规则</h4><p>　　volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，<strong>都强迫从主内存中读该变量的 值</strong>，而<strong>当该变量发生变化时，又会强迫将最新的值刷新到主内存</strong>，任何时刻，不同的 线程总是能够看到该变量的最新值。</p><h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>　　线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>　　A先于B ，B先于C 那么A必然先于C</p><h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p>　　线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p>　　对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>　　对象的构造函数执行，结束先于finalize()方法 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS 详解</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>Java 自带的各种同步工具类的 基石</p><p>将临界资源抽象成一个 <code>volatile int stat</code>，并通过 cas 操作进行加减锁</p><p>此外，AQS 设计了一个 FIFO 的线程等待 （双向）队列，用以帮助并发竞争的线程间 进行 阻塞、唤醒等功能</p><p>而且，提供基础的 排它锁、共享锁设计基础， 实现类可在此基础上进一步补充 公平、非公平机制，实现常用锁功能和特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span>/Setter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁相关"><a href="#写锁相关" class="headerlink" title="写锁相关"></a>写锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>acquire 由 实现类的 lock() 调用，调用前 及 tryAcquire 具体实现中可自定义 公平&#x2F;非公平策略</li></ul><h2 id="共享锁相关"><a href="#共享锁相关" class="headerlink" title="共享锁相关"></a>共享锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">// 由子类实现</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 找到前继节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);<span class="comment">// 由子类实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平-与-非公平-写锁-–-以-ReentrantLock-为例"><a href="#公平-与-非公平-写锁-–-以-ReentrantLock-为例" class="headerlink" title="公平 与 非公平 写锁 – 以 ReentrantLock 为例"></a>公平 与 非公平 写锁 – 以 ReentrantLock 为例</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li><h4 id="fair-lock"><a href="#fair-lock" class="headerlink" title="fair lock"></a>fair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="unfair-lock"><a href="#unfair-lock" class="headerlink" title="unfair lock"></a>unfair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 总结</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="作用-使用场景"><a href="#作用-使用场景" class="headerlink" title="作用 &#x2F; 使用场景"></a>作用 &#x2F; 使用场景</h2><ul><li>线程隔离</li><li>同一 &#x2F; 父子 线程内跨方法传参</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>废话不多说，直接看代码</p><p>先是 ThreadLocal 类本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>ThreadLocal</code> 设值是找到当前线程的 <code>ThreadLocalMap</code> 对象，并以 <code>ThreadLocal</code> 对象自身为 key，以传入值为 value 添加 entry </p><p>所以再看 <code>Thread</code>  中的相关定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 对象实际是 <code>ThreadLocal</code> 的 静态内部类，看一下类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal Map</code> 还包含几个核心方法——<code>getEntry</code>、<code>set()</code>、<code>remove()</code>， 其总体实现逻辑与 常规 Map 没什么太大差别，这里就不展开细讲了</p><p>这里主要讲一下 <code>ThreadLocalMap</code> 中这个 <code>WeakReference</code>， 这也是 ThreadLocal 常被诟病的内存泄漏的问题分析基石</p><h2 id="ThreadLocal-内存泄漏问题分析"><a href="#ThreadLocal-内存泄漏问题分析" class="headerlink" title="ThreadLocal 内存泄漏问题分析"></a>ThreadLocal 内存泄漏问题分析</h2><ul><li><code>Entry</code> 继承自 <code>ThreadLocal&lt;?&gt;</code> 的弱引用， 而 <code>Entry</code> 构造时，父类构造函数调用传入的是参数是 key 也即 <code>ThreadLocal</code> 对象，而 <code>super()</code> 调用过程也就是 弱引用的创建过程，因此，<code>ThreadLocal</code> 中的弱引用实际是 <code>Entry</code> -&gt; <code>ThreadLocal</code> (key) 的弱引用</li><li>而实际上存在 <code>thread</code> -&gt; <code>threadLocalMap</code> -&gt; <code>Entry[]</code> -&gt; <code>entry</code> -&gt; <code>value</code> 的强引用链</li></ul><p>所以在以下场景中，<code>threadlocal</code> 会有内存泄漏问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        createThreadLocal();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601012342860.png" alt="image-20240601012342860"></p><h3 id="ThreadLocal-中-弱引用的作用"><a href="#ThreadLocal-中-弱引用的作用" class="headerlink" title="ThreadLocal 中 弱引用的作用"></a>ThreadLocal 中 弱引用的作用</h3><p>到这，弱引用的作用就比较清楚了</p><ul><li>可以保证 <code>threadLocal</code> 对象本身 可以在 GC 时被正常回收</li><li>但 <code>Value</code> 实际上还是强引用可达，因此并不能被 GC 自动回收，可能还是会造成内存泄漏</li></ul><h3 id="ThreadLocal-如何防止内存泄漏"><a href="#ThreadLocal-如何防止内存泄漏" class="headerlink" title="ThreadLocal 如何防止内存泄漏"></a>ThreadLocal 如何防止内存泄漏</h3><ul><li>使用完手动 <code>remove()</code></li></ul><h2 id="JAVA-引用类型"><a href="#JAVA-引用类型" class="headerlink" title="JAVA 引用类型"></a>JAVA 引用类型</h2><ul><li>强引用 —— 无论内存是否充足，均不回收</li><li>软引用 —— GC 时内存充足不回收，不充足时会回收<ul><li>意思是内存充足也会发生GC ?   手动触发 <code>System.gc()</code> ?</li></ul></li><li>弱引用 —— 无论内存是否充足，只要发生 GC ，都会将其回收</li><li>虚引用 —— 普通开发中几乎不会用到，一般在 GC 过程当中有使用<ul><li>参考： <a href="https://www.cnblogs.com/mfrank/p/9837070.html">你不可不知的Java引用类型之——虚引用 - 弗兰克的猫 - 博客园 (cnblogs.com)</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，<code>Collection</code> 接口派生三个子接口 <code>List</code> <code>Set</code> <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240506003529811.png" alt="image-20240506003529811"></p><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>: 底层 Object 数组</li><li><code>Vector</code>: 底层 Object 数组</li><li><code>LinkedList</code>: 底层双向链表</li></ul></li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code> : 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆</li><li><code>DelayQueue</code>:&#96;PriorityQueue&#96;&#96;</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值<ul><li><code>HashMap</code>：数组 + 链表 + 红黑树</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-Array（数组）的区别"><a href="#ArrayList-和-Array（数组）的区别" class="headerlink" title="ArrayList 和 Array（数组）的区别"></a>ArrayList 和 Array（数组）的区别</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h2 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h2><h3 id="插入——add-："><a href="#插入——add-：" class="headerlink" title="插入——add()："></a>插入——add()：</h3><ul><li>头插：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾插：<ul><li>当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul></li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul><li><strong>头部删除</strong>：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li><strong>尾部删除</strong>：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li><strong>指定位置删除</strong>：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)</li></ul><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;</h2><p>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><p>ArrayList 的扩容是创建一个<strong>1.5 倍</strong>的新数组，然后把原数组的值拷贝过去。</p><h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>不推荐使用</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>写时复制技术，可以保障读写并发安全性</li></ul><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><ul><li>代理对象，额外创建mutex ，执行相关操作时，对mutex 加锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><h4 id="Queue-相关API"><a href="#Queue-相关API" class="headerlink" title="Queue 相关API"></a>Queue 相关API</h4><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><h4 id="Deque-相关API"><a href="#Deque-相关API" class="headerlink" title="Deque 相关API"></a>Deque 相关API</h4><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>此外，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-对比"><a href="#ArrayDeque-与-LinkedList-对比" class="headerlink" title="ArrayDeque 与 LinkedList 对比"></a>ArrayDeque 与 LinkedList 对比</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个<code>queue</code>的子接口。<code>BlockingQueue</code> 定义了阻塞式等待的插入和拿取操作（也可指定超时时间）</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制</li><li>读写&#x2F;生产消费 使用一把锁</li><li>提前分配内存，可能存在内存浪费，但是会快些</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>基于链表实现的阻塞队列</li><li>读写锁分离</li><li>无内存浪费，但是需要动态申请堆内存，会慢些</li></ul><h4 id="其他阻塞队列"><a href="#其他阻塞队列" class="headerlink" title="其他阻塞队列"></a>其他阻塞队列</h4><ul><li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p></li><li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p></li><li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的hash表，已不建议使用</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ul><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="&#x3D;&#x3D;HashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>&#x3D;&#x3D;<strong>数组 + 链表 + 红黑树</strong>&#x3D;&#x3D; （1.8 以后）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509021422847.png" alt="image-20240509021422847"></p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>默认长度： 16</li><li>最大长度： 2^30</li><li>负载因子： 0.75</li><li>链表树化阈值： 8</li><li>红黑树退化阈值： 6</li><li>链表树化时数组长度阈值： 64</li><li>node 数组扩容倍数： 2</li></ul><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509022413104.png" alt="image-20240509022413104"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><h4 id="常用的hash冲突解决办法"><a href="#常用的hash冲突解决办法" class="headerlink" title="常用的hash冲突解决办法"></a>常用的hash冲突解决办法</h4><ul><li>再哈希，直至找到空槽</li><li>开放地址法，寻找下一个空槽<ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数</li></ul></li><li>拉链法——也即JDK 1.8 HashMap 所采用方法</li></ul></li><li><h4 id="为什么-node-数组长度要是-2的幂次方"><a href="#为什么-node-数组长度要是-2的幂次方" class="headerlink" title="为什么 node 数组长度要是 2的幂次方"></a>为什么 node 数组长度要是 2的幂次方</h4><ul><li><strong>两点原因： 插入时定下标快，扩容时重新确定下标块</strong><ul><li>hash 过多，内存放不下，进而</li><li>一般通过 hash（或再映射）对数组长区域确定下标</li><li>而用 2的整数次幂为长度，余运算可以转为位运算，计算更快</li><li>此外，初始数组在没有把握的情况下，不宜设得过大，因此存在数组的后续扩容操作</li><li>以2的整数次幂为长度，且以 2 做扩容倍数时，可以方便的确定原数组链表内所有节点在扩容后的位置</li></ul></li></ul></li><li><h4 id="为什么选-0-75-为扩容因子"><a href="#为什么选-0-75-为扩容因子" class="headerlink" title="为什么选 0.75 为扩容因子"></a>为什么选 0.75 为扩容因子</h4></li><li><p>由加载因子的定义，其取值范围是 (0, 1]。</p></li><li><p>还有一个因素是为了提升扩容效率。因为<code>HashMap</code>的容量（<code>size</code>属性，构造函数中的<code>initialCapacity</code>变量）有一个要求：它一定是 2 的幂 （4,8,16，……）。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。</p></li><li><p>经验</p><ul><li>如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。</li><li>如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。</li></ul></li><li><h4 id="死循环问题"><a href="#死循环问题" class="headerlink" title="死循环问题"></a>死循环问题</h4><ul><li>1.8 之后改为尾插法不存在此问题， 1.7 及之前，头插法可能导致此问题</li></ul></li><li><h4 id="Hash-扰动"><a href="#Hash-扰动" class="headerlink" title="Hash 扰动"></a>Hash 扰动</h4><ul><li><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>一般数组长度可能不会太长，扰动后可使高16位也能参与下标计算，可在一定程度上缓解 hash 碰撞，使 key 分布更均衡</li><li>同时位运算消耗较低</li></ul></li><li><h4 id="为什么采用-红黑树-而不是-AVL-树"><a href="#为什么采用-红黑树-而不是-AVL-树" class="headerlink" title="为什么采用 红黑树 而不是 AVL 树"></a>为什么采用 红黑树 而不是 AVL 树</h4><ul><li><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p></li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>JDK1.7 的 采用 <strong>分段的数组+链表</strong> 实现， 每一个分段类似于一个子 Map ，一般也称 segment</li><li>JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，</li></ul><h3 id="实现线程安全的方式"><a href="#实现线程安全的方式" class="headerlink" title="&#x3D;&#x3D;实现线程安全的方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>实现线程安全的方式</strong>&#x3D;&#x3D;</h3><ul><li>JDK1.7 时，针对 segment 加锁</li><li>JDK 1.8 时数据结构跟 <code>HashMap</code> 1.8 的结构一样。并采用 <code>Node + CAS + synchronized</code> 来保证并发安全，同时降低了锁粒度，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</li><li>并发度层面 JDK 1.7 时最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap-中-key-和-value-不能为-null"><a href="#ConcurrentHashMap-中-key-和-value-不能为-null" class="headerlink" title="ConcurrentHashMap 中 key 和 value 不能为 null"></a>ConcurrentHashMap 中 key 和 value 不能为 null</h3><p><strong>原因</strong>： 主要是为了避免二义性。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li>继承Thread 类</li><li>实现 Runable 接口</li><li>实现 callable 接口</li><li>使用线程池</li></ul><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>此外，严格来说，Java 其实只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h2 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h2><ul><li><p><strong>wait()</strong></p><ul><li>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，</li><li>会释放对象的锁</li></ul></li><li><p><strong>sleep()</strong></p><ul><li>sleep 导致当前线程休眠，sleep(long)会导致线程进入TIMED-WATING 状态</li><li>不会释放锁</li></ul></li><li><p><strong>yield()</strong></p><ul><li>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。</li><li>不释放锁</li></ul></li><li><p><strong>join()</strong></p><ul><li>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位，这个线程本身并不会因此而改变状态(如阻塞，终止等)。</li></ul></li><li><p><strong>interrupt()</strong></p><ul><li>将一个阻塞状态线程的中断标志位置位，并使其中断&#x2F;抛出异常，抛出异常后 清楚中断标记位</li><li></li></ul></li></ul><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1383841-20190624155001636-644135935.jpg" alt="img"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java线程可以具有不同的优先级，用于告诉操作系统在竞争CPU时间片时应该优先考虑哪个线程。线程的优先级范围从1到10，默认优先级是5。您可以使用setPriority()方法设置线程的优先级，范围从1（最低优先级）到10（最高优先级）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><h2 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h2><p><strong>池化思想</strong>： 频繁创建销毁的东西，尽量设计成一个可以预分配、使用后归还、且可重复使用的模式，并交由一个管理器进行统一管理，以负责可复用对象的初始化、申请和归还处理；</p><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="使用-Executors-工具"><a href="#使用-Executors-工具" class="headerlink" title="使用 Executors 工具"></a>使用 Executors 工具</h3><p>Executors.newFixedThreadPool</p><p>Executors.newSingleThreadExecutor</p><p>Executors.newCachedThreadPool</p><p>Executors.newScheduledThreadPool</p><p>Executors.newSingleThreadScheduledExecutor</p><h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><h4 id="通用线程池-——-ThreadPoolExecutor"><a href="#通用线程池-——-ThreadPoolExecutor" class="headerlink" title="通用线程池 —— ThreadPoolExecutor"></a>通用线程池 —— ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a><strong>参数列表</strong></h5><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize： 最大线程数</li><li>keepAliveTime： 超出核心线程数的线程闲置后，最大存活时间</li><li>unit： 最大存活时间对应时间单位</li><li>workQueue： 任务队列</li><li>threadFactory： 线程工厂（可以配置线程命名、优先级等）</li><li>handler： 拒绝策略（可以集成 prometheus 实现埋点上报）<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240607015733333.png" alt="image-20240607015733333"><ul><li>AbortPolicy —— 不执行，并抛出异常</li><li>CallerRunPolicy —— 调用者执行</li><li>DiscardPolicy —— 不执行，也不抛出异常</li><li>DiscardOldestPolicy —— 不抛出异常，换掉最旧的任务</li></ul></li></ul><h4 id="延时任务线程池-——-ScheduledThreadPoolExecutor"><a href="#延时任务线程池-——-ScheduledThreadPoolExecutor" class="headerlink" title="延时任务线程池 —— ScheduledThreadPoolExecutor"></a>延时任务线程池 —— ScheduledThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞队列为无界队列</li></ul><h2 id="线程池参数设置"><a href="#线程池参数设置" class="headerlink" title="线程池参数设置"></a>线程池参数设置</h2><h3 id="核心线程数大小"><a href="#核心线程数大小" class="headerlink" title="核心线程数大小"></a>核心线程数大小</h3><ul><li>corePoolSize：<ul><li>CPU 密集型： CPU 核数 + 1</li><li>IO 密集型:  CPU 核数 * 2</li></ul></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p>无界队列</p><ul><li>LinkedBlockingQueue</li></ul></li><li><p>有界队列</p><ul><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-语言特点"><a href="#1-Java-语言特点" class="headerlink" title="1.    Java 语言特点"></a>1.    Java 语言特点</h2><ul><li><strong>面向对象</strong></li><li><strong>平台无关</strong></li><li><strong>支持多线程</strong><br>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li><li><strong>编译与解释并存</strong></li></ul><h2 id="2-JDK、JRE、JVM-关系"><a href="#2-JDK、JRE、JVM-关系" class="headerlink" title="2.    JDK、JRE、JVM 关系"></a>2.    JDK、JRE、JVM 关系</h2><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。</p><p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p><p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><h2 id="3-什么是字节码"><a href="#3-什么是字节码" class="headerlink" title="3.    什么是字节码"></a>3.    什么是字节码</h2><p>字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p>Java 跨平台特性其实就是为不同平台提供不同的 JVM，JVM 基于平台特性调整字节码解释实现，从而使得字节码在不同平台均可运行</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505211415926.png" alt="image-20240505211415926" style="zoom:67%;" /><h2 id="4-什么是面向对象"><a href="#4-什么是面向对象" class="headerlink" title="4.    什么是面向对象"></a>4.    什么是面向对象</h2><p><strong>面向对象是一种 相对面向过程 而言的编程范式</strong></p><p><strong>面向过程</strong>程序设计是具体化的，流程化的；面向过程的代码设计通过着手于事物的实现流程，根据已有条件如何一步一步生成结果。</p><p>因此，基于面向过程思路所涉及的代码通常不便于扩展和代码复用，此外，面向过程的思路在处理复杂问题时，编程难度将显著增加。</p><p>而<strong>面向对象</strong>程序设计是模型化的，把对象作为基本单位，将问题抽象建模为一系列对象之间的交互，使得程序易于理解、维护。具有相同行为和属性的对象泛化为类的实例。此外，面向对象具有三大特性——封装、继承与多态</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1    封装"></a>4.1    封装</h4><p><strong>概念</strong>：将一些属性和相关方法封装在一个对象中，对外隐藏内部实现细节。内部具体实现，外界不需要关心，而只需要根据”内部提供的接口“去使用就可以。</p><p><strong>好处</strong>：</p><ul><li><p>使用起来更加方便</p></li><li><p>保证数据的安全，针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改）</p></li><li><p>利于代码维护：如果后期功能实现逻辑需要调整，则保持接口名不变，修改实现代码即可，外界不需要做任何代码修改。</p></li></ul><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2    继承"></a>4.2    继承</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。</p><p>可提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p><h4 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3    多态"></a>4.3    多态</h4><p>同一个方法，在不同的对象上有不同的表现形式</p><p><strong>多态的要点：</strong></p><ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol><h2 id="5-访问权限"><a href="#5-访问权限" class="headerlink" title="5.    访问权限"></a>5.    访问权限</h2><ul><li><strong><code>default</code></strong> （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong><code>private</code></strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong><code>public</code></strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong><code>protected</code></strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="6-final-关键字"><a href="#6-final-关键字" class="headerlink" title="6.    final 关键字"></a>6.    final 关键字</h2><ul><li>当 <code>final</code> 修饰一个类时，表明这个类不能被继承。比如，<code>String</code> 类、<code>Integer</code> 类和其他包装类都是用 <code>final</code> 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（<code>@Override</code>）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 <code>final</code> 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。<ul><li>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；</li><li>如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。</li></ul></li></ul><h2 id="7-引用数据类型-、基本数据类型-与-包装类"><a href="#7-引用数据类型-、基本数据类型-与-包装类" class="headerlink" title="7.    引用数据类型 、基本数据类型 与 包装类"></a>7.    引用数据类型 、基本数据类型 与 包装类</h2><h4 id="7-1-引用数据类型"><a href="#7-1-引用数据类型" class="headerlink" title="7.1    引用数据类型"></a>7.1    引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="7-2-基本数据类型"><a href="#7-2-基本数据类型" class="headerlink" title="7.2    基本数据类型"></a>7.2    基本数据类型</h4><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1 比特</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h4 id="7-3-包装类"><a href="#7-3-包装类" class="headerlink" title="7.3    包装类"></a>7.3    包装类</h4><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，而几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h5 id="7-3-1-包装类常量池-缓存"><a href="#7-3-1-包装类常量池-缓存" class="headerlink" title="7.3.1    包装类常量池(缓存)"></a>7.3.1    包装类常量池(缓存)</h5><p>byte、int、long 类型 均缓存有 -128~127 的值在常量池中</p><p>char 缓存所有char</p><h2 id="8-Java-拷贝机制"><a href="#8-Java-拷贝机制" class="headerlink" title="8.    Java 拷贝机制"></a>8.    Java 拷贝机制</h2><ul><li><strong>浅拷贝</strong>：值类型拷贝，引用类型指向同一对象</li><li><strong>深拷贝</strong>：值类型拷贝，引用类型则拷贝了一个新对象，且引用类型内部按此规则递归</li></ul><h4 id="8-1-cloneable-接口与-clone"><a href="#8-1-cloneable-接口与-clone" class="headerlink" title="8.1    cloneable 接口与 clone()"></a>8.1    cloneable 接口与 clone()</h4><p><code>clone()</code> 默认浅拷贝， 且相应对象若未实现 <code>cloneable</code> 接口，会抛出异常</p><h4 id="8-2-如何实现-深拷贝"><a href="#8-2-如何实现-深拷贝" class="headerlink" title="8.2    如何实现 深拷贝"></a>8.2    如何实现 深拷贝</h4><ul><li>自定义拷贝构造函数（递归）</li><li>递归实现 <code>cloneable</code> 接口并重写 <code>clone()</code> 方法</li><li>序列化</li></ul><h2 id="9-String-相关"><a href="#9-String-相关" class="headerlink" title="9.    String 相关"></a>9.    String 相关</h2><h4 id="9-1-String、StringBuffer、StringBuilder"><a href="#9-1-String、StringBuffer、StringBuilder" class="headerlink" title="9.1    String、StringBuffer、StringBuilder"></a>9.1    String、StringBuffer、StringBuilder</h4><p><code>String</code> 是不可变的（自然线程安全）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，且 <code>StringBuffer</code> 对字符串的操作方法都添加了同步锁，因此性能安全，但同时影响了性能</p><h4 id="9-2-String-为什么不可变"><a href="#9-2-String-为什么不可变" class="headerlink" title="9.2    String 为什么不可变"></a>9.2    String 为什么不可变</h4><ul><li>String 类中 核心数组 被final修饰，此外，String 类中未提供修改 数组内元素的方法</li><li>String 类自身也是 final 的，可以避免子类提供数组修改方法</li></ul><h4 id="9-3-String-为什么要设计成不可变的"><a href="#9-3-String-为什么要设计成不可变的" class="headerlink" title="9.3    String 为什么要设计成不可变的"></a>9.3    String 为什么要设计成不可变的</h4><ul><li><strong>安全</strong> —— String 类型经常用来做参数，比如 url、pwd 之类的</li><li><strong>允许缓存 HashCode</strong> —— Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存</li><li><strong>字符串常量池需要</strong></li></ul><h2 id="10-Object"><a href="#10-Object" class="headerlink" title="10.    Object"></a>10.    Object</h2><h4 id="10-1-常用方法"><a href="#10-1-常用方法" class="headerlink" title="10.1    常用方法"></a>10.1    常用方法</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505224438372.png" alt="image-20240505224438372"></p><h4 id="10-2-和-equals"><a href="#10-2-和-equals" class="headerlink" title="10.2    &#x3D;&#x3D; 和 equals"></a>10.2    &#x3D;&#x3D; 和 equals</h4><ul><li>&#x3D;&#x3D; 判断值类型是否相等，引用类型是否指向同一对象</li><li><code>equals</code> 默认情况下与 &#x3D;&#x3D; 等价，重写后可能不等价</li></ul><h4 id="10-3-为什么重写-equals-时必须重写-hashCode-方法"><a href="#10-3-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="10.3    为什么重写 equals() 时必须重写 hashCode() 方法"></a>10.3    为什么重写 equals() 时必须重写 hashCode() 方法</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>导致 HashMap 可能存入两个逻辑相等的对象</p><h2 id="11-序列化、反序列化"><a href="#11-序列化、反序列化" class="headerlink" title="11.    序列化、反序列化"></a>11.    序列化、反序列化</h2><h4 id="11-1-什么是序列化、反序列化"><a href="#11-1-什么是序列化、反序列化" class="headerlink" title="11.1    什么是序列化、反序列化"></a>11.1    什么是序列化、反序列化</h4><ul><li>序列化：把 Java 对象转换为字节序列的过程</li><li>反序列：把字节序列恢复为 Java 对象的过程</li></ul><h4 id="11-2-注意点"><a href="#11-2-注意点" class="headerlink" title="11.2    注意点"></a>11.2    注意点</h4><ul><li>static 静态变量和 transient 修饰的字段是不会被序列化的</li><li>serialVersionUID问题</li><li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li><li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li></ul><h4 id="11-3-不推荐使用-JDK-自带的序列化"><a href="#11-3-不推荐使用-JDK-自带的序列化" class="headerlink" title="11.3    不推荐使用 JDK 自带的序列化"></a>11.3    不推荐使用 JDK 自带的序列化</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.    异常"></a>12.    异常</h2><h4 id="12-1-异常层级"><a href="#12-1-异常层级" class="headerlink" title="12.1    异常层级"></a>12.1    异常层级</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505230455539.png" alt="image-20240505230455539"></p><ul><li>**<code>Throwable</code>**：是 java 中所有异常和错误的超类,其两个子类为 <strong><code>Error</code></strong>(错误) 和 <strong><code>Exception</code></strong>(异常)<ul><li><strong>Error</strong>： 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</li><li>**<code>Exception</code>**： 是程序本身可以捕获并且可以处理的异常。其中可分为运行时异常（RuntimeException）和非运行时异常，也叫做受检异常<ul><li>**运行时异常(不受检异常)**： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li><li>**非运行时异常(受检异常)**： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</li></ul></li></ul></li></ul><h4 id="12-1-try-with-finally"><a href="#12-1-try-with-finally" class="headerlink" title="12.1    try - with - finally"></a>12.1    try - with - finally</h4><ul><li><p>无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p></li><li><p>不要在 finally 语句块中使用 return， 因为当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略</p></li><li><p>finally 语句在 线程被杀死、JVM 关闭等情况时也不一定会执行</p></li><li><p>对必须关闭的资源，推荐使用 <code>try with resources</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注解"><a href="#13-注解" class="headerlink" title="13.    注解"></a>13.    注解</h2><h4 id="13-1-注解作用"><a href="#13-1-注解作用" class="headerlink" title="13.1    注解作用"></a>13.1    注解作用</h4><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，并可添加根据注解内容而执行的特定逻辑。</p><h4 id="13-2-注解类型"><a href="#13-2-注解类型" class="headerlink" title="13.2    注解类型"></a>13.2    注解类型</h4><ul><li><p>元注解</p><ul><li>@Retention</li><li>@Documented</li><li>@Target</li><li>@Inherited</li><li>@Repeatable</li></ul></li><li><p>内置普通注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SupressWarnings</li><li>@SafeVarargs</li></ul></li><li><p>自定义注解</p></li></ul><h4 id="13-3-其他"><a href="#13-3-其他" class="headerlink" title="13.3    其他"></a>13.3    其他</h4><ul><li>注解也是一个类，可以添加属性，并设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Coder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GRQ&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">language</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">company</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;China_Company&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
