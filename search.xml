<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/02/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/"/>
      <url>/2025/02/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DDD 简介</title>
      <link href="/2024/10/27/%E6%9E%B6%E6%9E%84/DDD%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/10/27/%E6%9E%B6%E6%9E%84/DDD%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="领域驱动设计（DDD）深度解析：从战略设计到战术落地"><a href="#领域驱动设计（DDD）深度解析：从战略设计到战术落地" class="headerlink" title="领域驱动设计（DDD）深度解析：从战略设计到战术落地"></a>领域驱动设计（DDD）深度解析：从战略设计到战术落地</h3><hr><h4 id="一、为什么需要DDD？"><a href="#一、为什么需要DDD？" class="headerlink" title="一、为什么需要DDD？"></a>一、为什么需要DDD？</h4><p>在传统软件开发中，<strong>业务逻辑与技术实现的高度耦合</strong>常导致系统难以维护。MVC架构容易退化为”贫血模型”，业务规则散落在Service层，领域知识逐渐丢失。而DDD通过<strong>以领域为中心的设计哲学</strong>，提供了一套应对复杂业务系统的完整方法论。</p><hr><h4 id="二、DDD核心思想"><a href="#二、DDD核心思想" class="headerlink" title="二、DDD核心思想"></a>二、DDD核心思想</h4><ol><li><p><strong>领域为王</strong><br>一切设计围绕业务领域展开，技术实现为领域服务</p></li><li><p><strong>统一语言</strong><br>开发团队与业务专家使用一致的术语表（Ubiquitous Language）</p></li><li><p><strong>分治策略</strong><br>通过限界上下文（Bounded Context）划分复杂系统</p></li></ol><hr><h3 id="三、战略设计：划分战场"><a href="#三、战略设计：划分战场" class="headerlink" title="三、战略设计：划分战场"></a>三、战略设计：划分战场</h3><ol><li><p><strong>子域划分</strong></p><ul><li><strong>核心域</strong>：业务核心竞争力（如电商的订单系统）</li><li><strong>支撑域</strong>：辅助核心业务（如物流跟踪）</li><li><strong>通用域</strong>：通用解决方案（如支付模块）</li></ul></li><li><p><strong>限界上下文</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[订单上下文]           [库存上下文]</span><br><span class="line">- 订单聚合根          - 库存条目</span><br><span class="line">- 订单项值对象        - 仓库实体</span><br><span class="line">- 订单状态机          - 库存锁定服务</span><br></pre></td></tr></table></figure></li><li><p><strong>上下文映射</strong></p><ul><li>合作关系（Partnership）</li><li>客户&#x2F;供应商（Customer&#x2F;Supplier）</li><li>防腐层（Anticorruption Layer）</li></ul></li></ol><hr><h3 id="四、战术设计：构建领域模型"><a href="#四、战术设计：构建领域模型" class="headerlink" title="四、战术设计：构建领域模型"></a>四、战术设计：构建领域模型</h3><table><thead><tr><th>构建块</th><th>核心特征</th><th>示例</th></tr></thead><tbody><tr><td><strong>实体</strong></td><td>唯一标识+生命周期</td><td>User(userId)</td></tr><tr><td><strong>值对象</strong></td><td>不可变+无标识</td><td>Money(amount,currency)</td></tr><tr><td><strong>聚合根</strong></td><td>一致性边界</td><td>Order(orderId)</td></tr><tr><td><strong>领域服务</strong></td><td>无状态操作</td><td>TransferService</td></tr><tr><td><strong>领域事件</strong></td><td>记录领域状态变化</td><td>OrderShippedEvent</td></tr></tbody></table><p><strong>聚合设计原则</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> OrderId id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(Product product, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(items.size() &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessRuleException</span>(<span class="string">&quot;Max items exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        items.add(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(product, quantity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="五、架构实现模式"><a href="#五、架构实现模式" class="headerlink" title="五、架构实现模式"></a>五、架构实现模式</h3><ol><li><p><strong>分层架构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐</span><br><span class="line">│  User Interface │</span><br><span class="line">├─────────────┤</span><br><span class="line">│ Application  │</span><br><span class="line">│   Service    │</span><br><span class="line">├─────────────┤</span><br><span class="line">│   Domain     │</span><br><span class="line">├─────────────┤</span><br><span class="line">│ Infrastructure │</span><br><span class="line">└─────────────┘</span><br></pre></td></tr></table></figure></li><li><p><strong>CQRS模式</strong></p><ul><li>命令端：领域模型处理业务逻辑</li><li>查询端：优化后的读模型直接返回DTO</li></ul></li><li><p><strong>事件溯源</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, events</span>):</span><br><span class="line">        self.balance = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> event <span class="keyword">in</span> events:</span><br><span class="line">            self.apply(event)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deposit</span>(<span class="params">self, amount</span>):</span><br><span class="line">        self.apply(DepositEvent(amount))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">apply</span>(<span class="params">self, event</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(event, DepositEvent):</span><br><span class="line">            self.balance += event.amount</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="六、实践建议"><a href="#六、实践建议" class="headerlink" title="六、实践建议"></a>六、实践建议</h4><ol><li><p><strong>实施步骤</strong></p><ul><li>事件风暴工作坊 → 领域模型 → 限界上下文 → 微服务划分</li></ul></li><li><p><strong>技术选型</strong></p><ul><li>框架：Axon Framework, DDDLib</li><li>存储：EventStoreDB, MongoDB</li></ul></li><li><p><strong>常见陷阱</strong></p><ul><li>过度设计聚合边界</li><li>忽略领域事件的消息可靠性</li><li>将DDD与微服务强制绑定</li></ul></li></ol><hr><h4 id="七、何时使用DDD？"><a href="#七、何时使用DDD？" class="headerlink" title="七、何时使用DDD？"></a>七、何时使用DDD？</h4><ul><li>✅ 业务规则复杂多变的系统（保险、金融）</li><li>✅ 需要长期演进的战略级项目</li><li>❌ 简单CRUD管理系统</li><li>❌ 交付周期极短的MVP项目</li></ul><hr><p>通过DDD，我们不仅是在构建软件，更是在构建对业务领域的深刻认知。这种设计思想需要持续的精益实践，但当复杂业务遇上DDD，就像给迷宫装上了导航系统——虽然不能消除所有曲折，却能始终指引正确的方向。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构演进</title>
      <link href="/2024/10/24/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2024/10/24/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="架构演进"><a href="#架构演进" class="headerlink" title="架构演进"></a>架构演进</h1><h2 id="原始分布式时代"><a href="#原始分布式时代" class="headerlink" title="原始分布式时代"></a>原始分布式时代</h2><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><ul><li><strong>硬件限制</strong>：在20世纪70年代末期到80年代初，计算机科学经历了从大型机向微型机的转变。当时的微型计算机系统通常具有16位寻址能力、不足5MHz时钟频率的处理器和128KB左右的内存地址空间。这样的硬件限制直接妨碍了单台计算机上信息系统软件的最大规模，因此需要多台计算机共同协作来支撑同一套软件系统的运行。</li><li><strong>突破算力限制</strong>：为了突破硬件算力的限制，各个高校、研究机构、软硬件厂商开始探索使用多台计算机共同协作来支撑同一套软件系统运行的可行性。</li><li><strong>计算机应用的扩展</strong>：计算机逐渐从科研设备转变为商业企业的生产设备，甚至是面向家庭、个人用户的娱乐设备，这要求计算机能够处理更大规模的信息系统软件</li></ul><h3 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h3><ol><li><strong>网络运算架构（NCA）</strong>：惠普公司提出的网络运算架构是未来远程服务调用的雏形 （RPC）。</li><li><strong>分布式文件系统（AFS）</strong>：卡内基·梅隆大学提出的AFS文件系统是日后分布式文件系统的最早实现。</li><li><strong>Kerberos协议</strong>：麻省理工学院提出的Kerberos协议是服务认证和访问控制的基础性协议，是分布式服务安全性的重要支撑，目前仍被用于实现包括Windows和MacOS在内众多操作系统的登录、认证功能。</li><li><strong>分布式运算环境（DCE）</strong>：开放软件基金会（OSF）制订了名为“分布式运算环境”的软件架构公约，包括了一整套完整的分布式服务组件的规范与实现，如DCE&#x2F;RPC、DCE&#x2F;DFS等。</li></ol><p>这些技术、概念对Unix系统后续的发展，乃至对今天计算机科学的诸多领域都产生了巨大而深远的影响，直接牵引了后续软件架构演化进程。</p><h3 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h3><ul><li>诸如 服务发现、负载均衡、熔断、隔离、降级、序列化、传输协议、认证和授权 、分布式数据一致性 等后续分布式&#x2F;微服务 时代老生常谈的话题，其实在这时候都已经开始了大量探索</li><li><strong>某个功能能够进行分布式，并不意味着它就应该进行分布式，强行追求透明的分布式操作，只会自寻苦果</strong></li></ul><h2 id="单体系统时代"><a href="#单体系统时代" class="headerlink" title="单体系统时代"></a>单体系统时代</h2><h3 id="演进前提"><a href="#演进前提" class="headerlink" title="演进前提"></a>演进前提</h3><ol><li><strong>硬件性能的提升</strong>：随着摩尔定律的生效，微型计算机的性能以每两年增长一倍的速度提升，使得单台或少数几台计算机即可作为服务器来支撑大型信息系统运作，这使得单体架构成为可能。</li></ol><h3 id="演进原因"><a href="#演进原因" class="headerlink" title="演进原因"></a>演进原因</h3><h4 id="分布式（在当时条件下）存在的问题"><a href="#分布式（在当时条件下）存在的问题" class="headerlink" title="分布式（在当时条件下）存在的问题"></a>分布式（在当时条件下）存在的问题</h4><ol><li><p><strong>分布式架构的复杂性</strong>：原始分布式架构虽然提出了很多技术和概念，但其复杂性高，包括服务发现、负载均衡、网络分区、超时处理、序列化协议、传输协议、认证授权等一系列问题，这些问题使得分布式架构难以管理和维护。</p></li><li><p><strong>对透明分布式操作的追求</strong>：Unix设计哲学强调接口与实现的简单性，比系统的其他属性更为重要。原始分布式架构追求如同本地调用一般简单透明的分布式系统，但实际中这种透明性难以实现，导致了许多问题。</p></li></ol><h4 id="单体系统的优势"><a href="#单体系统的优势" class="headerlink" title="单体系统的优势"></a>单体系统的优势</h4><ol><li><p><strong>开发简单</strong>：单体架构中所有功能单元紧密集成，使得应用开发相对简单。</p></li><li><p><strong>易于部署</strong>：单体应用通常只需要将打包好的应用拷贝到服务器上，部署过程简单明了。</p></li><li><p><strong>测试直观</strong>：由于所有组件都在同一个应用中，测试过程相对简单直观。</p></li><li><p><strong>易于大规模更改</strong>：在单体架构中，对应用程序进行大规模更改相对容易。</p></li><li><p><strong>横向扩展容易</strong>：单体架构可以通过在负载均衡器后端运行多个应用副本来轻松实现应用扩展。</p></li></ol><h3 id="单体系统的劣势"><a href="#单体系统的劣势" class="headerlink" title="单体系统的劣势"></a>单体系统的劣势</h3><ol><li><p><strong>复杂度问题</strong>：随着业务的拓展和功能的增多，单体应用变得越来越复杂，维护和升级成为挑战。</p></li><li><p><strong>扩展局限</strong>：单体架构很难进行水平扩展，当某个模块需要单独扩展时，整个系统都需要扩展，成本高昂。</p></li><li><p><strong>部署困难</strong>：频繁的部署需求使得单体架构在每次更新时都需要重新部署整个应用，增加了风险和工作量。</p></li><li><p><strong>技术迭代困难</strong>：在单体架构下引入新技术和工具，或进行架构优化，通常意味着大规模的改动和可能的风险。</p></li><li><p><strong>可靠性差</strong>：单体应用中任何一部分代码出现缺陷，如内存泄漏或线程爆炸，都将影响整个程序的正常运作。</p></li><li><p><strong>难以技术异构</strong>：单体架构中各模块通常需要使用相同的技术栈，限制了技术多样性。</p></li></ol><p><strong>综上所述，原始分布式时代向单体系统时代的演进是为了解决分布式架构的复杂性和管理难题，而单体系统虽然简化了开发和部署流程，但也带来了新的挑战，特别是在系统规模扩大和需求变化时。</strong></p><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><h3 id="演进原因-1"><a href="#演进原因-1" class="headerlink" title="演进原因"></a>演进原因</h3><p>单体架构向分层架构演进的主要原因是为了解决以下几个问题：</p><ol><li><p><strong>易于开发与维护</strong>：随着业务的发展，单体应用变得越来越复杂，难以维护。分层架构通过将系统拆分成具有独立职责的多个层次，简化了系统设计，使得团队成员可以专注于特定层次的开发。</p></li><li><p><strong>提高代码的复用性和系统的横向扩展能力</strong>：分层架构允许在不同系统或模块中重用相同的代码，尤其是在数据访问层。</p></li><li><p><strong>应对高并发系统设计</strong>：分层架构支持高并发和向分布式方向发展，对网站支持高并发至关重要。</p></li></ol><h3 id="分层架构优势"><a href="#分层架构优势" class="headerlink" title="分层架构优势"></a>分层架构优势</h3><p>分层架构相对于单体架构的优势包括：</p><ol><li><p><strong>高内聚低耦合</strong>：每个层次都有明确的职责，内聚度高，层与层之间的耦合度低，提高了系统的可维护性和可扩展性。</p></li><li><p><strong>易于测试</strong>：由于每一层都有明确的职责，可以对每一层进行单独的测试，简化了测试工作。</p></li><li><p><strong>可重用性和灵活性</strong>：分层架构提高了代码的可重用性，如果在某一层引入了改变，只需要修改那一层的代码，而不会影响到其他层，这大大增加了系统的灵活性。</p></li></ol><h3 id="分层架构不足"><a href="#分层架构不足" class="headerlink" title="分层架构不足"></a>分层架构不足</h3><p>然而，分层架构也引入了新的挑战和不足：</p><ol><li><p><strong>性能问题</strong>：分层架构可能会引入额外的性能开销，因为一个请求可能需要穿越多层才能得到处理，这可能会导致延迟。</p></li><li><p><strong>过度复杂化</strong>：如果过度使用分层架构，可能会导致系统过于复杂，管理和维护这些层变得困难。</p></li><li><p><strong>架构设计之初没有严格的层级和边界设计</strong>：如果层与层之间只是物理代码的隔离，逻辑上却严重耦合，会导致架构设计的初衷无法实现。</p></li><li><p><strong>有层级设计，但每层的职责设计难以支撑业务演进</strong>：如果某一层没有承担起它该有的责任，其他层只能把这个责任担起来，从而引入不必要的问题。</p></li><li><p><strong>开发团队的认知水平和协作水平低下</strong>：软件开发是一个团队协作共同创作的过程，如果在每个阶段都完全依靠每个个体的能力，软件的架构和质量取决于团队内最差的个体的能力和认知水平。</p></li></ol><p>综上所述，分层架构通过将复杂的系统分解为更小、更易于管理的部分，提高了系统的可维护性和可扩展性，但也带来了性能和复杂性方面的挑战。</p><h2 id="SOA-架构"><a href="#SOA-架构" class="headerlink" title="SOA 架构"></a>SOA 架构</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>SOA (Service-oriented architecture，面相服务的软件架构)是一种软件设计方法 或 大型服务架构设计思想，</p><p>SOA 侧重于构建和维护一系列的大型服务系统的基本组件， 这些基本组件可以相互调用，且相互松耦合，每一个组件可以完整的覆盖一个子模块，或子业务的各项基本功能。</p><p>在完成 基础组件搭建后， 可以快速的将业务进行编排、组合来实现具体的或不断变化业务。</p><p>在SOA中，重点是模块化、可重用性和互操作性——当业务将复杂的应用程序分解成更小、更易于管理的构建块时，结果是更大的灵活性和可伸缩性。</p><h3 id="主要技术概念"><a href="#主要技术概念" class="headerlink" title="主要技术概念"></a>主要技术概念</h3><p>SOA 软件设计指导原则： 包括服务的 封装性、</p><h2 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务治理概述</title>
      <link href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p><strong>服务治理</strong>是微服务架构中的核心概念，旨在确保分布式系统中各个服务的稳定性、可靠性和可维护性。它涵盖了从服务发现到故障恢复的多个方面。以下是服务治理的主要方面：</p><hr><h3 id="1-服务发现与注册"><a href="#1-服务发现与注册" class="headerlink" title="1. 服务发现与注册"></a>1. <strong>服务发现与注册</strong></h3><ul><li><strong>定义</strong>：服务实例启动时向注册中心注册自己的信息（如IP、端口、服务名），其他服务通过注册中心发现目标服务。</li><li><strong>常见工具</strong>：<ul><li><strong>Consul</strong>：支持服务发现、健康检查、KV存储。</li><li><strong>Eureka</strong>：Netflix开源的注册中心，适合Spring Cloud生态。</li><li><strong>Zookeeper</strong>：分布式协调服务，支持服务注册与发现。</li><li><strong>Nacos</strong>：阿里巴巴开源的注册中心，支持服务发现和配置管理。</li></ul></li><li><strong>关键点</strong>：<ul><li>服务动态上下线。</li><li>服务信息的实时更新。</li></ul></li></ul><hr><h3 id="2-负载均衡"><a href="#2-负载均衡" class="headerlink" title="2. 负载均衡"></a>2. <strong>负载均衡</strong></h3><ul><li><strong>定义</strong>：将请求均匀分发到多个服务实例，以提高系统的吞吐量和可用性。</li><li><strong>负载均衡策略</strong>：<ul><li>轮询（Round Robin）。</li><li>加权轮询（Weighted Round Robin）。</li><li>最小连接数（Least Connections）。</li><li>一致性哈希（Consistent Hashing）。</li></ul></li><li><strong>实现方式</strong>：<ul><li>客户端负载均衡（如Ribbon）。</li><li>服务端负载均衡（如Nginx、HAProxy）。</li></ul></li></ul><hr><h3 id="3-服务容错与熔断"><a href="#3-服务容错与熔断" class="headerlink" title="3. 服务容错与熔断"></a>3. <strong>服务容错与熔断</strong></h3><ul><li><strong>定义</strong>：在服务出现故障时，防止故障扩散，保证系统的稳定性。</li><li><strong>常见机制</strong>：<ul><li><strong>熔断器（Circuit Breaker）</strong>：当服务失败率达到阈值时，熔断器会暂时停止调用该服务。</li><li><strong>降级（Fallback）</strong>：在服务不可用时，返回默认值或执行备用逻辑。</li><li><strong>重试（Retry）</strong>：在服务调用失败时，自动重试。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Hystrix</strong>：Netflix开源的熔断器实现。</li><li><strong>Resilience4j</strong>：轻量级的容错库。</li><li><strong>Sentinel</strong>：阿里巴巴开源的流量控制和熔断工具。</li></ul></li></ul><hr><h3 id="4-流量控制与限流"><a href="#4-流量控制与限流" class="headerlink" title="4. 流量控制与限流"></a>4. <strong>流量控制与限流</strong></h3><ul><li><strong>定义</strong>：通过限制服务的请求量，防止系统过载。</li><li><strong>限流算法</strong>：<ul><li>计数器算法。</li><li>滑动窗口算法。</li><li>令牌桶算法。</li><li>漏桶算法。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Sentinel</strong>：支持流量控制、熔断降级。</li><li><strong>Nginx</strong>：通过配置实现限流。</li><li><strong>Redis</strong>：利用Redis实现分布式限流。</li></ul></li></ul><hr><h3 id="5-配置管理"><a href="#5-配置管理" class="headerlink" title="5. 配置管理"></a>5. <strong>配置管理</strong></h3><ul><li><strong>定义</strong>：集中管理服务的配置信息，支持动态更新。</li><li><strong>常见工具</strong>：<ul><li><strong>Spring Cloud Config</strong>：基于Git的配置管理。</li><li><strong>Nacos</strong>：支持配置管理和服务发现。</li><li><strong>Apollo</strong>：携程开源的配置中心。</li></ul></li><li><strong>关键点</strong>：<ul><li>配置的动态更新。</li><li>配置的版本管理。</li></ul></li></ul><hr><h3 id="6-服务监控与告警"><a href="#6-服务监控与告警" class="headerlink" title="6. 服务监控与告警"></a>6. <strong>服务监控与告警</strong></h3><ul><li><strong>定义</strong>：实时监控服务的运行状态，及时发现和处理问题。</li><li><strong>监控指标</strong>：<ul><li>请求量、响应时间、错误率。</li><li>CPU、内存、磁盘等资源使用情况。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Prometheus</strong>：开源的监控系统。</li><li><strong>Grafana</strong>：可视化监控数据。</li><li><strong>ELK Stack</strong>：用于日志收集和分析。</li><li><strong>SkyWalking</strong>：分布式追踪系统。</li></ul></li></ul><hr><h3 id="7-日志管理"><a href="#7-日志管理" class="headerlink" title="7. 日志管理"></a>7. <strong>日志管理</strong></h3><ul><li><strong>定义</strong>：集中收集、存储和分析服务的日志。</li><li><strong>常见工具</strong>：<ul><li><strong>ELK Stack</strong>：Elasticsearch、Logstash、Kibana。</li><li><strong>Fluentd</strong>：日志收集工具。</li><li><strong>Splunk</strong>：商业日志管理工具。</li></ul></li><li><strong>关键点</strong>：<ul><li>日志的标准化。</li><li>日志的实时分析。</li></ul></li></ul><hr><h3 id="8-分布式追踪"><a href="#8-分布式追踪" class="headerlink" title="8. 分布式追踪"></a>8. <strong>分布式追踪</strong></h3><ul><li><strong>定义</strong>：跟踪请求在分布式系统中的调用链路，帮助定位问题。</li><li><strong>常见工具</strong>：<ul><li><strong>Zipkin</strong>：开源的分布式追踪系统。</li><li><strong>Jaeger</strong>：支持高并发的分布式追踪。</li><li><strong>SkyWalking</strong>：APM工具，支持分布式追踪和性能监控。</li></ul></li><li><strong>关键点</strong>：<ul><li>调用链路的可视化。</li><li>性能瓶颈的分析。</li></ul></li></ul><hr><h3 id="9-服务安全"><a href="#9-服务安全" class="headerlink" title="9. 服务安全"></a>9. <strong>服务安全</strong></h3><ul><li><strong>定义</strong>：保护服务免受未授权访问和攻击。</li><li><strong>常见措施</strong>：<ul><li>身份认证（如OAuth2、JWT）。</li><li>权限控制（如RBAC）。</li><li>数据加密（如HTTPS、TLS）。</li><li>防止常见攻击（如SQL注入、XSS）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Spring Security</strong>：Java生态的安全框架。</li><li><strong>Keycloak</strong>：开源的身份和访问管理工具。</li></ul></li></ul><hr><h3 id="10-服务版本管理"><a href="#10-服务版本管理" class="headerlink" title="10. 服务版本管理"></a>10. <strong>服务版本管理</strong></h3><ul><li><strong>定义</strong>：管理服务的不同版本，支持灰度发布和回滚。</li><li><strong>常见策略</strong>：<ul><li>蓝绿部署。</li><li>金丝雀发布。</li><li>版本路由（如通过HTTP头或参数区分版本）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Kubernetes</strong>：支持蓝绿部署和金丝雀发布。</li><li><strong>Istio</strong>：服务网格，支持流量管理。</li></ul></li></ul><hr><h3 id="11-服务依赖管理"><a href="#11-服务依赖管理" class="headerlink" title="11. 服务依赖管理"></a>11. <strong>服务依赖管理</strong></h3><ul><li><strong>定义</strong>：管理服务之间的依赖关系，避免循环依赖和单点故障。</li><li><strong>常见措施</strong>：<ul><li>依赖隔离（如线程池隔离）。</li><li>依赖降级（如关闭非核心服务）。</li></ul></li><li><strong>常见工具</strong>：<ul><li><strong>Hystrix</strong>：支持依赖隔离和降级。</li><li><strong>Sentinel</strong>：支持依赖流量控制。</li></ul></li></ul><hr><h3 id="12-服务编排与调度"><a href="#12-服务编排与调度" class="headerlink" title="12. 服务编排与调度"></a>12. <strong>服务编排与调度</strong></h3><ul><li><strong>定义</strong>：在容器化环境中，管理服务的部署和调度。</li><li><strong>常见工具</strong>：<ul><li><strong>Kubernetes</strong>：容器编排工具。</li><li><strong>Docker Swarm</strong>：轻量级的容器编排工具。</li></ul></li><li><strong>关键点</strong>：<ul><li>服务的自动扩缩容。</li><li>资源调度和优化。</li></ul></li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>服务治理是微服务架构中不可或缺的一部分，涵盖了从服务注册发现到监控告警的多个方面。通过合理的服务治理，可以显著提高系统的稳定性、可维护性和可扩展性。在实际项目中，通常需要结合具体需求选择合适的工具和策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡概述</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="负载均衡常见面试题解析"><a href="#负载均衡常见面试题解析" class="headerlink" title="负载均衡常见面试题解析"></a>负载均衡常见面试题解析</h1><h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1-什么是负载均衡？为什么需要它？"><a href="#1-什么是负载均衡？为什么需要它？" class="headerlink" title="1. 什么是负载均衡？为什么需要它？"></a>1. 什么是负载均衡？为什么需要它？</h3><p><strong>答案</strong>：<br>负载均衡是一种将网络请求或计算任务<strong>动态分配</strong>到多个服务器（或资源）的技术，目标是：</p><ul><li><strong>提高系统吞吐量</strong>：避免单个服务器过载。</li><li><strong>增强可用性</strong>：通过故障转移（Failover）避免单点故障。</li><li><strong>优化资源利用率</strong>：合理分配请求，减少资源浪费。</li></ul><h3 id="2-四层负载均衡-vs-七层负载均衡的区别？"><a href="#2-四层负载均衡-vs-七层负载均衡的区别？" class="headerlink" title="2. 四层负载均衡 vs. 七层负载均衡的区别？"></a>2. 四层负载均衡 vs. 七层负载均衡的区别？</h3><p><strong>答案</strong>：  </p><ul><li><strong>四层（L4）</strong>：基于内核态的TCP&#x2F;IP协议栈，通过修改IP&#x2F;TCP头信息实现转发（如DNAT）。性能高（可达到百万级QPS），但无法理解HTTP报文。典型工具：LVS（Linux Virtual Server）。</li><li><strong>七层（L7）</strong>：工作在用户态，解析HTTP&#x2F;HTTPS头部，支持按URL、Cookie等路由。性能较低（通常十万级QPS），但灵活性极强。典型工具：Nginx、Envoy。<br><strong>性能优化</strong>：LVS使用IPVS内核模块避免数据拷贝；Nginx通过epoll多路复用和非阻塞I&#x2F;O提升并发能力。<br><strong>关键区别</strong>：L7能识别应用协议，支持更复杂的路由策略（如按URL分发），但延迟略高。</li></ul><h3 id="3-负载均衡的实现方式有哪些"><a href="#3-负载均衡的实现方式有哪些" class="headerlink" title="3. 负载均衡的实现方式有哪些"></a>3. 负载均衡的实现方式有哪些</h3><p><strong>答案：</strong></p><ul><li><p>代理模式（proxy model）<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250209002825710.png" alt="image-20250209002825710"></p></li><li><p>客户端负载均衡（Balancing-aware Client）</p><ul><li><p>集成式 —— 负载均衡策略解析 与 服务调用发起  动作由同一进程处理</p></li><li><p>拓展式 —— LB 从消费进程移动出来</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250209003310225.png" alt="image-20250209003310225"></p></li></ul></li></ul><hr><h2 id="二、负载均衡算法"><a href="#二、负载均衡算法" class="headerlink" title="二、负载均衡算法"></a>二、负载均衡算法</h2><h3 id="1-常见的负载均衡算法有哪些？"><a href="#1-常见的负载均衡算法有哪些？" class="headerlink" title="1. 常见的负载均衡算法有哪些？"></a>1. 常见的负载均衡算法有哪些？</h3><p><strong>答案</strong>：  </p><ul><li><strong>轮询（Round Robin）</strong>：依次分配请求，适合服务器性能相近的场景。  </li><li><strong>加权轮询（Weighted Round Robin）</strong>：根据服务器权重分配，权重高的处理更多请求。  </li><li><strong>最少连接（Least Connections）</strong>：将请求分发给当前连接数最少的服务器。  </li><li><strong>IP哈希（IP Hash）</strong>：根据客户端IP计算哈希值，固定分配到某台服务器，适合需要会话保持的场景。  </li><li><strong>响应时间加权（Response Time）</strong>：优先选择响应时间短的服务器。</li></ul><h3 id="2-一致性哈希（Consistent-Hashing）解决了什么问题？"><a href="#2-一致性哈希（Consistent-Hashing）解决了什么问题？" class="headerlink" title="2. 一致性哈希（Consistent Hashing）解决了什么问题？"></a>2. 一致性哈希（Consistent Hashing）解决了什么问题？</h3><p><strong>答案</strong>：<br>传统哈希算法在服务器增减时会导致大量请求重新映射，引发缓存雪崩。一致性哈希通过环形哈希空间，仅影响相邻节点，<strong>减少重新映射的比例</strong>，适用于分布式缓存和动态扩缩容场景。</p><hr><h2 id="三、云原生与Kubernetes中的负载均衡"><a href="#三、云原生与Kubernetes中的负载均衡" class="headerlink" title="三、云原生与Kubernetes中的负载均衡"></a>三、云原生与Kubernetes中的负载均衡</h2><h3 id="1-Kubernetes-Service的负载均衡机制"><a href="#1-Kubernetes-Service的负载均衡机制" class="headerlink" title="1. Kubernetes Service的负载均衡机制"></a>1. Kubernetes Service的负载均衡机制</h3><p><strong>核心组件</strong>：</p><ul><li><strong>kube-proxy</strong>：维护节点上的iptables&#x2F;IPVS规则，实现ClusterIP的负载均衡。</li><li><strong>Ingress Controller</strong>：七层负载均衡器（如Nginx Ingress），支持基于Host&#x2F;Path的路由。<br><strong>流量路径</strong>：<br>用户请求 → Ingress (L7) → Service (L4) → Pod</li></ul><h3 id="2-Service-Mesh中的负载均衡（以Istio为例）"><a href="#2-Service-Mesh中的负载均衡（以Istio为例）" class="headerlink" title="2. Service Mesh中的负载均衡（以Istio为例）"></a>2. Service Mesh中的负载均衡（以Istio为例）</h3><p><strong>架构革新</strong>：</p><ul><li><strong>Sidecar模式</strong>：每个Pod部署Envoy代理，实现细粒度流量控制。</li><li><strong>高级策略</strong>：<ul><li>金丝雀发布：按百分比分配流量到新版本。</li><li>熔断与重试：基于响应状态的自动故障隔离。<br><strong>配置示例（Istio VirtualService）</strong>：</li></ul></li></ul><p>yaml</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: networking.istio.io/v1alpha3</span><br><span class="line">kind: VirtualService</span><br><span class="line">metadata:</span><br><span class="line">  name: reviews</span><br><span class="line">spec:</span><br><span class="line">  hosts:</span><br><span class="line">  - reviews</span><br><span class="line">  http:</span><br><span class="line">  - route:</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v1</span><br><span class="line">      weight: 90</span><br><span class="line">    - destination:</span><br><span class="line">        host: reviews</span><br><span class="line">        subset: v2</span><br><span class="line">      weight: 10</span><br></pre></td></tr></table></figure><hr><h2 id="四、实践与工具"><a href="#四、实践与工具" class="headerlink" title="四、实践与工具"></a>四、实践与工具</h2><h3 id="1-如何用Nginx实现简单的负载均衡？"><a href="#1-如何用Nginx实现简单的负载均衡？" class="headerlink" title="1. 如何用Nginx实现简单的负载均衡？"></a>1. 如何用Nginx实现简单的负载均衡？</h3><p><strong>示例配置</strong>：  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> backend &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.101:8080</span> weight=<span class="number">3</span>;  <span class="comment"># 加权轮询</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.102:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.1.103:8080</span> backup;    <span class="comment"># 备用服务器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-什么是健康检查（Health-Check）？"><a href="#2-什么是健康检查（Health-Check）？" class="headerlink" title="2. 什么是健康检查（Health Check）？"></a>2. 什么是健康检查（Health Check）？</h3><p><strong>答案</strong>：<br>负载均衡器定期检测后端服务器的状态（如HTTP 200响应），自动剔除故障节点。分为：</p><ul><li><strong>主动检查</strong>：定时发送探测请求（如每10秒一次）。</li><li><strong>被动检查</strong>：根据请求失败率判断（如连续3次超时标记为不可用）。</li></ul><hr><h2 id="四、高频面试问题"><a href="#四、高频面试问题" class="headerlink" title="四、高频面试问题"></a>四、高频面试问题</h2><h3 id="1-如何实现会话保持（Session-Persistence）？"><a href="#1-如何实现会话保持（Session-Persistence）？" class="headerlink" title="1. 如何实现会话保持（Session Persistence）？"></a>1. 如何实现会话保持（Session Persistence）？</h3><p><strong>答案</strong>：  </p><ul><li><strong>Cookie插入</strong>：负载均衡器注入Cookie记录服务器信息（如AWS ALB的<code>AWSALB</code>）。  </li><li><strong>Redis集中存储</strong>：将Session数据存储在外部缓存，解耦服务器。  </li><li><strong>IP哈希</strong>：同一IP的请求固定到同一服务器（可能导致负载不均）。</li></ul><h3 id="2-负载均衡器本身如何避免成为单点故障？"><a href="#2-负载均衡器本身如何避免成为单点故障？" class="headerlink" title="2. 负载均衡器本身如何避免成为单点故障？"></a>2. 负载均衡器本身如何避免成为单点故障？</h3><p><strong>答案</strong>：  </p><ul><li><strong>集群化部署</strong>：使用主备（Active-Standby）或双活模式（Active-Active）。  </li><li><strong>DNS轮询</strong>：通过DNS将域名解析到多个负载均衡器IP。  </li><li><strong>云服务多可用区</strong>：在AWS、阿里云等平台跨可用区部署。</li></ul><h3 id="3-什么是SSL终结（SSL-Termination）？"><a href="#3-什么是SSL终结（SSL-Termination）？" class="headerlink" title="3. 什么是SSL终结（SSL Termination）？"></a>3. 什么是SSL终结（SSL Termination）？</h3><p><strong>答案</strong>：<br>负载均衡器负责解密HTTPS请求，将明文HTTP请求转发给后端服务器。<strong>优点</strong>是减少后端服务器的计算压力，但需确保内网传输安全（如使用VPC隔离）。</p><hr><h2 id="五、进阶场景"><a href="#五、进阶场景" class="headerlink" title="五、进阶场景"></a>五、进阶场景</h2><h3 id="1-如何处理突发流量？"><a href="#1-如何处理突发流量？" class="headerlink" title="1. 如何处理突发流量？"></a>1. 如何处理突发流量？</h3><p><strong>策略</strong>：  </p><ul><li><strong>自动扩缩容（Auto Scaling）</strong>：根据CPU&#x2F;连接数动态增减服务器。  </li><li><strong>限流与降级</strong>：通过令牌桶或漏桶算法限制请求速率。  </li><li><strong>队列缓冲</strong>：使用消息队列（如Kafka）异步处理请求。</li></ul><h3 id="2-如何实现跨地域负载均衡？"><a href="#2-如何实现跨地域负载均衡？" class="headerlink" title="2. 如何实现跨地域负载均衡？"></a>2. 如何实现跨地域负载均衡？</h3><p><strong>方案</strong>：  </p><ul><li><strong>DNS全局负载均衡（GSLB）</strong>：根据用户地理位置返回最近的IP。  </li><li><strong>Anycast网络</strong>：同一IP在多个地域广播，路由选择最短路径（如Cloudflare）。</li></ul><hr><h2 id="六、面试实战问题"><a href="#六、面试实战问题" class="headerlink" title="六、面试实战问题"></a>六、面试实战问题</h2><ul><li><strong>问题</strong>：某电商大促时，部分服务器CPU飙升，负载均衡如何应对？  </li><li><strong>回答</strong>：结合健康检查快速剔除故障节点，启用自动扩缩容添加新实例，同时配合限流（如Nginx的<code>limit_req</code>）保护后端服务。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>负载均衡不仅要求掌握算法和工具，还需理解其在高可用、扩展性、安全性中的角色。面试中需结合具体场景（如微服务、云原生）展现技术深度。建议动手实践Nginx&#x2F;HAProxy配置，并阅读云厂商（如AWS、阿里云）的负载均衡文档以补充实战经验。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HaProxy 配置详解</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy-配置详解与综合示例"><a href="#HAProxy-配置详解与综合示例" class="headerlink" title="HAProxy 配置详解与综合示例"></a>HAProxy 配置详解与综合示例</h1><h2 id="一、配置文件结构解析"><a href="#一、配置文件结构解析" class="headerlink" title="一、配置文件结构解析"></a>一、配置文件结构解析</h2><p>HAProxy配置文件由5个主要部分组成，优先级从高到低：</p><ol><li><strong>global</strong>：全局系统参数</li><li><strong>defaults</strong>：默认参数模板</li><li><strong>frontend</strong>：客户端连接入口</li><li><strong>backend</strong>：服务端集群配置</li><li><strong>listen</strong>：frontend+backend组合声明</li></ol><h2 id="二、核心配置指令详解"><a href="#二、核心配置指令详解" class="headerlink" title="二、核心配置指令详解"></a>二、核心配置指令详解</h2><h3 id="2-1-全局配置（Global）"><a href="#2-1-全局配置（Global）" class="headerlink" title="2.1 全局配置（Global）"></a>2.1 全局配置（Global）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log 127.0.0.1 local0 info    # 日志服务器配置</span><br><span class="line">    maxconn 100000               # 最大并发连接数</span><br><span class="line">    user haproxy                 # 运行用户</span><br><span class="line">    group haproxy                # 运行组</span><br><span class="line">    nbthread 4                   # 工作线程数（建议等于CPU核心）</span><br><span class="line">    stats socket /var/run/haproxy.sock mode 660 level admin # 管理接口</span><br><span class="line">    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256 # SSL加密套件</span><br><span class="line">    tune.ssl.default-dh-param 2048      # DH参数长度</span><br></pre></td></tr></table></figure><h3 id="2-2-默认配置（Defaults）"><a href="#2-2-默认配置（Defaults）" class="headerlink" title="2.2 默认配置（Defaults）"></a>2.2 默认配置（Defaults）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defaults</span><br><span class="line">    mode http                    # 默认代理模式（http/tcp）</span><br><span class="line">    timeout connect 5s           # 后端连接超时</span><br><span class="line">    timeout client 30s           # 客户端空闲超时</span><br><span class="line">    timeout server 30s           # 服务端响应超时</span><br><span class="line">    option httplog               # 详细HTTP日志</span><br><span class="line">    option dontlognull           # 忽略空连接日志</span><br><span class="line">    option redispatch            # 故障节点重试</span><br><span class="line">    retries 3                    # 最大重试次数</span><br></pre></td></tr></table></figure><h3 id="2-3-前端配置（Frontend）"><a href="#2-3-前端配置（Frontend）" class="headerlink" title="2.3 前端配置（Frontend）"></a>2.3 前端配置（Frontend）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">frontend web-in</span><br><span class="line">    bind *:80</span><br><span class="line">    bind *:443 ssl crt /etc/ssl/certs/example.com.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line">    # 访问控制列表</span><br><span class="line">    acl is_static path_end -i .jpg .css .js</span><br><span class="line">    acl is_api path_beg /api/</span><br><span class="line">    acl is_admin path_beg /admin</span><br><span class="line">    </span><br><span class="line">    # 流量分割</span><br><span class="line">    use_backend static_servers if is_static</span><br><span class="line">    use_backend api_cluster if is_api</span><br><span class="line">    use_backend admin_servers if is_admin</span><br><span class="line">    default_backend web_servers</span><br><span class="line">    </span><br><span class="line">    # 安全防护</span><br><span class="line">    http-request deny if &#123; src_get_gpc0(web-in) gt 10 &#125; # 请求频率限制</span><br><span class="line">    stick-table type ip size 1m expire 10m store gpc0   # 会话追踪表</span><br></pre></td></tr></table></figure><h3 id="2-4-后端配置（Backend）"><a href="#2-4-后端配置（Backend）" class="headerlink" title="2.4 后端配置（Backend）"></a>2.4 后端配置（Backend）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">backend web_servers</span><br><span class="line">    balance leastconn            # 最少连接算法</span><br><span class="line">    cookie SERVERID insert indirect nocache # 会话保持</span><br><span class="line">    </span><br><span class="line">    server web1 192.168.1.101:80 check maxconn 500 cookie s1</span><br><span class="line">    server web2 192.168.1.102:80 check maxconn 500 cookie s2</span><br><span class="line">    server backup 192.168.1.103:80 check backup</span><br><span class="line">    </span><br><span class="line">    # 健康检查配置</span><br><span class="line">    option httpchk GET /health</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    default-server inter 5s fall 3 rise 2</span><br></pre></td></tr></table></figure><h3 id="2-5-监控界面（Stats）"><a href="#2-5-监控界面（Stats）" class="headerlink" title="2.5 监控界面（Stats）"></a>2.5 监控界面（Stats）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">listen stats</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /haproxy?stats</span><br><span class="line">    stats realm &quot;HAProxy Stats&quot;</span><br><span class="line">    stats auth admin:SecureP@ssw0rd</span><br><span class="line">    stats refresh 10s</span><br><span class="line">    stats show-legends</span><br></pre></td></tr></table></figure><h2 id="三、综合配置示例"><a href="#三、综合配置示例" class="headerlink" title="三、综合配置示例"></a>三、综合配置示例</h2><h3 id="业务场景描述"><a href="#业务场景描述" class="headerlink" title="业务场景描述"></a>业务场景描述</h3><p>某电商平台需要部署HAProxy实现以下需求：</p><ol><li>同时支持HTTP和HTTPS访问</li><li>分离静态资源与动态请求</li><li>提供管理后台访问控制</li><li>实现灰度发布功能</li><li>监控与自动故障转移</li><li>防御CC攻击</li></ol><h3 id="完整配置文件"><a href="#完整配置文件" class="headerlink" title="完整配置文件"></a>完整配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    log /dev/log local0 info</span><br><span class="line">    maxconn 50000</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    nbthread 8</span><br><span class="line">    tune.ssl.default-dh-param 2048</span><br><span class="line">    stats socket /var/run/haproxy.sock mode 660 level admin</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode http</span><br><span class="line">    timeout connect 5s</span><br><span class="line">    timeout client 30s</span><br><span class="line">    timeout server 30s</span><br><span class="line">    option forwardfor</span><br><span class="line">    option httplog</span><br><span class="line">    option dontlognull</span><br><span class="line">    retries 3</span><br><span class="line"></span><br><span class="line">frontend main</span><br><span class="line">    bind *:80</span><br><span class="line">    bind *:443 ssl crt /etc/ssl/certs/ecommerce.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line">    # 访问控制规则</span><br><span class="line">    acl is_static path_end -i .jpg .css .js .png</span><br><span class="line">    acl is_api path_beg /api/</span><br><span class="line">    acl is_admin path_beg /admin</span><br><span class="line">    acl new_feature path_beg /v2</span><br><span class="line">    acl abusive_conn src_conn_rate gt 50</span><br><span class="line">    </span><br><span class="line">    # 安全策略</span><br><span class="line">    tcp-request connection reject if abusive_conn</span><br><span class="line">    http-request deny if &#123; path -m sub ..; url_dec -m len 1024 &#125;</span><br><span class="line">    </span><br><span class="line">    # 流量路由</span><br><span class="line">    use_backend static_servers if is_static</span><br><span class="line">    use_backend api_servers if is_api</span><br><span class="line">    use_backend admin_servers if is_admin</span><br><span class="line">    use_backend canary_servers if new_feature</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">backend web_servers</span><br><span class="line">    balance roundrobin</span><br><span class="line">    cookie SERVERID insert indirect</span><br><span class="line">    server web01 10.0.1.11:80 check cookie s1</span><br><span class="line">    server web02 10.0.1.12:80 check cookie s2</span><br><span class="line">    server web03 10.0.1.13:80 check cookie s3</span><br><span class="line"></span><br><span class="line">backend static_servers</span><br><span class="line">    balance source</span><br><span class="line">    server static01 10.0.2.21:80 check</span><br><span class="line">    server static02 10.0.2.22:80 check</span><br><span class="line"></span><br><span class="line">backend api_servers</span><br><span class="line">    balance leastconn</span><br><span class="line">    option httpclose</span><br><span class="line">    server api01 10.0.3.31:8080 check maxconn 1000</span><br><span class="line">    server api02 10.0.3.32:8080 check maxconn 1000</span><br><span class="line"></span><br><span class="line">backend admin_servers</span><br><span class="line">    acl valid_ip src 10.0.0.0/24</span><br><span class="line">    http-request deny unless valid_ip</span><br><span class="line">    server admin01 10.0.4.41:8080 check</span><br><span class="line"></span><br><span class="line">backend canary_servers</span><br><span class="line">    server canary01 10.0.5.51:80 check weight 10</span><br><span class="line">    server canary02 10.0.5.52:80 check weight 90</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /stats</span><br><span class="line">    stats auth admin:$&#123;STATS_PASSWORD&#125;</span><br><span class="line">    stats refresh 10s</span><br><span class="line">    stats admin if TRUE</span><br></pre></td></tr></table></figure><h3 id="配置解析与业务对应"><a href="#配置解析与业务对应" class="headerlink" title="配置解析与业务对应"></a>配置解析与业务对应</h3><ol><li><p><strong>SSL&#x2F;TLS配置</strong>：</p><ul><li>同时支持HTTP&#x2F;2和HTTP&#x2F;1.1</li><li>使用2048位DH参数增强安全性</li></ul></li><li><p><strong>流量分类</strong>：</p><ul><li>静态资源路由到专用服务器（CDN架构）</li><li>API请求采用最少连接算法</li><li>管理后台限制IP访问</li></ul></li><li><p><strong>灰度发布</strong>：</p><ul><li>通过路径&#x2F;v2访问新版服务</li><li>Canary服务器权重控制流量比例</li></ul></li><li><p><strong>安全防护</strong>：</p><ul><li>连接速率限制防御CC攻击</li><li>URL长度和路径检测防注入</li></ul></li><li><p><strong>会话保持</strong>：</p><ul><li>Cookie插入实现状态保持</li><li>源IP哈希保障静态资源缓存命中</li></ul></li><li><p><strong>监控管理</strong>：</p><ul><li>独立统计端口带权限控制</li><li>实时健康检查与自动切换</li></ul></li></ol><h2 id="四、配置验证与调优建议"><a href="#四、配置验证与调优建议" class="headerlink" title="四、配置验证与调优建议"></a>四、配置验证与调优建议</h2><ol><li><p><strong>语法检查</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">haproxy -c -f /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure></li><li><p><strong>性能监控指标</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 <span class="string">&quot;echo &#x27;show info&#x27; | socat stdio /var/run/haproxy.sock&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>调优参数建议</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tune.bufsize 32768        # 增加缓冲区大小</span><br><span class="line">tune.http.cookielen 128   # 优化Cookie长度</span><br><span class="line">tune.http.maxhdr 100      # 扩展头部数量限制</span><br></pre></td></tr></table></figure></li><li><p><strong>动态调整命令示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disable server web_servers/web03&quot;</span> | socat stdio /var/run/haproxy.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看实时统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show stat&quot;</span> | socat stdio /var/run/haproxy.sock | column -t -s,</span><br></pre></td></tr></table></figure></li></ol><h2 id="五、典型问题解决方案"><a href="#五、典型问题解决方案" class="headerlink" title="五、典型问题解决方案"></a>五、典型问题解决方案</h2><ol><li><p><strong>TIME_WAIT过多</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune.idleclose on         # 启用延迟关闭</span><br><span class="line">option forceclose         # 强制关闭连接</span><br></pre></td></tr></table></figure></li><li><p><strong>内存持续增长</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tune.maxrewrite 2048      # 限制缓冲区重写空间</span><br><span class="line">no option http-use-htx    # 禁用实验性HTTP引擎</span><br></pre></td></tr></table></figure></li><li><p><strong>SSL性能瓶颈</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssl-engine openssl        # 启用硬件加速</span><br><span class="line">ssl-default-bind-options prefer-client-ciphers</span><br></pre></td></tr></table></figure></li></ol><p>通过以上配置示例和解析，可以快速构建适应高并发、高可用场景的负载均衡方案。实际部署时应根据具体业务需求调整参数，并通过持续监控优化系统表现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HaProxy 概述</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/HaProxy%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="HAProxy深度指南：从配置实战到架构选型"><a href="#HAProxy深度指南：从配置实战到架构选型" class="headerlink" title="HAProxy深度指南：从配置实战到架构选型"></a>HAProxy深度指南：从配置实战到架构选型</h1><h2 id="一、核心概念解析"><a href="#一、核心概念解析" class="headerlink" title="一、核心概念解析"></a>一、核心概念解析</h2><h3 id="1-1-四层-vs-七层代理"><a href="#1-1-四层-vs-七层代理" class="headerlink" title="1.1 四层 vs 七层代理"></a>1.1 四层 vs 七层代理</h3><p>HAProxy同时支持L4(TCP)和L7(HTTP)代理，架构差异如下：</p><table><thead><tr><th>特性</th><th>L4代理</th><th>L7代理</th></tr></thead><tbody><tr><td>协议感知</td><td>无</td><td>有（HTTP解析）</td></tr><tr><td>会话保持</td><td>基于源IP</td><td>基于Cookie&#x2F;Header</td></tr><tr><td>健康检查</td><td>TCP端口检测</td><td>HTTP状态码验证</td></tr><tr><td>典型场景</td><td>数据库负载均衡</td><td>Web应用路由</td></tr></tbody></table><h3 id="1-2-核心组件"><a href="#1-2-核心组件" class="headerlink" title="1.2 核心组件"></a>1.2 核心组件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">frontend web-in           # 流量入口</span><br><span class="line">    bind *:80</span><br><span class="line">    acl is_api path_beg /api</span><br><span class="line">    use_backend api_cluster if is_api</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">backend web_servers       # 服务集群</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server web1 10.0.1.1:80 check</span><br><span class="line">    server web2 10.0.1.2:80 check</span><br><span class="line"></span><br><span class="line">listen stats              # 监控界面</span><br><span class="line">    bind *:1936</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /haproxy?stats</span><br></pre></td></tr></table></figure><h2 id="二、配置引擎深度剖析"><a href="#二、配置引擎深度剖析" class="headerlink" title="二、配置引擎深度剖析"></a>二、配置引擎深度剖析</h2><h3 id="2-1-智能ACL系统"><a href="#2-1-智能ACL系统" class="headerlink" title="2.1 智能ACL系统"></a>2.1 智能ACL系统</h3><p>HAProxy的ACL（Access Control List）支持复杂条件组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acl valid_src src 192.168.0.0/24   # 源IP匹配</span><br><span class="line">acl is_post method POST             # HTTP方法</span><br><span class="line">acl json_content hdr_val(Content-Type) -i application/json</span><br><span class="line">acl high_load conn_rate gt 200      # 连接速率</span><br><span class="line"></span><br><span class="line"># 组合条件</span><br><span class="line">use_backend premium if valid_src is_post json_content !high_load</span><br></pre></td></tr></table></figure><h3 id="2-2-负载均衡算法"><a href="#2-2-负载均衡算法" class="headerlink" title="2.2 负载均衡算法"></a>2.2 负载均衡算法</h3><p>HAProxy支持10+种算法，常用算法对比：</p><table><thead><tr><th>算法</th><th>适用场景</th><th>实现复杂度</th><th>会话保持</th></tr></thead><tbody><tr><td>roundrobin</td><td>通用场景</td><td>O(1)</td><td>无</td></tr><tr><td>leastconn</td><td>长连接服务</td><td>O(n)</td><td>无</td></tr><tr><td>source</td><td>IP哈希</td><td>O(1)</td><td>强</td></tr><tr><td>uri</td><td>静态资源缓存</td><td>O(1)</td><td>强</td></tr><tr><td>hdr</td><td>定制头部路由</td><td>O(1)</td><td>强</td></tr></tbody></table><p>动态权重调整示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server web1 10.0.1.1:80 weight 100 check</span><br><span class="line">server web2 10.0.1.2:80 weight 50 check</span><br></pre></td></tr></table></figure><h2 id="三、高性能实现原理"><a href="#三、高性能实现原理" class="headerlink" title="三、高性能实现原理"></a>三、高性能实现原理</h2><h3 id="3-1-事件驱动架构"><a href="#3-1-事件驱动架构" class="headerlink" title="3.1 事件驱动架构"></a>3.1 事件驱动架构</h3><p>HAProxy采用单进程事件驱动模型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_poll_loop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取活跃事件</span></span><br><span class="line">        <span class="type">int</span> n = poll(events, MAX_EVENTS, timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理I/O事件</span></span><br><span class="line">            <span class="keyword">if</span> (events[i].revents &amp; POLLIN)</span><br><span class="line">                process_read_event(events[i].fd);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (events[i].revents &amp; POLLOUT)</span><br><span class="line">                process_write_event(events[i].fd);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理定时任务</span></span><br><span class="line">        process_expired_tasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-零拷贝优化"><a href="#3-2-零拷贝优化" class="headerlink" title="3.2 零拷贝优化"></a>3.2 零拷贝优化</h3><p>HAProxy通过<code>sendfile()</code>系统调用实现零拷贝数据传输：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">send_data</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> buffer *buf)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (buf-&gt;file) &#123;</span><br><span class="line">        sendfile(fd, buf-&gt;file_fd, &amp;buf-&gt;file_offset, buf-&gt;file_len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(fd, buf-&gt;data, buf-&gt;len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、企业级功能特性"><a href="#四、企业级功能特性" class="headerlink" title="四、企业级功能特性"></a>四、企业级功能特性</h2><h3 id="4-1-健康检查机制"><a href="#4-1-健康检查机制" class="headerlink" title="4.1 健康检查机制"></a>4.1 健康检查机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">backend db_cluster</span><br><span class="line">    option httpchk GET /health</span><br><span class="line">    http-check expect status 200</span><br><span class="line">    server db1 10.0.2.1:3306 check inter 5s rise 2 fall 3</span><br><span class="line">    server db2 10.0.2.2:3306 check backup</span><br></pre></td></tr></table></figure><p>健康检查类型对比：</p><table><thead><tr><th>检查类型</th><th>协议层</th><th>开销</th><th>检测精度</th></tr></thead><tbody><tr><td>TCP Connect</td><td>L4</td><td>低</td><td>中</td></tr><tr><td>HTTP Expect</td><td>L7</td><td>中</td><td>高</td></tr><tr><td>SSL Hello</td><td>L4</td><td>低</td><td>低</td></tr><tr><td>MySQL Ping</td><td>L7</td><td>高</td><td>极高</td></tr></tbody></table><h3 id="4-2-动态配置"><a href="#4-2-动态配置" class="headerlink" title="4.2 动态配置"></a>4.2 动态配置</h3><p>通过Runtime API实现热更新：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁用节点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;disable server web_servers/web1&quot;</span> | socat stdio /var/run/haproxy.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 流量统计</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show stat&quot;</span> | socat stdio /var/run/haproxy.sock | column -t -s,</span><br></pre></td></tr></table></figure><h2 id="五、横向技术对比"><a href="#五、横向技术对比" class="headerlink" title="五、横向技术对比"></a>五、横向技术对比</h2><h3 id="5-1-负载均衡器选型矩阵"><a href="#5-1-负载均衡器选型矩阵" class="headerlink" title="5.1 负载均衡器选型矩阵"></a>5.1 负载均衡器选型矩阵</h3><table><thead><tr><th>特性</th><th>HAProxy</th><th>Nginx</th><th>LVS</th><th>Traefik</th></tr></thead><tbody><tr><td>协议支持</td><td>L4&#x2F;L7</td><td>L4&#x2F;L7</td><td>L4</td><td>L4&#x2F;L7</td></tr><tr><td>最大并发连接</td><td>100万+</td><td>50万+</td><td>100万+</td><td>10万+</td></tr><tr><td>配置复杂度</td><td>中</td><td>低</td><td>高</td><td>低</td></tr><tr><td>动态配置</td><td>API支持</td><td>需Reload</td><td>不支持</td><td>自动发现</td></tr><tr><td>服务发现集成</td><td>有限</td><td>有限</td><td>无</td><td>原生支持</td></tr><tr><td>SSL Offloading</td><td>支持</td><td>支持</td><td>不支持</td><td>支持</td></tr><tr><td>典型延迟</td><td>0.2ms</td><td>0.5ms</td><td>0.1ms</td><td>1.2ms</td></tr></tbody></table><h3 id="5-2-性能基准测试"><a href="#5-2-性能基准测试" class="headerlink" title="5.2 性能基准测试"></a>5.2 性能基准测试</h3><p>测试环境：4核CPU&#x2F;8GB RAM，1000并发连接</p><table><thead><tr><th>工具</th><th>请求速率 (req&#x2F;s)</th><th>内存占用</th><th>长连接支持</th></tr></thead><tbody><tr><td>HAProxy 2.8</td><td>98,000</td><td>120MB</td><td>优秀</td></tr><tr><td>Nginx 1.25</td><td>75,000</td><td>220MB</td><td>良好</td></tr><tr><td>Envoy 1.28</td><td>82,000</td><td>350MB</td><td>优秀</td></tr><tr><td>Traefik 2.10</td><td>45,000</td><td>280MB</td><td>一般</td></tr></tbody></table><h2 id="六、安全加固实践"><a href="#六、安全加固实践" class="headerlink" title="六、安全加固实践"></a>六、安全加固实践</h2><h3 id="6-1-DDoS防护配置"><a href="#6-1-DDoS防护配置" class="headerlink" title="6.1 DDoS防护配置"></a>6.1 DDoS防护配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">frontend http-in</span><br><span class="line">    # 连接速率限制</span><br><span class="line">    stick-table type ip size 1m expire 10s store conn_rate(3s)</span><br><span class="line">    tcp-request connection track-sc0 src</span><br><span class="line">    tcp-request connection reject if &#123; sc0_conn_rate gt 50 &#125;</span><br><span class="line">    </span><br><span class="line">    # 请求频率限制</span><br><span class="line">    acl abuse_requests req.rate ge 100</span><br><span class="line">    http-request deny if abuse_requests</span><br></pre></td></tr></table></figure><h3 id="6-2-SSL最佳实践"><a href="#6-2-SSL最佳实践" class="headerlink" title="6.2 SSL最佳实践"></a>6.2 SSL最佳实践</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind *:443 ssl crt /etc/ssl/certs/example.com.pem alpn h2,http/1.1</span><br><span class="line">    </span><br><span class="line"># 启用TLS 1.3</span><br><span class="line">ssl-default-server-options no-sslv3 no-tlsv10 no-tlsv11 no-tlsv12</span><br><span class="line">ssl-server-options prefer-client-ciphers</span><br><span class="line">ssl-server-options no-tls-tickets</span><br></pre></td></tr></table></figure><h2 id="七、云原生集成"><a href="#七、云原生集成" class="headerlink" title="七、云原生集成"></a>七、云原生集成</h2><h3 id="7-1-Kubernetes-Ingress配置"><a href="#7-1-Kubernetes-Ingress配置" class="headerlink" title="7.1 Kubernetes Ingress配置"></a>7.1 Kubernetes Ingress配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">haproxy.org/ssl-redirect:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">    <span class="attr">haproxy.org/backend-config-snippet:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      balance leastconn</span></span><br><span class="line"><span class="string">      timeout server 30s</span></span><br><span class="line"><span class="string"></span><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ingressClassName:</span> <span class="string">haproxy</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">app.example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">web-service</span></span><br><span class="line">            <span class="attr">port:</span> </span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h3 id="7-2-Prometheus监控集成"><a href="#7-2-Prometheus监控集成" class="headerlink" title="7.2 Prometheus监控集成"></a>7.2 Prometheus监控集成</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listen stats</span><br><span class="line">    bind *:9101</span><br><span class="line">    stats enable</span><br><span class="line">    stats uri /metrics</span><br><span class="line">    stats show-legends</span><br><span class="line">    stats prometheus</span><br></pre></td></tr></table></figure><h2 id="八、调试与优化"><a href="#八、调试与优化" class="headerlink" title="八、调试与优化"></a>八、调试与优化</h2><h3 id="8-1-实时调试技巧"><a href="#8-1-实时调试技巧" class="headerlink" title="8.1 实时调试技巧"></a>8.1 实时调试技巧</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 抓取流量日志</span></span><br><span class="line">tcpdump -i eth0 -s 0 -w haproxy.pcap port 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动态日志级别调整</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;show info&quot;</span> | socat stdio /var/run/haproxy.sock | grep Debug</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;debug 2&quot;</span> | socat stdio /var/run/haproxy.sock</span><br></pre></td></tr></table></figure><h3 id="8-2-内核参数调优"><a href="#8-2-内核参数调优" class="headerlink" title="8.2 内核参数调优"></a>8.2 内核参数调优</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提升端口复用</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse=1</span><br><span class="line">sysctl -w net.ipv4.tcp_max_tw_buckets=2000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加文件描述符限制</span></span><br><span class="line">sysctl -w fs.file-max=1000000</span><br><span class="line"><span class="built_in">ulimit</span> -n 1000000</span><br></pre></td></tr></table></figure><h2 id="九、架构演进趋势"><a href="#九、架构演进趋势" class="headerlink" title="九、架构演进趋势"></a>九、架构演进趋势</h2><h3 id="9-1-eBPF加速"><a href="#9-1-eBPF加速" class="headerlink" title="9.1 eBPF加速"></a>9.1 eBPF加速</h3><p>HAProxy 2.8+支持eBPF实现高性能路由：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">    BPF_LDX_MEM(BPF_W, BPF_REG_6, BPF_REG_1, offsetof(<span class="keyword">struct</span> __sk_buff, data)),</span><br><span class="line">    BPF_LDX_MEM(BPF_W, BPF_REG_7, BPF_REG_1, offsetof(<span class="keyword">struct</span> __sk_buff, data_end)),</span><br><span class="line">    <span class="comment">// 包解析逻辑</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="9-2-QUIC-HTTP3支持"><a href="#9-2-QUIC-HTTP3支持" class="headerlink" title="9.2 QUIC&#x2F;HTTP3支持"></a>9.2 QUIC&#x2F;HTTP3支持</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">frontend quic-in</span><br><span class="line">    bind :443 quic4</span><br><span class="line">    default_backend web_servers</span><br><span class="line"></span><br><span class="line">    # 启用HTTP/3</span><br><span class="line">    quic-force-retry on</span><br><span class="line">    quic-socket-owner listener</span><br></pre></td></tr></table></figure><h2 id="结语：负载均衡器的技术演进"><a href="#结语：负载均衡器的技术演进" class="headerlink" title="结语：负载均衡器的技术演进"></a>结语：负载均衡器的技术演进</h2><p>HAProxy凭借其卓越的性能、灵活的配置能力和企业级功能特性，在云原生时代持续保持技术竞争力。通过深入理解其架构原理和最佳实践，开发者可以构建出既具备高可用性，又能应对复杂业务场景的现代负载均衡体系。随着eBPF、QUIC等新技术的不断集成，HAProxy正在向更智能、更高效的下一代代理架构演进。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S 服务注册、发现 与 负载均衡 原理解析</title>
      <link href="/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/K8S%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E6%9E%90/"/>
      <url>/2024/09/07/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/K8S%20%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E4%B8%8E%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="K8S-服务注册、发现-与-负载均衡-原理解析"><a href="#K8S-服务注册、发现-与-负载均衡-原理解析" class="headerlink" title="K8S 服务注册、发现 与 负载均衡 原理解析"></a>K8S 服务注册、发现 与 负载均衡 原理解析</h1><p>在 Kubernetes（K8S）集群中，服务注册、发现与负载均衡是确保微服务架构高效运行的核心机制。这些机制共同解决了分布式系统中服务实例动态变化、流量分配以及高可用性等问题。本文将系统、专业地解析这些机制的原理，并提供详细的配置示例，帮助读者深入理解 K8S 的工作方式。</p><h2 id="一、服务注册原理"><a href="#一、服务注册原理" class="headerlink" title="一、服务注册原理"></a>一、服务注册原理</h2><h3 id="1-1-服务注册的概念"><a href="#1-1-服务注册的概念" class="headerlink" title="1.1 服务注册的概念"></a>1.1 服务注册的概念</h3><p>服务注册是指将服务实例的相关信息（如 IP 地址、端口号等）记录到一个中心化的注册中心，以便其他服务能够发现并调用这些服务。在 K8S 中，服务注册主要通过 <strong>API Server</strong> 和 <strong>etcd</strong> 来实现。</p><h3 id="1-2-服务注册的流程"><a href="#1-2-服务注册的流程" class="headerlink" title="1.2 服务注册的流程"></a>1.2 服务注册的流程</h3><ul><li><strong>Pod 创建时注册</strong>：当一个新的 Pod 创建时，Kubelet 会将该 Pod 的信息（包括 IP 地址、端口号等）注册到 API Server。</li><li><strong>API Server 存储信息</strong>：API Server 接收到 Pod 信息后，将其存储到 etcd 中。</li><li><strong>Service 关联 Pod</strong>：Service 通过标签选择器（Label Selector）与 Pod 进行关联。当 Service 创建时，API Server 会根据标签选择器找到匹配的 Pod，并将这些 Pod 的信息存储在 Endpoints 资源中。</li></ul><h2 id="二、服务发现原理"><a href="#二、服务发现原理" class="headerlink" title="二、服务发现原理"></a>二、服务发现原理</h2><h3 id="2-1-服务发现的概念"><a href="#2-1-服务发现的概念" class="headerlink" title="2.1 服务发现的概念"></a>2.1 服务发现的概念</h3><p>服务发现是指客户端能够通过某种方式找到服务实例的地址信息，从而实现服务调用。K8S 提供了多种服务发现方式，主要包括 <strong>DNS</strong> 和 <strong>环境变量</strong>。</p><h3 id="2-2-服务发现的实现方式"><a href="#2-2-服务发现的实现方式" class="headerlink" title="2.2 服务发现的实现方式"></a>2.2 服务发现的实现方式</h3><ul><li><strong>DNS 服务发现</strong>：K8S 集群中内置了 DNS 服务（如 CoreDNS），每个 Service 都会被分配一个稳定的虚拟 IP（Cluster IP）。客户端可以通过 DNS 查询 Service 的名称，获取其 Cluster IP，进而访问后端的 Pod。</li><li><strong>环境变量</strong>：当 Pod 启动时，Kubelet 会为每个活跃的 Service 添加一组环境变量，包含服务的 IP 和端口信息。客户端可以通过这些环境变量直接访问服务。</li></ul><h3 id="2-3-Endpoints-的作用"><a href="#2-3-Endpoints-的作用" class="headerlink" title="2.3 Endpoints 的作用"></a>2.3 Endpoints 的作用</h3><p>Endpoints 资源对象存储了 Service 后端 Pod 的地址信息（包括 IP 地址和端口号）。当 Pod 的状态发生变化（如增加、删除或更新）时，Endpoints 会自动更新，确保 Service 能够找到正确的后端 Pod。</p><h2 id="三、负载均衡原理"><a href="#三、负载均衡原理" class="headerlink" title="三、负载均衡原理"></a>三、负载均衡原理</h2><h3 id="3-1-负载均衡的概念"><a href="#3-1-负载均衡的概念" class="headerlink" title="3.1 负载均衡的概念"></a>3.1 负载均衡的概念</h3><p>负载均衡是指将进入系统的请求分配到多个服务实例上，以实现资源的合理利用和服务的持续可用。K8S 的负载均衡机制可以确保流量均匀分配到后端的 Pod，提高系统的可用性和性能。</p><h3 id="3-2-负载均衡的实现方式"><a href="#3-2-负载均衡的实现方式" class="headerlink" title="3.2 负载均衡的实现方式"></a>3.2 负载均衡的实现方式</h3><ul><li><strong>Service 类型</strong>：K8S 提供了多种 Service 类型，包括 ClusterIP、NodePort、LoadBalancer 和 ExternalName。其中，ClusterIP 是默认类型，它会为 Service 分配一个仅在集群内部可访问的虚拟 IP。</li><li><strong>kube-proxy 的作用</strong>：kube-proxy 是 K8S 的网络代理组件，运行在每个节点上。它通过监听 API Server 的 Service 和 Endpoints 资源的变化，动态更新节点上的 iptables 或 IPVS 规则，从而实现负载均衡。</li><li><strong>负载均衡策略</strong>：K8S 支持多种负载均衡策略，包括轮询（Round Robin）、最少连接（Least Connections）和 IP 哈希（IP Hash）。这些策略可以根据实际需求进行配置。</li></ul><h3 id="3-3-负载均衡的工作机制"><a href="#3-3-负载均衡的工作机制" class="headerlink" title="3.3 负载均衡的工作机制"></a>3.3 负载均衡的工作机制</h3><p>当客户端请求到达 Service 的 Cluster IP 时，kube-proxy 会根据配置的负载均衡策略，将请求转发到相应的 Pod。如果某个 Pod 出现故障，kube-proxy 会自动将流量转移到其他健康的 Pod，确保服务的高可用性。</p><h2 id="四、实际应用中的注意事项"><a href="#四、实际应用中的注意事项" class="headerlink" title="四、实际应用中的注意事项"></a>四、实际应用中的注意事项</h2><h3 id="4-1-选择合适的-Service-类型"><a href="#4-1-选择合适的-Service-类型" class="headerlink" title="4.1 选择合适的 Service 类型"></a>4.1 选择合适的 Service 类型</h3><ul><li><strong>ClusterIP</strong>：适用于集群内部的服务访问，提供稳定的内部访问接口。</li><li><strong>NodePort</strong>：允许从集群外部通过节点的 IP 地址和指定端口访问服务，适用于简单的外部访问。</li><li><strong>LoadBalancer</strong>：通常与云服务提供商的负载均衡器结合使用，适用于需要高性能和高可用性的外部服务。</li><li><strong>ExternalName</strong>：将 Service 映射到一个外部名称（如域名），适用于需要将外部服务接入到 K8S 集群中的场景。</li></ul><h3 id="4-2-优化-kube-proxy-配置"><a href="#4-2-优化-kube-proxy-配置" class="headerlink" title="4.2 优化 kube-proxy 配置"></a>4.2 优化 kube-proxy 配置</h3><ul><li><p><strong>性能优化</strong>：可以通过调整 kube-proxy 的配置参数（如连接超时时间、最大连接数等）来优化负载均衡的性能。例如，可以通过以下配置文件调整 kube-proxy 的行为：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">&quot;iptables&quot;</span></span><br><span class="line"><span class="attr">iptables:</span></span><br><span class="line">  <span class="attr">masqueradeBit:</span> <span class="number">14</span></span><br><span class="line">  <span class="attr">masqueradeAll:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">syncPeriod:</span> <span class="string">&quot;30s&quot;</span></span><br><span class="line"><span class="attr">conntrack:</span></span><br><span class="line">  <span class="attr">maxPerCore:</span> <span class="number">32768</span></span><br><span class="line">  <span class="attr">min:</span> <span class="number">131072</span></span><br><span class="line">  <span class="attr">tcpEstablishedTimeout:</span> <span class="string">&quot;24h&quot;</span></span><br><span class="line">  <span class="attr">tcpCloseWaitTimeout:</span> <span class="string">&quot;1h&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>健康检查</strong>：启用 Pod 的健康检查（如 Liveness Probes 和 Readiness Probes），确保 kube-proxy 只将流量转发到健康的 Pod。</p></li></ul><h3 id="4-3-使用-Ingress-进行高级路由"><a href="#4-3-使用-Ingress-进行高级路由" class="headerlink" title="4.3 使用 Ingress 进行高级路由"></a>4.3 使用 Ingress 进行高级路由</h3><p>Ingress 是 K8S 中用于管理外部访问的资源，可以提供更复杂的路由规则和负载均衡策略。通过配置 Ingress，可以实现基于域名、路径等的路由转发，进一步优化服务的访问体验。以下是一个简单的 Ingress 配置示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">example-ingress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">example.com</span></span><br><span class="line">    <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/service1</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service1</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/service2</span></span><br><span class="line">        <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">service2</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="五、配置示例"><a href="#五、配置示例" class="headerlink" title="五、配置示例"></a>五、配置示例</h2><h3 id="5-1-创建一个简单的-Service"><a href="#5-1-创建一个简单的-Service" class="headerlink" title="5.1 创建一个简单的 Service"></a>5.1 创建一个简单的 Service</h3><p>以下是一个创建 <code>type: ClusterIP</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br></pre></td></tr></table></figure><h3 id="5-2-创建一个-NodePort-类型的-Service"><a href="#5-2-创建一个-NodePort-类型的-Service" class="headerlink" title="5.2 创建一个 NodePort 类型的 Service"></a>5.2 创建一个 NodePort 类型的 Service</h3><p>以下是一个创建 <code>type: NodePort</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">NodePort</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">nodePort:</span> <span class="number">30007</span></span><br></pre></td></tr></table></figure><h3 id="5-3-创建一个-LoadBalancer-类型的-Service"><a href="#5-3-创建一个-LoadBalancer-类型的-Service" class="headerlink" title="5.3 创建一个 LoadBalancer 类型的 Service"></a>5.3 创建一个 LoadBalancer 类型的 Service</h3><p>以下是一个创建 <code>type: LoadBalancer</code> Service 的 YAML 文件示例：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyApp</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">9376</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">LoadBalancer</span></span><br></pre></td></tr></table></figure><h2 id="六、-完整流程说明"><a href="#六、-完整流程说明" class="headerlink" title="六、 完整流程说明"></a>六、 完整流程说明</h2><p>在 Kubernetes 中，一个被调用方的 Pod 启动后关联到 Service，以及调用方 Pod 如何找到并调用该 Pod 的过程，是一个涉及多个组件协同工作的复杂流程。以下是全面详细的流程解析：</p><h3 id="1、被调用方-Pod-启动并关联到-Service-的"><a href="#1、被调用方-Pod-启动并关联到-Service-的" class="headerlink" title="1、被调用方 Pod 启动并关联到 Service 的"></a>1、被调用方 Pod 启动并关联到 Service 的</h3><h4 id="Pod-创建与启动"><a href="#Pod-创建与启动" class="headerlink" title="Pod 创建与启动"></a><strong>Pod 创建与启动</strong></h4><ul><li><p>用户通过 <code>kubectl</code> 或 Kubernetes API 创建一个 Pod，例如通过部署一个 Deployment：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-app-container</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">my-app-image</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>Kubernetes 调度器（Scheduler）根据资源需求和调度策略将 Pod 分配到某个节点（Node）上，Kubelet 在该节点上启动 Pod。</p></li></ul><h4 id="Service-的创建与定义"><a href="#Service-的创建与定义" class="headerlink" title="Service 的创建与定义"></a><strong>Service 的创建与定义</strong></h4><ul><li><p>用户创建一个 Service 来暴露 Pod 提供的服务，例如创建一个 ClusterIP 类型的 Service：</p><p>yaml复制</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-app-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">my-app</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>Kubernetes 控制平面（API Server）接收到 Service 的定义后，会为该 Service 分配一个内部虚拟 IP（ClusterIP），并将其存储在 etcd 中。</p></li></ul><h4 id="Endpoints-的自动发现与关联"><a href="#Endpoints-的自动发现与关联" class="headerlink" title="Endpoints 的自动发现与关联"></a><strong>Endpoints 的自动发现与关联</strong></h4><ul><li>当 Pod 启动并运行后，Kubernetes 的控制器管理器（Controller Manager）中的 Endpoint Controller 会持续监控 Pod 的状态和 Service 的定义。</li><li>Endpoint Controller 根据 Service 的标签选择器（Label Selector）找到匹配的 Pod，并将这些 Pod 的 IP 地址和端口号信息写入到对应的 Endpoints 资源中。</li><li>例如，如果 Service 的标签选择器是 <code>app: my-app</code>，那么所有带有 <code>app: my-app</code> 标签的 Pod 都会被关联到该 Service 的 Endpoints 中。</li></ul><h4 id="DNS-注册与解析"><a href="#DNS-注册与解析" class="headerlink" title="DNS 注册与解析"></a><strong>DNS 注册与解析</strong></h4><ul><li>Kubernetes 内置的 DNS 服务（如 CoreDNS）会自动将 Service 的名称注册到 DNS 中，使得 Service 可以通过名称进行解析。</li><li>当调用方 Pod 需要访问该 Service 时，它会通过 DNS 查询 Service 的名称，DNS 服务会返回 Service 的 ClusterIP。</li></ul><h3 id="2、调用方-Pod-如何找到并调用被调用方-Pod-的过程"><a href="#2、调用方-Pod-如何找到并调用被调用方-Pod-的过程" class="headerlink" title="2、调用方 Pod 如何找到并调用被调用方 Pod 的过程"></a>2、调用方 Pod 如何找到并调用被调用方 Pod 的过程</h3><ol><li><strong>DNS 查询与解析</strong><ul><li>调用方 Pod 通过 DNS 查询被调用方 Service 的名称，例如 <code>my-app-service</code>。</li><li>DNS 服务将 Service 的名称解析为对应的 ClusterIP，调用方 Pod 获得该 ClusterIP。</li></ul></li><li><strong>kube-proxy 的负载均衡</strong><ul><li>调用方 Pod 将请求发送到 Service 的 ClusterIP，该 ClusterIP 是一个虚拟 IP，由 kube-proxy 管理。</li><li>kube-proxy 运行在每个节点上，它维护着节点上的网络规则，当请求到达 ClusterIP 时，kube-proxy 会根据配置的负载均衡策略（如轮询、最少连接等）将请求转发到后端的某个 Pod。</li><li>kube-proxy 支持多种代理模式，如用户空间（User Space）、iptables 和 IPVS，这些模式在性能和灵活性上各有优劣。</li></ul></li><li><strong>请求转发与 Pod 通信</strong><ul><li>kube-proxy 根据 Endpoints 资源中记录的 Pod 列表，选择一个健康的 Pod，并将请求转发到该 Pod 的 IP 地址和端口号上。</li><li>被调用方 Pod 接收到请求后，处理请求并返回响应，响应数据通过相同的路径返回到调用方 Pod。</li></ul></li><li><strong>健康检查与动态更新</strong><ul><li>如果某个 Pod 出现故障（如容器崩溃或网络问题），Kubernetes 的健康检查机制（如 Liveness Probe 和 Readiness Probe）会检测到该 Pod 不可用。</li><li>Endpoint Controller 会自动将故障 Pod 从 Endpoints 资源中移除，kube-proxy 会更新其内部的转发规则，确保后续请求不会被转发到故障 Pod。</li><li>当新的 Pod 创建并加入 Service 时，Endpoint Controller 会将其添加到 Endpoints 资源中，kube-proxy 会动态更新转发规则，使其能够接收请求。</li></ul></li></ol><p>通过上述流程，Kubernetes 实现了 Pod 的动态注册、发现和负载均衡，确保了服务的高可用性和可扩展性。调用方 Pod 可以通过稳定的 Service 名称或 ClusterIP 访问后端的 Pod，而无需关心 Pod 的具体 IP 地址和数量变化。</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>K8S 的服务注册、发现与负载均衡机制为微服务架构提供了强大的支持。通过合理配置 Service 类型、优化 kube-proxy 参数以及使用 Ingress 进行高级路由，可以实现高效、可靠的服务通信和流量管理。希望本文的解析和配置示例能够帮助读者深入理解这些机制，并在实际项目中更好地应用 K8S 技术。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务治理 </tag>
            
            <tag> 云原生 </tag>
            
            <tag> K8S </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX 进阶</title>
      <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E8%BF%9B%E9%98%B6/"/>
      <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="NGINX-进阶"><a href="#NGINX-进阶" class="headerlink" title="NGINX 进阶"></a>NGINX 进阶</h1><h2 id="一、NGINX架构设计核心"><a href="#一、NGINX架构设计核心" class="headerlink" title="一、NGINX架构设计核心"></a>一、NGINX架构设计核心</h2><h3 id="1-1-多进程模型"><a href="#1-1-多进程模型" class="headerlink" title="1.1 多进程模型"></a>1.1 多进程模型</h3><p>NGINX采用经典的主从多进程架构，包含1个Master进程和N个Worker进程（N通常等于CPU核心数），其中：</p><ul><li><p>Master 进程主要用来管理 Worker 进程，包含：</p><ul><li>接收来自外界的信号，向各 Worker 进程发送信号，</li><li>监控 Worker 进程的运行状态，当 Worker 进程异常退出后，会自动重新启动新的 Worker 进程。</li></ul></li><li><p>Worker 进程则负责处理基本的网络事件。</p><ul><li>多个 Worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。</li><li>一个请求，只可能在一个 Worker 进程中处理，一个 Worker 进程，不可能处理其它进程的请求。</li></ul></li></ul><p>这种设计实现了：</p><ol><li><strong>热部署与零停机更新</strong>：通过<code>execve()</code>系统调用原子替换二进制文件</li><li><strong>异常隔离机制</strong>：Worker进程崩溃不会影响整体服务</li><li><strong>特权分离设计</strong>：Master进程以root身份运行，Worker以降权身份执行</li></ol><p>Nginx 的进程模型，可以由下图来表示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250208010821759.png" alt="image-20250208010821759" style="zoom:67%;" /><h4 id="1-1-1-热升级技术实现"><a href="#1-1-1-热升级技术实现" class="headerlink" title="1.1.1 热升级技术实现"></a>1.1.1 热升级技术实现</h4><p>零宕机升级流程：</p><ol><li>旧Master收到USR2信号，执行execve()加载新二进制</li><li>新旧Worker共存，旧Worker完成现有请求后退出</li><li>新Master通过进程间通信获取旧配置状态</li></ol><p>关键代码路径：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 热升级处理</span></span><br><span class="line">ngx_exec_new_binary(cycle, argv) &#123;</span><br><span class="line">    ngx_write_channel(ngx_processes[s].channel[<span class="number">0</span>],</span><br><span class="line">                      &amp;ch, <span class="keyword">sizeof</span>(<span class="type">ngx_channel_t</span>), cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line">    execve(path, argv, environ);  <span class="comment">// 原子替换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工程挑战</strong>：共享内存的版本兼容性管理。NGINX采用版本标记和回退机制确保平滑过渡。</p><h3 id="1-2-事件驱动架构"><a href="#1-2-事件驱动架构" class="headerlink" title="1.2 事件驱动架构"></a>1.2 事件驱动架构</h3><h4 id="1-2-1-Reactor模式实现"><a href="#1-2-1-Reactor模式实现" class="headerlink" title="1.2.1 Reactor模式实现"></a>1.2.1 Reactor模式实现</h4><p>NGINX采用主从Reactor变体：</p><ul><li>Main Reactor：负责Accept新连接（通过EPOLLEXCLUSIVE避免惊群）</li><li>Sub Reactor：Worker进程独立的事件循环处理I&#x2F;O</li></ul><p>事件处理核心逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_process_events_and_timers</span><span class="params">(<span class="type">ngx_cycle_t</span> *cycle)</span> &#123;</span><br><span class="line">    <span class="comment">// 处理网络事件</span></span><br><span class="line">    (<span class="type">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理定时器事件</span></span><br><span class="line">    <span class="keyword">if</span> (delta) &#123;</span><br><span class="line">        ngx_event_expire_timers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理后延事件</span></span><br><span class="line">    ngx_event_process_posted(cycle, &amp;ngx_posted_events);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-2-Epoll深度优化"><a href="#1-2-2-Epoll深度优化" class="headerlink" title="1.2.2 Epoll深度优化"></a>1.2.2 Epoll深度优化</h4><p>NGINX对epoll的极致优化体现在：</p><ol><li><p><strong>事件触发模式</strong>：</p><ul><li>默认采用边沿触发（EPOLLET），减少事件通知次数</li><li>结合非阻塞I&#x2F;O实现完全异步处理</li></ul></li><li><p><strong>高效内存管理</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预分配事件对象</span></span><br><span class="line">event_list = ngx_alloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> epoll_event) * nevents, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 批量处理事件</span></span><br><span class="line">nevents = epoll_wait(ep, event_list, nevents, timer);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nevents; i++) &#123;</span><br><span class="line">    <span class="comment">// 事件分发逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>时间精度控制</strong>：</p><ul><li>定时器红黑树实现O(log n)复杂度</li><li>时间缓存机制减少系统调用</li></ul></li></ol><p><strong>性能对比</strong>：</p><table><thead><tr><th align="left">连接数</th><th align="left">select</th><th align="left">poll</th><th align="left">epoll</th></tr></thead><tbody><tr><td align="left">1k</td><td align="left">2.1ms</td><td align="left">1.8ms</td><td align="left">0.3ms</td></tr><tr><td align="left">10k</td><td align="left">24ms</td><td align="left">22ms</td><td align="left">0.8ms</td></tr><tr><td align="left">100k</td><td align="left">内存溢出</td><td align="left">超时</td><td align="left">1.2ms</td></tr></tbody></table><h3 id="1-3-模块化设计体系"><a href="#1-3-模块化设计体系" class="headerlink" title="1.3 模块化设计体系"></a>1.3 模块化设计体系</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/v2-a21dc54d422d860eb38cde7898003de8_1440w.jpg" alt="img"></p><p>NGINX采用<strong>层次化模块架构</strong>，各模块通过严格的接口规范进行通信。模块类型可分为：</p><ul><li><strong>核心模块</strong>：ngx_core_module（进程管理）、ngx_events_module（事件驱动）</li><li><strong>协议模块</strong>：ngx_http_module、ngx_stream_module</li><li><strong>功能模块</strong>：ngx_http_proxy_module、ngx_http_rewrite_module</li><li><strong>第三方模块</strong>：OpenResty生态的lua-nginx-module</li></ul><p>模块注册机制示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块定义结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">ngx_str_t</span>             name;</span><br><span class="line">    <span class="type">void</span>               *(*create_conf)(<span class="type">ngx_cycle_t</span> *cycle);</span><br><span class="line">    <span class="type">char</span>               *(*init_conf)(<span class="type">ngx_cycle_t</span> *cycle, <span class="type">void</span> *conf);</span><br><span class="line">&#125; <span class="type">ngx_module_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP模块注册示例</span></span><br><span class="line"><span class="type">ngx_module_t</span> ngx_http_core_module = &#123;</span><br><span class="line">    NGX_MODULE_V1,</span><br><span class="line">    &amp;ngx_http_core_module_ctx,    <span class="comment">/* 模块上下文 */</span></span><br><span class="line">    ngx_http_core_commands,       <span class="comment">/* 模块指令集 */</span></span><br><span class="line">    NGX_HTTP_MODULE,              <span class="comment">/* 模块类型 */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-3-1-模块执行阶段"><a href="#1-3-1-模块执行阶段" class="headerlink" title="1.3.1  模块执行阶段"></a>1.3.1  模块执行阶段</h4><p>HTTP请求处理流程被划分为11个阶段（PHASE），模块通过挂载回调函数参与处理：</p><table><thead><tr><th>阶段顺序</th><th>阶段名称</th><th>典型模块</th></tr></thead><tbody><tr><td>1</td><td>POST_READ</td><td>realip模块</td></tr><tr><td>3</td><td>SERVER_REWRITE</td><td>rewrite模块</td></tr><tr><td>8</td><td>CONTENT</td><td>proxy_pass&#x2F;fastcgi</td></tr><tr><td>10</td><td>LOG</td><td>access_log</td></tr></tbody></table><p>阶段处理伪代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (phase = <span class="number">0</span>; phase &lt; NGX_HTTP_MAX_PHASE; phase++) &#123;</span><br><span class="line">    h = cmcf-&gt;phases[phase].handlers.elts;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cmcf-&gt;phases[phase].handlers.nelts; i++) &#123;</span><br><span class="line">        rc = h[i](r);  <span class="comment">// 执行阶段处理函数</span></span><br><span class="line">        <span class="keyword">if</span> (rc != NGX_OK) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计难点</strong>：模块执行顺序的确定性保障。NGINX通过显式定义模块优先级（NGX_MODULE_V1的index字段）解决依赖问题，确保关键模块（如rewrite）优先执行。</p><h2 id="二、内存管理"><a href="#二、内存管理" class="headerlink" title="二、内存管理"></a>二、内存管理</h2><h3 id="2-1-内存池设计"><a href="#2-1-内存池设计" class="headerlink" title="2.1 内存池设计"></a>2.1 内存池设计</h3><p>NGINX采用分级内存池管理机制：</p><ul><li>请求级内存池：4KB~16MB（根据<code>client_body_buffer_size</code>配置）</li><li>连接级内存池：固定256字节</li><li>全局内存池：使用slab分配器管理共享内存</li></ul><p>内存回收策略示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 共享内存配置示例</span><br><span class="line">proxy_cache_path /data/nginx/cache levels=1:2 keys_zone=my_cache:10m </span><br><span class="line">                 inactive=60m use_temp_path=off max_size=1g;</span><br></pre></td></tr></table></figure><h3 id="2-2-内存对齐与性能优化"><a href="#2-2-内存对齐与性能优化" class="headerlink" title="2.2 内存对齐与性能优化"></a>2.2 内存对齐与性能优化</h3><p>NGINX通过<code>NGX_ALIGNMENT</code>宏实现严格的内存对齐（通常为16字节）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NGX_ALIGNMENT   sizeof(unsigned long)    <span class="comment">/* platform word */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ngx_align(d, a)     (((d) + (a - 1)) &amp; ~(a - 1))</span></span><br></pre></td></tr></table></figure><p>实测数据表明，严格对齐可提升内存访问效率达15%-20%。</p><h2 id="三、负载均衡算法实现内幕"><a href="#三、负载均衡算法实现内幕" class="headerlink" title="三、负载均衡算法实现内幕"></a>三、负载均衡算法实现内幕</h2><h3 id="3-1-一致性哈希的深度优化"><a href="#3-1-一致性哈希的深度优化" class="headerlink" title="3.1 一致性哈希的深度优化"></a>3.1 一致性哈希的深度优化</h3><p>NGINX在<code>ngx_http_upstream_hash_module</code>中实现了改进型一致性哈希：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚拟节点生成算法</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ngx_http_upstream_chash</span><span class="params">(<span class="type">ngx_http_request_t</span> *r)</span> &#123;</span><br><span class="line">    u_char *name = r-&gt;upstream-&gt;hash.key.data;</span><br><span class="line">    <span class="type">uint32_t</span> hash = ngx_crc32_long(name, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚拟节点数=真实节点数*160</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">160</span>; i++) &#123;</span><br><span class="line">        point = hash * <span class="number">2862933555777941757ULL</span> + i;</span><br><span class="line">        <span class="comment">// 红黑树插入逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法通过虚拟节点数动态调整实现了：</p><ul><li>节点扩容时数据迁移量 &lt; 10%</li><li>请求分布标准差 &lt; 5%</li></ul><h3 id="3-2-动态权重调整算法"><a href="#3-2-动态权重调整算法" class="headerlink" title="3.2 动态权重调整算法"></a>3.2 动态权重调整算法</h3><p>在加权轮询（Weighted Round Robin）中，NGINX采用GCD（最大公约数）优化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ngx_int_t</span> </span><br><span class="line"><span class="title function_">ngx_http_upstream_get_peer</span><span class="params">(<span class="type">ngx_peer_connection_t</span> *pc)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        peer = &amp;rrp-&gt;peers-&gt;peer[rrp-&gt;current];</span><br><span class="line">        <span class="comment">// 权重动态计算逻辑</span></span><br><span class="line">        best = current;</span><br><span class="line">        <span class="keyword">if</span> (peer-&gt;effective_weight &gt; best-&gt;effective_weight) &#123;</span><br><span class="line">            best = peer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、缓存系统的工程实践"><a href="#四、缓存系统的工程实践" class="headerlink" title="四、缓存系统的工程实践"></a>四、缓存系统的工程实践</h2><h3 id="4-1-缓存淘汰算法创新"><a href="#4-1-缓存淘汰算法创新" class="headerlink" title="4.1 缓存淘汰算法创新"></a>4.1 缓存淘汰算法创新</h3><p>NGINX采用LRU-K算法改进传统LRU：</p><table><thead><tr><th align="left">算法</th><th align="left">时间复杂度</th><th align="left">缓存命中率</th><th align="left">实现复杂度</th></tr></thead><tbody><tr><td align="left">LRU</td><td align="left">O(1)</td><td align="left">65%</td><td align="left">低</td></tr><tr><td align="left">LFU</td><td align="left">O(1)</td><td align="left">72%</td><td align="left">中</td></tr><tr><td align="left">LRU-2</td><td align="left">O(log n)</td><td align="left">85%</td><td align="left">高</td></tr><tr><td align="left">NGINX改进</td><td align="left">O(1)</td><td align="left">82%</td><td align="left">中</td></tr></tbody></table><h3 id="4-2-缓存锁的优化策略"><a href="#4-2-缓存锁的优化策略" class="headerlink" title="4.2 缓存锁的优化策略"></a>4.2 缓存锁的优化策略</h3><p>NGINX使用自旋锁+互斥锁的混合锁方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ngx_shmtx_lock</span><span class="params">(<span class="type">ngx_shmtx_t</span> *mtx)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ngx_atomic_cmp_set(&amp;mtx-&gt;lock, <span class="number">0</span>, ngx_pid)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (ngx_ncpu &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 自旋等待</span></span><br><span class="line">            <span class="keyword">for</span> (n = <span class="number">1</span>; n &lt; mtx-&gt;spin; n &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                ngx_cpu_pause();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入休眠等待</span></span><br><span class="line">        ngx_sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、性能调优实战指南"><a href="#五、性能调优实战指南" class="headerlink" title="五、性能调优实战指南"></a>五、性能调优实战指南</h2><h3 id="5-1-百万并发连接调优"><a href="#5-1-百万并发连接调优" class="headerlink" title="5.1 百万并发连接调优"></a>5.1 百万并发连接调优</h3><p>关键参数配置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">worker_processes <span class="keyword">auto</span>;</span><br><span class="line">worker_rlimit_nofile <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections <span class="number">50000</span>;</span><br><span class="line">    use epoll;</span><br><span class="line">    multi_accept on;</span><br><span class="line">    epoll_events <span class="number">512</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    sendfile on;</span><br><span class="line">    tcp_nopush on;</span><br><span class="line">    tcp_nodelay on;</span><br><span class="line">    keepalive_requests <span class="number">1000</span>;</span><br><span class="line">    keepalive_timeout <span class="number">65</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-内核参数优化"><a href="#5-2-内核参数优化" class="headerlink" title="5.2 内核参数优化"></a>5.2 内核参数优化</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最大打开文件数</span></span><br><span class="line">sysctl -w fs.file-max=1000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP缓冲区设置</span></span><br><span class="line">sysctl -w net.ipv4.tcp_mem=<span class="string">&#x27;786432 2097152 3145728&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_rmem=<span class="string">&#x27;4096 87380 6291456&#x27;</span></span><br><span class="line">sysctl -w net.ipv4.tcp_wmem=<span class="string">&#x27;4096 16384 4194304&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口复用</span></span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse=1</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle=0</span><br></pre></td></tr></table></figure><h2 id="六、未来演进：从Web-Server到应用网络"><a href="#六、未来演进：从Web-Server到应用网络" class="headerlink" title="六、未来演进：从Web Server到应用网络"></a>六、未来演进：从Web Server到应用网络</h2><p>NGINX正在向云原生服务网格演进，最新版本已支持：</p><ul><li>QUIC&#x2F;HTTP3协议栈</li><li>WASM扩展支持</li><li>动态可编程配置（NJS）</li><li>服务网格数据平面集成</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># WASM配置示例</span><br><span class="line">location /wasm &#123;</span><br><span class="line">    wasm &#123;</span><br><span class="line">        module hello_world /path/to/hello.wasm;</span><br><span class="line">        init_func _start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NGINX 概述</title>
      <link href="/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/09/06/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/NGINX%20%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="NGINX-简介"><a href="#NGINX-简介" class="headerlink" title="NGINX 简介"></a>NGINX 简介</h1><p>Nginx是一款高性能的开源HTTP服务器和反向代理服务器，同时也支持IMAP&#x2F;POP3代理服务器。它以其高性能、稳定性、丰富的功能和低资源消耗而闻名。以下是Nginx的一些基础知识，包括其架构、配置文件、主要模块和常见用途。</p><h3 id="1-Nginx-架构"><a href="#1-Nginx-架构" class="headerlink" title="1. Nginx 架构"></a>1. Nginx 架构</h3><h4 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h4><p>Nginx采用事件驱动的非阻塞I&#x2F;O模型，能够高效地处理大量并发连接。其架构主要包括以下几个部分：</p><ul><li><strong>主进程（Master Process）</strong>：负责管理和维护工作进程，处理日志文件的写入等。</li><li><strong>工作进程（Worker Processes）</strong>：实际处理客户端请求，每个工作进程可以处理多个连接。</li><li><strong>缓存管理</strong>：Nginx可以缓存静态文件和动态内容，提高响应速度。</li></ul><h4 id="1-2-事件驱动模型"><a href="#1-2-事件驱动模型" class="headerlink" title="1.2 事件驱动模型"></a>1.2 事件驱动模型</h4><p>Nginx 使用事件驱动模型来处理请求，这意味着它可以同时处理多个连接，而无需为每个连接创建一个线程或进程。这种模型使得Nginx在处理高并发请求时表现出色。</p><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><h4 id="2-1-配置文件结构"><a href="#2-1-配置文件结构" class="headerlink" title="2.1 配置文件结构"></a>2.1 配置文件结构</h4><p>Nginx的配置文件通常位于<code>/etc/nginx/nginx.conf</code>，或者在<code>/etc/nginx/sites-available/</code>和<code>/etc/nginx/sites-enabled/</code>目录中。配置文件由多个块组成，每个块定义了特定的配置指令。</p><ul><li><strong>全局块</strong>：定义全局配置，如用户、工作进程数等。</li><li><strong>http块</strong>：定义HTTP服务器相关配置，如虚拟主机、日志格式等。</li><li><strong>server块</strong>：定义虚拟主机，包括监听端口、域名等。</li><li><strong>location块</strong>：定义特定路径的处理规则，如静态文件服务、反向代理等。</li></ul><h4 id="2-2-示例配置"><a href="#2-2-示例配置" class="headerlink" title="2.2 示例配置"></a>2.2 示例配置</h4><p>nginx复制</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">worker_processes</span> auto;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">            <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /api/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://backend-server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-主要模块"><a href="#3-主要模块" class="headerlink" title="3. 主要模块"></a>3. 主要模块</h3><h4 id="3-1-HTTP模块"><a href="#3-1-HTTP模块" class="headerlink" title="3.1 HTTP模块"></a>3.1 HTTP模块</h4><ul><li>**<code>ngx_http_core_module</code>**：核心模块，处理基本的HTTP请求和响应。</li><li>**<code>ngx_http_static_module</code>**：提供静态文件服务。</li><li>**<code>ngx_http_proxy_module</code>**：实现反向代理功能。</li><li>**<code>ngx_http_ssl_module</code>**：支持SSL&#x2F;TLS加密。</li></ul><h4 id="3-2-其他模块"><a href="#3-2-其他模块" class="headerlink" title="3.2 其他模块"></a>3.2 其他模块</h4><ul><li>**<code>ngx_http_gzip_module</code>**：支持响应内容的GZIP压缩。</li><li>**<code>ngx_http_rewrite_module</code>**：支持基于正则表达式的URL重写。</li><li>**<code>ngx_http_limit_req_module</code>**：限制请求速率，防止滥用。</li></ul><h3 id="4-常见用途"><a href="#4-常见用途" class="headerlink" title="4. 常见用途"></a>4. 常见用途</h3><h4 id="4-1-静态内容服务器"><a href="#4-1-静态内容服务器" class="headerlink" title="4.1 静态内容服务器"></a>4.1 静态内容服务器</h4><p>Nginx可以高效地提供静态文件服务，如HTML、CSS、JavaScript和图片文件。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-反向代理"><a href="#4-2-反向代理" class="headerlink" title="4.2 反向代理"></a>4.2 反向代理</h4><p>Nginx可以作为反向代理服务器，将请求转发到后端应用服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend-server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-负载均衡"><a href="#4-3-负载均衡" class="headerlink" title="4.3 负载均衡"></a>4.3 负载均衡</h4><p>Nginx可以将客户端请求分发到多个后端服务器，提高系统的可用性和性能。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可选负载均衡策略：</p><ul><li>简单轮询 （Round Robin）</li><li>加权轮询 （Weighted Robin）</li><li>最少连接 </li><li>IP hash</li><li>基于响应时间的算法 （NGINX Plus 中提供）</li><li>随机算法</li><li>通用 HASH （一致性哈希）<ul><li><code>hash $remote_addr consistent</code></li><li><code>hash $request_uri consistent</code></li><li><code>hash $http_host consistent</code></li><li><code>hash $scheme consistent</code></li><li>组合，如：   <code>hash $remote_addr$request_uri consistent</code></li></ul></li></ul><h4 id="4-4-SSL-TLS终止"><a href="#4-4-SSL-TLS终止" class="headerlink" title="4.4 SSL&#x2F;TLS终止"></a>4.4 SSL&#x2F;TLS终止</h4><p>Nginx 可以处理 SSL&#x2F;TLS 加密，将加密流量解密后转发到后端服务器。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/certificate.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/private.key;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-性能优化"><a href="#5-性能优化" class="headerlink" title="5. 性能优化"></a>5. 性能优化</h3><h4 id="5-1-缓存"><a href="#5-1-缓存" class="headerlink" title="5.1 缓存"></a>5.1 缓存</h4><p>Nginx可以缓存静态文件和动态内容，减少对后端服务器的请求，提高响应速度。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /data/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=my_cache:<span class="number">10m</span> max_size=<span class="number">10g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">        <span class="attribute">proxy_cache</span> my_cache;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-GZIP压缩"><a href="#5-2-GZIP压缩" class="headerlink" title="5.2 GZIP压缩"></a>5.2 GZIP压缩</h4><p>Nginx可以对响应内容进行GZIP压缩，减少传输数据量，提高性能。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;</span><br></pre></td></tr></table></figure><h3 id="6-安全性"><a href="#6-安全性" class="headerlink" title="6. 安全性"></a>6. 安全性</h3><h4 id="6-1-SSL-TLS加密"><a href="#6-1-SSL-TLS加密" class="headerlink" title="6.1 SSL&#x2F;TLS加密"></a>6.1 SSL&#x2F;TLS加密</h4><p>Nginx支持SSL&#x2F;TLS加密，确保数据传输的安全性。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /path/to/certificate.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /path/to/private.key;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">1m</span>;</span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-2-防止DDoS攻击"><a href="#6-2-防止DDoS攻击" class="headerlink" title="6.2 防止DDoS攻击"></a>6.2 防止DDoS攻击</h4><p>Nginx可以通过限制请求速率来防止DDoS攻击。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">limit_req_zone</span> <span class="variable">$binary_remote_addr</span> zone=one:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> example.com;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=one burst=<span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Nginx是一款功能强大、性能卓越的HTTP服务器和反向代理服务器。通过合理配置和优化，Nginx可以满足多种应用场景，包括静态内容服务、反向代理、负载均衡和SSL&#x2F;TLS终止。掌握Nginx的基本知识和配置方法，可以帮助你更好地管理和优化你的Web服务。</p><h1 id="附-——-配置示例"><a href="#附-——-配置示例" class="headerlink" title="附 —— 配置示例"></a>附 —— 配置示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 定义 server1 集群的 upstream，使用最小连接数算法</span><br><span class="line">    upstream server1 &#123;</span><br><span class="line">        least_conn;</span><br><span class="line">        server 192.168.1.1:8080;  # 替换为 server1 集群的实际 IP 和端口</span><br><span class="line">        server 192.168.1.2:8080;</span><br><span class="line">        # 添加更多 server1 的节点</span><br><span class="line"></span><br><span class="line">        # 健康检查配置</span><br><span class="line">        health_check uri=/health match=healthy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 server2 集群的 upstream，使用轮询算法</span><br><span class="line">    upstream server2 &#123;</span><br><span class="line">        server 192.168.2.1:8080;  # 替换为 server2 集群的实际 IP 和端口</span><br><span class="line">        server 192.168.2.2:8080;</span><br><span class="line">        # 添加更多 server2 的节点</span><br><span class="line"></span><br><span class="line">        # 健康检查配置</span><br><span class="line">        health_check uri=/health match=healthy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义健康检查匹配规则</span><br><span class="line">    http_check &#123;</span><br><span class="line">        match healthy &#123;</span><br><span class="line">            status 200-299;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 server 块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">        # 强制重定向到 HTTPS</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    # 定义 HTTPS server 块</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        server_name your-domain.com;</span><br><span class="line"></span><br><span class="line">        # SSL 证书配置</span><br><span class="line">        ssl_certificate /path/to/your-domain.crt;  # 替换为你的 SSL 证书路径</span><br><span class="line">        ssl_certificate_key /path/to/your-domain.key;  # 替换为你的 SSL 私钥路径</span><br><span class="line"></span><br><span class="line">        # 配置 /location1 路径转发到 server1 集群</span><br><span class="line">        location /location1 &#123;</span><br><span class="line">            proxy_pass http://server1;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        # 配置 /location2 路径转发到 server2 集群</span><br><span class="line">        location /location2 &#123;</span><br><span class="line">            proxy_pass http://server2;</span><br><span class="line">            proxy_set_header Host $host;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 负载均衡 </tag>
            
            <tag> 服务治理 </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Pipeline</title>
      <link href="/2024/07/21/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Pipeline/"/>
      <url>/2024/07/21/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Pipeline/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty EventLoop</title>
      <link href="/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/EventLoop/"/>
      <url>/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/EventLoop/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Channel</title>
      <link href="/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Channel/"/>
      <url>/2024/07/20/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Channel/</url>
      
        <content type="html"><![CDATA[<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><h2 id="Channel-简介"><a href="#Channel-简介" class="headerlink" title="Channel 简介"></a>Channel 简介</h2><p>在 Java NIO 中，Channel 即通道，是用来传输数据的一条“管道”，它与 Buffer 相辅相成；并且在 Java NIO 中，我们只能从 Channel 读取数据到 Buffer 中，或者从 Buffer 读取数据到 Channel 中</p><p>在 Netty 中同样有一个 Channel，该 <strong>Channel 是 Netty 的核心概念之一，它是 Netty 网络 IO 操作的抽象，即 Netty 网络通信的主体，由它来负责对端进行网络通信、注册、数据操作等一切 IO 相关的操作</strong>，其主要功能包括：</p><ol><li>网络 IO 的读写</li><li>客户端发起连接</li><li>关闭连接</li><li>网络连接的相关参数</li><li>绑定端口</li><li>Netty 框架相关操作，如获取 Channel 相关联的 EventLoop、pipeline 等。</li></ol><h3 id="为什么要重新设计"><a href="#为什么要重新设计" class="headerlink" title="为什么要重新设计"></a>为什么要重新设计</h3><ol><li>原生的 Channel 功能太少，不满足 Netty 的要求。</li><li>原生的 ServerSocketChannel 和 SocketChannel 是一个 SPI 接口，具体的实现由虚拟厂商来实现，直接通过原生 ServerSocketChannel 和 SocketChannel 来实现及满足 Netty 的要求，其工作量不亚于重新开发一个。</li><li>Netty 的 Channel 需要符合 Netty 的整体架构设计，他需要和 Netty 的整体架构耦合在一起，比如 IO 模型、基于元数据描述配置化的TCP参数等等，原生的 Channel 都不支持。</li><li>自定义的 Channel，灵活性更高，功能更加全面。</li></ol><h2 id="Channel-原理"><a href="#Channel-原理" class="headerlink" title="Channel 原理"></a>Channel 原理</h2><p>Channel 的核心原理如下图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206212000006.jpg" alt="img"></p><ol><li>客户端与服务端成功建立连接后，服务端会为该连接创建一个 Channel。</li><li>Channel 从 EventLoopGroup 中获取一个 EventLoop，Channel 注册到该 EventLoop 中，从此 Channel 就与该 EventLoop 绑定在一起了，在 Channel 整个生命周期内都只会与该 EventLoop 绑定在一起。</li><li>客户端发起的 IO 操作，在 Channel 中都将产生相对应的 Event，触发与该 Channel 绑定的 EventLoop 进行处理</li><li>如果是读写事件，执行线程调度 ChannelPipeline 来处理业务逻辑。ChannelPipeline 只负责 Handler 的编排，真正执行任务的是各个具体的 ChannelHandler。</li></ol><h2 id="Channel-的状态转换"><a href="#Channel-的状态转换" class="headerlink" title="Channel 的状态转换"></a>Channel 的状态转换</h2><p>Channel 从创建到消亡，他有四种状态，分别是：</p><ul><li><strong>打开状态（Open）：</strong><ul><li>Channel 处于打开状态时，表示它已经被创建，但尚未绑定到任何地址或连接到远端服务器。</li></ul></li><li><strong>活动状态（Active）</strong><ul><li>Channel 处于活动状态时，表示它已经成功绑定到本地地址或连接到远端服务器。</li><li>这个时候可以调用 <code>writeAndFlush()</code> 向对方发送数据了。</li></ul></li><li><strong>非活动状态（Inactive）</strong><ul><li>Channel 处于非活动状态时，表示它已经处于活动状态，但连接已经断开或由于其他原因不可用。</li><li>当连接被关闭或出现错误时，Channel 会进入非活动状态。</li><li>无法进行读取或写入操作，但可重新激活 Channel。</li></ul></li><li><strong>关闭状态（Closed）：</strong><ul><li>Channel 处于关闭状态时，表示它已经完全关闭，无法再进行任何操作。</li></ul></li></ul><p>Netty 提供了四个方法来判断 Channel 的状态：</p><ul><li><code>isOpen()</code>：检查 Channel 是否为 open 状态。</li><li><code>isRegistered()</code>：检查 Channel 是否为 registered 状态。</li><li><code>isActive()</code>：检查 Channel 是否为 active 状态。</li><li><code>isWritable()</code>：这个方法有误导性，它并不是判断当前 Channel 是否可写，实际上它是用来检测当前 Channel 的写操作是否可以立刻被 IO 线程处理，当该方法返回 false 时，任何写请求都会被阻塞，知道 I&#x2F;O 线程有能力能处理这些请</li></ul><h2 id="Channel-的-API"><a href="#Channel-的-API" class="headerlink" title="Channel 的 API"></a>Channel 的 API</h2><p>略</p><h2 id="Channel-的配置"><a href="#Channel-的配置" class="headerlink" title="Channel 的配置"></a>Channel 的配置</h2><p>在 Netty 中，每个 Channel 都有与之相对应的 ChannelConfig ， 可以通过调用 <code>config()</code> 来获取。ChannelConfig 是一个接口，每个特定的 Channel 都有具体的 ChannelConfig 实现类，例如：</p><ul><li>NioSocketChannel 的对应的配置类为 NioSocketChannelConfig。</li><li>NioServerSocketChannel 的对应的配置类为 NioServerSocketChannelConfig。</li></ul><h3 id="ChannelConfig-提供通用型配置"><a href="#ChannelConfig-提供通用型配置" class="headerlink" title="ChannelConfig 提供通用型配置"></a>ChannelConfig 提供通用型配置</h3><ul><li><code>ChannelOption.CONNECT_TIMEOUT_MILLIS</code>：连接超时时间，默认值30000毫秒即30秒。</li><li><code>ChannelOption.WRITE_SPIN_COUNT</code>：写操作的最大循环数，即一次写事件处理期间最多调用 <code>write()</code> 的次数。它有点儿像 Java 中的自旋锁。引入该参数的主要木的是为了避免一个 Channel 写入大量数据，对其他网络通道的读写处理带来延时。</li><li><code>ChannelOption.ALLOCATOR</code>：设置内存分配器。</li><li><code>ChannelOption.RCVBUF_ALLOCATOR</code>：对读事件设置内存分配器。</li><li><code>ChannelOption.AUTO_READ</code>：配置是否自动触发 <code>read()</code> ，默认为 True，程序不需要显示调用 <code>read()</code>。</li><li><code>ChannelOption.AUTO_CLOSE</code>：配置当写事件失败时，是否自动关闭 Channel，默认为 True。</li><li><code>ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK</code>：设置写缓存区的高水位线。如果写缓存区中的数据超过该值， <code>Channel#isWritable()</code> 方法将返回 false。</li><li><code>ChannelOption.WRITE_BUFFER_LOW_WATER_MARK</code>：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(<code>Channel#isWritable()</code>将再次返回true)。</li><li><code>ChannelOption.MESSAGE_SIZE_ESTIMATOR</code>：设置用于检测通道消息大小的检测器：MessageSizeEstimator。</li></ul><h3 id="NioSocketChannelConfig"><a href="#NioSocketChannelConfig" class="headerlink" title="NioSocketChannelConfig"></a>NioSocketChannelConfig</h3><p>NioSocketChannelConfig 在 ChannelConfig 的基础上增加了如下几个配置：</p><ul><li><code>ChannelOption.SO_KEEPALIVE</code>： 连接保持，默认为 False，我们可以将这个参数视为 TCP 的心跳机制。</li><li><code>ChannelOption.SO_REUSEADDR</code>：地址复用，默认值False。</li><li><code>ChannelOption.SO_LINGER</code>：关闭 Socket 的延迟时间，默认值  为 -1，表示禁用该功能</li><li><code>ChannelOption.TCP_NODELAY</code>：立即发送数据，默认值为 Ture。该值其实是设置 Nagle 算法的启用。关于 Nagle 算法我们后面再细说。</li><li><code>ChannelOption.SO_RCVBUF</code>：TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口。</li><li><code>ChannelOption.SO_SNDBUF</code>：TCP 数据发送缓冲区大小。该缓冲区即 TCP 发送滑动窗口。</li><li><code>ChannelOption.IP_TOS</code>：IP 参数，设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。</li><li><code>ChannelOption.ALLOW_HALF_CLOSURE</code>：一个连接的远端关闭时本地端是否关闭，默认值为False。</li></ul><h3 id="NioServerSocketChannelConfig"><a href="#NioServerSocketChannelConfig" class="headerlink" title="NioServerSocketChannelConfig"></a>NioServerSocketChannelConfig</h3><ul><li><code>ChannelOption.SO_REUSEADDR</code>：地址复用，默认值False。</li><li><code>ChannelOption.SO_RCVBUF</code>：TCP 数据接收缓冲区大小。该缓冲区即 TCP 接收滑动窗口。</li><li><code>ChannelOption.SO_BACKLOG</code>：服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝</li></ul><h2 id="Channel-的使用方法"><a href="#Channel-的使用方法" class="headerlink" title="Channel 的使用方法"></a>Channel 的使用方法</h2><p>略</p>]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty ByteBuf</title>
      <link href="/2024/07/18/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/ByteBuf/"/>
      <url>/2024/07/18/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/ByteBuf/</url>
      
        <content type="html"><![CDATA[<h1 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h1><h2 id="从-ByteBuffer-说起"><a href="#从-ByteBuffer-说起" class="headerlink" title="从 ByteBuffer 说起"></a>从 ByteBuffer 说起</h2><p>Java NIO 有一个原生的 ByteBuffer，但由于 Java NIO 的 ByteBuffer 有一些设计上的缺陷和痛点，Netty 重新造了一个轮子</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206281000001.jpg" alt="img"></p><p>Java NIO 的 ByteBuffer 有四个属性</p><ul><li><strong>capacity</strong>：容量，表示当前 ByteBuffer 最大可写的数据量。</li><li><strong>limit</strong>：ByteBuffer 中有效的数据长度大小，具体含义与当前 ByteBuffer 处于哪种模式有关<ul><li>写模式：limit 是指能够往 Buffer 中写入多少数据，其值等于 capacity。</li><li>读模式：limit 表示能够从 Buffer 中最多能够读取多少数据出来。当从写模式切换到读模式时，limit 的写模式的 position。</li></ul></li><li><strong>position</strong>：当前位置，与 limit 一样，具体含义与当前 ByteBuffer 处于哪种模式有关<ul><li>写模式：当前写的位置，初始值为 0 ，最大值为 capacity - 1，当往 ByteBuffer 中写入一个数据时，position 就会向前移动到下一个待写入的位置。</li><li>读模式：当前读的位置，读一个数据，position 就往前移一位。</li></ul></li><li><strong>mark</strong>：标志位，一般都是用这个属性来标识某个特殊的位置，方便我们到时候回退到该位置。</li></ul><p>基于 ByteBuffer 的属性特点可以看出它有如下几个缺陷：</p><ol><li>只有一个标识位置的指针 position，在我们使用过程中需要频繁调用 <code>flip()</code>、<code>rewind()</code> 来进行读写模式的切换，我们需要非常清晰地知道这些 API 具体的含义，知道他们的使用场景，否则就会导致程序出错。</li><li>长度固定。我们在申请一个 ByteBuffer 的时候就已经固定了它的容量了，它无法扩容，然后在实际开发过程中，我们是无法来衡量一个具体的容量的，所以很难控制需要分配的容量。分配太多，容易造成内存浪费；分配太少，则会引发索引越界异常 BufferOverflowException。</li><li>提供的 API 不够丰富，一些高级和实用的特性它不支持，需要我们自己动手实现。</li></ol><p>而作为 Netty 的数据传输的载体，ByteBuffer 显然无法满足 Netty 的需求，所以 Netty 就另起炉灶实现了一个性能更高，灵活性更强的 ByteBuf。作为 ByteBuffer 的替代者，ByteBuf 具有如下几个优点：</p><ol><li>容量可以动态扩容</li><li>读写索引分开，读写模式可以随意切换，不需要调用 <code>flip()</code> 方法</li><li>支持引用计数</li><li>支持池化</li><li>通过内置的复合缓冲区类型实现透明的零拷贝</li><li>支持方法的链式调用</li></ol><h2 id="ByteBuf-原理"><a href="#ByteBuf-原理" class="headerlink" title="ByteBuf 原理"></a>ByteBuf 原理</h2><h3 id="ByteBuf-的内部结构"><a href="#ByteBuf-的内部结构" class="headerlink" title="ByteBuf 的内部结构"></a>ByteBuf 的内部结构</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202206293000001.jpg" alt="img"></p><h3 id="ByteBuf-的三个指针"><a href="#ByteBuf-的三个指针" class="headerlink" title="ByteBuf 的三个指针"></a>ByteBuf 的三个指针</h3><ul><li>readerIndex：读指针</li><li>writerIndex：写指针</li><li>maxCapacity：最大容量</li></ul><h3 id="ByteBuf-的四个部分"><a href="#ByteBuf-的四个部分" class="headerlink" title="ByteBuf 的四个部分"></a>ByteBuf 的四个部分</h3><p>三个指针将整个 ByteBuf 分为四个部分：</p><ol><li><strong>废弃字节</strong>：表示已经丢弃的无效字节，我们可以调用 <code>discardReadBytes()</code> 释放这部分空间。</li><li><strong>可读字节</strong>：表示可以从 ByteBuf 中读取到的数据，这部分内容等于 writerIndex - readerIndex。readerIndex 随着我们读取 ByteBuf 中的数据而递增，当从 ByteBuf 中读取 N 个字节， readerIndex 就会自增 N，直到 readerIndex &#x3D; writerIndex 时，就表示 ByteBuf 不可读。</li><li><strong>可写字节</strong>：表示可以向 ByteBuf 可写入的字节。writerIndex 也是随着我们向 ByteBuf 中写入数据而自增，当想 ByteBuf 中写入 N 个字节，writerIndex 就会自增 N，当 writerIndex 超过 capacity 时，就需要扩容了。</li><li><strong>可扩容字节</strong>：表示 ByteBuf 最多可扩容多少字节 。当向 ByteBuf 写入的数据超过了 capacity 时，就会触发扩容，但是最多可扩容到 maxCapacity ，超过时就会报错。</li></ol><p>netty 为 读写操作分别设计指针，很好地解决了 NIO ByteBuffer 的不可扩容及读写模式切换的问题，使得 ByteBu 能够更加高效、更加灵活地处理数据</p><h2 id="ByteBuf-分类"><a href="#ByteBuf-分类" class="headerlink" title="ByteBuf 分类"></a>ByteBuf 分类</h2><p>Netty 提供的 ByteBuf 有多种实现类，每种都有不同的特性和使用场景，主要分为三种类型：</p><ol><li>Pooled 和 Unpooled：池化和非池化；</li><li>Heap 和 Direct：堆内存和直接内存；</li><li>Safe 和 Unsafe：安全和非安全。</li></ol><ul><li><strong>Pooled 和 Unpooled</strong></li></ul><p>Pooled 就是从预先分配好的内存中取出来，使用完成后又放回 ByteBuf 内存中，等待下一次分配。而 Unpooled 是直接调用系统 API 来申请内存的，使用完成后需要立刻销毁的。</p><p>从性能上来说，Pooled 要比 Unpooled 性能好，因为它可以重复利用，不需要每次都创建</p><ul><li><strong>Heap 和 Direct</strong></li></ul><p>Heap 就是在 JVM 堆内分配的，其生命周期受 JVM 管理，我们不需要主动回收他们。而 Direct 则由操作系统管理，使用完成后需要主动释放这部分内存，否则容易造成内存溢出。</p><ul><li><strong>Safe 和 Unsafe</strong></li></ul><p>主要是 Java 底层操作数据的一种安全和非安全的方式。Unsafe 表示每次调用 JDK 的 Unsafe 对象操作物理内存的，而 Safe 则不需要依赖 JDK 的 Unsafe 对象，直接通过数组下标的方式来操作。</p><p>经排列组合，可知 ByteBuf 共有 2^3 &#x3D;8 种实现</p><ol><li>池化 + 堆内存：PooledHeapByteBuf</li><li>池化 + 直接内存：PooledDirectByteBuf</li><li>池化 + 堆内存 + 不安全：PooledUnsafeHeapByteBuf</li><li>池化 + 直接内存 + 不安全：PooledUnsafeDirectByteBuf</li><li>非池化 + 堆内存：UnpooledHeapByteBuf</li><li>非池化 + 直接内存：UnpooledDirectByteBuf</li><li>非池化 + 堆内存 + 不安全：UnpooledUnsafeHeapByteBuf</li><li>非池化 + 直接内存 + 不安全：UnpooledUnsafeDirectByteBuf</li></ol><h2 id="ByteBuf-核心-API"><a href="#ByteBuf-核心-API" class="headerlink" title="ByteBuf 核心 API"></a>ByteBuf 核心 API</h2><p>ByteBuf 的核心 API 分为四类：</p><ol><li>容量相关 API</li><li>指针操作相关 API</li><li>数据读写相关 API</li><li>内存管理相关 API</li></ol><p>下面我们依次来了解这些 API。</p><h3 id="容量相关-API"><a href="#容量相关-API" class="headerlink" title="容量相关 API"></a>容量相关 API</h3><p>容量相关的 API 主要用来获取 ByteBuf 的容量的。</p><ul><li><strong>capacity()</strong></li></ul><p>表示 ByteBuf 占用了多少字节的内存，它包括已放弃 + 可读 + 可写。</p><ul><li><strong>maxCapacity()</strong></li></ul><p>表示 ByteBuf 最大能占用多少字节的内存。当不断向 ByteBuf 中写入数据的时候，如果发现容量不足时（writerIndex 超过 capacity）就会触发扩容，最大可扩容到 maxCapacity，如果超过 maxCapacity 时就会抛出异常。</p><h3 id="指针操作相关-API"><a href="#指针操作相关-API" class="headerlink" title="指针操作相关 API"></a>指针操作相关 API</h3><p>指针操作相关 API 就是操作读写指针的。</p><ul><li><strong>readerIndex() &amp; readerIndex(int)</strong></li></ul><p>前置返回读指针 readerIndex 的位置，而后者是设置读指针 readerIndex 的位置。</p><ul><li><strong>writerIndex() &amp; writerIndex(int)</strong></li></ul><p>前者返回写指针 writerIndex 的位置，而后者是设置写指针 writerIndex 的位置。</p><ul><li><strong>markReaderIndex() &amp; resetReaderIndex()</strong></li></ul><p><code>markReaderIndex()</code>用于标注当前 readerIndex 的位置，即把当前 readerIndex 保存起来。而 <code>resetReaderIndex()</code> 则是将当前的 readerIndex 指针恢复到之前保存的位置。</p><ul><li><strong>markWriterIndex() &amp; resetWriterIndex()</strong></li></ul><p>与 readerIndex 的一致。</p><h3 id="数据读写相关-API"><a href="#数据读写相关-API" class="headerlink" title="数据读写相关 API"></a>数据读写相关 API</h3><ul><li><strong>readableBytes() &amp; isReadable()</strong></li></ul><p><code>readableBytes()</code> 表示 ByteBuf 中有多少字节可以读，它的值等于 writerIndex - readerIndex。<code>isReadable()</code> 用于判断 ByteBuf 是否可读，若 <code>readableBytes()</code> 返回的值大于 0 ，则 <code>isReadable()</code> 则为 true。</p><ul><li><strong>readByte() &amp; writeByte(byte b)</strong></li></ul><p><code>readByte()</code> 是从 ByteBuf 中读取一个字节，则 readerIndex + 1。同理 <code>writeByte(byte b)</code> 是向 ByteBuf 中写入一个字节，相应的 writerIndex + 1。</p><p>在 Netty 中，它提供了 8 种基础数据类型的读取和写入 API，如 <code>readInt()</code>，<code>readLong()</code>，<code>readShort()</code> 等等，这里就不一一阐述了。</p><ul><li><strong>readBytes(byte[] dst) &amp; writeBytes(byte[] src)</strong></li></ul><p><code>readBytes(byte[] dst)</code> 是将 ByteBuf 里面的数据全部读取到 dst 中，这里 dst 数据的大小通常等于 <code>readableBytes()</code>。</p><p><code>writeBytes(byte[] src)</code> 则是将 src 数组里面的内容全部写到 ByteBuf 中。</p><ul><li><strong>getByte(int) &amp; setByte(int,int)</strong></li></ul><p>这两个方法与 <code>readByte()</code> &amp; <code>writeByte(byte b)</code> 方法类似，两者区别在于 <code>readByte()</code> 会改变 readerIndex 的位置，而 <code>getByte(int)</code> 则不会改变 readerIndex 的位置。</p><h3 id="内存管理相关-API"><a href="#内存管理相关-API" class="headerlink" title="内存管理相关 API"></a>内存管理相关 API</h3><ul><li><strong>retain() &amp; release()</strong></li></ul><p>ByteBuf 是基于引用计数设计的，它实现了 ReferenceCounted 接口。在默认情况下，我们创建一个 ByteBuf 时，它的计数为 1。</p><p>当计数大于 0 ，就说该 ByteBuf 还在被使用，当计数等于 0 的时候，说明该 ByteBuf 不再被其他对象所引用。</p><p>我们每调用一个 <code>retain()</code> ，计数就 + 1，每调用一次 <code>release()</code> 计数就 - 1，当计数减到 0 的时候，就会被回收。</p><ul><li><strong>slice() &amp; duplicate() &amp; copy()</strong></li></ul><p><code>slice()</code>从 ByteBuf 中截取一段从 readerIndex 到 writerIndex 之间的数据，该新的 ByteBuf 的最大容量为原始 ByteBuf 的 <code>readableBytes()</code>。新的 ByteBuf 其底层分配的内存、引用计数与原始的 ByteBuf 共享，这样就会有一个问题：如果我们调用新的 ByteBuf 的 write 系列方法，就会影响到原始的 ByteBuf 的底层数据。</p><p><code>duplicate()</code> 也是从 ByteBuf 中截取一段数据，返回一个新的 ByteBuf，但是它截取的是整个原始的 ByteBuf，与 <code>slice()</code> 一样，<code>duplicate()</code> 返回新的 ByteBuf 其底层分配的内存、引用计数与原始 ByteBuf 共享。</p><p><code>copy()</code> 从原始 ByteBuf 中拷贝所有信息，包括读写指针、底层分配的内存、引用计数等等所有的信息，所以新的 ByteBuf 是一个独立的个体，它与原始的 ByteBuf 不再共享。</p><p>在使用这三个方法的时候一定要切记如下点：</p><ul><li><code>slice()</code> 和 <code>duplicate()</code> 新的 ByteBuf 与原始的 ByteBuf 内存共享、引用计数共享、读写指针不共享</li><li><code>copy()</code> 新的 ByteBuf 与原始 ByteBuf 底层内存、引用计数、读写指针都不共享</li></ul><h2 id="ByteBuf-实现零拷贝"><a href="#ByteBuf-实现零拷贝" class="headerlink" title="ByteBuf 实现零拷贝"></a>ByteBuf 实现零拷贝</h2><ul><li>byte数组转换为ByteBuf对象。Unpooled.wrappedBuffer方法来将bytes 包装成为一个UnpooledHeapByteBuf对象, 而在包装的过程中, 是不会有拷贝操作的。最后我们生成的生成的ByteBuf对象是和bytes数组共用了同一个存储空间, 对bytes的修改也会反映到ByteBuf对象中.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 传统做法，这样的方式也是有一个额外的拷贝操作的</span></span><br><span class="line"><span class="type">byte</span>[] bytes = ...</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.buffer();</span><br><span class="line">byteBuf.writeBytes(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 无额外copy方式</span></span><br><span class="line"><span class="type">byte</span>[] bytes = ...</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> Unpooled.wrappedBuffer(bytes);</span><br></pre></td></tr></table></figure><ul><li><p>Unpooled工具类还提供了很多重载的wrappedBuffer方法:这些方法可以将一个或多个buffer包装为一个ByteBuf对象, 从而避免了拷贝操作。</p></li><li><p>通过slice操作实现零拷贝: slice操作和wrap操作刚好相反, Unpooled.wrappedBuffer可以将多个ByteBuf合并为一个, 而slice操作可以将一个ByteBuf切片 为多个共享一个存储区域的ByteBuf对象。</p><ul><li>ByteBuf 提供了两个 slice 操作方法:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">slice</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">slice</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li>不带参数的slice方法等同于buf.slice(buf.readerIndex(), buf.readableBytes())调用, 即返回buf中可读部分的切片. 而 slice(int index, int length) 方法相对就比较灵活了, 我们可以设置不同的参数来获取到 buf的不同区域的切片.</li><li>用slice方法产生header和body的过程是没有拷贝操作的,header和 body对象在内部其实是共享了byteBuf存储空间的不同部分而已</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty Bootstrap</title>
      <link href="/2024/07/17/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Bootstrap/"/>
      <url>/2024/07/17/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Bootstrap/</url>
      
        <content type="html"><![CDATA[<h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>Bootstrap 充当了 Netty 服务端或客户端应用程序的启动者，为 netty 应用开发提供了一种简洁且流畅的 API 来配置和启动网络服务。</p><p>在 Netty 中有两个主要的 Bootstrap 类型：</p><ul><li>ServerBootstrap：用于启动服务端应用。</li><li>Bootstrap：用于启动客户端应用。</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240724223711483.png" alt="image-20240724223711483" style="zoom: 67%;" /><h2 id="Bootstrap-的使用步骤"><a href="#Bootstrap-的使用步骤" class="headerlink" title="Bootstrap 的使用步骤"></a>Bootstrap 的使用步骤</h2><ol><li><strong>创建 Bootstrap 实例</strong>：创建 Bootstrap 或 ServerBootstrap 实例。</li><li><strong>设置 EventLoopGroup</strong>：EventLoopGroup 是处理 I&#x2F;O 操作的线程组。通常，客户端会设置一个 EventLoopGroup，而服务端会设置两个（一个用于接收连接，另一个用于处理连接）。</li><li><strong>选择 Channel 类型</strong>：指定要使用的 Channel 类型，例如 NioSocketChannel 或 EpollSocketChannel。</li><li><strong>添加 ChannelInitializer</strong>：通过 handler() 方法添加 ChannelInitializer，它会在每个新 Channel 创建后被调用，用于添加 ChannelHandler 到 ChannelPipeline。</li><li><strong>配置 Channel 选项</strong>：可以设置各种 ChannelOption，比如 TCP_NODELAY 和 SO_KEEPALIVE。</li><li><strong>连接或绑定</strong>：<ul><li>客户端调用 connect() 方法尝试连接到远程服务器。</li><li>服务端调用 bind() 方法绑定到本地端口并开始监听连接。</li></ul></li></ol><p>(ServerBootStrap 调用周期)</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202205221000003.jpg" alt="img" style="zoom: 30%;" /><h3 id="设置-EventLoopGroup-线程组"><a href="#设置-EventLoopGroup-线程组" class="headerlink" title="设置 EventLoopGroup 线程组"></a>设置 EventLoopGroup 线程组</h3><p>调用 <code>group()</code> 可以设置 EventLoopGroup 的线程组，该线程组其实就是 Reactor 的线程组</p><p>对于Server 端而言 ，Reactor 模式线程组有两个：</p><ul><li>BossGroup：服务器连接监听线程组，该线程组专门用来处理客户端的连接请求</li><li>WorkGroup：工作线程组，即业务处理线程组，用来处理每一条连接的数据收发的线程组。</li></ul><p>ServerBootstrap 提供了两个 <code>group()</code> 方法用来设置线程组：</p><ul><li><code>group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>：设置 BossGroup 和 WorkGroup。</li><li><code>group(EventLoopGroup group)</code>：这里只配置了一个线程组，也就是 BossGroup 和 WorkGroup 共用一个线程组。</li></ul><h3 id="设置-Channel-类型"><a href="#设置-Channel-类型" class="headerlink" title="设置 Channel 类型"></a>设置 Channel 类型</h3><p>在 NIO 中 Channel 是通信的根本，我们收发数据都是基于 Channel 来实现的，对于 Netty 来说 Channel 也是它通信的通道，不过 Netty 不仅仅只支持 NIO 模式，还有 OIO 。</p><p>调用 <code>channel()</code> 方法即可设置通道的 IO 类型。</p><p>Netty 支持的 IO 类型有如下几种：</p><ul><li><code>NioSocketChannel</code>：异步的客户端 TCP Socket 连接.</li><li><code>NioServerSocketChannel</code>：异步的服务器端 TCP Socket 连接.</li><li><code>NioDatagramChannel</code>：异步的 UDP 连接</li><li><code>NioSctpChannel</code>：异步的客户端 Sctp 连接.</li><li><code>NioSctpServerChannel</code>：异步的 Sctp 服务器端连接.</li><li><code>OioSocketChannel</code>：同步的客户端 TCP Socket 连接.</li><li><code>OioServerSocketChannel</code>：同步的服务器端 TCP Socket 连接.</li><li><code>OioDatagramChanne</code>：同步的 UDP 连接</li><li><code>OioSctpChanne</code>：同步的 Sctp 服务器端连接.</li><li><code>OioSctpServerChannel</code>：同步的客户端 TCP Socket 连接.</li></ul><p>从上面可以看出，Netty 不仅仅只支持 TCP 协议，还支持 UDP 、STCP 协议，同时每种协议都有 NIO 和 OIO 模式，从 Netty 支持的通道类型就可以看出，Netty 功能有多么强大了。</p><h3 id="配置-Option-参数"><a href="#配置-Option-参数" class="headerlink" title="配置 Option 参数"></a>配置 Option 参数</h3><p>调用 <code>option()</code> 可以设置 Channel 相关的参数，其实 ServerBootstrap 还有一个 <code>childOption()</code> 方法。两个方法的区别是：</p><ul><li><code>option()</code> ：是给 parent Channel 设置参数的</li><li><code>childOption()</code> ：是给 child Channel 设置参数的。</li></ul><p>为什么这里会有一个 parent Channel 和 child Channel 呢？首先我们需要明确一点，Channel 是 Socket 连接的一个抽象，我们可以理解它对 Socket 做了一些封装。当 Netty 建立一个连接后，它会为该连接 new 一个 Channel 实例。同时，它也有了父子的概念了，服务端监听的 Channel 叫做 parent Channel，对应每一个 Socket 连接的 Channel 叫做 child Channel。其实我们从设置 EventLoopGroup 的时候就可以看出，<code>group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>。</p><p>可以设置的参数比较多，之类列几个常见的：</p><ul><li>ChannelOption.CONNECT_TIMEOUT_MILLIS：客户端建立连接时，如果超过指定的时间仍未连接，则抛出 timeout 异常。</li><li>ChannelOption.SO_KEEPALIVE：是否开启 TCP 底层心跳机制，true 表示开启。</li><li>ChannelOption.TCP_NODELAY：是否启用 Nagle 算法，true 表示开启。开启可能会对消息的实时性有影响，因为为了提升效率， Nagle 算法会将一些较小的数据包收集后再进行发送，这样就会造成我们的消息有延迟。所以如果实时性要求高的话，一般不建议开启。</li><li>ChannelOption.SO_RCVBUF：设置接收缓冲区的大小  </li><li>ChannelOption.SO_SNDBUF：设置发送缓冲区的大小，一般 SO_RCVBUF 和 SO_SNDBUF 不建议手动设置，因为操作系统会根据当前占用，进行自动的调整。</li></ul><p>其他参数，大明哥就不一一介绍了，有兴趣的小伙伴可以自行研究，大明哥在后面的 Netty 调优部分会对这些字段进行详细讲解的。</p><h3 id="设置-pipeline"><a href="#设置-pipeline" class="headerlink" title="设置 pipeline"></a>设置 pipeline</h3><p>设值 pipeline 其实就是配置处理的 Handler，ChannelPipeline 负责协调这些 Handler，它是 Netty 处理请求的责任链，该链上每个节点都是 ChannelHandler，而这些 ChannelHandler 就是用来处理这些请求的。</p><p>ServerBoostrap 提供了 <code>childHandler()</code> 方法用来装配这些 ChannelHandler ，用来组装成一个处理请求的流水线。我们传递一个 ChannelInitializer 实例，ChannelInitializer 是一个特殊的 ChannelHandler，它主要是为我们提供了一个简单的工具，用于在某个 Channel 注册到 EventLoop 后，对这个 Channel 执行一些初始化操作。</p><p>ChannelInitializer 是一个抽象类，我们需要实现它的 <code>initChannel()</code>，在该方法中我们通过 ChannelPipeline 来完成流水线的装配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;<span class="comment">//&#125;);</span></span><br></pre></td></tr></table></figure><p>ChannelHandler 有两种，分别是 ChannelInboundHandler 和 ChannelOutboundHandler，一个是处理进站，一个处理出站，通俗理解就是，ChannelInboundHandler 处理读入 IO 请求，ChannelOutboundHandler 处理写出 IO 请求。</p><p>我们调用 <code>ch.pipeline().addLast()</code> 方法可以装配一个 ChannelHandler 链，结构如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/202205221000004.jpg" alt="img"></p><p>当读请求进来时，传播链从 head 出发，依次经过 InboundHandlerA，InboundHandlerB，InboundHandlerC，InboundHandlerD，最后在 Tail 终止。而写出 IO 请求则相反，它是从 Tail 出发，依次经过 OutboundHandlerB，OutboundHandlerA，最后在 Head 终止。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Java%20%20NIO/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Java%20%20NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h1><h2 id="什么是-NIO"><a href="#什么是-NIO" class="headerlink" title="什么是 NIO"></a>什么是 NIO</h2><ul><li>Java NIO 全称 Java non-blocking IO，指的是 JDK 提供的新 API。从 JDK 1.4 开始，Java 提供了一系列改进的输入&#x2F;输出的新特性，被统称为 NIO，即 New IO，是<code>同步非阻塞</code>的。</li><li>NIO 相关类都放在 java.nio 包下，并对原 java.io 包中很多类进行了改写。</li><li>NIO 有<strong>三大核心</strong>部分：<code>Channel（管道）</code>、<code>Buffer（缓冲区）</code>、<code>Selector（选择器）</code>。</li><li>NIO 是面向<code>缓冲区</code>编程的。数据读取到了一个它稍微处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络。</li><li>Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用数据，如果目前没有可用数据时，则说明不会获取，而不是保持线程阻塞，所以直到数据变为可以读取之前，该线程可以做其他事情。非阻塞写入同理。</li></ul><h2 id="三大核心组件"><a href="#三大核心组件" class="headerlink" title="三大核心组件"></a>三大核心组件</h2><p>NIO 主要包括以下三个核心组件：</p><ul><li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</li><li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过 Channel 来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li><li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到 Selector 上，由 Selector 来分配线程来处理事件。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240716230507797.png" alt="image-20240716230507797"></p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><h4 id="Channel-的概念"><a href="#Channel-的概念" class="headerlink" title="Channel 的概念"></a>Channel 的概念</h4><ul><li>Channel 是 Java NIO 中的一个接口，它定义了读写数据的基本操作。与传统的流不同，Channel 支持双向数据传输，即可以从 Channel 中读取数据，也可以向 Channel 写入数据。Channel 不直接处理数据，而是通过 Buffer 来读取和写入数据。这意味着数据总是从 Channel 读取到 Buffer 或者从 Buffer 写入到 Channel。</li></ul><h4 id="Channel-的类型"><a href="#Channel-的类型" class="headerlink" title="Channel 的类型"></a>Channel 的类型</h4><p>Java NIO 提供了几种不同的 Channel 类型，每种类型都有其特定的用途：</p><ul><li><code>FileChannel</code><ul><li>用于文件的读写操作。</li><li>可以从文件中读取数据到 Buffer，也可以从 Buffer 写入数据到文件。</li><li>支持映射文件到 Buffer，允许直接对文件内存映像进行操作。</li></ul></li><li><code>SocketChannel</code><ul><li>用于 TCP 套接字的读写操作。</li><li>可以从远程主机读取数据到 Buffer，也可以从 Buffer 向远程主机写入数据。</li><li>支持非阻塞模式，可以在没有数据可读或写的情况下不会阻塞线程。</li></ul></li><li><code>ServerSocketChannel</code><ul><li>用于监听 TCP 连接请求。</li><li>当有客户端尝试建立连接时，可以接受连接并创建一个新的 SocketChannel。</li><li>通常与 Selector 配合使用，以实现多路复用，即一个线程可以同时监听多个 ServerSocketChannel。</li></ul></li><li><code>DatagramChannel</code><ul><li>用于 UDP 协议的数据报文读写。</li><li>支持发送和接收 UDP 数据包。</li><li>由于 UDP 是无连接的协议，因此每次发送或接收数据都需要指定目标地址或源地址。</li></ul></li><li><code>Pipe.SinkChannel 和 Pipe.SourceChannel</code><ul><li>用于管道通信，SinkChannel 用于写入数据，SourceChannel 用于读取数据。</li><li>通常用于进程间通信或线程间的同步数据传输。</li></ul></li></ul><h4 id="Channel-的操作"><a href="#Channel-的操作" class="headerlink" title="Channel 的操作"></a>Channel 的操作</h4><p>Channel 提供了一系列的方法来执行读写操作，例如：</p><ul><li><code>read(ByteBuffer dst)</code>：从 Channel 读取数据到 Buffer。</li><li><code>write(ByteBuffer src)</code>：从 Buffer 写入数据到 Channel。</li><li><code>transferTo(long position, long count, WritableByteChannel target)</code>：直接从 Channel 转移数据到另一个 Channel，无需通过 Buffer。</li><li><code>transferFrom(ReadableByteChannel src, long position, long count)</code>：直接从另一个 Channel 转移数据到当前 Channel。</li></ul><h4 id="Channel-的特性"><a href="#Channel-的特性" class="headerlink" title="Channel 的特性"></a>Channel 的特性</h4><ul><li><strong>双向性</strong>：大多数 Channel 支持读写操作。</li><li><strong>非阻塞性</strong>：Channel 可以设置为非阻塞模式，这使得线程在没有数据可读或写时不会被阻塞。</li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><h4 id="Buffer的基本属性"><a href="#Buffer的基本属性" class="headerlink" title="Buffer的基本属性"></a>Buffer的基本属性</h4><p>Buffer主要由以下几个属性组成：</p><ul><li><code>capacity</code>（容量）：Buffer能够容纳的数据元素的最大数量。</li><li><code>limit</code>（界限）：Buffer中第一个不可读或不可写的位置，即Buffer中有效数据的末尾位置加一。</li><li><code>position</code>（位置）：下一个可读或可写元素的索引。当向Buffer写入数据时，position指向下一个可写入的位置；当从Buffer读取数据时，position指向下一个可读取的位置。</li><li><code>mark</code>（标记）：一个可选的备忘位置，可以用来保存position的值，稍后可以通过reset()方法恢复到这个位置。</li></ul><h4 id="Buffer的操作模式"><a href="#Buffer的操作模式" class="headerlink" title="Buffer的操作模式"></a>Buffer的操作模式</h4><p>Buffer 的操作模式分为读模式和写模式：</p><ul><li><strong>写模式</strong>：默认模式，此时position从0开始，可以向Buffer中写入数据，直到达到limit（默认为capacity）。</li><li><strong>读模式</strong>：通过调用flip()方法从写模式切换到读模式。此时，position变为0，limit变为之前的position，表示可以读取之前写入的所有数据。</li></ul><h4 id="Buffer的常用方法"><a href="#Buffer的常用方法" class="headerlink" title="Buffer的常用方法"></a>Buffer的常用方法</h4><ul><li><code>put()</code>：将数据写入Buffer。</li><li><code>get()</code>：从Buffer中读取数据。</li><li><code>flip()</code>：将Buffer从写模式切换到读模式。</li><li><code>rewind()</code>：重置position为0，但保留limit不变，通常用于再次读取Buffer中的所有数据。</li><li><code>clear()</code>：重置Buffer，position和limit都回到初始状态，相当于清空Buffer，使其可以再次被写入数据。</li><li><code>compact()</code>：将未读的数据移动到Buffer的起始位置，并清空已经读取的部分，position设置在未读数据的末尾，limit设置为capacity。这通常用于连续写入数据，而不需要重新分配Buffer。</li></ul><h4 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h4><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h4 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据写入Buffer</span></span><br><span class="line">byteBuffer.put(<span class="string">&quot;Hello, World!&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换到读模式</span></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从Buffer读取数据</span></span><br><span class="line"><span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[byteBuffer.remaining()];</span><br><span class="line">byteBuffer.get(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印读取的数据</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br></pre></td></tr></table></figure><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>Selector是一个多路复用器，它能够同时监控多个Channel的I&#x2F;O操作。当一个Channel准备好进行读或写操作时，Selector会通知应用程序。这避免了轮询多个Channel的需要，从而减少了CPU的开销。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>注册Channel：应用程序首先需要将Channel注册到Selector上，注册时可以指定感兴趣的操作，如读、写或连接操作。</li><li>选择操作：Selector会阻塞在select()方法上，直到至少有一个Channel的I&#x2F;O操作就绪。select()方法返回就绪的Channel的数量。</li><li>处理事件：一旦select()返回，应用程序可以通过遍历Selector的selectedKeys()集合来获取就绪的Channel。每个就绪的Channel都有一个与之关联的SelectionKey，这个key包含了Channel的信息以及就绪的操作类型。</li><li>处理事件后清理：处理完就绪的Channel后，需要调用SelectionKey的cancel()方法来清除已处理的事件，否则这些事件会被重复报告。</li></ul><h4 id="使用范例-1"><a href="#使用范例-1" class="headerlink" title="使用范例"></a>使用范例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Selector</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 channel</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">serverChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">serverChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(port));</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> serverChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 选择就虚的channel </span></span><br><span class="line"><span class="type">int</span> <span class="variable">readyChannels</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="keyword">if</span> (readyChannels == <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="comment">// 没有就绪的Channel，可以做其他事情</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 处理就绪的Channel</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理就绪的channel </span></span><br><span class="line">Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">   <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">   <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">       <span class="comment">// 处理新的连接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">       <span class="comment">// 读取数据</span></span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">       <span class="comment">// 写入数据</span></span><br><span class="line">   &#125;</span><br><span class="line">   iterator.remove(); <span class="comment">// 清除已处理的key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><p><strong>非阻塞性</strong></p><p>NIO允许应用程序在等待I&#x2F;O操作完成时执行其他任务，这在处理大量并发连接时特别有用，因为不必为每个连接分配一个线程。</p></li><li><p><strong>资源效率</strong></p><p>由于NIO使用较少的线程来处理更多的连接，因此可以显著降低系统的资源消耗，提高服务器的负载能力。</p></li><li><p><strong>高性能</strong></p><p>NIO通过使用Buffer和Channel，减少了数据复制的次数，提高了数据处理的速度。此外，使用Selector可以高效地管理多个Channel，避免了轮询的开销。</p></li><li><p><strong>灵活性</strong></p><p>NIO提供了更高级别的抽象，如文件映射缓冲区，允许直接在内存映射文件上操作，这在大数据量的文件处理中非常高效。</p></li><li><p><strong>异步操作</strong></p><p>NIO支持异步文件操作，如异步读写，这在处理大文件或长时间运行的任务时非常有用。</p></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li><p><strong>复杂性</strong></p><p>NIO的API比传统的IO API更复杂，需要程序员对Buffer、Channel和Selector有深入的理解才能正确使用。</p><p>此外开发者还需要花费很多时间去学习NIO的概念和编程模式，这对于习惯了传统IO的开发者来说可能是一个挑战。</p></li><li><p>调试难度</p><p>NIO的非阻塞性质使得调试和定位问题变得困难，尤其是当涉及到复杂的并发问题时。</p></li><li><p>兼容性</p><p>NIO的一些高级特性可能在某些老旧的JVM版本或操作系统上不受支持，这可能限制了其在某些环境下的应用。</p></li><li><p>错误处理</p><p>错误处理在NIO中更加复杂，因为错误可能不会立即显现，而是会在后续的I&#x2F;O操作中才被发现。</p></li><li><p>线程安全</p><p>在多线程环境中使用NIO需要额外注意线程安全，因为Buffer和Channel的操作需要在适当的同步机制下进行</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Netty%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/Netty%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Netty-概述"><a href="#Netty-概述" class="headerlink" title="Netty 概述"></a>Netty 概述</h1><h2 id="Netty-总体内容"><a href="#Netty-总体内容" class="headerlink" title="Netty 总体内容"></a>Netty 总体内容</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/CgqCHl-NAQaABGcDAAZa0pmBs40719.png" alt="CgqCHl-NAQaABGcDAAZa0pmBs40719"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/420lgrdxx7.png" alt="img"></p><ul><li>基础知识<ul><li>Java NIO：Netty 基于 Java NIO 构建，因此理解 NIO 的概念（如 Selector, Channel, Buffer）是非常重要的。</li><li>多线程：熟悉 Java 的多线程编程，理解线程模型和并发控制。</li><li>网络编程：了解 TCP&#x2F;IP 协议栈，熟悉网络编程的基本原理和术语。</li></ul></li><li>Netty 核心概念<ul><li>EventLoop 和 EventLoopGroup：理解 Netty 的事件循环机制，如何管理和调度 I&#x2F;O 任务。</li><li>Channel 和 ChannelHandlerContext：Channel 是 Netty 中 I&#x2F;O 操作的中心，而 ChannelHandlerContext 提供了对 Channel 的操作上下文。</li><li>Pipeline：理解 Channel 的 Pipeline 概念，以及如何使用 Inbound 和 Outbound handlers 来处理 I&#x2F;O 事件。</li><li>Bootstrap：Bootstrap 是启动 Netty 服务的起点，用于配置服务的参数和初始化 Channel。</li></ul></li><li>编码和解码<ul><li>ByteBuf：Netty 中用于操作字节缓冲区的类，了解如何使用 ByteBuf 进行数据读写。</li><li>Codec：学习如何使用编解码器（Encoder 和 Decoder）来处理数据的序列化和反序列化。</li><li>MessageToMessageEncoder &#x2F; MessageToMessageDecoder：用于在不同消息类型之间转换的编解码器。</li></ul></li><li>网络协议<ul><li>HTTP&#x2F;HTTPS：Netty 支持多种协议，了解如何使用 Netty 开发 HTTP 或 HTTPS 服务器和客户端。</li><li>WebSocket：学习 WebSocket 协议的实现，以及如何使用 Netty 构建 WebSocket 服务。</li></ul></li><li>高级特性<ul><li>ChannelFuture：用于异步操作的结果和回调。</li><li>ChannelPromise：用于异步操作的承诺，通常在 ChannelFuture 的回调中使用。</li><li>ChannelOption 和 Attribute：了解如何配置 Channel 的选项和附加属性。</li><li>自定义 Handler：学习如何开发自定义的 ChannelHandler 来处理特定的 I&#x2F;O 事件。</li></ul></li><li>性能优化<ul><li>Zero-Copy：理解 Netty 中的零拷贝技术，如何减少数据复制以提高性能。</li><li>内存管理：了解 Netty 的内存管理机制，以及如何避免内存泄漏。</li></ul></li><li>故障处理和调试<ul><li>异常处理：学习如何处理 Netty 中可能出现的各种异常和错误。</li><li>日志记录：了解如何配置和使用日志记录来调试和监控 Netty 应用程序。</li></ul></li></ul><h2 id="Netty-入门"><a href="#Netty-入门" class="headerlink" title="Netty 入门"></a>Netty 入门</h2><h3 id="HelloWorld-案例"><a href="#HelloWorld-案例" class="headerlink" title="HelloWorld 案例"></a>HelloWorld 案例</h3><p><strong>服务端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//创建两个线程组 boosGroup、workerGroup</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务端的启动对象，设置参数</span></span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            <span class="comment">//设置两个线程组boosGroup和workerGroup</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">//设置服务端通道实现类型    </span></span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                <span class="comment">//设置线程队列得到连接个数    </span></span><br><span class="line">                .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                <span class="comment">//设置保持活动连接状态    </span></span><br><span class="line">                .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                <span class="comment">//使用匿名内部类的形式初始化通道对象    </span></span><br><span class="line">                .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//给pipeline管道设置处理器</span></span><br><span class="line">                            socketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.bind(<span class="number">7777</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//获取客户端发送过来的消息</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发送消息给客户端</span></span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;message received&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发生异常，关闭通道</span></span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建bootstrap对象，配置参数</span></span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            <span class="comment">//设置线程组</span></span><br><span class="line">            bootstrap.group(eventExecutors)</span><br><span class="line">                <span class="comment">//设置客户端的通道实现类型    </span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">//使用匿名内部类初始化通道</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">//添加客户端通道的处理器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">MyClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="comment">//连接服务端</span></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>).sync();</span><br><span class="line">            <span class="comment">//对通道关闭进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭线程组</span></span><br><span class="line">            eventExecutors.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyClientHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelInboundHandlerAdapter</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//发送消息到服务端</span></span><br><span class="line">            ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;Hello Server&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">//接收服务端发送过来的消息</span></span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心组件-属性"><a href="#核心组件-属性" class="headerlink" title="核心组件&#x2F;属性"></a>核心组件&#x2F;属性</h3><ul><li>ServerBootStrap &#x2F; BootStrap</li><li>EventLoopGroup — bossGroup &#x2F; workerGroup</li><li>option &#x2F; childOption</li><li>pipeline</li><li>handler</li><li>channel</li><li>ChannelHandlerContext</li><li>ByteBuf</li></ul><p>后续会对其中的组件分别进行介绍</p>]]></content>
      
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO 概述</title>
      <link href="/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/IO%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/07/16/%E6%A1%86%E6%9E%B6/Netty/Netty%20%E5%9F%BA%E7%A1%80/IO%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="IO-概述"><a href="#IO-概述" class="headerlink" title="IO 概述"></a>IO 概述</h1><p>输入&#x2F;输出（Input&#x2F;Output，简称I&#x2F;O）是计算机科学中的基本概念，涉及计算机与外部世界的数据交换。I&#x2F;O操作可以发生在硬件设备之间，也可以在软件与硬件之间进行。下面是对I&#x2F;O系统的全面介绍，包括其概念、分类、模型以及在现代操作系统中的实现。</p><h2 id="I-O的概念"><a href="#I-O的概念" class="headerlink" title="I&#x2F;O的概念"></a>I&#x2F;O的概念</h2><p>I&#x2F;O是指计算机系统与外部环境之间的数据传输过程。输入操作是从外部设备读取数据到计算机系统，而输出操作是将数据从计算机系统发送到外部设备。外部设备可以是键盘、鼠标、显示器、打印机、磁盘驱动器、网络接口卡等。</p><h2 id="I-O的分类"><a href="#I-O的分类" class="headerlink" title="I&#x2F;O的分类"></a>I&#x2F;O的分类</h2><p>I&#x2F;O可以按照不同的标准进行分类：</p><ul><li>按设备类型：分为字符设备（如键盘、终端）和块设备（如硬盘、光驱）。</li><li>按数据传输方向：分为输入（从设备到系统）和输出（从系统到设备）。</li><li>按数据传输方式：分为串行I&#x2F;O和并行I&#x2F;O。</li><li>按数据传输速度：分为高速I&#x2F;O和低速I&#x2F;O。</li><li>按数据传输协议：分为USB、PCI、SATA、Ethernet等。</li></ul><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>I&#x2F;O模型描述了数据如何在用户空间和内核空间之间传输，主要有以下几种：</p><ul><li><strong>阻塞I&#x2F;O</strong>（Blocking I&#x2F;O）：是最常见的模型，当进程发起I&#x2F;O请求时，它会被挂起直到I&#x2F;O操作完成。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125534850-1197249268.png" alt="img"></p><ul><li><strong>非阻塞I&#x2F;O</strong>（Non-blocking I&#x2F;O）：进程发起I&#x2F;O请求后不会被挂起，而是立即返回，如果数据不可用则返回一个错误。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125615836-918812694.png" alt="img"></p><ul><li><strong>I&#x2F;O多路复用</strong>（I&#x2F;O Multiplexing）：使用如select、poll或epoll等系统调用，可以让单个进程同时监听多个文件描述符的I&#x2F;O事件。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125835677-896662204.png" alt="img"></p><ul><li><strong>异步I&#x2F;O</strong>（Asynchronous I&#x2F;O）：进程发起I&#x2F;O请求后继续执行，当I&#x2F;O操作完成时，系统会通知进程。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125908929-2128858514.png" alt="img"></p><ul><li><strong>信号驱动I&#x2F;O</strong>（Signal-driven I&#x2F;O）：类似于异步I&#x2F;O，但使用信号来通知进程I&#x2F;O事件的发生。</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125811408-1472626030.png" alt="img"></p><h3 id="基本分类依据"><a href="#基本分类依据" class="headerlink" title="基本分类依据"></a>基本分类依据</h3><ul><li>阻塞&#x2F;非阻塞（Blocking vs Non-blocking）<ul><li>阻塞I&#x2F;O（Blocking I&#x2F;O）<ul><li>当一个线程发起一个阻塞I&#x2F;O操作时，该线程会暂停执行，直到I&#x2F;O操作完成。</li><li>在此期间，线程不能执行任何其他任务，这可能浪费计算资源，尤其是在I&#x2F;O操作耗时较长的情况下。</li><li>阻塞I&#x2F;O常用于单线程或多线程环境中的简单I&#x2F;O操作。</li></ul></li><li>非阻塞I&#x2F;O（Non-blocking I&#x2F;O）<ul><li>当一个线程发起一个非阻塞I&#x2F;O操作时，如果I&#x2F;O操作不能立即完成，该操作会立即返回一个错误或特殊值，线程可以继续执行其他任务。</li><li>线程需要定期检查I&#x2F;O操作是否完成，这通常通过轮询或使用I&#x2F;O多路复用来实现。</li><li>非阻塞I&#x2F;O允许线程在等待I&#x2F;O的同时执行其他工作，提高了资源利用率。</li></ul></li></ul></li><li>同步&#x2F;异步（Synchronous vs Asynchronous）<ul><li>同步（Synchronous）<ul><li>在同步操作中，调用者发出一个请求后，必须等待直到请求完成才能继续执行后续代码。</li><li>请求的响应是同步返回的，调用者在等待响应时无法执行其他任务。</li><li>同步操作通常用于短时间操作或在单线程环境中。</li></ul></li><li>异步（Asynchronous）<ul><li>在异步操作中，调用者发出一个请求后，可以立即继续执行后续代码，无需等待请求完成。</li><li>请求的响应会在将来某个时刻通过回调、事件、future&#x2F;promise等方式返回，调用者可以在此期间执行其他任务。</li><li>异步操作适用于长时间运行的操作或在多线程&#x2F;多进程环境中。</li></ul></li></ul></li><li>区别总结<ul><li>阻塞&#x2F;非阻塞 关注的是线程在等待I&#x2F;O操作时的状态，即是否会被挂起。</li><li>同步&#x2F;异步 关注的是调用者在等待操作完成时的行为，即是否可以继续执行其他操作。</li></ul></li></ul><h2 id="I-O在操作系统中的实现"><a href="#I-O在操作系统中的实现" class="headerlink" title="I&#x2F;O在操作系统中的实现"></a>I&#x2F;O在操作系统中的实现</h2><p>在现代操作系统中，I&#x2F;O操作的实现通常涉及以下几个关键组件：</p><ul><li>设备驱动程序：负责与物理设备通信，提供设备的抽象接口。</li><li>缓冲区管理：操作系统使用缓冲区来缓存数据，以减少对物理设备的访问次数，提高性能。</li><li>中断处理：设备完成I&#x2F;O操作后，会向CPU发送中断信号，操作系统会响应中断并处理I&#x2F;O结果。</li><li>系统调用：如read、write、open、close等，提供用户空间与内核空间交互的接口。</li></ul><h2 id="I-O性能优化"><a href="#I-O性能优化" class="headerlink" title="I&#x2F;O性能优化"></a>I&#x2F;O性能优化</h2><p>为了提高I&#x2F;O性能，操作系统和应用程序可能会采用以下策略：</p><ul><li>缓存：使用高速缓存来减少对慢速设备的访问。</li><li>DMA（Direct Memory Access）：允许设备直接访问内存，无需CPU介入，提高数据传输速度。</li><li>并发：通过多线程或异步I&#x2F;O，允许多个I&#x2F;O操作同时进行。</li><li>批处理：一次处理多个I&#x2F;O请求，减少I&#x2F;O操作的开销。</li><li>预测性I&#x2F;O：基于历史模式预测未来的I&#x2F;O请求，提前加载数据。</li></ul><h2 id="IO-交互过程"><a href="#IO-交互过程" class="headerlink" title="IO 交互过程"></a>IO 交互过程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125037162-803835128.png" alt="img"></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1574180-20191128125247097-1784257745.png" alt="img"></p><p>内核空间中存放的是内核代码和数据、而进程的用户空间中存放的是用户程序的代码和数据、不管是内核空间还是用户空间、它们都处于虚拟空间中、Linux使用两级保护机制：0级供内核使用、3级供用户程序使用、</p><p> 操作系统和驱动程序运行在内核空间、应用程序运行在用户空间、两者不能简单地使用指针传递数据、因为Linux使用的虚拟内存机制、其必须通过系统调用请求kernel来协助完成IO动作、内核会为每个IO设备维护一个缓冲区、用户空间的数据可能被换出、当内核空 间使用用户空间指针时、对应的数据可能不在内存中</p><p>对于一个输入操作来说、进程IO系统调用后、内核会先看缓冲区中有没有相应的缓存数据、没有的话再到设备中读取、因为设备IO一般速度较慢、需要等待、内核缓冲区有数据则直接复制到进程空间、</p><p>所以、对于一个网络输入操作通常包括两个不同阶段：</p><p>（1）等待网络数据到达网卡 –&gt; 读取到内核缓冲区</p><p>（2）从内核缓冲区复制数据 –&gt; 用户空间</p><p>IO有内存IO、网络IO和磁盘IO三种、通常我们说的IO指的是后两者</p>]]></content>
      
      
      
        <tags>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/1、HTTP/2 和 HTTP/3 对比</title>
      <link href="/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/QUIC%20%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/QUIC%20%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="QUIC-协议介绍"><a href="#QUIC-协议介绍" class="headerlink" title="QUIC 协议介绍"></a>QUIC 协议介绍</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>QUIC，发音同quick，是”Quick UDP Internet Connections”的简称，是一种通用的传输层网络协议。QUIC与TCP相同，是一种有连接的传输协议。但是与TCP不同的是QUIC是建立在UDP传输层协议之上的，实现了在两个端点之间的多路复用。QUIC的是在用户空间实现的，TCP&#x2F;UDP则是在内核空间实现的。</p><p>QUIC所处的网络层次如下图所示。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194320126-1654964147.png" style="zoom:67%;" /><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：<br>1、减少了 TCP 三次握手及 TLS 握手时间。<br>2、改进的拥塞控制。<br>3、避免队头阻塞的多路复用。<br>4、连接迁移。<br>5、前向安全。</p><h3 id="快速建联"><a href="#快速建联" class="headerlink" title="快速建联"></a>快速建联</h3><p>QUIC实现了快速握手，并把握手过程分为两种情况，分别是1-RTT和0-RTT。（前置知识： Diffie-Hellman算法的基本原理）</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194321095-535625030.png" alt="image_202"></p><p>在上图中显示了三种不同情况的连接过程。其中最左边的图表示的是第一次连接时的情况，中间的图表示重复连接的情况（在一定条件下，客户端可以重新连接服务器而不需要从初始化情况连接），最右边的图则是重连失败之后从初始话连接的情况。最后一种情况是第一种情况的组会，0-RTT也是1-RTT的一部分，后文中将重点介绍1-RTT的连接过程。</p><h4 id="1-RTT"><a href="#1-RTT" class="headerlink" title="1-RTT"></a>1-RTT</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194321846-1226453431.png" alt="QUIC_1_RTT"></p><p><strong>第一次握手</strong>：</p><ul><li>客户端主动向服务器发送Inchoate CHLO报文</li><li>服务器会向客户端发送REJ报文。REJ报文包含了服务器的配置信息，如长期的Diffie-Hellman值，服务器配置的签名，source-address-token(stk, 用于验证的加密块，包含有服务器看到的客户端的IP地址和服务器当前的时间戳，之后客户端会将该stk发回)等，为了进行身份证明还会使用私钥进行签名，同时也可以防篡改；</li><li>在收到服务器的配置信息后，客户端会通过证书链机制验签，并实现对服务器的身份认证。</li></ul><p><strong>第二次握手</strong>：</p><ul><li>客户端在通过对服务器的验证之后，客户端会生成一个Diffie-Hellman值。此时客户端有了自身和对方的Diffie-Hellman值，就可以计算出初始密钥（initial key, ik）；</li><li>客户端将包含有DH公开之的明文Complete CHLO发送至服务器；</li><li>客户端使用ik对请求数据加密，发送至服务器；</li><li>服务器收到Complete CHLO之后就可以获得客户端的Diffie-Hellman的值，就可以计算出初始密钥。</li><li>服务器立即向客户端发送SHLO报文（ik加密的）。SHLO报文含有一个服务器临时Diffie-Hellman值，可以用于计算前向安全的密钥（会话密钥）；</li><li>服务器收到加密的请求数据，使用初始密钥进行解密；</li><li>服务器使用会话密钥对响应数据进行加密，发回给客户端。</li><li>客户端在收到SHLO之后使用初始密钥解密得到服务器的临时DH公开值，根据该临时值计算出会话密钥；</li><li>客户端收到加密的响应数据后，使用会话密钥进行解密。</li></ul><p>整个握手过程会在2个RTT内完成。</p><h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p>客户端在重连同一个服务器时，会使用已经缓存的服务器相关配置信息（stk，DH公开值等信息），并直接向服务器发送Complete CHLO报文，并使用ik对请求报文进行加密。但是服务器方面会标识相应的stk等信息已经过期，这时服务器会发送REJ信息，客户端需要重新与服务器进行连接。</p><p>如果没有过期的话，就可以直接建立连接，省下了重新建立连接的开销。</p><p>【注】其实需要发送 initial 报文，明文提供历史会话信息 和 客户端 ID ，供服务端查找 PSK </p><h4 id="多路复用机制"><a href="#多路复用机制" class="headerlink" title="多路复用机制"></a>多路复用机制</h4><p>基于TCP的应用程序会在TCP单字节流抽象层中实现多路复用。为了避免由于TCP顺序传递导致的头部阻塞（head-of-line blocking），QUIC支持在单个UDP连接中复用多个流，并保证UDP报文的丢失仅影响相应的流，而不会影响其他的流（stream）。</p><p>可以在QUIC流上构建任意大小的应用程序报文，最多支持264264的字节。并且stream的实现是轻量级的，即使消息报文很小也可以为它们使用单独的流。每一个Stream都有stream ID唯一标识。这些流ID由客户端&#x2F;服务器进行静态分配。客户端主动发起的流的ID永远是奇数，服务器发起的流的ID是偶数。这样可以避免冲突。当在一个未使用过的流上发送数据时，流会自动创建；当需要关闭时，就会在最后一帧数据上设置一个FIN的标志指示接收方关闭流。如果发送方或接收方确定不再需要流上的数据，则可以取消流，而无需断开整个 QUIC 连接。尽管流是可靠的抽象，但 QUIC 不会为已取消的流重新传输数据。</p><p>一个QUIC包是由一个公共的头后面跟着一个或多个帧组成的，如下图所示。QUIC流复用是通过将流数据封装在一个或多个流帧中来实现的，单个QUIC包可以携带来自多个流的流帧.</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1653979-20220307194322442-307715805.png" alt="image_205"></p><h3 id="丢包重传"><a href="#丢包重传" class="headerlink" title="丢包重传"></a>丢包重传</h3><p>TCP 序列号有助于提高可靠性，并表示在接收方传送字节的顺序。这种混淆会导致“重传模糊”（retransmission ambiguity）问题，因为重传的 TCP 段携带与原始数据包相同的序列号 。 TCP ACK 的接收者无法确定 ACK 是为原始传输还是为重传而发送，并且通常通过昂贵的超时来检测重传段的丢失。每个 QUIC 数据包都携带一个新的数据包编号，包括那些携带重传数据的数据包。这种设计不需要单独的机制来区分重传的 ACK 和原始传输的 ACK，从而避免了 TCP 的重传模糊问题。流帧中的流偏移用于传递排序，数据包编号表示一个明确的时间顺序，这使得丢失检测比 TCP 更简单、更准确。</p><p>QUIC的ACK显示地记录了接收的数据报文和ACK之间的延迟。单调增加的报文编号一起，可以精确估算RTT，有助于丢失检测。QUIC的确认报文支持多达256个ACK，这是使得QUIC比带有SACK的TCP更能适应重新排序或丢失的情况下在线路上保留更多字节。</p><h3 id="流量控制-Flow-Control"><a href="#流量控制-Flow-Control" class="headerlink" title="流量控制(Flow Control)"></a>流量控制(Flow Control)</h3><p>当应用程序从QUIC的接收缓冲区中读取数据较慢时，留恋控制就会限制接收者必须保持的接收缓冲区大小。一个缓慢耗尽的stream会逐渐耗尽整个连接connection的缓冲区，因此必须要限制QUIC连接上的每个流可以消耗的缓冲区大小，避免消耗其他流的缓冲区的大小。这样可以改善流之间潜在的队头阻塞（head-of-line blocking）。因此QUIC采用连接级别的流量控制（connection-level flow control），这样可以限制发送者在所有流中接收者使用的聚合缓冲区；采用流级别的流量控制(stream-level flow control)可以限制发送者在任何给定流上使用的缓冲区。</p><p>与HTTP&#x2F;2类似，QUIC采用基于信用的流量控制。QUIC接收器在每个流中通告接收器愿意接收数据的绝对字节偏移量。在特定流上发送、接收和传递数据时，接收器会定期发送窗口更新帧，以增加该流的窗口偏移限制，从而允许对等方在该流上发送更多数据。连接级流量控制的工作方式与流级流量控制相同，但传递的字节数和接收到的最高偏移量是所有流的。</p><h3 id="拥塞控制（Congestion-Control）"><a href="#拥塞控制（Congestion-Control）" class="headerlink" title="拥塞控制（Congestion Control）"></a>拥塞控制（Congestion Control）</h3><p>QUIC支持的拥塞控制算法有：<br>Reno（TCP用的）、基于Pacing的拥塞控制算法（PBCCA）、TCP CUBIC等。</p><h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>QUIC连接使用随机生成的64bit的cid唯一确定。cid允许客户机在网络之间漫游，而不受网络或传输层参数变化的影响。</p><p>cid使得客户端能够独立于网络地址转换（network address translation, NAT）之外。cid 在路由中起着重要作用，特别是用于连接标识的目的。此外，使用 cids 可以通过探测连接的新路径实现多路径。</p><p>在连接迁移期间，端点假设对等方愿意在其当前地址接受数据包。因此，端点可以迁移到新的 IP 地址，而无需首先验证对等方的 IP 地址。新的路由路径可能不支持端点的当前发送速率。在这种情况下，端点需要重新构建它的拥塞控制器。另一方面，从一个新的对等地址接收非探测包 ，确认对等地址已迁移到新的 IP 地址。</p><h2 id="QUIC-协议的安全风险分析"><a href="#QUIC-协议的安全风险分析" class="headerlink" title="QUIC 协议的安全风险分析"></a>QUIC 协议的安全风险分析</h2><h3 id="1-重放攻击"><a href="#1-重放攻击" class="headerlink" title="1. 重放攻击"></a>1. 重放攻击</h3><p>QUIC 协议中的 0-RTT 握手机制虽然显著减少了连接建立的延迟，但也带来了重放攻击的风险。在 0-RTT 握手中，客户端可以在首次发送数据包时就包含应用数据，这使得攻击者可以通过重发这些数据包来完成攻击。</p><p><strong>应对措施</strong>：</p><ul><li><strong>幂等性</strong>：QUIC 对帧的处理是幂等的，无论是重放、重排序、包丢失，都不会导致无效的连接状态。</li><li><strong>校验机制</strong>：0-RTT 握手时，QUIC 要求客户端传输 TLS 会话 ticket 和地址验证 token，使得连接状态高效地检查和恢复。</li><li><strong>关闭 0-RTT</strong>：关闭 0-RTT 是对抗重放攻击最有效的手段。如果要使用 0-RTT，QUIC 要求应用程序做进一步的安全校验。</li></ul><h3 id="2-连接迁移中的安全风险"><a href="#2-连接迁移中的安全风险" class="headerlink" title="2. 连接迁移中的安全风险"></a>2. 连接迁移中的安全风险</h3><p>QUIC 支持连接迁移，允许客户端在不同网络之间无缝切换。然而，这一特性也可能被攻击者利用，例如通过篡改连接 ID 或源地址 token 来发起攻击。</p><p><strong>应对措施</strong>：</p><ul><li><strong>IP 地址验证</strong>：QUIC 使用特殊的机制来验证新的客户端地址，例如服务器发送一个特殊的探测包到新地址，客户端必须正确响应这个探测才能完成迁移。</li><li><strong>限制连接迁移</strong>：在某些高安全需求的场景中，可以限制连接迁移的使用，或者对迁移后的连接进行额外的安全检查。</li></ul><h3 id="3-反射放大攻击"><a href="#3-反射放大攻击" class="headerlink" title="3. 反射放大攻击"></a>3. 反射放大攻击</h3><p>QUIC 协议在设计之初就考虑了防止反射放大攻击的安全风险，但实际应用中仍存在被利用的可能性。攻击者可以利用 QUIC 服务器作为反射放大器，发送大量恶意的 Initial 请求，消耗服务器资源和带宽，甚至导致拒绝服务。</p><p><strong>应对措施</strong>：</p><ul><li><strong>流量监测与过滤</strong>：对 QUIC 流量进行实时监测，识别并过滤异常流量，特别是那些具有反射放大特征的流量。</li><li><strong>限制请求来源</strong>：通过限制请求来源的 IP 地址范围或域名，减少反射放大攻击的可能性。</li><li><strong>使用专业的 DDoS 防护服务</strong>：在面对大规模反射放大攻击时，建议寻求专业的 DDoS 防护团队协助。</li></ul><h3 id="4-前向安全性"><a href="#4-前向安全性" class="headerlink" title="4. 前向安全性"></a>4. 前向安全性</h3><p>QUIC 协议支持前向安全性，即使长期密钥被泄露，过去的通信仍然是安全的。这一特性通过定期更新加密密钥来实现。</p><p><strong>潜在风险</strong>：</p><ul><li><strong>密钥更新机制的实现问题</strong>：如果密钥更新机制没有正确实现，可能会导致前向安全性受损。</li></ul><p><strong>应对措施</strong>：</p><ul><li><strong>严格遵循协议规范</strong>：确保 QUIC 实现严格遵循协议规范，正确实现密钥更新机制。</li><li><strong>定期审计与测试</strong>：对 QUIC 实现进行定期的安全审计和测试，确保前向安全性机制的有效性。</li></ul><h3 id="5-其他安全风险"><a href="#5-其他安全风险" class="headerlink" title="5. 其他安全风险"></a>5. 其他安全风险</h3><ul><li><strong>源地址 token 操作攻击</strong>：攻击者可以篡改源地址 token，导致客户端和服务器生成不同的密钥，从而无法完成正常的信息交流。</li><li><strong>加密流偏移攻击</strong>：攻击者可以通过反转字节流数据，破坏字节流，导致连接建立失败。</li></ul><p><strong>应对措施</strong>：</p><ul><li><strong>增强加密机制</strong>：使用更强大的加密算法和密钥管理机制，减少此类攻击的风险。</li><li><strong>应用层防护</strong>：在应用层实现额外的安全校验机制，确保数据的完整性和一致性。</li></ul><h2 id="QUIC-实施难点与应对策略"><a href="#QUIC-实施难点与应对策略" class="headerlink" title="QUIC 实施难点与应对策略"></a>QUIC 实施难点与应对策略</h2><h3 id="中间设备兼容性"><a href="#中间设备兼容性" class="headerlink" title="中间设备兼容性"></a>中间设备兼容性</h3><p>许多现有的防火墙和 NAT 设备可能不理解或不支持 QUIC 协议，可能会错误地阻止 QUIC 流量。此外，传统的基于 TCP 的负载均衡器可能无法正确处理 QUIC 流量。</p><h4 id="应对策略："><a href="#应对策略：" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>升级防火墙、NAT 设备和负载均衡器，以支持 QUIC 协议。</li><li>使用支持 QUIC 的网络监控工具，以确保网络的可管理性和安全性。</li></ul><h3 id="CPU-使用率"><a href="#CPU-使用率" class="headerlink" title="CPU 使用率"></a>CPU 使用率</h3><p>QUIC 默认对所有数据进行加密，这增加了 CPU 的计算负担。在高吞吐量场景下，这可能导致服务器和客户端的 CPU 使用率显著增加。</p><h4 id="应对策略：-1"><a href="#应对策略：-1" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>使用更高效的加密算法，减少加密开销。</li><li>利用硬件加速技术（如 GPU 或专用加密芯片）来处理加密和包处理任务。</li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>由于 QUIC 流量是加密的，传统的网络分析工具可能无法提供详细的可见性。这增加了识别和解决网络问题的难度。</p><h4 id="应对策略：-2"><a href="#应对策略：-2" class="headerlink" title="应对策略："></a><strong>应对策略</strong>：</h4><ul><li>使用支持 QUIC 协议的调试工具，如 Wireshark。</li><li>在应用程序和服务中实现详细的日志记录功能，以便在出现问题时能够快速定位和解决。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP/1、HTTP/2 和 HTTP/3 对比</title>
      <link href="/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1%20HTTP2%20HTTP3%20%20%E6%BC%94%E5%8C%96%E4%B8%8E%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2024/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP1%20HTTP2%20HTTP3%20%20%E6%BC%94%E5%8C%96%E4%B8%8E%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-1、HTTP-2-和-HTTP-3-对比：关键特性与演变"><a href="#HTTP-1、HTTP-2-和-HTTP-3-对比：关键特性与演变" class="headerlink" title="HTTP&#x2F;1、HTTP&#x2F;2 和 HTTP&#x2F;3 对比：关键特性与演变"></a>HTTP&#x2F;1、HTTP&#x2F;2 和 HTTP&#x2F;3 对比：关键特性与演变</h2><h3 id="HTTP-1-0：基础与局限"><a href="#HTTP-1-0：基础与局限" class="headerlink" title="HTTP&#x2F;1.0：基础与局限"></a>HTTP&#x2F;1.0：基础与局限</h3><h4 id="关键特性：短连接"><a href="#关键特性：短连接" class="headerlink" title="关键特性：短连接"></a>关键特性：短连接</h4><p>HTTP&#x2F;1.0 是 HTTP 协议的第一个广泛应用版本，其核心特性是<strong>短连接</strong>。每次请求都需要建立一个新的 TCP 连接，请求完成后立即关闭连接。这种机制简单直接，但存在显著的性能问题：</p><ul><li><strong>高延迟</strong>：频繁建立和关闭 TCP 连接导致高延迟。</li><li><strong>资源消耗</strong>：每个请求都需要完整的 TCP 三次握手和四次挥手。</li></ul><p>此外，HTTP&#x2F;1.0 的协议结构简单，仅支持基本的请求方法（如 GET、POST）和头部字段。虽然引入了基础的缓存支持（如 <code>Expires</code> 字段），但缺乏细粒度的缓存控制。</p><h3 id="HTTP-1-1：性能优化与持久连接"><a href="#HTTP-1-1：性能优化与持久连接" class="headerlink" title="HTTP&#x2F;1.1：性能优化与持久连接"></a>HTTP&#x2F;1.1：性能优化与持久连接</h3><h4 id="关键特性：持久连接与管道化"><a href="#关键特性：持久连接与管道化" class="headerlink" title="关键特性：持久连接与管道化"></a>关键特性：持久连接与管道化</h4><p>HTTP&#x2F;1.1 在 HTTP&#x2F;1.0 的基础上引入了<strong>持久连接</strong>和<strong>管道化</strong>。持久连接允许在单个 TCP 连接上发送多个请求和响应，减少了连接建立和关闭的开销。管道化则允许客户端在收到上一个响应之前发送下一个请求，提高了请求的并发性。</p><p>然而，HTTP&#x2F;1.1 仍然存在<strong>队头阻塞</strong>问题。由于响应必须按顺序返回，一个慢响应会阻塞后续响应。此外，HTTP&#x2F;1.1 的头部信息冗余较高，每个请求都会发送完整的头部信息。</p><h3 id="HTTP-2：二进制分帧与多路复用"><a href="#HTTP-2：二进制分帧与多路复用" class="headerlink" title="HTTP&#x2F;2：二进制分帧与多路复用"></a>HTTP&#x2F;2：二进制分帧与多路复用</h3><h4 id="关键特性：二进制分帧与多路复用"><a href="#关键特性：二进制分帧与多路复用" class="headerlink" title="关键特性：二进制分帧与多路复用"></a>关键特性：二进制分帧与多路复用</h4><p>HTTP&#x2F;2 的核心特性是<strong>二进制分帧</strong>和<strong>多路复用</strong>。二进制分帧机制将数据划分为更小的帧，这些帧可以独立传输和重组，使得协议解析更高效。多路复用则允许在单个 TCP 连接上并行发送多个请求和响应，解决了 HTTP&#x2F;1.1 的队头阻塞问题。</p><p>HTTP&#x2F;2 还引入了<strong>头部压缩</strong>（HPACK 算法），减少了头部信息的冗余。此外，HTTP&#x2F;2 支持<strong>服务器推送</strong>，允许服务器主动向客户端推送资源，优化了页面加载速度。</p><h3 id="HTTP-3：基于-QUIC-的下一代协议"><a href="#HTTP-3：基于-QUIC-的下一代协议" class="headerlink" title="HTTP&#x2F;3：基于 QUIC 的下一代协议"></a>HTTP&#x2F;3：基于 QUIC 的下一代协议</h3><h4 id="关键特性：QUIC-协议"><a href="#关键特性：QUIC-协议" class="headerlink" title="关键特性：QUIC 协议"></a>关键特性：QUIC 协议</h4><p>HTTP&#x2F;3 是基于 QUIC 协议的下一代 HTTP 协议。QUIC 是一种基于 UDP 的传输层协议，旨在减少网络延迟，提高网络速度。HTTP&#x2F;3 的核心特性包括：</p><ul><li><strong>连接迁移</strong>：通过引入 Connection ID，HTTP&#x2F;3 支持连接迁移，即使客户端的 IP 地址或端口发生变化，连接依然可以维持。</li><li><strong>无队头阻塞</strong>：QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流，解决了 TCP 中队头阻塞的问题。</li><li><strong>更快的连接建立</strong>：QUIC 允许 TLS 版本协商与加密和传输握手同时发生，显著减少了连接建立时间。</li><li><strong>零往返时间（0-RTT）</strong>：对于已经连接的服务器，客户端可以跳过握手要求，进一步减少了延迟。</li></ul><h3 id="关键特性对比"><a href="#关键特性对比" class="headerlink" title="关键特性对比"></a>关键特性对比</h3><table><thead><tr><th align="left">特性</th><th align="left">HTTP&#x2F;1.0</th><th align="left">HTTP&#x2F;1.1</th><th align="left">HTTP&#x2F;2</th><th align="left">HTTP&#x2F;3</th></tr></thead><tbody><tr><td align="left"><strong>连接管理</strong></td><td align="left">短连接（每次请求新建连接）</td><td align="left">持久连接（默认 keep-alive）</td><td align="left">多路复用（一个连接并行处理）</td><td align="left">基于 UDP 的 QUIC，无 TCP 连接</td></tr><tr><td align="left"><strong>数据传输</strong></td><td align="left">文本格式</td><td align="left">文本格式</td><td align="left">二进制格式</td><td align="left">二进制格式</td></tr><tr><td align="left"><strong>队头阻塞</strong></td><td align="left">存在</td><td align="left">存在（管道化部分缓解）</td><td align="left">完全解决</td><td align="left">完全解决</td></tr><tr><td align="left"><strong>头部压缩</strong></td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持（HPACK 算法）</td><td align="left">支持（QPACK 算法）</td></tr><tr><td align="left"><strong>服务器推送</strong></td><td align="left">不支持</td><td align="left">不支持</td><td align="left">支持</td><td align="left">支持</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">无</td><td align="left">无</td><td align="left">通常基于 HTTPS</td><td align="left">通常基于 HTTPS</td></tr><tr><td align="left"><strong>性能</strong></td><td align="left">低</td><td align="left">中等</td><td align="left">高</td><td align="left">最高</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTTP&#x2F;1.0 作为基础版本，虽然简单但存在性能瓶颈。HTTP&#x2F;1.1 通过持久连接和管道化显著提升了性能，但仍存在队头阻塞问题。HTTP&#x2F;2 通过二进制分帧和多路复用解决了队头阻塞问题，显著提升了并发性能。HTTP&#x2F;3 基于 QUIC 协议，进一步解决了 TCP 的队头阻塞问题，并支持连接迁移，显著提升了网络性能和用户体验。</p><p>在实际应用中，选择合适的 HTTP 版本需要根据具体需求进行权衡。对于高性能和低延迟的需求，HTTP&#x2F;3 是最佳选择；对于一般的 Web 应用，HTTP&#x2F;2 已经能够提供良好的性能；而对于一些对性能要求不高的场景，HTTP&#x2F;1.1 仍然可以使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 应用层</title>
      <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络-——-应用层"><a href="#计算机网络-——-应用层" class="headerlink" title="计算机网络 —— 应用层"></a>计算机网络 —— 应用层</h1><h2 id="常见应用层协议"><a href="#常见应用层协议" class="headerlink" title="常见应用层协议"></a>常见应用层协议</h2><ul><li>DNS（Domain Name System，域名系统）</li><li>DNS用于将人类可读的域名转换成计算机可以识别的IP地址。</li><li>FTP（File Transfer Protocol，文件传输协议）</li><li>FTP提供了一种在互联网上传输文件的标准方法，支持文件上传和下载。</li><li>Telnet（远程终端协议）</li><li>Telnet允许用户登录到远程计算机并执行命令，尽管现在SSH（Secure Shell）已经替代了它在安全方面的应用。</li><li>HTTP（Hypertext Transfer Protocol，超文本传输协议）</li><li>HTTP是用于从万维网服务器传输超文本到本地浏览器的传输协议。</li><li>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）</li><li>SMTP用于在邮件服务器之间发送电子邮件，以及从用户的邮件客户端向邮件服务器发送邮件。</li><li>POP3（Post Office Protocol Version 3，邮局协议第三版）</li><li>POP3是一种接收电子邮件的协议，允许用户从邮件服务器上下载邮件。</li><li>IMAP（Internet Message Access Protocol，互联网消息访问协议）</li><li>IMAP也用于接收电子邮件，但与POP3不同的是，它通常允许邮件保留在服务器上，以便多设备同步。</li><li>HTTPS（Hypertext Transfer Protocol Secure，安全超文本传输协议）</li><li>HTTPS是HTTP的安全版本，使用SSL&#x2F;TLS加密来保护数据传输。</li><li>SSH（Secure Shell，安全外壳协议）</li><li>SSH提供了一个安全的网络环境，用于远程登录、远程命令执行、文件传输等功能。</li><li>TLS&#x2F;SSL（Transport Layer Security &#x2F; Secure Sockets Layer，传输层安全&#x2F;安全套接字层）</li><li>虽然通常被认为是传输层协议，但在应用层中使用，为应用数据提供加密和身份验证。</li><li>SNMP（Simple Network Management Protocol，简单网络管理协议）</li><li>SNMP用于监控网络设备的状态和性能，是网络管理的重要工具。</li><li>RTSP（Real Time Streaming Protocol，实时流媒体协议）</li><li>RTSP用于控制实时媒体数据的传输，例如音频和视频流。</li><li>NTP（Network Time Protocol，网络时间协议）</li><li>NTP用于在分布式时间服务器和客户端之间同步时钟。</li></ul><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS的基本功能"><a href="#DNS的基本功能" class="headerlink" title="DNS的基本功能"></a>DNS的基本功能</h3><p>DNS的主要功能是将人类可读的域名转换为计算机可理解的IP地址，以便计算机能够定位和访问互联网上的资源。这个过程被称为“域名解析”。</p><h3 id="DNS的结构"><a href="#DNS的结构" class="headerlink" title="DNS的结构"></a>DNS的结构</h3><p>DNS采用层次化的树状结构，从根域开始，向下分为顶级域（如.com、.org、.edu等）、二级域、三级域等，直至具体的主机名。</p><h3 id="DNS的组件"><a href="#DNS的组件" class="headerlink" title="DNS的组件"></a>DNS的组件</h3><ul><li>根域名服务器：位于DNS层次结构的最顶端，负责维护顶级域名服务器的信息。</li><li>顶级域名服务器：负责管理特定的顶级域，如.com、.org等。</li><li>权威名称服务器：负责具体域名的解析，存储该域名的A记录（IP地址）、MX记录（邮件服务器信息）等。</li><li>本地DNS解析器：运行在用户计算机上的软件，负责向DNS服务器发起查询并缓存查询结果。</li></ul><h3 id="DNS查询过程"><a href="#DNS查询过程" class="headerlink" title="DNS查询过程"></a>DNS查询过程</h3><p>DNS查询通常有两种方式：递归查询和迭代查询。</p><h4 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h4><ol><li>用户的计算机向本地DNS解析器发送查询请求。</li><li>如果本地DNS解析器没有缓存结果，它会向根域名服务器发起查询。</li><li>根域名服务器返回顶级域名服务器的地址。</li><li>本地DNS解析器继续向顶级域名服务器查询，直到找到权威名称服务器。</li><li>权威名称服务器返回域名对应的IP地址。</li><li>本地DNS解析器将结果返回给用户计算机，并将结果缓存。</li></ol><h4 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h4><p>迭代查询与递归查询类似，但每个DNS服务器只提供下一步查询的线索，而不是最终答案。这意味着查询请求会从一个DNS服务器跳转到另一个，直到找到权威名称服务器为止。</p><h3 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h3><ul><li>除了A记录（IP地址），DNS还支持多种记录类型，包括但不限于：</li><li>CNAME记录：别名记录，用于将一个域名指向另一个域名。</li><li>MX记录：邮件交换记录，指定邮件服务器的位置。</li><li>NS记录：名称服务器记录，列出负责某个域的权威DNS服务器。</li><li>TXT记录：文本记录，用于存储任意文本信息，常用于SPF（Sender Policy Framework）记录，防止邮件伪造。</li><li>PTR记录：指针记录，用于反向DNS查找，即将IP地址映射回域名。</li><li>SOA记录：起始授权记录，包含有关DNS区域的管理信息。</li></ul><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP，即HyperText Transfer Protocol（超文本传输协议），是用于从Web服务器传输超文本到本地浏览器的传送协议。它是互联网上应用最为广泛的一种网络协议</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/7a13a69686adce6f209b9070fa7061bd.jpeg" alt="HTTP 请求报文由请求行、请求头部、空行 和 请求包体 4 个部分组成" style="zoom:130%;" /><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/085c7e5a4d33cfda578afcb6b4bd83ab.png" alt="img" style="zoom:130%;" /><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul><li>HTTP&#x2F;1.0：早期版本，每个请求都需要建立一个新的连接。</li><li>HTTP&#x2F;1.1：改进版本，支持持久连接（keep-alive），允许在一个TCP连接上发送多个请求和响应。</li><li>HTTP&#x2F;2：二进制协议，支持多路复用、头部压缩、服务器推送等功能，提高了性能。</li><li>HTTP&#x2F;3：基于QUIC协议，进一步优化了延迟和丢包恢复。</li></ul><h3 id="进阶特性"><a href="#进阶特性" class="headerlink" title="进阶特性"></a>进阶特性</h3><h4 id="keepAlive"><a href="#keepAlive" class="headerlink" title="keepAlive"></a>keepAlive</h4><p>Keep-Alive 机制是 http 从 1.1 版本开始支持的一种优化网络性能的技术，它允许客户端和服务器在完成一次请求和响应后，保持TCP连接处于打开状态，以便后续的请求可以复用这个连接，而不需要重新建立连接。这种机制显著减少了因频繁建立和关闭连接带来的网络开销，提高了Web应用的性能和响应速度。</p><p><strong>Keep-Alive的好处</strong></p><ul><li>减少连接建立的延迟：避免了每次请求都需要进行TCP连接建立的时间，提高了响应速度。</li><li>降低网络负载：减少了连接建立和关闭的次数，降低了网络带宽的消耗。</li><li>提高服务器吞吐量：更少的连接意味着更少的系统内核调用，如accept()和close()，从而提高了服务器的处理能力。</li></ul><p><strong>Keep-Alive的实现细节</strong></p><ul><li>超时设置：服务器通常会设置一个超时时间，如果在这段时间内没有收到新的请求，连接将被关闭。这是因为长时间保持连接打开可能会占用过多的系统资源。</li><li>空闲检测：客户端和服务器可以通过发送空的“心跳”数据包来检测连接是否仍然有效，这称为TCP的keepalive选项，但要注意不要与HTTP的Keep-Alive混淆。</li><li>并发限制：尽管Keep-Alive可以提高性能，但每个客户端与服务器之间的连接数量通常会受到限制，以防止服务器资源过度消耗。</li></ul><h4 id="multipart"><a href="#multipart" class="headerlink" title="multipart"></a>multipart</h4><p>Multipart主要用于在单个HTTP请求或响应中传输多个部分的数据，尤其适用于上传文件或多部分消息。</p><p>Multipart编码允许在同一个请求中发送多个实体，每个实体可以有不同的数据类型，比如文本、图像、音频等。这在提交包含文件和表单字段的HTTP POST请求时非常有用。</p><p>Multipart编码通常使用边界（boundary）来分隔不同的实体，边界是一个随机生成的字符串，用于标记每个实体的开始和结束。每个实体都包含自己的头部信息，如Content-Disposition、Content-Type等，用于描述实体的性质。</p><p><strong>Multipart的使用场景：</strong></p><ul><li>文件上传：允许用户在Web表单中上传一个或多个文件。</li><li>多部分消息：在邮件中，可以使用multipart来组合文本、图片和其他附件。</li></ul><h4 id="chunked"><a href="#chunked" class="headerlink" title="chunked"></a>chunked</h4><p>Chunked transfer encoding是一种传输编码方式，用于在不知道数据总长度的情况下，允许服务器动态地发送数据。在HTTP&#x2F;1.1中，当服务器无法预知响应的总长度时，可以使用chunked编码来发送数据。</p><p>Chunked编码将数据分割成一系列的块（chunks），每个块都有一个明确的长度，块的长度以十六进制数表示，后面跟着块数据，最后以零长度的块表示数据传输的结束。这种方式允许服务器在生成响应的同时发送数据，而不需要等待整个响应构建完成。</p><p><strong>Chunked的使用场景：</strong></p><ul><li>动态生成的响应：服务器在生成响应的过程中可以立即开始发送数据。</li><li>长连接的流式传输：在持续的HTTP连接中，服务器可以持续发送数据，而不需要知道总的数据量。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h3><ul><li>最终用对称加密</li><li>对称加密秘钥通过特定算法生成，如 ECDHE，期间可能涉及一些随机数</li><li>对称密钥依赖的数据通过非对称加密进行交换</li><li>非对称加密可靠性通过证书方式进行验证</li></ul><h3 id="https-握手流程"><a href="#https-握手流程" class="headerlink" title="https 握手流程"></a>https 握手流程</h3><p>实则依赖具体算法套件</p><h4 id="ECDH-握手"><a href="#ECDH-握手" class="headerlink" title="ECDH 握手"></a>ECDH 握手</h4><p>ECDH是一种基于椭圆曲线的Diffie-Hellman密钥交换算法，它允许两个通信方在不安全的信道上安全地协商出一个共享密钥。然而，在TLS中，ECDH本身并不提供前向安全性（Forward Secrecy），因为一旦服务器的长期私钥被破解，所有使用该私钥协商的会话密钥都可以被追溯破解。</p><h5 id="ECDH-握手过程"><a href="#ECDH-握手过程" class="headerlink" title="ECDH 握手过程"></a>ECDH 握手过程</h5><ul><li>服务器在ServerHello消息中选择ECDH作为密钥交换算法。</li><li>服务器发送Certificate消息，其中包含其长期公钥。</li><li>服务器发送ServerKeyExchange消息，其中包含用于ECDH密钥交换的参数。</li><li>客户端使用服务器的长期公钥计算出预主密钥（pre-master secret），并发送ClientKeyExchange消息。</li><li>双方计算出会话密钥，并开始使用该密钥加密通信。</li></ul><h4 id="ECDHE-握手"><a href="#ECDHE-握手" class="headerlink" title="ECDHE 握手"></a>ECDHE 握手</h4><p>ECDHE是ECDH的一个变种，它引入了短暂（ephemeral）密钥的概念，即每次握手时生成一个新的密钥对。这意味着即使服务器的长期私钥在未来被破解，过去握手过程中协商的会话密钥仍然是安全的，因为它们都是基于短暂密钥对生成的。ECDHE提供了前向安全性，这是现代安全通信的一个重要特性。</p><h5 id="ECDHE握手过程"><a href="#ECDHE握手过程" class="headerlink" title="ECDHE握手过程"></a>ECDHE握手过程</h5><ul><li>服务器在ServerHello消息中选择ECDHE作为密钥交换算法。</li><li>服务器发送Certificate消息，其中包含其长期公钥，但这不是用于ECDHE密钥交换的公钥。</li><li>服务器发送ServerKeyExchange消息，其中包含一个短暂（ephemeral）的公钥，用于此次握手的ECDHE密钥交换。</li><li>客户端使用服务器的短暂公钥计算出预主密钥，并发送ClientKeyExchange消息。</li><li>双方计算出会话密钥，并开始使用该密钥加密通信。</li></ul><h2 id="输入网址到显示网页全过程"><a href="#输入网址到显示网页全过程" class="headerlink" title="输入网址到显示网页全过程"></a>输入网址到显示网页全过程</h2><p>在浏览器中输入一个网址并按下回车键，直到页面完全加载并展示出来，期间会发生一系列复杂的操作。这个过程大致可以分为以下几个阶段：</p><ul><li><strong>解析URL</strong><ul><li>浏览器首先解析你输入的URL，确定协议（如HTTP、HTTPS）、主机名、端口号、路径、查询参数等。</li></ul></li><li><strong>域名解析（DNS查询）</strong><ul><li>浏览器需要将域名转换为IP地址。它首先检查本地缓存，如果找不到，则向DNS服务器发送请求。DNS服务器会返回相应的IP地址，或者继续递归查询直到找到正确的IP地址。</li></ul></li><li><strong>建立TCP连接</strong><ul><li>获取到IP地址后，浏览器会尝试与服务器建立TCP连接。这涉及到TCP的三次握手过程，以确保连接的建立。</li></ul></li><li><strong>发送HTTP请求</strong><ul><li>TCP连接建立成功后，浏览器发送HTTP请求到服务器。请求中包含了请求方法（GET、POST等）、请求头、请求体等信息。</li></ul></li><li><strong>服务器处理请求</strong><ul><li>服务器接收到请求后，根据请求的内容处理请求，这可能包括读取文件、执行脚本、数据库查询等。</li></ul></li><li><strong>服务器响应</strong><ul><li>服务器处理完请求后，会构建一个HTTP响应并发送回浏览器。响应中包含了状态码、响应头和响应体。</li></ul></li><li><strong>接收数据</strong><ul><li>浏览器接收服务器的响应数据。如果是HTML文档，浏览器会开始解析HTML文档；如果是其他资源（如CSS、JavaScript、图片等），浏览器会异步下载这些资源。</li></ul></li><li><strong>解析HTML文档</strong><ul><li>浏览器解析HTML文档，构建DOM树（Document Object Model）。DOM树是HTML文档的结构化表示，用于浏览器进一步渲染页面。</li></ul></li><li><strong>请求并加载外部资源</strong><ul><li>HTML文档中可能引用了外部资源，如CSS样式表、JavaScript脚本、图片等。浏览器会根据这些资源的URL发起新的请求，并下载这些资源。</li></ul></li><li><strong>执行JavaScript</strong><ul><li>如果页面中有JavaScript代码，浏览器会执行这些代码。JavaScript可能修改DOM树，或者发起新的网络请求，进一步改变页面内容。</li></ul></li><li><strong>渲染页面</strong><ul><li>浏览器将DOM树和CSS样式结合，创建渲染树。渲染树描述了页面元素的视觉表现，浏览器使用渲染树绘制页面到屏幕上。</li></ul></li><li><strong>关闭TCP连接</strong><ul><li>页面加载完成后，浏览器和服务器之间的TCP连接通常会被关闭，除非使用了Keep-Alive机制，那么连接可能会保持一段时间以供后续请求使用。</li></ul></li><li><strong>事件监听和交互</strong><ul><li>页面加载完成后，浏览器会监听用户的交互事件，如点击、滚动等，并响应这些事件。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> http/https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拥塞控制算法</title>
      <link href="/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="拥塞控制算法"><a href="#拥塞控制算法" class="headerlink" title="拥塞控制算法"></a>拥塞控制算法</h1><p>拥塞控制算法是网络通信中用于管理数据传输速率的关键机制，以避免网络拥塞和确保数据包有效传输</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><ul><li>基于 目标 &#x2F; 控制策略<ul><li>基于丢包</li><li>基于延迟</li></ul></li><li>基于控制机制<ul><li>基于链路容量预测</li><li>基于学习或探测</li></ul></li></ul><h2 id="常见拥塞控制算法"><a href="#常见拥塞控制算法" class="headerlink" title="常见拥塞控制算法"></a>常见拥塞控制算法</h2><h3 id="RENO"><a href="#RENO" class="headerlink" title="RENO"></a>RENO</h3><p>也即传统的 拥塞控制算法，包含 慢启动，拥塞避免，快重传，快恢复 四个阶段</p><h4 id="RENO-的局限性"><a href="#RENO-的局限性" class="headerlink" title="RENO 的局限性"></a>RENO 的局限性</h4><ul><li><strong>慢启动阈值（ssthresh）的设定：</strong><ul><li>在Reno算法中，当检测到网络拥塞（如超时或重复ACK）时，慢启动阈值ssthresh会被减半，然后拥塞窗口cwnd也会被重置为1 MSS（最大报文段大小），并进入慢启动阶段。这种方法在高速网络中会导致拥塞窗口恢复得过慢，从而降低了网络的利用率。</li></ul></li><li><strong>拥塞避免的线性增长：</strong><ul><li>在拥塞避免阶段，Reno算法中的拥塞窗口cwnd每次接收到一个ACK时仅增加1 MSS&#x2F;cwnd。在高带宽延迟产品（BDP）的网络中，这种线性增长速度过慢，不能充分利用网络带宽。</li></ul></li><li><strong>拥塞恢复机制：</strong><ul><li>Reno的快速重传和快速恢复机制在检测到数据包丢失时，会将拥塞窗口cwnd设置为ssthresh，然后以慢启动的方式恢复。这种方法在高带宽网络中可能导致拥塞窗口恢复得太慢，影响了网络的吞吐量。</li></ul></li><li><strong>对丢包的敏感性：</strong><ul><li>Reno算法对丢包非常敏感，即使是非拥塞引起的丢包（如链路质量差、硬件故障等），也会触发拥塞控制机制，导致不必要的窗口收缩。</li></ul></li><li><strong>对高延迟网络的不适应性：</strong><ul><li>在高延迟网络中，Reno算法的慢启动和拥塞避免机制可能无法及时响应网络状态变化，导致网络资源的浪费和低效利用。</li></ul></li><li><strong>公平性问题：</strong><ul><li>在多条并发连接共享同一网络资源时，Reno算法可能会导致某些连接的不公平竞争，尤其是在混合连接类型（如Reno与更先进的拥塞控制算法）共存的场景下。</li></ul></li><li><strong>对网络容量的适应性：</strong><ul><li>Reno算法可能无法准确地探测和适应网络的实际容量，特别是在网络条件动态变化的环境中。</li></ul></li></ul><h3 id="CUBIC"><a href="#CUBIC" class="headerlink" title="CUBIC"></a>CUBIC</h3><h4 id="CUBIC-出现的背景"><a href="#CUBIC-出现的背景" class="headerlink" title="CUBIC 出现的背景"></a>CUBIC 出现的背景</h4><p>CUBIC（Cube Root Increase Decrease）拥塞控制算法的出现主要是为了应对高速网络环境中的性能挑战，特别是针对TCP Reno算法在高带宽和高延迟网络中的局限性。在20世纪末和21世纪初，随着互联网基础设施的快速发展，骨干网络的带宽和覆盖范围显著提升，传统的TCP拥塞控制算法如Reno开始显现出不足。</p><p>在高速网络中，Reno算法的拥塞窗口调整机制导致了几个关键问题，包括：</p><ul><li><strong>恢复速度慢</strong>：在检测到拥塞时，Reno会将慢启动阈值（ssthresh）减半，并将拥塞窗口（cwnd）重置为1 MSS，这在高带宽网络中导致了拥塞窗口恢复得过慢，影响了网络的利用率。</li><li><strong>利用率低</strong>：Reno的线性拥塞避免策略在高带宽延迟产品（BDP）的网络中无法充分使用网络带宽。</li><li><strong>公平性问题</strong>：在多连接共享网络资源时，Reno 可能无法提供足够的公平性，尤其是在混合连接类型共存的场景下。</li></ul><p>为了解决这些问题，CUBIC 算法被提出，旨在提高 TCP 在高速网络中的性能和效率，同时保持良好的公平性和稳定性。</p><h4 id="CUBIC-与-RENO-的主要区别"><a href="#CUBIC-与-RENO-的主要区别" class="headerlink" title="CUBIC 与 RENO 的主要区别"></a>CUBIC 与 RENO 的主要区别</h4><ul><li><strong>窗口调整机制：</strong><ul><li>Reno使用慢启动和线性拥塞避免策略，而CUBIC使用立方根函数来动态调整拥塞窗口，这使得窗口增长和减少更加平滑和适应性强。</li></ul></li><li><strong>恢复机制：</strong><ul><li>Reno在检测到拥塞时，会大幅度减少拥塞窗口，而CUBIC使用线性减少策略，这有助于更精确地控制拥塞窗口的大小，避免过度反应。</li></ul></li><li><strong>阈值调整：</strong><ul><li>Reno的慢启动阈值（ssthresh）在检测到拥塞时被减半，而CUBIC会根据网络条件动态调整ssthresh，这有助于在拥塞发生后更快地恢复到较高的传输速率。</li></ul></li><li><strong>适应性：</strong><ul><li>CUBIC算法能够更好地适应高带宽和高延迟的网络环境，而Reno在这些条件下性能较差。</li></ul></li></ul><h4 id="CUBIC-的核心原理"><a href="#CUBIC-的核心原理" class="headerlink" title="CUBIC 的核心原理"></a>CUBIC 的核心原理</h4><p>CUBIC算法的核心在于其拥塞窗口调整策略，它使用了一个累积增加的变量C，这个变量随时间t的增加而增加。当网络中没有拥塞时，C按时间的立方根增加，而当检测到拥塞时，C 减少，导致拥塞窗口减少。</p><p>拥塞窗口的大小与C的关系为：$[ cwnd &#x3D; C^{1&#x2F;3} ]$</p><p>这里的 C 实际是一个累积的变量，它在没有拥塞的情况下随时间增加，在检测到拥塞时减少。通过这种方式，CUBIC 算法能够实现更平稳的拥塞窗口调整，避免了传统算法中拥塞窗口剧烈波动的问题，从而提高了网络资源的利用率和传输效率。</p><p>CUBIC 算法的设计使得它在各种网络条件下都能表现出较好的性能，尤其在高带宽和高延迟的网络中，能够更有效地利用网络资源，减少数据包的丢失，同时保持良好的公平性。</p><h3 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h3><p>BBR（Bottleneck Bandwidth and RTT）是Google开发的一种新型TCP拥塞控制算法，旨在解决传统拥塞控制算法（如Reno和CUBIC）在现代网络中的一些问题，尤其是对于高带宽和高延迟网络的效率和公平性问题。BBR的设计理念是直接对网络拥塞进行建模，而不是依赖于数据包丢失作为拥塞的唯一指标。</p><h4 id="BBR的出现背景"><a href="#BBR的出现背景" class="headerlink" title="BBR的出现背景"></a>BBR的出现背景</h4><p>传统的拥塞控制算法，如 Reno 和 CUBIC，主要依赖于数据包的丢失来检测网络拥塞，这在很多情况下是有效的，但在高速网络中，这种机制可能导致不必要的性能下降和资源浪费。此外，这些算法在多路径和高延迟网络中也面临挑战，因为它们可能无法准确地估计网络的瓶颈带宽和往返时间（RTT）。</p><p>BBR算法的开发是为了克服这些局限性，提供一种更准确地测量网络容量和响应网络条件变化的机制，从而实现更高效、更公平的数据传输。</p><h4 id="BBR与传统算法的主要区别"><a href="#BBR与传统算法的主要区别" class="headerlink" title="BBR与传统算法的主要区别"></a>BBR与传统算法的主要区别</h4><ul><li><strong>拥塞检测：</strong><ul><li>传统算法依赖于数据包丢失作为拥塞的信号，而 BBR 则直接测量网络的 瓶颈带宽 和 RTT ，以更准确地识别和响应拥塞。</li></ul></li><li><strong>状态机：</strong><ul><li>BBR具有两种主要的操作模式：探测（Probing）和 加载（Loading）。在探测模式下，BBR会尝试推断网络的瓶颈带宽和RTT；在加载模式下，BBR会以接近瓶颈带宽的速度发送数据，同时监控网络状态以避免拥塞。</li></ul></li><li><strong>动态调整：</strong><ul><li>BBR算法能够根据网络反馈动态调整发送速率，这使得它能够更有效地利用网络资源，同时避免过度使用而导致的拥塞。</li></ul></li><li><strong>抗丢包能力：</strong><ul><li>BBR的抗丢包能力较强，即使在网络中出现丢包时，也能保持相对稳定的传输速率，而不像传统算法那样可能需要大幅降低速率。</li></ul></li></ul><h4 id="BBR的核心原理"><a href="#BBR的核心原理" class="headerlink" title="BBR的核心原理"></a>BBR的核心原理</h4><p>BBR的核心原理是基于对网络瓶颈带宽和RTT的精确估计，通过主动探测和动态调整发送速率来避免拥塞。它的工作流程可以概括为以下步骤：</p><ul><li><strong>探测阶段（Probing）：</strong><ul><li>在此阶段，BBR会以高于当前估计的瓶颈带宽的速率发送数据，以探测网络的实际容量。通过分析往返时间的变化，BBR可以更新其对瓶颈带宽的估计。</li></ul></li><li><strong>加载阶段（Loading）：</strong><ul><li>在探测阶段之后，BBR会进入加载阶段，此时它会以接近瓶颈带宽的速度发送数据。BBR会持续监控网络状态，如RTT的变化，以确保不会引起网络拥塞。</li></ul></li><li><strong>动态调整：</strong><ul><li>BBR会根据网络反馈动态调整其发送速率，以维持一个稳定的传输速率，同时避免拥塞。这种调整是基于对网络状态的实时评估，而不是依赖于数据包丢失的滞后信号。</li></ul></li></ul><p>BBR算法的设计使得它在现代网络环境中表现出色，尤其是在高带宽、高延迟和多路径网络中，能够提供更高效、更公平的数据传输服务。自发布以来，BBR已经在Linux内核中得到实现，并在数据中心和广域网等多种场景中得到了广泛应用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 传输层</title>
      <link href="/2024/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2024/07/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——传输层"><a href="#计算机网络——传输层" class="headerlink" title="计算机网络——传输层"></a>计算机网络——传输层</h1><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240702234147757.png" alt="image-20240702234147757" style="zoom:70%;" /><h2 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h2><p>传输层是计算机网络模型中的第4层，位于网络层之上、会话层之下，它的主要功能是为网络中的应用程序提供端到端的通信服务。传输层是整个网络体系结构中承上启下的关键层次，它确保数据能够从一个网络中的程序可靠、有序地传输到另一个网络中的对应程序，而不关心底层网络的具体细节。以下是传输层的几个关键方面：</p><h3 id="核心服务"><a href="#核心服务" class="headerlink" title="核心服务"></a>核心服务</h3><ul><li><strong>端到端连接</strong>：传输层为应用层提供虚拟的、逻辑上的端到端连接，使得上层应用感觉像是直接在两个端点之间通信，而无需了解中间网络的复杂性。</li><li><strong>数据分割与重组</strong>：传输层可以将上层数据分割成适合网络层传输的数据段，并在接收端重新组合成原始数据，这有助于提高数据传输的效率。</li><li><strong>错误检测与纠正</strong>：通过校验和等机制，传输层可以检测数据在传输过程中是否发生错误，并在某些协议（如TCP）中尝试纠正这些错误。</li><li><strong>流量控制</strong>：为了避免数据发送过快导致接收方无法处理，传输层实施流量控制机制，确保发送速率与接收方的处理能力相匹配。</li><li><strong>拥塞控制</strong>：在网络拥堵时，传输层可以调整数据的发送速率，以减少网络拥塞，提高整体网络的效率和稳定性。</li></ul><h3 id="主要协议"><a href="#主要协议" class="headerlink" title="主要协议"></a>主要协议</h3><ul><li><code>TCP（Transmission Control Protocol）</code>：TCP是一个面向连接的、可靠的传输协议，它通过确认、重传、排序等机制确保数据的可靠传输。TCP还提供流量控制和拥塞控制功能，适用于对数据完整性要求高的应用，如Web浏览、电子邮件等。</li><li><code>UDP（User Datagram Protocol）</code>：UDP是一个无连接的、不可靠的传输协议，它不保证数据的顺序或可靠性，但因为省去了建立连接和确认的过程，所以传输速度快，适用于实时性要求高、能容忍少量数据丢失的应用，如在线游戏、语音通话、视频流等。</li></ul><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP-报文结构"><a href="#TCP-报文结构" class="headerlink" title="TCP 报文结构"></a>TCP 报文结构</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240702235349511.png" alt="image-20240702235349511"></p><h4 id="TCP-首部字段"><a href="#TCP-首部字段" class="headerlink" title="TCP 首部字段"></a>TCP 首部字段</h4><ul><li><p><strong>源端口和目的端口</strong>：各占两个字节；(16bit的端口号+32bit的ip地址形成了一个套接字socket，每一条TCP连接唯一的被两端的两个端点也就是两个套接字确认，所以这也构成了传输层的点到点通信)</p></li><li><p>**序号(seq)**：占4个字节；(在传输的数据中，每一个字节都有一个序号，这个序号就是本次传输数据的第一个字节的序号)；</p></li><li><p>**确认号(ack)**：占4个字节；(这个值是代表期待收到对方下次发送的数据的第一个字节的序号，比如如果发送ack&#x3D;301，则表示前300个我收到了，下次你给我发第301个)；</p></li><li><p><strong>数据偏移</strong>：占4位，也叫首部长度(Header length),一般情况下首部长度是20字节，但是也可以扩展，比如这4位都置为1时十进制是15，代表可以首部可以有15行，一行4个字节，所以是60个字节；</p></li><li><p><strong>6个控制位</strong></p><ul><li><p><strong>URG</strong>:  紧急指针有效位，和第5行的紧急指针一起用，可以让紧急数据进行加塞，接收端可以优先快速的获取紧急数据；</p></li><li><p><strong>ACK</strong>:  指示ack确认号是否有效；</p></li><li><p><strong>PSH</strong>:  置为1时表示将本报文段立即向上交付有应用层，而不用等缓存填满再交付；</p></li><li><p><strong>RST</strong>:  置为1时通知重新建立TCP连接；</p></li><li><p><strong>SYN</strong>:  同步序号位，置为1表示需要建立连接；比如SYN&#x3D;1,ACK&#x3D;0时表明是一个连接建立请求；而SYN&#x3D;1,ACK&#x3D;1,表明是一个连接接受请求；  </p></li><li><p><strong>FIN</strong>:  置为1时表明发送数据结束，连接释放；</p></li></ul></li><li><p><strong>窗口</strong>：占2个字节：用来说明本地可以接收的数据段的数目，以字节为单位，流量控制就是基于这个窗口来实现的，其大小是可变的；</p></li><li><p><strong>检验和</strong>：占2个字节：用来做差错控制，在发送端计算一次所有数据的检验和，在接收端再计算一次，一致则说明数据基本正确；</p></li><li><p><strong>紧急窗口</strong>：和URG配合使用；</p></li></ul><h3 id="TCP-连接管理"><a href="#TCP-连接管理" class="headerlink" title="TCP 连接管理"></a>TCP 连接管理</h3><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240703000934584.png" alt="image-20240703000934584" style="zoom: 67%;" /><h4 id="TCP-握手为什么是三次"><a href="#TCP-握手为什么是三次" class="headerlink" title="TCP 握手为什么是三次"></a>TCP 握手为什么是三次</h4><ul><li>确认消息相互可达</li><li>同步序列号</li><li>两次握手无法确认 Server 到 Client 消息可达</li><li>两次握手无法规避历史连接</li><li>三次可以达到以上目的，无需四次，或者说中间的握手实际就是四次握手的中间两次进行合并的</li></ul><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240706225451043.png" alt="image-20240706225451043" style="zoom: 63%;" /><h4 id="TCP-回收为什么是四次"><a href="#TCP-回收为什么是四次" class="headerlink" title="TCP 回收为什么是四次"></a>TCP 回收为什么是四次</h4><ul><li>需要双方均确认关闭</li><li>被动关闭方在收到FIN 时，可能还有数据需要发送，因此不能像 三次握手一样将中间两次进行合并</li></ul><h3 id="TCP-可靠性原理"><a href="#TCP-可靠性原理" class="headerlink" title="TCP 可靠性原理"></a>TCP 可靠性原理</h3><ul><li><strong>错误</strong> —— 校验和</li><li><strong>乱序</strong> —— 序列号</li><li><strong>丢包</strong> —— 丢包重传<ul><li>序列号</li><li>确认应答</li><li>超时重传</li><li>快速重传</li><li>连接管理 —— 三次握手，四次挥手</li><li>（拥塞控制）</li></ul></li></ul><h3 id="TCP-流量控制-拥塞控制"><a href="#TCP-流量控制-拥塞控制" class="headerlink" title="TCP 流量控制 &#x2F; 拥塞控制"></a>TCP 流量控制 &#x2F; 拥塞控制</h3><h4 id="鉴别"><a href="#鉴别" class="headerlink" title="鉴别"></a>鉴别</h4><p><strong>拥塞控制</strong>：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：（ 1 ）慢开始、拥塞避免（ 2 ）快重传、快恢复。</p><p><strong>流量控制</strong>：流量控制 由 接收者 控制 发送者 的发送速度 从而使接收者来得及接收，防止分组丢失的。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 流量控制通过 滑动窗口协议 (连续 ARQ) 实现，关于 ARQ 协议参见 ： <a href="https://blog.csdn.net/aaahuahua/article/details/119965804">TCP可靠传输：ARQ协议（停止等待、超时重传、滑动窗口、回退N帧、选择重传）-CSDN博客</a></p><h4 id="经典-TCP-拥塞控制-——-RENO-算法"><a href="#经典-TCP-拥塞控制-——-RENO-算法" class="headerlink" title="经典 TCP 拥塞控制 —— RENO 算法"></a>经典 TCP 拥塞控制 —— RENO 算法</h4><ul><li><strong>类型： 基于丢包</strong></li><li><strong>核心概念：</strong> <ul><li><strong>拥塞窗口</strong></li><li><strong>门限值</strong></li></ul></li><li><strong>具体实现：</strong><ul><li><strong>慢启动（Slow Start）：</strong><br>慢启动算法在连接建立初期或在经历长时间静默后，此阶段每收到 一个 ACK 则 CWND +1 ，以指数增长的方式增加拥塞窗口大小 直到遇到网络拥塞的迹象（如超时或重复ACK）。</li><li><strong>拥塞避免（Congestion Avoidance）：</strong><br>当慢启动阶段结束，拥塞避免算法开始以线性方式增加拥塞窗口大小，即每收到一个ACK，cwnd增加一个MSS（最大报文段大小）。</li><li><strong>快速重传（Fast Retransmit）：</strong><br>在发送方收到三个重复的ACK时，会立即重传丢失的数据段，而不需要等到超时发生。</li><li><strong>快速恢复（Fast Recovery）：</strong><br>在快速重传之后使用，它会将拥塞窗口设置为当前 cwnd 的一半，然后开始缓慢增加，直到收到丢失数据段的ACK。</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/6f1657d8b22e4ea79b1f6ba2243a7dcd.png" alt="img"></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-特点"><a href="#UDP-特点" class="headerlink" title="UDP 特点"></a>UDP 特点</h3><ul><li><strong>无连接：</strong><ul><li>UDP在发送数据前不需要建立连接，这意味着它可以立即开始发送数据，而无需等待连接建立的过程。</li></ul></li><li><strong>不可靠：</strong><ul><li>UDP不保证数据的可靠传输，即发送的数据可能丢失、重复或乱序到达目的地。它不提供确认机制或重传机制，因此数据传输的可靠性完全依赖于应用层。</li></ul></li><li><strong>最小开销：</strong><ul><li>UDP头部非常简单，只有8字节，包括源端口、目的端口、长度和校验和字段。这使得UDP的处理速度比TCP快，因为它不需要处理TCP的复杂状态机和拥塞控制算法。</li></ul></li><li><strong>广播和多播支持：</strong><ul><li>UDP非常适合用于广播和多播通信，因为它不需要逐个建立连接就可以向多个接收者发送数据。</li></ul></li><li><strong>数据报：</strong><ul><li>UDP使用数据报的形式传输数据，每个数据报独立于其他数据报发送，可能沿着不同的路径到达目的地。</li></ul></li><li><strong>校验和：</strong><ul><li>UDP提供了一个可选的校验和字段，用于检测数据报在传输过程中的错误。但是，这个校验和不是强制性的，可以被应用层禁用。</li></ul></li></ul><h3 id="UDP-应用场景"><a href="#UDP-应用场景" class="headerlink" title="UDP 应用场景"></a>UDP 应用场景</h3><ul><li><strong>实时音频和视频流：</strong><ul><li>对于实时多媒体应用，如VoIP（Voice over IP）、在线游戏和视频会议，UDP的低延迟特性比可靠性更为重要。</li></ul></li><li><strong>DNS查询：</strong><ul><li>DNS（Domain Name System）查询通常使用UDP，因为大多数查询只需要单次往返即可完成，且数据量不大。</li></ul></li><li><strong>网络管理：</strong><ul><li>SNMP（Simple Network Management Protocol）和其他网络管理协议使用UDP，因为它们通常发送的是小数据包，且可以容忍数据丢失。</li></ul></li><li><strong>多播应用：</strong><ul><li>UDP的多播能力使其成为多播应用的理想选择，如实时股票行情更新、新闻广播等。</li></ul></li><li><strong>游戏和实时通信：</strong><ul><li>实时游戏和实时通信应用往往使用UDP，因为它们需要快速响应时间，可以容忍偶尔的数据包丢失。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 网络层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——网络层"><a href="#计算机网络——网络层" class="headerlink" title="计算机网络——网络层"></a>计算机网络——网络层</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层是计算机网络体系结构中的一层，也是整个互联网的核心；网络层负责处理数据的传输、路由和转发。它位于传输层和数据链路层之上，为上层提供了透明的数据传输服务，并通过路由选择和转发算法，实现了不同网络之间的互联和通信</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630233644164.png" alt="image-20240630233644164" style="zoom:50%;" /><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>网络层在计算机网络中具有以下主要功能：</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>网络层负责将数据从源主机传输到目标主机。它接收上层传来的数据，并根据目标地址和路由表等信息，将数据分组成数据包进行传输。网络层通过逐跳传输，将数据包从源主机经过一系列中间节点（路由器）转发到目标主机。</p><h3 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h3><p>路由选择是网络层的核心功能之一。当数据包从源主机发出后，网络层需要决定数据包的传输路径。路由选择算法根据目标地址、网络拓扑、链路状态等因素，选择最佳的路径将数据包转发到目标主机。常见的路由选择协议包括RIP（Routing Information Protocol）、OSPF（Open Shortest Path First）和BGP（Border Gateway Protocol）等。</p><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>转发是网络层的另一个重要功能，它是指在路由器上根据目标地址，将接收到的数据包从一个接口转发到另一个接口。转发过程是基于路由表进行的，路由表记录了目标地址与出接口之间的映射关系。当接收到数据包时，路由器根据路由表中的信息，进行转发操作，将数据包发送到正确的接口，以便继续向目标主机传输。</p><h3 id="路由器通信"><a href="#路由器通信" class="headerlink" title="路由器通信"></a>路由器通信</h3><p>网络层通过路由器实现不同网络之间的互联和通信。路由器是网络层的关键设备，它通过连接多个网络的接口，实现数据包在不同网络之间的转发。路由器通过学习路由信息、更新路由表和转发数据包，实现网络之间的通信和连接。</p><h2 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h2><ul><li>IP</li><li>ICMP</li><li>IGMP</li><li>ARP</li></ul><h2 id="IP-协议"><a href="#IP-协议" class="headerlink" title="IP 协议"></a>IP 协议</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>IP 提供了一种不可靠，无连接的数据包交付服务。依赖其他层的协议进行差错控制。 </p><ul><li><strong>不可靠</strong>: IP数据报不保证能成功的到达目的地，如果出现错误则选择丢弃该数据，然后发送ICMP消息报给信源端 </li><li><strong>无连接</strong>: IP不提供任何后续数据报的状态信息，每个数据报处理都是独立的。如果一个信源发送了连续的两个数据报，每个数据报选择独立的路由，两个数据可能不同时到达。IP通信双方都不长久地维持对方的任何信息。这样上层协议每次发送数据的时候，都必须明确指定对方的IP地址。</li></ul><h3 id="IP-数据报"><a href="#IP-数据报" class="headerlink" title="IP 数据报"></a>IP 数据报</h3><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067" alt="img" style="zoom:75%;" /><ul><li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li><li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li><li><strong>区分服务</strong> : 用来获得更好的服务，一般情况下不使用。</li><li><strong>总长度</strong> : 包括首部长度和数据部分长度。</li><li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li><li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</li><li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li><li><strong>标识</strong> : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li><li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li></ul><h3 id="IP-分片"><a href="#IP-分片" class="headerlink" title="IP 分片"></a>IP 分片</h3><p>当IP数据报的长度超过帧的MTU时，它将被分片传输。</p><p>分片可能发生在发送端，也可能发生在中转路由器上，而且可能在传输过程中多次分片，但只有在最终的目标机器上，这些分片才会被内核中的IP模块重新组装。 </p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<strong>数据报标识</strong>、**标志 ** 和 <strong>片偏移</strong>。</p><p>一个IP数据报的每个分片都具有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总长度字段将被设置位该分片的长度。</p><h3 id="IP-转发"><a href="#IP-转发" class="headerlink" title="IP 转发"></a>IP 转发</h3><p>当主机收到一个数据报时，首先检查目的地址：</p><ul><li>如果是自己（自己某一个接口所配置的IP地址或IP广播或者组播地址），则交给协议字段或者IPv6头部的下一个头部字段指定的协议模块处理。</li><li>如果不是： <ul><li>如果IP层被配置为路由器，则转发该数据报。</li><li>否则默默丢弃，必要时生成ICMP报文给发送者。</li></ul></li></ul><p>转发不会改变数据报的IP地址，只是通过设置链路层地址来完成交付的过程：</p><ul><li>发送者定义好源IP和目的IP，如果目的IP不在本地，则将链路层的目的MAC地址设置为路由器，由路由器代为转发。</li><li>每一跳路由器在转发时，都会将源MAC地址设置为自己，目的MAC地址设置为下一跳路由器。</li></ul><h3 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h3><p>IPv4（Internet Protocol Version 4）地址是一个32位的二进制数字，通常以点分十进制形式表示，由四个介于0到255之间的十进制数构成，各部分之间用句点（.）分隔。每个十进制数实际上代表了8位二进制数，因此整个IPv4地址共由四个8位段组成，总共32位。下面是IPv4地址的详细组成和功能说明：</p><ul><li>地址结构：<ul><li>一个IPv4地址看起来像这样：xxx.xxx.xxx.xxx，其中每个xxx是一个0到255之间的十进制数。</li></ul></li><li>网络部分（Network ID）：<ul><li>这一部分标识了网络或子网。根据不同的子网掩码（Netmask或Subnet Mask），网络部分的长度可以变化，决定了该地址属于哪个网络或子网。</li></ul></li><li>主机部分（Host ID）：<ul><li>这一部分用于标识网络内的特定主机。在同一网络中，每个主机的主机部分必须是唯一的。</li></ul></li><li>特殊地址：<ul><li>广播地址：全1的主机部分（如255.255.255.255）用于向网络内的所有主机发送数据。</li><li>网络地址：全0的主机部分表示网络本身，不指向任何特定主机。</li><li>回环地址：127.0.0.1是一个特殊的回环地址，用于本机测试，发送到该地址的数据包会被送到本机。</li></ul></li><li>子网掩码（Subnet Mask）：<ul><li>用于区分IP地址中的网络部分和主机部分，通常与IP地址一起使用。子网掩码也是一个32位的二进制数，其中网络部分对应位设为1，主机部分对应位设为0。</li></ul></li></ul><h4 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h4><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类，如下图所示：</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20211119105027526.png" alt="image-20211119105027526" style="zoom:80%;" /><ul><li>A类（Class A）：<ul><li>范围：1.0.0.0 到 126.255.255.255</li><li>第一个字节的最高位固定为0，接下来的7位表示网络地址，最后24位表示主机地址。</li><li>A类地址适用于大型网络，每个网络可以有大约1677万个主机地址。</li></ul></li><li>B类（Class B）：<ul><li>范围：128.0.0.0 到 191.255.255.255</li><li>前两个字节中，最高两位固定为10，接下来的14位表示网络地址，最后16位表示主机地址。</li><li>B类地址适用于中等规模的网络，每个网络最多可有65534个主机地址。</li></ul></li><li>C类（Class C）：<ul><li>范围：192.0.0.0 到 223.255.255.255</li><li>前三个字节中，最高三位固定为110，接下来的21位表示网络地址，最后8位表示主机地址。</li><li>C类地址适用于小型网络，每个网络最多可有254个主机地址，是最常见的分配给家庭用户和小型企业的地址类型。</li></ul></li><li>D类（Class D）：<ul><li>范围：224.0.0.0 到 239.255.255.255</li><li>第一个字节的最高四位固定为1110，用于多播（组播）通信，不分配给特定网络或主机，而是用于向一组主机同时发送数据。</li></ul></li><li>E类（Class E）：<ul><li>范围：240.0.0.0 到 255.255.255.255</li><li>第一个字节的最高位固定为11110，保留作研究和将来使用，目前不分配给任何网络或作为常规用途。</li></ul></li></ul><h4 id="特殊的主机地址"><a href="#特殊的主机地址" class="headerlink" title="特殊的主机地址"></a>特殊的主机地址</h4><p>在IPv4中，主机地址部分确实有一些特殊值，这些值具有特定的含义和用途，以下是一些重要的特殊值：</p><ul><li><strong>全 0 主机地址</strong>：<ul><li>当主机部分的所有位都是0时，这个地址表示的是网络地址，而不是任何特定的主机。它标识了一个特定的网络或子网，而不是网络内的某个设备。</li></ul></li><li><strong>全 1 主机地址</strong>：<ul><li>当主机部分的所有位都是1时，这个地址是广播地址。在IPv4中，广播地址用于向同一网络内的所有主机发送数据包。例如，192.168.1.255（假设网络部分是192.168.1）就是一个广播地址。</li></ul></li><li><strong>回环地址</strong>：<ul><li>虽然严格意义上这不是主机地址部分的特殊值，但127.0.0.1是一个特殊的IPv4地址，被称为回环地址。发送到这个地址的数据包不会离开本地计算机，而是被送回给发送方，常用于测试本地网络软件栈。</li></ul></li></ul><p>除了上述之外，还有一些地址被保留用于特殊目的，虽然它们不是仅通过主机地址部分的特殊值来定义，但它们在实际应用中具有特殊意义：</p><ul><li><strong>私有IP地址</strong>：<ul><li>私有IP地址范围内的地址（如10.0.0.0&#x2F;8、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16）在内部网络中使用，不能直接在公网上路由，用于节省公网IP地址资源。</li></ul></li><li><strong>未指定地址</strong>：<ul><li>0.0.0.0有时被用作未指定地址，特别是在配置中表示默认路由或作为源地址时，意味着“任意”或“本机尚未获得有效IP地址”。</li></ul></li></ul><h4 id="子网划分-与-子网掩码"><a href="#子网划分-与-子网掩码" class="headerlink" title="子网划分 与 子网掩码"></a>子网划分 与 子网掩码</h4><p>子网划分是网络工程中的一种技术，它允许将一个大的IP网络划分为多个更小的网络，称为子网。这样做可以更有效地利用IP地址空间，增强网络管理的灵活性，并提高网络安全性。以下是子网划分的基本概念和步骤：</p><ul><li><strong>子网划分的目的</strong><ul><li>节约IP地址：通过创建较小的子网，可以避免地址空间的浪费，尤其是在大型网络中。</li><li>增强网络管理：子网使得网络可以按逻辑或物理区域组织，便于管理和故障排查。</li><li>提高安全性：限制广播域，减少广播流量，同时可以通过子网隔离提高网络的安全级别。</li><li>便于路由聚合：在互联网中，CIDR允许将多个连续的子网聚合为一个更大的网络前缀，简化路由表。</li></ul></li><li><strong>子网划分的过程</strong><ul><li>确定子网掩码：子网掩码是一个32位的二进制数，其作用是区分IP地址中的网络部分和主机部分。通过增加子网掩码中1的个数，可以减少主机部分的位数，从而创建子网。</li><li>计算子网数量和主机数：</li><li>子网数量由子网掩码的位数决定。例如，&#x2F;24（即255.255.255.0）的网络，若划分为&#x2F;26（即255.255.255.192），则每个子网有(2^{2^(32-26)} &#x3D; 2^6 &#x3D; 64)个地址，减去网络地址和广播地址，每个子网可用主机数为62。</li><li>分配子网：根据网络的需求，将大网络划分为多个子网，并为每个子网分配一段连续的IP地址范围。</li><li>配置网络设备：在路由器和网络设备上设置正确的子网掩码和路由规则，确保数据包能够正确地在子网间转发。</li></ul></li><li><strong>子网划分实例</strong><ul><li>假设有一个C类网络192.168.1.0，默认子网掩码为255.255.255.0（&#x2F;24）。如果需要划分为4个子网，可以使用&#x2F;26的子网掩码（即255.255.255.192），这样每个子网将有64个地址，去除网络地址和广播地址后，每个子网实际可用的主机地址为62个。</li></ul></li></ul><h4 id="无分类-IP-地址-CIDR"><a href="#无分类-IP-地址-CIDR" class="headerlink" title="无分类 IP 地址 CIDR"></a>无分类 IP 地址 CIDR</h4><p>CIDR，全称 Classless Inter-Domain Routing（无类域间路由选择），是一种在Internet上管理和分配IP地址以及进行路由决策的策略。它是对传统分类网络地址体系（A类、B类、C类等）的改进，旨在更有效地利用IPv4地址空间，并简化路由表的管理。</p><ul><li><strong>CIDR的核心特点</strong>：<ul><li><strong>无类</strong>：CIDR摒弃了传统的A、B、C类地址的分类方式，不再根据地址的首位来决定网络大小，而是使用变长子网掩码（VLSM，Variable Length Subnet Mask），允许网络管理员灵活地分配地址空间。</li><li><strong>网络前缀</strong>：CIDR使用斜杠记法（&#x2F;）来表示IP地址和其对应的网络前缀长度。例如，192.168.1.0&#x2F;24表示前24位是网络部分，剩下的8位是主机部分。这等同于说该IP地址属于一个具有24位网络掩码的网络。</li><li><strong>路由聚合</strong>：CIDR允许将多个连续的网络汇聚成一个单一的、更短的路由条目，减少了路由表的大小，提高了路由器的效率和Internet路由的可扩展性。这一过程也称为超网（Supernetting）。</li><li><strong>地址分配效率</strong>：通过精细地调整子网大小，CIDR使得IP地址分配更加高效，尤其是在面对不同规模的网络需求时，可以更灵活地适应。</li></ul></li><li><strong>实施效果</strong>：<ul><li><strong>减少路由表项</strong>：通过路由聚合，ISP和其他大型网络运营商能够将大量网络汇总为少数几条路由，减轻了路由器的负担，加速了路由更新和查找过程。</li><li><strong>优化地址分配</strong>：CIDR使得IP地址的分配更加动态和适应性强，尤其是对于快速增长的网络和ISP而言，能够更合理地规划和使用稀缺的IPv4地址资源。</li><li><strong>促进过渡到IPv6</strong>：虽然CIDR有效缓解了IPv4地址耗尽的问题，但它也是推动向更大地址空间的IPv6过渡的一部分策略，因为IPv6的设计从一开始就采用了无类地址结构。</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p><code>IPv6</code>（Internet Protocol version 6）是互联网协议的第六版，设计用于替代<code>IPv4</code>，以解决IPv4地址空间耗尽的问题并提升网络性能。IPv6于1998年正式成为标准，其主要特点和改进包括：</p><ul><li><strong>扩大地址空间</strong>： IPv6使用128位地址，相较于IPv4的32位，这提供了极其庞大的地址空间（大约3.4×10^38个地址），足以满足全球网络扩张的需求，并且支持未来互联网设备的指数增长。</li><li><strong>简化报头结构</strong>： IPv6报头更为简洁，固定长度为40字节，而IPv4的报头长度可变。简化后的报头提升了数据包处理的效率，减少了延迟。</li><li><strong>内置安全特性</strong>： IPv6原生支持IPsec（Internet Protocol Security），提供更强的数据安全和验证功能，有助于保障端到端的通信安全。</li><li><strong>取消广播，采用组播</strong>： IPv6不再支持广播地址，而是使用一种更灵活的组播（Multicast）通信，使得数据可以高效地传送到一组感兴趣的接收者。</li><li><strong>无状态地址自动配置</strong>（SLAAC）： IPv6设备可以自动配置其接口地址，无需DHCP服务器，简化了网络管理。设备通过路由器宣告的路由器广告消息获得网络前缀和配置信息。</li><li><strong>邻居发现协议</strong>（NDP）： 替代了IPv4中的ARP协议，提供地址解析、重复地址检测、邻居状态跟踪等多种功能。</li><li><strong>流标签</strong>： IPv6报头中的流标签字段允许数据包标记特定的流量，便于路由器对特定数据流应用特定的服务质量（QoS）策略。</li><li><strong>扩展报头</strong>： IPv6使用一系列可选的扩展报头来实现分片、路由选择、认证、封装等高级功能，这些报头可以根据需要插入到基本报头之后，提供了更高的灵活性和扩展性。</li><li><strong>兼容性和过渡技术</strong>： 为实现IPv4向IPv6的平滑过渡，开发了一系列过渡技术，如双栈（Dual Stack）、隧道技术（如6to4、ISATAP）和翻译技术（如NAT64）。</li></ul><h2 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h2><p><code>ARP（Address Resolution Protocol，地址解析协议）</code>是网络层和数据链路层之间的一个重要协议，<strong>主要用于在局域网（LAN）中将已知的IP地址解析为对应的MAC（Media Access Control，媒体访问控制）地址</strong>。在IPv4网络中，数据链路层的通信依赖于MAC地址，而网络层的通信则使用IP地址。因此，ARP协议在IP通信过程中扮演着桥梁的角色，确保数据包能够从发送方正确地传递到接收方。以下是ARP协议的工作原理和过程：</p><h3 id="ARP-工作原理"><a href="#ARP-工作原理" class="headerlink" title="ARP 工作原理"></a>ARP 工作原理</h3><ul><li><strong>查询过程：</strong><ul><li>当一台主机需要向同一局域网内的另一台主机发送数据时，首先检查自己的ARP缓存表中是否有目标IP地址对应的MAC地址。</li><li>如果没有找到，则该主机构造一个ARP请求报文，该报文中包含发送方的IP地址和MAC地址，以及目标IP地址（但不包含目标MAC地址，因为这就是查询的目的）。</li><li>这个ARP请求以广播形式发送到局域网内所有主机，因为此时发送方不知道目标的具体MAC地址。</li></ul></li><li><strong>响应过程：</strong><ul><li>目标主机接收到ARP请求后，识别出请求中的IP地址与自己的相符，便将自己MAC地址封装在一个ARP响应报文中，然后以单播形式发送给请求方。</li><li>发送方收到响应后，将目标IP地址与MAC地址的对应关系存储到自己的ARP缓存表中，以便后续通信直接使用，同时可以开始数据的传输。</li></ul></li></ul><h3 id="ARP缓存"><a href="#ARP缓存" class="headerlink" title="ARP缓存"></a>ARP缓存</h3><ul><li>每个主机都维护一个ARP缓存表，用来存储已知的IP地址到MAC地址的映射关系，以减少网络中的ARP请求广播。缓存中的条目可以是动态学习的（通过ARP响应获得），也可以是静态配置的（由网络管理员设定）。</li></ul><h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><ul><li>ARP协议基于信任机制，容易受到ARP欺骗攻击。攻击者可以通过发送伪造的ARP响应，误导其他主机将数据发送到错误的MAC地址，从而截获或中断通信。</li></ul><h2 id="ICMP-协议"><a href="#ICMP-协议" class="headerlink" title="ICMP 协议"></a>ICMP 协议</h2><p><code>ICMP（Internet Control Message Protocol，互联网控制消息协议）</code>是网络层的一个重要协议，它主要用于在IP主机、路由器之间传递控制和差错报告信息。ICMP并非为传输数据而设计，而是作为IP协议的补充，提供网络层的错误报告、拥塞控制、路径探测等功能。以下是ICMP协议的主要功能和消息类型：</p><h3 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h3><ul><li><strong>差错报告</strong>：当IP数据包无法送达目的地时，沿途的路由器或目标主机可能通过ICMP发送错误消息给源主机，告知数据包无法送达的原因，如目标不可达、超时、重定向等。</li><li><strong>网络诊断</strong>：最著名的应用是ping命令，它利用ICMP的Echo Request和Echo Reply消息来测试两台主机之间的连通性及往返时间（RTT）。</li><li><strong>路径控制</strong>：路由器可以使用ICMP重定向消息通知主机关于更好的路由路径，帮助改善网络性能。</li><li><strong>拥塞控制</strong>：某些类型的ICMP消息可以用来指示网络拥塞，尽管现代网络中这种方法已较少使用。</li></ul><h3 id="常见ICMP消息类型："><a href="#常见ICMP消息类型：" class="headerlink" title="常见ICMP消息类型："></a>常见ICMP消息类型：</h3><ul><li>Echo Request (Type 8)：用于测试目的主机的可达性，通常与ping命令关联。</li><li>Echo Reply (Type 0)：作为对Echo Request的响应，确认目的主机已收到请求并返回。</li><li>Destination Unreachable (Type 3)：当数据包无法到达目的地时，路由器或主机发送此消息，指出不可达的原因。</li><li>Time Exceeded (Type 11)：当IP数据包生存时间（TTL）耗尽仍未到达目的地时，路由器会发送此消息。</li><li>Parameter Problem (Type 12)：如果IP数据包头部有错误（如必要的字段缺失），接收方会发送此消息。</li><li>Redirect (Type 5)：路由器使用此消息通知主机应该使用另一个路由器作为到达特定目的地的下一跳。</li><li>Source Quench (Type 4)：已被废弃，过去用于拥塞控制，通知发送方降低发送速率。</li></ul><h2 id="网络层设备-——-路由器"><a href="#网络层设备-——-路由器" class="headerlink" title="网络层设备 —— 路由器"></a>网络层设备 —— 路由器</h2><p>路由器（Router）是计算机网络中至关重要的网络设备，<strong>它负责在不同的网络之间转发数据包</strong>。路由器的功能如下：</p><h4 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h4><ul><li>寻址与转发：路由器读取每个数据包中的IP地址信息，根据路由表中的信息决定数据包的转发路径，实现不同网络之间的互联互通。</li><li>协议理解：路由器能够理解并处理多种网络通信协议，如以太网协议、TCP&#x2F;IP协议等，确保不同协议的数据包能够正确转发。</li><li>路由选择：路由器依据路由算法（包括静态路由和动态路由）来决定最佳路径，动态路由能够根据网络状况变化自动调整路由选择。</li></ul><h4 id="网络互连："><a href="#网络互连：" class="headerlink" title="网络互连："></a>网络互连：</h4><p>路由器作为网关设备，可以连接不同类型的网络，例如将局域网（LAN）与广域网（WAN）相连，或者连接不同协议的网络。</p><h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>在必要时，路由器可以执行网络地址转换（NAT），将内部私有IP地址转换为外部公共IP地址，或者反之，以便不同类型的网络间能够相互通信。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 物理层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——物理层"><a href="#计算机网络——物理层" class="headerlink" title="计算机网络——物理层"></a>计算机网络——物理层</h1><p>物理层 负责解决在各种传输媒体上传输比特 0 和 1 的问题，进而给数据链路层提供透明传输比特流的服务</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/20191128164313811.JPG" alt="img"></p><h2 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h2><p>物理层的功能：怎样在连接各种计算机的传输媒体上传输数据比特流，屏蔽不同传输媒体和通信手段的差异</p><p>规程：用于物理层的协议</p><p>传输媒体接口的特性：</p><ul><li>机械特性：接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li><li>电气特性：接口电路的各条线上出现的电压范围</li><li>功能特性：某条线上出现某一电平电压的意义</li><li>过程特性：对于不同功能的各种可能事件的出现顺序</li></ul><h2 id="数据通信基本知识"><a href="#数据通信基本知识" class="headerlink" title="数据通信基本知识"></a>数据通信基本知识</h2><h3 id="数据通信系统模型"><a href="#数据通信系统模型" class="headerlink" title="数据通信系统模型"></a>数据通信系统模型</h3><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630211130501.png" alt="image-20240630211130501" style="zoom: 67%;" /><ul><li>如上图所示，一个数据通信系统可划分为三大部分，即<ul><li><strong>源系统（或发送端、发送方)</strong></li><li><strong>传输系统（或传输网络）</strong></li><li>**目的系统（或接收端、接收方)**。</li></ul></li></ul><ul><li><p>常用术语：</p><ul><li><p><strong>消息</strong>：通信的目的是传送消息，如语音、文字、图像、视频等</p></li><li><p><strong>数据</strong>：是运送消息的实体；使用特定方式表示的信息，通常是有意义的符号序列</p></li><li><p><strong>信号</strong>：数据的电气或电磁表现</p></li><li><p>**模拟信号 (连续信号)**：代表消息的参数取值是连续的</p></li><li><p>**数字信号 (离散信号)**：代表消息的参数的取值是离散的</p></li><li><p><strong>码元</strong>：代表不同离散数值的基本波形</p></li></ul></li></ul><h3 id="信道基本概念"><a href="#信道基本概念" class="headerlink" title="信道基本概念"></a>信道基本概念</h3><ul><li><p><strong>信道</strong>：表示向某一个方向传送信息的媒体</p></li><li><p><strong>信息交互的方式</strong>：</p><ul><li><p>单向通信(单工通信)：只能有一个方向的通信而没有反方向的交互；只需要一条信道</p></li><li><p>双向交替通信(半双工通信)：通信的双方都可以发送信息，但不能双方同时发送，而是一方发送另一方接收，一段时间后可以反过来；两条信道</p></li><li><p>双向同时通信(全双工通信)：通信双方可以同时发送和接收信息；两条信道；传输效率最高</p></li></ul></li><li><p><strong>基带信号</strong>：来自信源的信号；如计算机输出的代表文字或图像的数据信号都是基带信号</p></li><li><p><strong>调制分类</strong>：</p><ul><li><p>**基带调制(编码)**：仅对基带信号的波形进行变换，使其能与信道特性相适应，变换后的信号仍是基带信号</p></li><li><p><strong>带通调制</strong>：使用载波进行调制，把基带信号的频率范围移到较高频段，并转换为模拟信号，变换后的信号称为带通信号</p></li></ul></li><li><p><strong>常用编码方式</strong></p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630212518146.png" alt="image-20240630212518146"></p><ul><li><p><strong>不归零制</strong>：正电平代表1，负电平代表0</p></li><li><p><strong>归零制</strong>：正脉冲代表1，负脉冲代表0</p></li><li><p><strong>曼切斯特编码</strong>：位周期中心的向上跳变代表0，位周期中心的向下跳变代表1；也可反过来定义</p></li><li><p><strong>差分曼切斯特编码</strong>：在每一位的中心处始终都有跳变。位开始边界有跳变代表0，位开始边界没有跳变代表1</p></li></ul></li></ul><p><strong>基本带通调制方法</strong></p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630212440455.png" alt="image-20240630212440455" style="zoom: 80%;" /><ul><li><strong>调幅</strong>：载波的振幅随基带数字信号而变化；如0或1分别对应无载波或有载波输出</li><li><strong>调频</strong>：载波的频率随基带数字信号而变化；如0或1分别对应频率f1或f2</li><li><strong>调相</strong>：载波的初始相位随基带数字信号而变化；如0或1分别对应于相位0度或180度</li></ul><h3 id="信道极限容量"><a href="#信道极限容量" class="headerlink" title="信道极限容量"></a>信道极限容量</h3><p>限制码元在信道上传输速率的因素：</p><ul><li><p>信道能够通过的频率范围：</p><ul><li><strong>码间串扰</strong>：信号中高频分类受到衰减，在接收端收到的波形前沿和后沿不那么陡峭，每个码元所占时间界限不明确，失去了码元间的清晰界限的现象</li><li><strong>奈氏准则</strong>：在任何信道，码元传输的速率是有上限的，超过上限就会出现严重的码间串扰，使接收端对码元无法识别</li></ul></li><li><p>信噪比：</p><ul><li><p>定义：信号的平均功率和噪声的平均功率之比，记作S&#x2F;N</p><p>$$信噪比 (dB)&#x3D;10 log 10 (S&#x2F;N)$$</p></li><li><p>香农公式：信道的极限信息传输速率C是</p><p>$$C&#x3D;Wlog<del>2</del>(1+S&#x2F;N)(bit&#x2F;s)$$</p><p>其中</p><ul><li>W为信道带宽，</li><li>S为信道内所传信号的平均功率，</li><li>N为信道内部的高斯噪声功率</li></ul><p>香农公式表明，信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高</p><p>香农公式的意义：只要信息传输速率低于信道的极限速率，就一定存在某种方法来实现无差错的传输</p></li></ul></li></ul><h2 id="物理层传输媒体"><a href="#物理层传输媒体" class="headerlink" title="物理层传输媒体"></a>物理层传输媒体</h2><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。传输媒体可分为两大类：</p><ul><li><strong>导引型传输媒体</strong>：在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播；</li><li><strong>非导引型传输媒体</strong>：非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输。</li></ul><p>下图是电信领域使用的电磁波的频谱。<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630213537285.png" alt="image-20240630213537285" style="zoom:70%;" /></p><h3 id="引导型传输媒体"><a href="#引导型传输媒体" class="headerlink" title="引导型传输媒体"></a>引导型传输媒体</h3><p>常见引导性传输媒体包括</p><ul><li>双绞线</li><li>同轴电缆</li><li>光纤</li></ul><h3 id="非引导性媒体"><a href="#非引导性媒体" class="headerlink" title="非引导性媒体"></a>非引导性媒体</h3><p>若通信线路要通过一些高山或岛屿，有时就很难施工。即使是在城市中，挖开马路敷设电缆也不是一件很容易的事。当通信距离很远时，敷设电缆既昂贵又费时。但利用无线电波在自由空间的传播就可较快地实现多种通信。非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。无线传输所使用的频段很广。短波通信主要是靠电离层的反射，但短波信道的通信质量较差。</p><p>两种通信方式：</p><ul><li><strong>地面微波接力通信</strong>：微波接力通信可传输电话、电报、图像、数据等信息。微波波段频率很高，其频段范围也很宽，因此其通信信道的容量很大。与相同容量和长度的电缆载波通信比较，微波接力通信建设投资少，见效快，易于跨越山区、江河。但是微波接力通信与电缆通信系统比较，微波通信的隐蔽性和保密性较差，同时对大量中继站的使用和维护要耗费较多的人力和物力。</li><li><strong>卫星通信</strong>：卫星通信的频带很宽，通信容量很大，信号所受到的干扰也较小，通信比较稳定。卫星通信的另一特点就是具有较大的传播时延。</li></ul><p>当利用无线信道传送数字信号时，必须使误码率（即比特错误率）不大于可容许的范围。三个有关的基本概念：</p><ul><li>对于给定的调制方式和数据率，信噪比越大，误码率就越低。</li><li>对于同样的信噪比，具有更高数据率的调制技术的误码率也更高。</li><li>如果移动用户在进行通信时还在不断改变自己的地理位置，就会引起无线信道特性的改变，因而信噪比和误码率都会发生变化。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 通信基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络 —— 链路层</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络——数据链路层"><a href="#计算机网络——数据链路层" class="headerlink" title="计算机网络——数据链路层"></a>计算机网络——数据链路层</h1><h2 id="链路层功能"><a href="#链路层功能" class="headerlink" title="链路层功能"></a>链路层功能</h2><p>数据链路层在物理层提供服务的基础上向网络层提供服务，将物理层提供的可能出错的物理连接改造为逻辑上无差错的数据链路。基本任务是将源机器中来自网络层的数据传输到目标机器的网络层。</p><p> 数据链路指网络中两个结点之间的逻辑通道，把实现控制数据传输协议的硬件和软件加到链路上就构成数据链路。数据链路层负责通过一条链路从一个结点向另一个物理链路直接相连的相邻结点传送数据报。</p><h4 id="为网络层提供服务"><a href="#为网络层提供服务" class="headerlink" title="为网络层提供服务"></a>为网络层提供服务</h4><ul><li><p><strong>无确认的无连接服务</strong><br>源机器发送数据帧时不需先建立链路连接，目的机器收到数据帧时不需发回确认。适用于实时通信或误码率较低的通信信道，如以太网。</p></li><li><p><strong>有确认的无连接服务</strong><br>源机器发送数据帧时不需先建立链路连接，但目的机器收到数据帧时必须发回确认。源机器在所规定的时间内未收到确定信号时，就重传丢失的帧。该服务适用于误码率较高的通信信道，如无线通信。</p></li><li><p><strong>有确认的面向连接服务</strong><br>帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对收到的每一帧都要给出确认，源机器收到确认后才能发送下一帧。该服务适用于通信要求（可靠性、实时性）较高的场合。</p></li></ul><h4 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h4><p> 数据链路层连接的建立、维持和释放过程称为链路管理，它主要用于面向连接的服务。</p><h4 id="封装成帧与透明传输"><a href="#封装成帧与透明传输" class="headerlink" title="封装成帧与透明传输"></a>封装成帧与透明传输</h4><p> 两台主机之间传输信息时，必须将网络层的分组封装成帧，以帧的格式进行传送。</p><ul><li>帧构成：数据前后添加首部和尾部。帧长&#x3D;数据长度+首部长度+尾部长度</li><li>帧定界：帧首部尾部包含控制信息，其中一个重要作用是确定帧的界限。</li><li>帧同步：接收方应能从接收到的二进制比特流中区分出帧的起始与终止。</li><li>最大传送单元（MTU）：为了提高帧的传输效率，应当使帧的数据部分的长度尽可能地大于首部和尾部的长度，但每种数据链路层协议都规定了帧的数据部分的长度上限——最大传送单元（MTU）。</li></ul><h4 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h4><ul><li>由于信道噪声等原因，帧在传输过程中可能出现错误。</li><li>用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。</li><li>位错 —— 帧中某些位出现了差错<ul><li>通常采用循环冗余校验（CRC）方式发现<strong>位错</strong> （帧中某些位出现了差错）</li><li>通过自动重传请求（Automatic Repeat reQuest, ARQ）方式来重传出错的帧。</li></ul></li><li>帧错 —— 帧的丢失、重复或失序等错误。<ul><li>在数据链路层引入定时器和编号机制，能保证每一帧最终都能有且仅有一次正确地交付给目的结点。</li></ul></li></ul><h2 id="链路分类"><a href="#链路分类" class="headerlink" title="链路分类"></a>链路分类</h2><h3 id="广播式链路"><a href="#广播式链路" class="headerlink" title="广播式链路"></a>广播式链路</h3><p>一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。</p><p>所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。</p><p>主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</p><h3 id="点对点链路"><a href="#点对点链路" class="headerlink" title="点对点链路"></a>点对点链路</h3><p>一对一通信。</p><p>因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>频分复用： 将多路信号调制到不同频率的载波上再进行叠加</li><li>时分复用： 将物理信道按时间划分为若干时间片，轮流给不同信道使用</li><li>波分复用： 光纤中传输不同波长的光信号 —— 实际也是频分</li><li>码分复用： 靠不同的编码来区分各路原始信号，如 CDMA 技术</li></ul><h2 id="如何实现-随机访问"><a href="#如何实现-随机访问" class="headerlink" title="如何实现 随机访问"></a>如何实现 随机访问</h2><p>略</p><h2 id="关键协议"><a href="#关键协议" class="headerlink" title="关键协议"></a>关键协议</h2><ul><li><strong>以太网（Ethernet）：</strong><ul><li>最常见的局域网（LAN）技术之一，基于载波侦听多点接入&#x2F;碰撞检测（CSMA&#x2F;CD）协议，适用于共享介质环境。以太网定义了如何封装数据成帧，以及如何在物理层之上提供错误检测和纠正功能。</li></ul></li><li><strong>点对点协议（PPP, Point-to-Point Protocol）：</strong><ul><li>通常用于串行线路，如拨号连接或DSL，提供简单、直接的两节点间的连接。PPP支持多种网络层协议（如IP），并具备错误检测、支持认证等功能。</li></ul></li><li><strong>高级数据链路控制（HDLC, High-Level Data Link Control）：</strong><ul><li>一种面向比特的协议，常用于广域网（WAN）和专线连接，提供可靠的数据传输服务。HDLC支持多种操作模式，包括正常响应模式（NRM）、异步平衡模式（ABM）等。</li></ul></li><li><strong>帧中继（Frame Relay）：</strong><ul><li>一种面向连接的数据链路层协议，主要用于广域网通信。帧中继提供了一种高效的、基于虚电路的服务，它在性能上介于传统的电路交换和包交换之间，适用于高速数据传输。</li></ul></li><li><strong>异步传输模式（ATM, Asynchronous Transfer Mode）：</strong><ul><li>设计用于宽带网络，ATM是一种面向连接的、分组交换的技术，它将数据分割成固定长度的信元（cell），适用于高速网络和多媒体传输。</li></ul></li><li><strong>IEEE 802系列标准：</strong><ul><li>包括了多种局域网和城域网的数据链路层协议，如IEEE 802.3（以太网）、IEEE 802.11（无线局域网Wi-Fi）、IEEE 802.15（无线个人区域网，如蓝牙）等。</li></ul></li></ul><h2 id="关键设备"><a href="#关键设备" class="headerlink" title="关键设备"></a>关键设备</h2><ul><li><strong>网络交换机（Switch）：</strong><ul><li>网络交换机是局域网中最常见的设备，能够根据数据帧中的MAC地址（媒体访问控制地址）来转发数据帧。它通过学习连接设备的MAC地址并建立MAC地址表来高效地在不同端口之间转发数据，支持多个设备同时通信而不冲突。</li></ul></li><li><strong>网桥（Bridge）：</strong><ul><li>网桥用于连接两个或多个局域网（LAN），通过检查数据帧的MAC地址来决定是否转发该帧到另一个网络段，以此来分割广播域，减少网络拥堵，提高网络性能。网桥相比交换机，功能较为基础，通常应用于较小规模的网络中。</li></ul></li><li><strong>网卡（Network Interface Card, NIC）：</strong><ul><li>网卡是安装在计算机或网络设备上的硬件组件，它提供了一个物理接口，用于连接到网络媒介（如双绞线、光纤等）。网卡负责在计算机和网络之间转换数据帧，执行数据链路层的封装和解封装，以及物理层的信号编码与解码。</li></ul></li><li><strong>路由器（Router）：</strong><ul><li>虽然路由器主要工作在网络层，但在某些讨论中，其数据链路层功能也不容忽视，特别是当涉及到不同局域网间的数据链路层协议转换时（如在某些多协议标签交换MPLS应用中）。路由器使用网络层地址（如IP地址）来转发数据包，但在实际操作中也会涉及到数据链路层的帧封装。</li></ul></li></ul><p>虽然路由器通常归在网络层设备，但在实际网络部署中，路由器的接口也会执行数据链路层的功能，如以太网接口的MAC地址处理。因此，根据上下文，路由器有时也被提及在数据链路层的讨论中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络概述</title>
      <link href="/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="什么是计算机网络"><a href="#什么是计算机网络" class="headerlink" title="什么是计算机网络"></a>什么是计算机网络</h3><ul><li><strong>广义观点</strong>：能实现远程信息处理的系统或能进一步达到资源共享的系统。</li><li><strong>资源共享观点</strong>：以能够相互 共享资源 的方式互连起来的自治计算机系统的集合。</li><li>目的：资源共享；组成：多台自治计算机；规则：网络协议</li><li><strong>用户透明性观点</strong>：整个网络就像一个大的计算机系统一样对用户是透明的。</li></ul><h3 id="链路，结点，协议和服务，实体和对等实体，PDU"><a href="#链路，结点，协议和服务，实体和对等实体，PDU" class="headerlink" title="链路，结点，协议和服务，实体和对等实体，PDU"></a>链路，结点，协议和服务，实体和对等实体，PDU</h3><ul><li><strong>链路</strong>：连接结点的称为链路，可以是铜缆，光纤，卫星等</li><li><strong>结点</strong>：可以是计算机，集线器，交换机或路由器等</li><li><strong>协议</strong>： 两个对等实体之间的通信规则。协议规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到信息或发生的事件所采取的动作。协议有三要素：语法（数据与控制信息的结构或格式、信号电平）、语义（需要发出何种控制信息、完成何种动作以及做出何种响应、差错控制）、时序（事件顺序、速度匹配）</li><li><strong>服务</strong>：在协议的控制下，本层向上一层提供服务，本层使用下一层所提供的服务</li><li><strong>实体</strong>：任何可发送或接收信息的硬件或软件进程</li><li><strong>对等实体</strong>：位于同等层中相互通信的两个实体。对等实体之间处理相同的PDU。</li><li><strong>PDU</strong>：对等层之间传送的数据单位</li></ul><h3 id="C-S模式，B-S模式，P2P模式"><a href="#C-S模式，B-S模式，P2P模式" class="headerlink" title="C&#x2F;S模式，B&#x2F;S模式，P2P模式"></a>C&#x2F;S模式，B&#x2F;S模式，P2P模式</h3><ul><li><strong>C&#x2F;S模式</strong>：也即客户-服务器方式。客户是服务请求方，服务器是服务提供方。客户必须知道服务器的地址，反之不必</li><li><strong>B&#x2F;S模式</strong>：也即浏览器-服务器方式。在服务器安装SQLserver，MYSQL等数据库，浏览器通过web server同数据库进行数据交换</li><li><strong>P2P模式</strong>：对等方式，通信在对等实体之间直接进行。每一个主机既是客户又是服务器，本质上仍是C&#x2F;S</li></ul><h3 id="LAN-WAN-MAN-PAN的划分"><a href="#LAN-WAN-MAN-PAN的划分" class="headerlink" title="LAN, WAN, MAN, PAN的划分"></a>LAN, WAN, MAN, PAN的划分</h3><table><thead><tr><th>网络</th><th>范围</th><th>特点</th></tr></thead><tbody><tr><td>广域网（WAN）</td><td>10km-1000km</td><td>互联网、交换技术</td></tr><tr><td>城域网（MAN）</td><td>5km-50km</td><td>以太网</td></tr><tr><td>局域网（LAN）</td><td>10m-5km</td><td>广播技术</td></tr><tr><td>个人局域网（PAN）</td><td>0-10m</td><td>无线技术</td></tr></tbody></table><h3 id="网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率"><a href="#网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率" class="headerlink" title="网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率"></a>网络性能参数：速率，带宽，吞吐量，时延，往返时间，信道利用率</h3><ul><li>速率：数据的传送速率，单位是Bit&#x2F;s</li><li>带宽:在计算机网络中，网络带宽表示单位时间内网络中某信道所能通过的“最高数据率”，单位为bit&#x2F;s</li><li>吞吐量:表示在发送端与接收端之间实际的传送数据速率（bit&#x2F;s）</li><li>时延:指数据从网络的一端传送到另外一端所需的时间。</li><li>发送时延：是主机或路由器发送数据帧所需要的时间。公式为：数据帧长度（bit）&#x2F;发送速率（bit&#x2F;s）</li><li>传播时延：是电磁波在信道中传播一定的距离需要花费的时间。公式为：信道长度（m）&#x2F;电磁波在信道上的传播速率（m&#x2F;s）</li><li>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理</li><li>排队时延：在分组进入路由器后要先在输入队列中排队等待处理</li><li>往返时间:从发送方发送数据开始，到发送方收到来自接受方的确认，总共经历的时间</li><li>信道利用率:指某信道有百分之几的时间是有数据通过的<ul><li>信道利用率并非越高越好，因为当利用率增大时，该信道引起的时延也就迅速增加</li></ul></li></ul><h3 id="互联网的组成（边缘部分与核心部分的作用）"><a href="#互联网的组成（边缘部分与核心部分的作用）" class="headerlink" title="互联网的组成（边缘部分与核心部分的作用）"></a>互联网的组成（边缘部分与核心部分的作用）</h3><ul><li><strong>边缘部分</strong>：各种端系统如主机，手机，大型或超级计算机组成。位于网络边缘；运行网络应用程序</li><li><strong>核心部分</strong>：互联的路由器网络。关键功能：路由和转发，其中交换机是在同一个子网内部转发数据，路由器是在不同子网之间转发数据。以数据交换的方式实现数据从源主机通过网络核心到达目的主机。</li></ul><h3 id="互联网基本拓扑类型"><a href="#互联网基本拓扑类型" class="headerlink" title="互联网基本拓扑类型"></a>互联网基本拓扑类型</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630205630445.png" alt="image-20240630205630445"></p><h3 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>最经典的电路交换网络是电话网络。主要特点就是独占资源。电路交换的三个阶段：建立连接（呼叫）、通信、释放连接（挂机）。用多路复用技术解决一条链路被多路通信共享的问题</p><h4 id="分组交换："><a href="#分组交换：" class="headerlink" title="分组交换："></a>分组交换：</h4><p>报文：源应用发送的信息整体<br>分组：由报文拆分成较小的数据块<br>在发送端，先把较长的报文划分成较短的，固定长度的数据段<br>每一个数据段前面添加上首部构成分组。每一个分组的首部都含有地址等控制信息<br>依次把各分组发送到接收端。每个分组在互联网中独立地选择传输路径<br>接收端收到分组后剥去首部还原成报文</p><h4 id="数据报交换"><a href="#数据报交换" class="headerlink" title="数据报交换"></a>数据报交换</h4><p>将整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点</p><h4 id="虚电路交换"><a href="#虚电路交换" class="headerlink" title="虚电路交换"></a>虚电路交换</h4><p>即先建一条逻辑通路，其通信过程类似电路交换。每个分组除了包含数据之外还包含一个虚电路标识号，而不是目的地址的信息；在预先建好的路径上的每个节点都知道把这些分组引导到哪里去，数据分组按已建立的路径顺序通过网络，不再需要路由选择判定。</p><h1 id="计算机网络层次划分"><a href="#计算机网络层次划分" class="headerlink" title="计算机网络层次划分"></a>计算机网络层次划分</h1><p>主要有三种划分方式</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630202830599.png" alt="image-20240630202830599"></p><p>在计算机网络体系结构的各个层次中，每个报文都分为两部分：一是数据部分，即SDU；二是控制信息部分，即PCI,它们共同组成PDU。</p><ul><li>服务数据单元(SDU)：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。</li><li>协议控制信息(PCI)：控制协议操作的信息。第n层的协议控制信息记为n-PCL。</li><li>协议数据单元(PDU)：对等层次之间传送的数据单位称为该层的PDU。</li></ul><h2 id="OSI-链路模型"><a href="#OSI-链路模型" class="headerlink" title="OSI 链路模型"></a>OSI 链路模型</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240630205411614.png" alt="image-20240630205411614"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 状态详解</title>
      <link href="/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%20%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-状态详解"><a href="#TCP-状态详解" class="headerlink" title="TCP 状态详解"></a>TCP 状态详解</h1><h3 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2846604-6a8557619966204d.png" alt="img"></p><h2 id="TCP-状态梳理"><a href="#TCP-状态梳理" class="headerlink" title="TCP 状态梳理"></a>TCP 状态梳理</h2><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>LISTEN</td><td>等待来自远程TCP应用程序的请求</td></tr><tr><td>SYN_SENT</td><td>发送连接请求后等待来自远程端点的确认。TCP第一次握手后客户端所处的状态</td></tr><tr><td>SYN-RECEIVED</td><td>该端点已经接收到连接请求并发送确认。 该端点正在等待最终确认。TCP第二次握手后服务端所处的状态</td></tr><tr><td>ESTABLISHED</td><td>代表连接已经建立起来了。这是连接数据传输阶段的正常状态</td></tr><tr><td>FIN_WAIT_1</td><td>等待来自远程TCP的终止连接请求或终止请求的确认</td></tr><tr><td>FIN_WAIT_2</td><td>在此端点发送终止连接请求后，等待来自远程TCP的连接终止请求</td></tr><tr><td>CLOSE_WAIT</td><td>该端点已经收到来自远程端点的关闭请求，此TCP正在等待本地应用程序的连接终止请求</td></tr><tr><td>CLOSING</td><td>等待来自远程TCP的连接终止请求确认</td></tr><tr><td>LAST_ACK</td><td>等待先前发送到远程TCP的连接终止请求的确认</td></tr><tr><td>TIME_WAIT</td><td>等待足够的时间来确保远程TCP接收到其连接终止请求的确认</td></tr></tbody></table><p><strong>牢记： TCP 到处都是坑</strong>， 现在就开始找坑</p><h2 id="SYN-SENT"><a href="#SYN-SENT" class="headerlink" title="SYN_SENT"></a>SYN_SENT</h2><ul><li><p>归属： 客户端独有</p></li><li><p>原因：</p><ul><li>网络延迟</li><li>服务器负载过高</li><li>防火墙有问题</li><li>中病毒——自动扫描其它机器</li></ul></li><li><p>限制</p><ul><li>超时后重传，重传间隔时间递增</li><li>限制最大重传次数</li></ul></li><li><p>linux syn 重试次数限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w net.ipv4.tcp_syn_retries=6</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 6 &gt; /proc/sys/net/ipv4/tcp_syn_retries</span><br></pre></td></tr></table></figure></li></ul><h2 id="SYN-RECV"><a href="#SYN-RECV" class="headerlink" title="SYN_RECV"></a>SYN_RECV</h2><ul><li><p>归属： 服务端独有</p></li><li><p>原因：</p><ul><li>对端网络突然异常 ？</li><li>网络攻击 —— <strong>SYN 泛洪攻击</strong></li></ul></li><li><p>术语</p><ul><li>SYN_FLOOD 泛洪攻击</li><li>半连接队列 <ul><li>自然 还有一个全连接队列</li></ul></li></ul></li><li><p>SYN_FLOOD 防范</p><ul><li>扩展半连接队列上限<ul><li><code>net.ipv4.tcp_max_syn_backlog</code></li></ul></li><li>覆盖最早半连接记录</li><li>SYN Cookie<ul><li>原理： <ul><li>收到 SYN 请求不加入半连接队列，而是通过提取当前 socket 及其他相关特征参数 通过某种特定算法生成 一个 cookie 并作为 seq &#x2F; 时间戳 或设置为其 高位部分</li><li>客户端收到后，再次返回 ACK ， 其中 cookie 所存储在的字段保留返回</li><li>server 端收到 ACK 之后，拿到 cookie ， 并当前状态重新计算一个 cookie ，进行对比验证，通过则直接加入 全连接队列， 否则 关闭相应 SOCKET</li></ul></li><li>优点： 可以在一定程度上规避 SYN Flood 攻击造成的资源消耗</li><li>缺点： <ul><li>误判风险：在某些情况下，合法的连接请求可能会因为Cookie验证失败而被错误地拒绝，尤其是在网络条件不稳定或时间同步问题导致时间戳不准确时。</li><li>功能限制：SYN Cookie不记录连接元数据，因此在连接建立后，服务器无法恢复到正常TCP行为下的某些高级特性，如TCP窗口缩放等。</li></ul></li></ul></li></ul></li><li><p>非攻击导致 半连接队列高涨</p><ul><li>可考虑修改 <code>net.ipv4.tcp_synack_retries</code></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240629203831107.png" alt="image-20240629203831107" style="zoom:67%;" /></li></ul><h2 id="FIN-WAIT-1"><a href="#FIN-WAIT-1" class="headerlink" title="FIN_WAIT_1"></a>FIN_WAIT_1</h2><ul><li>TCP 主动断开方，用户态进行系统调用 close()，内核发送 FIN 包， SOCKET 进入 FIN_WAIT_1 状态</li><li>FIN_WAIT_1 超时<ul><li>假设另一端非标准 或 恶意 TCP 端，诱导你发送 FIN，但一直不回 ACK，怎么办？</li><li>参考： <a href="https://blog.csdn.net/dog250/article/details/81697403">TCP FIN_WAIT1 超时机制 及 TCP假连接问题</a> ， 相关结论如下：<ul><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1，若对端此后无ACK返回，则无论是 pending在发送缓冲的数据 还是 FIN，Linux 内核都会尝试重新发送，并在收到 ACK 前会尝试 N 次退避， N 由 tcp_orphan_retries 参数控制</li><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1状态，此时如果对端接收窗口呈现打开状态，则主动断开端的 TCP 发送队列中的数据包会继续发往接收端，并在最后发送FIN包，收到FIN包ACK后进入FIN_WAIT2</li><li>主动断开端调用 close 关掉进程，随后进入FIN_WAIT1状态，此时如果对端接收窗口呈现关闭状态(零窗口)，此时主动端开端会不断发送零窗口探测包。且发送次数限制为：<ul><li>低版本内核(至少社区3.10及以下)：永久尝试，如果探测ACK每次都返回，则没完没了。</li><li>高版本内核(至少社区4.6及以上)：限制尝试tcp_orphan_retries次，不管是否收到探测ACK。</li></ul></li></ul></li></ul></li></ul><h2 id="FIN-WAIT-2"><a href="#FIN-WAIT-2" class="headerlink" title="FIN_WAIT_2"></a>FIN_WAIT_2</h2><ul><li>主动断开方，在 进入 <code>FIN_WAIT_1</code> 之后，收到对端 ACK，即进入 <code>FIN_WAIT_2</code> 状态，直到收到对端发来的 FIN 包，</li><li><code>FIN_WAIT_2</code> 连接数限制<ul><li>原因： server 端可能由于 KeepAlive 机制等原因导致 SERVER 主动关闭，若进入 FIN_WAIT_2 后，由于默认缺乏超时机制，可能导致 FIN_WAIT_2 连接数过多，占用系统资源，导致 系统 crash</li><li>方案：  修改系统配置  <code>/etc/sysctl.conf</code><ul><li><code>net.ipv4.tcp_fin_timeout = 30</code></li></ul></li></ul></li></ul><h2 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h2><ul><li>被动端开方，收到对端发送的 FIN 包并回复 ACK 后随机进入 CLOSE_WAIT 状态，直到 自身所有数据发送完毕，随后发送 FIN 包</li><li>没有默认的超时时间</li><li>CLOSE_WAIT 状态连接数过多 —— 一般是代码编写逻辑有问题<ul><li>需确保在 收到 FIN 报文后，尽快对 相应 socket 也发起 close 系统调用，以保证 连接正确释放</li></ul></li></ul><h2 id="LAST-ACK"><a href="#LAST-ACK" class="headerlink" title="LAST_ACK"></a>LAST_ACK</h2><ul><li>被动端开方，进入 CLOSE_WAIT 状态后，自身数据发送完毕，随机也发送 FIN 包，进入 LAST_ACK 状态并等待 主动断开方回复最后的 ACK</li><li>若预期时间内没有收到 ACK ，则被动断联方会重新发送 FIN 包，直到超时 或 成功收到确认</li><li>超时限制调整 —— 内核没有直接针对 LAST_ACK 状态的超时参数</li><li>极限情况下只能修改内核源码并重新编译来直接调整 LAST_ACK 状态的超时逻辑</li></ul><h2 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h2><ul><li>描述： 主动断开方收到对端 FIN 包后回复 ACK 并进入 <code>TIME_WAIT</code></li><li>时长： 2MSL (MSL：Maximum Segment Lifetime，通常默认为两分钟)</li><li>作用： 防止 ACK 丢失， 2MSL 的时长可确保 被动关闭方在 LAST_ACK 状态后未收到 ACK 还可重传 FIN</li><li>限制： 在高并发短连接的场景下，大量的 TIME_WAIT连接可能占用较多资源，影响服务的扩展性和性能<ul><li><code>net.ipcv4,tcp_tw_reuse</code>： 位于<code>/etc/sysctl.conf </code>文件中 ， 当 ~ 置为 1 时，内核允许将 TIME_WAIT 状态的 socket 的本地端口用于新的 TCP 连接请求</li><li><code>net.ipv4.tcp_tw_recycle</code>：同样位于<code>/etc/sysctl.conf 文件</code>中 ， 当 ~ 置为 1 时，内核会尝试快速回收那些处于 <code>TIME_WAIT</code> 状态的连接。它通过检查接收到的数据包中的 TCP 时间戳选项（TCP Timestamps），并与本机维护的最新时间戳进行对比，以此来判断数据包是否来自一个“旧”连接。如果时间戳过旧，内核将丢弃这些数据包，认为它们属于已经关闭的连接，从而可以更快地回收 TIME_WAIT 状态的套接字<ul><li>注意事项：<ul><li>兼容性问题：tcp_tw_recycle 的使用依赖于 TCP 时间戳选项，但并非所有系统或应用程序都会启用这个选项。这可能导致来自不支持或未启用时间戳功能的客户端的连接出现问题，比如连接失败或不稳定。</li><li>网络配置复杂性：由于时间戳的使用和校验，该参数在有中间网络设备（如 NAT 网关、负载均衡器）的环境中可能引起问题，因为这些设备可能会改变或去除时间戳，导致合法的数据包被错误地丢弃。</li><li>已知问题与建议：由于上述原因，尤其是在存在 NAT 环境或与互联网上的广泛客户端交互的场景下，使用 tcp_tw_recycle 可能弊大于利。实际上，该参数在较新的 Linux 内核版本中已被废弃或默认禁用，推荐使用 tcp_tw_reuse 作为替代方案，以更安全的方式复用端口</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> TCP </tag>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS 详解</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HDFS-BASIC"><a href="#HDFS-BASIC" class="headerlink" title="HDFS BASIC"></a>HDFS BASIC</h1><p>  当需要存储的数据集的大小超过了一台独立的物理计算机的存储能力时，就需要对数据进行分区并存储到若干台计算机上去。管理网络中跨多台计算机存储的文件系统统称为<strong>分布式文件系统（distributed fileSystem）</strong>。</p><p>  分布式文件系统由于其跨计算机的特性，所以依赖于网络的传输，势必会比普通的本地文件系统更加复杂，比如：如何使得文件系统能够容忍节点的故障并且保证不丢失数据，这就是一个很大的挑战</p><h2 id="HDFS简介及其基本概念"><a href="#HDFS简介及其基本概念" class="headerlink" title="HDFS简介及其基本概念"></a>HDFS简介及其基本概念</h2><p>  HDFS（Hadoop Distributed File System）是hadoop生态系统的一个重要组成部分，是hadoop中的的存储组件，在整个Hadoop中的地位非同一般，是最基础的一部分，因为它涉及到数据存储，MapReduce等计算模型都要依赖于存储在HDFS中的数据。HDFS是一个分布式文件系统，以流式数据访问模式存储超大文件，将数据分块存储到一个商业硬件集群内的不同机器上。</p><p>  这里重点介绍其中涉及到的几个概念：</p><p>（1）<strong>超大文件</strong>。目前的hadoop集群能够存储几百TB甚至PB级的数据。</p><p>（2）<strong>流式数据访问</strong>。HDFS的访问模式是：<strong>一次写入，多次读取</strong>，更加关注的是读取整个数据集的整体时间。</p><p>（3）<strong>商用硬件。</strong>HDFS集群的设备不需要多么昂贵和特殊，只要是一些日常使用的普通硬件即可，正因为如此，hdfs节点故障的可能性还是很高的，所以<strong>必须要有机制来处理这种单点故障</strong>，保证数据的可靠。</p><p>（4）<strong>不支持低时间延迟的数据访问</strong>。hdfs关心的是高数据吞吐量，不适合那些要求低时间延迟数据访问的应用。</p><p>（5）<strong>单用户写入，不支持任意修改。</strong>hdfs的数据以读为主，只支持单个写入者，并且写操作总是以添加的形式在文末追加，不支持在任意位置进行修改。</p><h2 id="HDFS-整体架构"><a href="#HDFS-整体架构" class="headerlink" title="HDFS 整体架构"></a>HDFS 整体架构</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616194928432.png" alt="image-20240616194928432"></p><ul><li>主从 —— nameNode + DataNode</li><li>Namenode—— Active &#x2F; Standby ，高可用</li></ul><h2 id="BLOCK-数据块-与-DataNode"><a href="#BLOCK-数据块-与-DataNode" class="headerlink" title="BLOCK 数据块 与 DataNode"></a>BLOCK 数据块 与 DataNode</h2><ul><li>HDFS 最小存储单元</li><li>多BLOCK多副本<ul><li>文件被器分为若干个 Block， 每个Block 有多个副本（默认3）</li><li>BLock 以 DataNode 为存储单元，即一个DataNode 智能存储Block的一个副本</li><li>机架感知： 尽量将 副本存放到不同的几家上，以提高容灾能力</li><li>副本均匀分布： DataNode 的 BLock 副本数和访问负荷要比较接近，已实现负载均衡</li></ul></li><li>Block 大小<ul><li>默认 128M，可调整（若Block中数据实际大小 &lt; 设定值，则Block 大小 &#x3D; 实际数据大小）</li><li>如何调整Block大小<ul><li>目标： <ul><li>最小化寻址开销， 降到 1%以下</li><li>任务并发度 和 集群负载比较适中，作业运行速度较快</li></ul></li><li>块太小<ul><li>寻址时间占比过高</li><li>Map 任务太多，并发度高，导致集群负载过高，作业变慢</li></ul></li><li>块太大<ul><li>Map 任务少，并发度太低，导致集群负载过低，作业变慢</li></ul></li></ul></li></ul></li><li>Block 文件<ul><li>Block 文件是DataNode 本地磁盘中名为 “blk_blockId”  的Linux 文件<ul><li>DataNode 在启动时自动创建存储目录，无需格式化</li><li>DataNode 的 current 目录下的文件名都已 “blk_” 为前缀</li><li>Block 的元数据文件（*.meta） 由一个包含版本、类型信息的头文件和一系列校验值组成</li></ul></li></ul></li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616200613192.png" alt="image-20240616200613192" style="zoom:73%;" /><h2 id="NameNode-与-元数据存储"><a href="#NameNode-与-元数据存储" class="headerlink" title="NameNode 与 元数据存储"></a>NameNode 与 元数据存储</h2><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li>目录文件爱你的基本属性（名称、所有者等），Block 相关信息（如文件包含哪些 Block，Block 放在那些节点上）、DataNode 相关信息</li><li>主要存储在 内存 <ul><li>为确保集群数据安全，需要对数据进行落盘 <ul><li>Block 位于哪些 DataNode    会由 DataNode 进行上报</li><li>因此仅持久化 文件划分成了 哪些 Block 的信息</li></ul></li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616201427764.png" alt="image-20240616201427764"></p><h3 id="内存元数据"><a href="#内存元数据" class="headerlink" title="内存元数据"></a>内存元数据</h3><ul><li>Active NameNode : 最新的元数据（fsimage + edits）</li><li>Standby NameNode： 通过QJM （默认60s ）同步AN 的元数据</li></ul><h3 id="文件元数据"><a href="#文件元数据" class="headerlink" title="文件元数据"></a>文件元数据</h3><ul><li>内存元数据持久化后形成的文件</li><li>edits （编辑日志文件）<ul><li>保存了最近一个 Checkpoint 检查点之后的所有变更操作</li><li>变更操作应先写 edits ， 再写内存</li><li>edits 文件名通过 “Transaction Id 前后缀” 标记所包含更新操作的范围</li></ul></li><li>fsimage （元数据检查点镜像文件）<ul><li>Standby NameNode 在 CheckPoint 检查点定期对内存中的元数据进行持久化，生成 fsimage 镜像文件</li><li>fsimage 的写入速度较慢，所以不可能对变更操作进行实时持久化</li><li>fsimage 文件名标记处最后一个变更操作的 TransactionId ，一下图为例， 只要在内存冲载入 fsimage_*19，然后在内存中执行 edits_improgress_*20 就可以还原出最新的元数据<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202407518.png" alt="image-20240616202407518"></li></ul></li></ul><h3 id="edits-fsimage-重写"><a href="#edits-fsimage-重写" class="headerlink" title="edits &#x2F; fsimage 重写"></a>edits &#x2F; fsimage 重写</h3><h4 id="Hadoop-1-X-实现方式"><a href="#Hadoop-1-X-实现方式" class="headerlink" title="Hadoop 1.X 实现方式"></a>Hadoop 1.X 实现方式</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202545245.png" alt="image-20240616202545245"></p><h4 id="Hadoop-2-X-实现方式"><a href="#Hadoop-2-X-实现方式" class="headerlink" title="Hadoop 2.X 实现方式"></a>Hadoop 2.X 实现方式</h4><ul><li>QJM 共享存储系统<ul><li>基于 Paxos 算法实现的 JournalNode 集群， 实现了 edits 的高可用存储和共享访问</li><li>最好部署奇数（2*n+1）个节点 ， 也即最多容忍 n 个节点宕机</li><li>过半节点写入成功，即代表写入成功</li></ul></li><li>基于 QJM 的 edits 持久化<ul><li>AN 将变更操作同步写入本地和 QJM 的 edits</li><li>在内存中继续执行该操作，并将结果反馈给 Client</li></ul></li><li>基于 QJM 的 fsimage 持久化<ul><li>在 checkpoint 检查点，SN 先将内存元数据变为只读来暂停 QJM edits 的定期同步，再讲元数据镜像到 fsimage 中</li><li>SN 将 fsimage 上传到 AN ，同时回复 QJM 定期同步</li><li>AN 根据 fsimage 的事务Id ，删除旧 edits ，实现瘦身</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616202739569.png" alt="image-20240616202739569"></p><h2 id="HDFS-读写流程"><a href="#HDFS-读写流程" class="headerlink" title="HDFS 读写流程"></a>HDFS 读写流程</h2><h3 id="HDFS-写流程"><a href="#HDFS-写流程" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><p><strong>注意点</strong></p><ul><li>block 拆分由 client 完成</li><li>Block 逐个发送</li><li>备份写入以 pipeline 形式实现，并递归返回写入结果</li><li>Block 全部写入后，Client 上报 AN ,  AN 生成元数据</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616203557631.png" alt="image-20240616203557631"></p><h3 id="HDFS-写流程-1"><a href="#HDFS-写流程-1" class="headerlink" title="HDFS 写流程"></a>HDFS 写流程</h3><ul><li>Block 对应DataNode 副本列表， AN 会以 距离远近进行排序</li><li>Block 逐个读取</li><li>副本建联，按AN 返回列表顺序进行尝试</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616204521373.png" alt="image-20240616204521373"></p><h2 id="HDFS-安全模式"><a href="#HDFS-安全模式" class="headerlink" title="HDFS 安全模式"></a>HDFS 安全模式</h2><h3 id="什么是安全模式"><a href="#什么是安全模式" class="headerlink" title="什么是安全模式"></a>什么是安全模式</h3><ul><li>安全模式 是 HDFS 的一种特殊状态，</li><li>进入 ~ 后， HDFS 只接受 读数据请求，不接收 增删改 数据请求</li><li>安全模式是 HDFS 确保BLock 数据安全的一种保护机制</li><li>AN 启动时，HDFS 进入安全模式， DataNode 主动向 AN 汇报Block 列表信息，直至 DataNode 上报数量达到阈值， AN 离开安全模式</li></ul><h3 id="何时离开安全模式"><a href="#何时离开安全模式" class="headerlink" title="何时离开安全模式"></a>何时离开安全模式</h3><ul><li>BLock 上报率： DataNode 上报的可用 Block 数量 &#x2F; NameNode 元数据记录的 Block 数量</li><li>阈值： 上报率 &gt;&#x3D; 0.999 （默认， 可调）</li><li>不建议手动强制退出安全模式</li></ul><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><ul><li>DataNode —— 是否有 DataNode 不能正常启动，手动重启</li><li>NameNode 内存或磁盘不足？</li></ul><h1 id="HDFS-架构设计思考"><a href="#HDFS-架构设计思考" class="headerlink" title="HDFS 架构设计思考"></a>HDFS 架构设计思考</h1><h2 id="HDFS-优劣势"><a href="#HDFS-优劣势" class="headerlink" title="HDFS 优劣势"></a>HDFS 优劣势</h2><h3 id="DHFS-架构设计优势"><a href="#DHFS-架构设计优势" class="headerlink" title="DHFS 架构设计优势"></a>DHFS 架构设计优势</h3><ul><li>高容错性</li><li>一定的扩展性</li><li>可支持海量数据的可靠读写</li></ul><h3 id="HDFS-劣势"><a href="#HDFS-劣势" class="headerlink" title="HDFS 劣势"></a>HDFS 劣势</h3><ul><li><p>NameNode 内存受限问题</p><ul><li>通过 Federation 机制进一步扩展<ul><li>实际是基于 “路径” 的联邦， 属于 基本业务层扩展<ul><li>路径划分不合理，仍有可能导致 单路径下存储压力过大，以及不同路径下存储压力严重不均衡的问题</li></ul></li></ul></li></ul></li><li><p>NameNode 单点故障问题</p><ul><li>对 NameNode 做高可用</li></ul></li></ul><h2 id="HDFS-NA-高可用架构"><a href="#HDFS-NA-高可用架构" class="headerlink" title="HDFS NA 高可用架构"></a>HDFS NA 高可用架构</h2><ul><li>以下给出了 一种 高可用架构实现参考<ul><li>实际还需要考虑 DataNode 对于 NA 的变更感知</li><li>以及 edits 的一致性问题</li></ul></li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210305888.png" alt="image-20240616210305888"></p><h1 id="HDFS-API"><a href="#HDFS-API" class="headerlink" title="HDFS API"></a>HDFS API</h1><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210654411.png" alt="image-20240616210654411" style="zoom:70%;" align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616210915156.png" alt="image-20240616210915156" style="zoom:75%;"  align="left"/><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616211122508.png" alt="image-20240616211122508" style="zoom:80%;" align="left"/>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/HDFS%20%E9%85%8D%E7%BD%AE%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="部署HDFS"><a href="#部署HDFS" class="headerlink" title="部署HDFS"></a>部署HDFS</h1><p>HDFS的基本操作可以分为集群管理和文件系统操作两种类型：</p><ul><li>集群管理：包括Namenodede 的格式化、集群的启动和停止、集群信息查看等。</li><li>文件系统：包括对目录、文件和权限等内容的操作。</li></ul><p>HDFS中的命令主要在sbin和bin目录下[一般要进行环境变量的设置]：</p><ul><li>sbin:集群控制脚本(.sh)。</li><li>bin:hadoop的文件系统命令和其他管理维护工具。</li></ul><h2 id="hadoop安装和维护的方式"><a href="#hadoop安装和维护的方式" class="headerlink" title="hadoop安装和维护的方式"></a>hadoop安装和维护的方式</h2><p>主要有2种方式：</p><ul><li>一是从开源软件的官网网站直接下载软件包。</li><li>二是利用集成化软件对Hadoop集群进行部署和维护。[集成化工具：amabri、cloudera manager、华为的FusionInsight]</li></ul><p>第一种方式缺点：</p><ul><li>配置优化难度</li><li>组件整合难度</li></ul><h2 id="部署HDFS的核心步骤和部署原则"><a href="#部署HDFS的核心步骤和部署原则" class="headerlink" title="部署HDFS的核心步骤和部署原则"></a>部署HDFS的核心步骤和部署原则</h2><h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><ul><li><p>hadoop系统的规模</p></li><li><p>组件和角色规划</p><ul><li>A.确定需要安装哪些组件：比如要实现Namenode的高可用性，就需要额外安装ZK组件。</li><li>B.确定组件中的不同角色分别安装在哪些节点上：比如需要几个Datanode，分别安装在哪些服务器上，Namenode是安装在独立服务器上，还是和某个Datanode共享一台服务器。</li><li>C.根据角色规划确定所需的服务器性能需求：比如namenode所在服务器可以适当加大内存，以适应fsimage的可能大小，并且安装多块硬盘，将元数据信息保存在多个硬盘路径上，防止单个硬盘发生故障。</li><li>D.节点扩增：计算和存储能力不够时，很多时候就通过节点数量解决。</li></ul></li><li><p>配置规划：Datanode和Namenode一般都可以配置多个存储路径。</p><ul><li>A.Datanode实现多硬盘均匀存储。</li><li>B.Namenode可以实现多副本备份。</li></ul></li></ul><h3 id="linux环境准备"><a href="#linux环境准备" class="headerlink" title="linux环境准备"></a>linux环境准备</h3><p>HDFS作为hadoop的核心组件，随Hadoop一起整体部署。</p><p>安装hadoop前的环境准备：</p><ol><li>配置java环境变量：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</li><li>hadoop部署在多台服务器上，主从节点之间、各节点之间可以通过TCP&#x2F;IP协议相互访问[通过设置DNS或hosts文件，使得主机名和IP地址绑定，实现通过主机名就能访问对方]</li><li>确保hadoop所需端口打开：hadoop以及各类配套模板需要使用大量网络端口，但是自带的防火墙软件，设置不当造成功能无法正确运行。</li><li>SSH接口免密登录</li><li>Hadoop以及分布式NoSQL数据库要求各个节点之间的时间同步：最常见的集群时间同步方案是部署NTP服务。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//确保hadoop所需端口打开，通过命令禁用并停止防火墙服务</span><br><span class="line">systemctl mask filewalld</span><br><span class="line">systemctl stop fillwalld</span><br></pre></td></tr></table></figure><h3 id="Hadoop的软件包部署"><a href="#Hadoop的软件包部署" class="headerlink" title="Hadoop的软件包部署"></a>Hadoop的软件包部署</h3><ul><li>sbin目录：存放HDFS和Yarn组件的集群控制命令。</li><li>bin目录：存放HDFS的文件系统命令行工具以及Yarn等组件的命令行工具。</li><li>etc&#x2F;hadoop目录：存放hadoop的配置文件。</li><li>share目录：存放hadoop的各类库包(Jar)。</li></ul><p>PS:分布式的时候，hadoop软件包需要解压缩，并复制到所有节点上，并且在每个节点上的存储位置都是相同的，并给予足够的用户访问权限。其次，进行系统配置。</p><h1 id="HDFS的基本配置"><a href="#HDFS的基本配置" class="headerlink" title="HDFS的基本配置"></a>HDFS的基本配置</h1><p>HDFS的配置文件：大多数默认是XML和TXT格式存在。配置文件默认存放在&#x2F;etc&#x2F;hadoop目录下。</p><p>HDFS中6个重要的配置文件：</p><ol><li><strong>core-site.xml</strong>: Hadoop全局的配置文件，也包含一些HDFS的宏观配置。</li><li><strong>dfs-site.xml</strong>: HDFS配置文件。</li><li><strong>yarn-site.xml</strong>: YARN配置文件。</li><li><strong>mapred-sie.xml</strong>: MapReduce配置文件。</li><li><strong>slaves</strong>: 从节点列表。</li><li><strong>hadoop-env.sh</strong>: 与运行脚本的环境变量相关的配置文件。</li></ol><h2 id="core-site-xml"><a href="#core-site-xml" class="headerlink" title="core-site.xml"></a>core-site.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//core-site.xml文件</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>       </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--指定namenode的地址--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://node1:8020<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">description</span>&gt;</span>node1节点为该集群的Namenode,对应节点的端口是8020<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span>&gt;</span><span class="comment">&lt;!--用来指定使用hadoop时产生文件的存放目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/data/hadoop/hadoop-2.6.0/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="dfs-site-xml"><a href="#dfs-site-xml" class="headerlink" title="dfs-site.xml"></a>dfs-site.xml</h2><p><strong>dfs-site.xml</strong> 是HDFS的重要配置文件，其Namenode节点和Datanode节点相关的配置项不同。</p><p><strong>Namenode</strong>主要有3个配置项: <code>dfs.namenode.name.dir</code>、<code>dfs.blocksize</code>、<code>dfs.replication</code>。</p><p><strong>Datanode</strong>主要有1个配置项：<code>dfs.datanode.data.dir</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//Namenode主要有3个配置项dfs.namenode.name.dir、dfs.blocksize、dfs.replication。</span><br><span class="line">//Datanode主要有1个配置项</span><br><span class="line">dfs.datanode.data.dir   </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>                 </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">         <span class="tag">&lt;<span class="name">description</span>&gt;</span>namenode的目录位置，对应的目录需要存在value里面的路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>         </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/opt/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>datanode的目录位置，对应的目录需要存在value里面的路径，可以是一个或多个用逗号分隔的本地路径<span class="tag">&lt;/<span class="name">description</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">          <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">value</span>&gt;</span> <span class="tag">&lt;<span class="name">description</span>&gt;</span>hdfs系统的副本数量    </span><br><span class="line">         <span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span>     </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>备份namenode的http地址，master是主机名<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 </span><br></pre></td></tr></table></figure><h2 id="slave-xml"><a href="#slave-xml" class="headerlink" title="slave.xml"></a>slave.xml</h2><p>slaves:在Namenode节点还需要建立一个名为slaves的文本文件，里面记录Datanode的子节点机名，用换行分割。</p><h2 id="hadoop-env-sh"><a href="#hadoop-env-sh" class="headerlink" title="hadoop-env.sh"></a>hadoop-env.sh</h2><p>JAVA_HOME进行环境变量配置：export JAVA_HOME&#x3D;&#x2F;opt&#x2F;java&#x2F;jdk</p><h2 id="配置机架感知策略"><a href="#配置机架感知策略" class="headerlink" title="配置机架感知策略"></a>配置机架感知策略</h2><p>需要实现机架感知的配置内容，在core-site.xml中实现两个配置项。</p><p>net.topology.node.switch.mapping.imp:org.apache.hadoop.net.TableMapping,表示采用映射文件的方式实现机架映射。</p><p>net.topology.table.file.name:内容为映射文件的路径和名称。</p><h1 id="集群的启动和停止"><a href="#集群的启动和停止" class="headerlink" title="集群的启动和停止"></a>集群的启动和停止</h1><p>软件包sbin目录下的start-dfs.sh和stop-dfs.sh为HDFS的集群启动和停止命令。</p><p>单独启动或停止一个HDFS进程，或者对单独的角色进行控制命令：hadoop-daemon.sh start | stop namenode |datanode|secondarynamenode</p><p>其次可以通过查看<a href="http://namenode:50070/%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%8C%E6%AF%94%E5%A6%82%E8%AF%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E3%80%81%E7%89%88%E6%9C%AC%E3%80%81%E9%9B%86%E7%BE%A4ID%E7%AD%89%E4%BF%A1%E6%81%AF%E3%80%82">http://namenode:50070/查看系统的状态，比如该系统的启动时间、版本、集群ID等信息。</a></p><h2 id="使用和管理HDFS"><a href="#使用和管理HDFS" class="headerlink" title="使用和管理HDFS"></a>使用和管理HDFS</h2><p>作为文件系统，HDFS的使用主要指对<strong>文件的上传、下载和移动，以及查看内容、建立或删除目录</strong>等。</p><p>查看HDFS状态，主要指查看节点的健康状态，查看存储容量，查看分块信息等。</p><p>控制HDFS，主要指对系统进行初始化，增加或删除子节点，以及提高HDFS的可用性等。</p><h2 id="管理和操作命令"><a href="#管理和操作命令" class="headerlink" title="管理和操作命令"></a>管理和操作命令</h2><p>hdfs的命令行操作用命令hdfs实现，即命令行敲入：hdfs.hdfs命令文件放在Hadoop目录下的bin子目录中，包含了HDFS绝大多数的用户命令，不带任何参数地执行hdfs，可以看到所有可用的指令。</p><ol><li>dfs:HDFS的文件系统操作指令。</li><li>dfsadmin:HDFS的集群管理命令，比如：查看机架感知状态，可以执行hdfs dfsadmin-printTopology。</li><li>fsck:HDFS的集群检查工具。</li><li>namenode-format:主节点格式化指令。</li><li>balaner:数据平衡指令。</li></ol><h2 id="格式化Namenode"><a href="#格式化Namenode" class="headerlink" title="格式化Namenode"></a>格式化Namenode</h2><p>hdfs namenode -format</p><h2 id="Namenode的安全模式"><a href="#Namenode的安全模式" class="headerlink" title="Namenode的安全模式"></a>Namenode的安全模式</h2><p>当namenode启动时，需要将fsimage等信息读入内存，并且等待各个Datanode上报存储状态，在这个过程完成之前，叫安全模式。（safenode）</p><p>此时namenode为只读状态，只能读取不能写入，当足够数量的节点以及数据块处在健康状态时，系统会自动退出安全模式。</p><p>手动对安全模式进行管理：hdfs dfsadmin -safemode [enter | leave |get |wait]</p><h2 id="元数据恢复"><a href="#元数据恢复" class="headerlink" title="元数据恢复"></a>元数据恢复</h2><p>由于secondary namenode在进行元数据合并时，保存了元数据的副本信息，当Namenode发生损坏时，可以利用secondary namenode中的数据进行恢复。</p><ol><li>利用stop-dfs.sh命令停止整个集群</li><li>清空namenode原有的元数据信息，路径可以从配置项dfs.namenode.name.dir中获得。</li><li>如果secondary namenode和namenode没有部署在同一个节点上，需要将secondary namenode存储的副本信息复制到namenode,其路径和secondary namenode中的元数据副本的路径一致，可以从配置项dfs.namenode.checkpoint.dir中获得。</li><li>执行hadoop namenode-importCheckpoint,系统将检查副本数据，并将其复制到dfs.namenode.name.dir所指示的路径当中。</li></ol><h2 id="子节点添加与删除"><a href="#子节点添加与删除" class="headerlink" title="子节点添加与删除"></a>子节点添加与删除</h2><p>大数据业务要求数据被不断采集、不断积累，需要分布式存储和NoSQL数据库等实现方便的横向扩展（scale out）。HDFS可以很方便的进行Datanode节点添加和删除。</p><h3 id="1-静态添加-删除Datanode的方法"><a href="#1-静态添加-删除Datanode的方法" class="headerlink" title="1.静态添加&#x2F;删除Datanode的方法"></a>1.静态添加&#x2F;删除Datanode的方法</h3><ul><li>利用stop-dfs.sh命令停止整个集群</li><li>在namenode节点上的slaves配置文件中添加新的节点，或删掉旧的节点。添加新节点时，要确保新节点和其他节点之间主机名和IP地址可以相互访问，可以实现SSH无密码访问等。</li><li>利用start-dfs.sh重新启动集群，在新节点配置正确的情况下，会随命令启动Datanode角色，并和Namenode连接。</li><li>可以执行hdfs balancer命令，在节点之间进行手动的数据平衡。删除节点之后，namenode会自动检查副本数量，并选择新的节点存储不足的副本。</li></ul><h3 id="2-动态添加Datanode的方法"><a href="#2-动态添加Datanode的方法" class="headerlink" title="2.动态添加Datanode的方法"></a>2.动态添加Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>在namenode节点上的slaves配置文件中添加新的节点。</li><li>在新节点执行hadoop-daemon.sh start datanode ,启动Datanode角色</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表，Namenode会根据新列表和子节点建立联系。</li></ul><h3 id="3-动态删除Datanode的方法"><a href="#3-动态删除Datanode的方法" class="headerlink" title="3.动态删除Datanode的方法"></a>3.动态删除Datanode的方法</h3><ul><li>HDFS集群保持运行状态</li><li>提前在hdfs-site.xml中配置dfs.hosts.exclude属性，内容为一个本地文本文件的路径，该文件可以称为exclude文件，其结构和slave文件的相同，即为每行一个节点主机名的列表。 记录在exclude文件中的主机，会在刷新之后被记作禁用状态，并在界面上看到这个状态。</li><li>在主节点执行hdfs dfsadmin -refreshNodes,刷新节点列表。</li><li>在节点写入exclude文件，并执行hdfs dfsadmin -refreshNodes，刷新节点列表。</li></ul><p>添加&#x2F;删除Datanode完成之后，可以通过两种手段查看结果。</p><ul><li>在命令行执行hdfs dfsadmin -report 查看节点列表信息。</li><li>通过web界面，切换到Datanodes标签，可以查看子节点的列表，in operation表示正在使用的节点，decommissinoning，表示目前禁用的节点。</li></ul><h2 id="HDFS文件系统操作"><a href="#HDFS文件系统操作" class="headerlink" title="HDFS文件系统操作"></a>HDFS文件系统操作</h2><p>可以通过执行hdfs dfs指令来进行各类操作，包括建立、删除目录、HDFS上的文件复制、移动和改名、本地文件系统和HDFS系统之间的文件相互复制等、文件的权限操作等。</p><ul><li>hdfs dfs -ls &#x2F;  —-查看文件目录状态</li><li>hdfs dfs -lsr &#x2F; —-递归查看hdfs的根目录下的内容的</li><li>hdfs dfs -mkdir &#x2F;d1 —-在hdfs上创建文件夹d1</li><li>hdfs dfs -put <linux source > <hdfs destination> —-把数据从linux[本地文件]上传到hdfs的特定路径中[HDFS文件或路径]</li><li>hdfs dfs -get <hdfs source> <linux destination>—-把数据从hdfs下载到linux的特定路径下</li><li>hdfs dfs -mv&#x2F;-cp <hdfs source > <hdfs destination>—在HDFS系统中进行文件移动或复制，参数为HDFS的源地址和目的地址。</li><li>hdfs dfs -text &lt;hdfs文件&gt; —将序列号文件转换成文本显示出来。</li><li>hdfs dfs -rm &lt;hdfs文件&gt; —-删除文件或空目录</li><li>hdfs dfs -rmr &lt;hdfs文件&gt; —-递归删除文件或空目录</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//查看文件目录状态，-ls之后必须指明需要查看的目录</span><br><span class="line">hdfs dfs -ls /hdfsdir/file1</span><br><span class="line">hdfs dfs -ls hdfs://node1:8020/hdfsdir/file1</span><br><span class="line">//建立新目录</span><br><span class="line">hdfs dfs -mkdir /hdfsdir/dir1</span><br><span class="line">//从本地文件系统向HDFS复制文件。-put、-copyFromLocal。</span><br><span class="line">hdfs dfs -put localfile/hdfsdir/file1</span><br><span class="line">hdfs dfs -put -f localfile1 localfile2/hadoopdir</span><br><span class="line">//从HDFS向本地复制文件。-get、-copyToLocal。</span><br><span class="line">hdfs dfs -get /hdfsdir/hdfsfile localfile</span><br></pre></td></tr></table></figure><h2 id="以web方式查看文件系统"><a href="#以web方式查看文件系统" class="headerlink" title="以web方式查看文件系统"></a>以web方式查看文件系统</h2><p>访问<a href="http://namenode:50070/explorer.html,%E9%80%89%E6%8B%A9%22browse">http://namenode:50070/explorer.html,选择&quot;browse</a> the file system”选项，可以对HDFS的目录结构进行查看。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> hdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YARN 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/YARN%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="YARN简介"><a href="#YARN简介" class="headerlink" title="YARN简介"></a>YARN简介</h1><p>Apache Hadoop YARN （Yet Another Resource Negotiator，另一种资源协调者）是一种新的 Hadoop 资源管理器，它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</p><h1 id="YARN的由来"><a href="#YARN的由来" class="headerlink" title="YARN的由来"></a>YARN的由来</h1><p>在YARN出来之前，其实在Hadoop体系里面，负责资源管理和作业控制的是MRv1（Hadoop 1.0）体系中的JobTracker在承担，但是MRv1体系其实有其缺点，如下：</p><ul><li><p><strong>可靠性差 &#x2F; 单点故障</strong></p><ul><li>JobTracker 既做资源管理，又做任务调度，任务太重，易产生单点故障</li></ul></li><li><p><strong>资源利用率低</strong></p><ul><li>MRv1 资源描述模型过于简单，仅把 Task 数量作为资源分配依据，没有考虑任务本身的性能消耗差异</li><li>强制把资源分成 Map Task Slot 和 Reduce Task Slot，且不允许它们之 间共享，常常会导致一种槽位资源紧张而另外一种闲置(比如一个作业刚刚提交时， 只会运行 Map Task，此时 Reduce Slot 闲置)。</li></ul></li><li><p><strong>扩展性差</strong> ： 在MRv1中，JobTracker是个重量级组件，集中了资源管理分配、作业控制两大核心功能，随着集群规模的增大，JobTracker处理各种RPC请求负载过重，这也是系统的最大瓶颈，严重制约了Hadoop集群的扩展性。</p></li></ul><p>为了克服以上几个缺点，Apache 开始尝试对 Hadoop 进行升级改造，进而诞生了更加 先进的下一代 MapReduce 计算框架 MRv2。正是由于 <strong>MRv2 将资源管理功能抽象成了一个 独立的通用系统 YARN，直接导致下一代 MapReduce 的核心从单一的计算框架 MapReduce转移为通用的资源管理系统 YARN</strong>。</p><p>YARN将 JobTracker 中的资源管理和作业控制功能分 开， 分 别 由 组件ResourceManager 和 ApplicationMaster 实 现， 其 中，ResourceManager 负责所有应用程序的资源分配，而 ApplicationMaster 仅负责管理一个应用程序，基于 YARN，用户可以运行各种类型的应用程序(不再像 1.0 那样仅局限于 MapReduce 一类应用)，从离线计算的 MapReduce 到在线计算 (流式处理)的 Storm 等。</p><h1 id="YARN的基本设计思想"><a href="#YARN的基本设计思想" class="headerlink" title="YARN的基本设计思想"></a>YARN的基本设计思想</h1><p>在 Hadoop 1.0 中，<strong>JobTracker</strong> 由 <strong>资源管理</strong>(由 TaskScheduler 模块实现) 和 <strong>作业控制</strong>(由 JobTracker 中多个模块共同实现)两部分组成。当前 Hadoop MapReduce 之所以在可扩展性、资源利用率和多框架支持等方面存在不足，正是由于 Hadoop 对 JobTracker 赋予的功能过多而造成负载过重。此外，从设计角度上看，Hadoop 未能够将资源管理相关的功能与应用程序相关的功能分开，造成 Hadoop 难以支持多种计算框架。</p><p>下一代 MapReduce 框架的基本设计思想是将 JobTracker 的两个主要功能，即资源管理和作业控制(包括作业监控、容错等)，分拆成两独立的进程。资源管理进程与具体应用程序无关，它负责整个集群的资源(内存、CPU、磁盘等)管理，而作业控制进程则是直接与应用程序相关的模块，且每个作业控制进程只负责管理一个作业。这样， 通过将原有 JobTracker 中与应用程序相关和无关的模块分开，不仅减轻了 JobTracker 负载， 也使得 Hadoop 支持更多的计算框架。</p><h1 id="YARN-的基本架构"><a href="#YARN-的基本架构" class="headerlink" title="YARN 的基本架构"></a>YARN 的基本架构</h1><h2 id="基本架构图"><a href="#基本架构图" class="headerlink" title="基本架构图"></a>基本架构图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616213808951.png" alt="image-20240616213808951" style="zoom:85%;" /><p>Yarn 在整体上看还是采用了和Hadoop1.x一样的Master&#x2F;Slave结构（横向扩展混杂Slave&#x2F;Slave结构），在整个Yarn资源管理系统当中，ResourceManager作为Master，各个节点的NodeManager作为Slave。各个节点上NodeManager的资源由ResourceManager统计进行管理和调度。当应用程序提交后，会有一个单独的ApplicationMaster来对该应用程序进行跟踪和管理，同时该ApplicationMaster还会为该应用程序向ResourceManager申请资源，并要求NodeManager启动该应用程序占用一定资源的任务。由于不同的 ApplicationMaster 被分布到不同的节点上，因此它们之间不会相互影响。</p><h2 id="基本组件介绍"><a href="#基本组件介绍" class="headerlink" title="基本组件介绍"></a>基本组件介绍</h2><h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>ResourceManager是Yarn的核心组件，主要由任务调度器（Resource Scheduler）和应用程序管理器（Applications Manager）组成。其主要功能是负责系统资源的管理和分配。</p><ul><li><h4 id="任务调度器-Resource-Scheduler"><a href="#任务调度器-Resource-Scheduler" class="headerlink" title="任务调度器(Resource Scheduler)"></a>任务调度器(Resource Scheduler)</h4></li></ul><p>调度器根据容量、队列等限制条件(如每个队列分配一定的资源，最多执行一定数量的作业等)，将系统中的资源分配给各个正在运行的应用程序。需要注意的是，该调度器是 一个“纯调度器”，它不再从事任何与具体应用程序相关的工作，比如不负责监控或者跟踪 应用的执行状态等，也不负责重新启动因应用执行失败或者硬件故障而产生的失败任务， 这些均交由应用程序相关的 ApplicationMaster 完成。调度器仅根据各个应用程序的资源需 求进行资源分配，而资源分配单位用一个抽象概念“资源容器”(Resource Container，简 称 Container)表示，Container 是一个动态资源分配单位，它将内存、CPU、磁盘、网络等 资源封装在一起，从而限定每个任务使用的资源量。此外，该调度器是一个可插拔的组件， 用户可根据自己的需要设计新的调度器，YARN 提供了多种直接可用的调度器，比如 Fair Scheduler 和 Capacity Scheduler 等。</p><ul><li><h4 id="应用程序管理器（Applications-Manager）"><a href="#应用程序管理器（Applications-Manager）" class="headerlink" title="应用程序管理器（Applications Manager）"></a>应用程序管理器（Applications Manager）</h4></li></ul><p>应用程序管理器负责管理整个系统中所有应用程序，包括应用程序提交、与调度器协商资源以启动 ApplicationMaster、监控 ApplicationMaster 运行状态并在失败时重新启动它等。</p><ul><li><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4></li></ul><p>ResourceManager中还包含了其他组件，如ResourceTrackerService用来直接处理心跳，NMLivelinessMonitor用来监控NodeManager，NodesListManager 提供NodeManager的黑白名单等等</p><h3 id="NodeManager（NM）"><a href="#NodeManager（NM）" class="headerlink" title="NodeManager（NM）"></a>NodeManager（NM）</h3><p>NM是每个子节点上的资源和任务管理器，一方面，它会定向通过心跳信息向RM汇报本节点上的资源使用情况和各个Container的运行情况；另一方面，它会接收并且处理来自AM的Container启动和停止的各种请求。它的能有点像Hadoop1.x中的TaskTracker。</p><ul><li><h4 id="ApplicationMaster（AM）"><a href="#ApplicationMaster（AM）" class="headerlink" title="ApplicationMaster（AM）"></a>ApplicationMaster（AM）</h4></li></ul><p>每当用户提交了一个应用程序就会为这个应用程序产生一个对应的ApplicationMaster，并且这个这个单独进程是在其中一个子节点上运行的。它的主要功能：为应用向ResourceManager申请资源、在job对Task实行调度、与NodeManager通信以启动或者停止任务、监控所有任务的运行情况，并且在任务失败的情下，重新为任务申请资源并且重启任务、负责推测任务的执行、当ApplicationMaster向ResourceManager注册后，ApplicationMaster可以提供客户端查询作业进度信息等。</p><ul><li><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4></li></ul><p>Container是Yarn中对系统资源的抽象，同时它也是系统资源分配的基本单位，它封装节点上多维度资源，其中包括CPU、内存、磁盘、网络等。Yarn会为每个任务分配一个Container，并且该任务只能够使用该Container中所描述的资源。值得关注的的是，Yarn中的Container和MRv1中的Slot是完全不同的，Container是一个动态的资源划分单位，它是根据实际提交的应用程序所需求的资源自动生成的，换句话说，Container其里边所描述的CPU、内存等资源是根据实际应用程序需求而变的。而Slot是一个静态的资源抽象单位，每一个同类型的Slot所描述的资源信息都是一样的。</p><h2 id="YARN-高可用"><a href="#YARN-高可用" class="headerlink" title="YARN 高可用"></a>YARN 高可用</h2><ul><li>引入 ZK</li><li>一个 Active RM， 多个 Standby RM</li><li>Active RM 宕机，Standby RM 通过 ZK 感知并竞选</li><li>也可手动切换</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221306795.png" alt="image-20240616221306795" style="zoom:80%;" /><h1 id="YARN-工作原理-流程"><a href="#YARN-工作原理-流程" class="headerlink" title="YARN 工作原理 &#x2F; 流程"></a>YARN 工作原理 &#x2F; 流程</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221044206.png" alt="image-20240616221044206"></p><ul><li>用户向Yarn提交应用程序，其中包括用户程序、相关文件、启动ApplicationMaster命令、ApplicationMaster程序等。</li><li>ResourceManager为该应用程序分配第一个Container，并且与Container所在的NodeManager通信，并且要求该NodeManager在这个Container中启动应用程序对应的ApplicationMaster。</li><li>ApplicationMaster首先会向ResourceManager注册，这样用户才可以直接通过ResourceManager查看到应用程序的运行状态，然后它将为该应用程序的各个任务申请资源，并监控它们的运行状态直到运行结束，即重复后面4~7步骤。</li><li>ApplicationMaster采用轮询的方式通过RPC协议向ResourceManager申请和领取资源。</li><li>一旦ApplicationMaster申请到资源后，便会与申请到的Container所对应的NodeManager进行通信，并且要求它在该Container中启动任务。</li><li>任务启动。NodeManager为要启动的任务配置好运行环境，包括环境变量、JAR包、二进制程序等，并且将启动命令写在一个脚本里，通过该脚本运行任务。</li><li>各个任务通过RPC协议向其对应的ApplicationMaster汇报自己的运行状态和进度，以让ApplicationMaster随时掌握各个任务的运行状态，从而可以再任务运行失败时重启任务。</li><li>应用程序运行完毕后，其对应的ApplicationMaster会向ResourceManager通信，要求注销和关闭自己。</li></ul><p><strong>【注】</strong>需要注意的是在整个工作流程当中，ResourceManager和NodeManager都是通过心跳保持联系的，NodeManager会通过心跳信息向ResourceManager汇报自己所在节点的资源使用情况。</p><h1 id="六、YARN通讯协议"><a href="#六、YARN通讯协议" class="headerlink" title="六、YARN通讯协议"></a>六、YARN通讯协议</h1><p>在 YARN 中，任何两个需相互通信的组件之间仅有一个 RPC 协 议，</p><p>而对于任何一个 RPC 协议，通信双方有一端是 Client，另一端为 Server，且 Client 总 是主动连接 Server 的</p><p>因此，YARN 实际上采用的是 拉式(pull-based)通信模型。</p><h2 id="RPC通信图"><a href="#RPC通信图" class="headerlink" title="RPC通信图"></a>RPC通信图</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616214648502.png" alt="image-20240616214648502" style="zoom:67%;" /><p>上图中，箭头指向的组件是 RPC Server，而箭头尾部的组件是 RPC Client</p><h2 id="组件通讯协议描述"><a href="#组件通讯协议描述" class="headerlink" title="组件通讯协议描述"></a>组件通讯协议描述</h2><h3 id="ApplicationClientProtocol"><a href="#ApplicationClientProtocol" class="headerlink" title="ApplicationClientProtocol"></a>ApplicationClientProtocol</h3><p>JobClient(作业提交客户端)与 RM 之间的协议 ，JobClient 通过该 RPC 协议提交应用程序、查询应用程序状态等。</p><h3 id="ResourceManagerAdministrationProtocol"><a href="#ResourceManagerAdministrationProtocol" class="headerlink" title="ResourceManagerAdministrationProtocol"></a>ResourceManagerAdministrationProtocol</h3><p>Admin(管理员)与 RM 之间的通信协议，Admin 通过该 RPC 协议更新系统配置文件，比如节点黑白名单、用户队列权限等。</p><h3 id="ApplicationMasterProtocol"><a href="#ApplicationMasterProtocol" class="headerlink" title="ApplicationMasterProtocol"></a>ApplicationMasterProtocol</h3><p>AM 与 RM 之间的协议，AM 通过该 RPC 协议向 RM 注册和撤销自己，并为各个任务申请资源。</p><h3 id="ContainerManagementProtocol"><a href="#ContainerManagementProtocol" class="headerlink" title="ContainerManagementProtocol"></a>ContainerManagementProtocol</h3><p>AM 与 NM 之间的协议，AM 通过该 RPC 要求 NM 启动或者停止 Container，获取各个 Container 的使用状态等信息。</p><h3 id="ResourceTracker"><a href="#ResourceTracker" class="headerlink" title="ResourceTracker"></a>ResourceTracker</h3><p>NM 与 RM 之间的协议，NM 通过该 RPC 协议向 RM 注册，并 定时发送心跳信息汇报当前节点的资源使用情况和 Container 运行情况。</p><h1 id="YARN-资源调度策略"><a href="#YARN-资源调度策略" class="headerlink" title="YARN 资源调度策略"></a>YARN 资源调度策略</h1><p>目前，Hadoop 作业调度器主要有三种：FIFO、Capacity Scheduler 和 Fair Scheduler。Hadoop 版本 2.6.0-cdh5.14.2 默认的资源调度器是 Fair Scheduler。</p><h2 id="FIFO-Scheduler-（先进先出调度器）"><a href="#FIFO-Scheduler-（先进先出调度器）" class="headerlink" title="FIFO Scheduler （先进先出调度器）"></a>FIFO Scheduler （先进先出调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221647043.png" alt="image-20240616221647043" style="zoom:80%;" /><p>FIFO Scheduler 把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。</p><p>FIFO Scheduler 是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用 Capacity Scheduler 或 Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。</p><ul><li><p><strong>缺点</strong></p><ul><li><p>资源利用率低，无法交叉运行任务</p></li><li><p>灵活性差 —— 紧急任务无法插队</p></li></ul></li></ul><h2 id="Capacity-Scheduler-（容量调度器）"><a href="#Capacity-Scheduler-（容量调度器）" class="headerlink" title="Capacity Scheduler （容量调度器）"></a>Capacity Scheduler （容量调度器）</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616221915860.png" alt="image-20240616221915860" style="zoom:80%;" /><ul><li><strong>核心思想</strong>： 提前做预算，在预算指导下分享集群资源</li><li><strong>调度策略</strong>：<ul><li>集群资源由多个队列共享</li><li>每个队列都要预设资源分配的比例</li><li>空闲资源优先分配给 “实际资源&#x2F;预算资源” 比例最低的队列</li><li>队列内采用 FIFO 策略</li></ul></li><li><strong>特点</strong>：<ul><li>层次化的队列设计 —— 子队列可使用父队列的资源</li><li>容量保证 —— 每个队列都要预设资源占比，防止资源独占</li><li>弹性分配 —— 空闲资源可以分配给任何队列，多个队列争用时，按比例进行平衡</li><li>支持动态管理 —— 可以动态调整队列的容量，权限等参数； 也可动态增加或暂停队列</li><li>访问控制 —— 用户只能向自己的队列中提交任务，不能访问其他队列</li><li>多租户 —— 多用户共享集群资源</li></ul></li></ul><h2 id="Fair-Scheduler"><a href="#Fair-Scheduler" class="headerlink" title="Fair Scheduler"></a>Fair Scheduler</h2><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240616223048730.png" alt="image-20240616223048730" style="zoom:80%;" /><p>支持多队列，多用户，每个队列中的资源量可以配置，同一队列中的作业公平共享队列中所有资源。</p><p>比如有三个队列 queue1、Queue2、Queue3，每个队列中的 job 按照优先级分配资源，优先级越高分配的资源越多，但是每个 job 都会分配到资源以确保公平。在资源有限的情况下，每个 job 理想情况下获得的计算资源与实际获得的计算资源存在一种差距，这个差距就叫做差额。在同一个队列中，job 的资源缺额越大，越先获得资源优先执行。作业是按照缺额的高低来先后执行的。在 Fair调度器中，我们不需要预先占用一定的系统资源，Fair 调度器会为所有运行的 job动态的调整系统资源。</p><p>如下图所示，当第一个大 job 提交时，只有这一个 job 在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair 调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop 概述</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/Hadoop/hadoop%20%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在学习<code>Hadoop</code>之前，先了解一下典型的大数据平台架构图：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/238353d9269d48509d9616d14c017af1.png" alt="img"></p><p>可以看到Hadoop在大数据平台里处于一个技术核心的地位</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Hadoop定义"><a href="#Hadoop定义" class="headerlink" title="Hadoop定义"></a>Hadoop定义</h2><p>Hadoop 是一个开源的分布式计算框架，由 Apache Software Foundation 开发和维护。它主要用于处理和分析大数据。Hadoop 的核心设计理念是将计算任务分布到多个节点上，以实现高度可扩展性和容错性。</p><h2 id="Hadoop组成"><a href="#Hadoop组成" class="headerlink" title="Hadoop组成"></a>Hadoop组成</h2><p>Hadoop 大数据技术生态，具体包含组件如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dbcf67baa6664a94b32f226f19e5066a.png" alt="90e2e8544f5a44fa91d4f70d57b7c0a1.png"></p><ul><li><strong>Hadoop HDFS</strong>（核心）：Hadoop 分布式存储系统；</li><li><strong>Yarn</strong>（核心）：Hadoop 2.x版本开始才有的资源管理系统；</li><li><strong>MapReduce</strong>（核心）：并行处理框架；</li><li><strong>HBase</strong>：基于HDFS的列式存储数据库，它是一种 NoSQL 数据库，非常适用于存储海量的稀疏的数据集；</li><li><strong>Hive</strong>：Apache Hive是一个数据仓库基础工具，它适用于处理结构化数据。它提供了简单的 sql 查询功能，可以将sql语句转换为 MapReduce任务进行运行；</li><li><strong>Pig</strong>：它是一种高级脚本语言。利用它不需要开发Java代码就可以写出复杂的数据处理程序；</li><li><strong>Flume</strong>：它可以从不同数据源高效实时的收集海量日志数据；</li><li><strong>Sqoop</strong>：适用于在 Hadoop 和关系数据库之间抽取数据；</li><li><strong>Oozie</strong>：这是一种 Java Web 系统，用于Hadoop任务的调度，例如设置任务的执行时间和执行频率等；</li><li><strong>Zookeeper</strong>：用于管理配置信息，命名空间。提供分布式同步和组服务；</li><li><strong>Mahout</strong>：可扩展的机器学习算法库。</li></ul><p>其中：<strong>HDFS</strong>、<strong>MapReduce</strong>、<strong>YARN</strong> 是核心组件。</p><h2 id="Hadoop优势"><a href="#Hadoop优势" class="headerlink" title="Hadoop优势"></a>Hadoop优势</h2><p>Hadoop 是一个用于 分布式存储 和 处理大数据 的开源框架，它具有以下几个优势：</p><h4 id="可伸缩性"><a href="#可伸缩性" class="headerlink" title="可伸缩性"></a>可伸缩性</h4><p>Hadoop 可以在成百上千台机器之间分配和处理数据，具有很高的可伸缩性。</p><h4 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h4><p>Hadoop 在处理数据时具备自动故障恢复的能力。如果某一台机器出现问题，Hadoop 会自动将该节点上的数据复制到其他节点上，确保数据的可靠性和不中断性。</p><h4 id="成本效益"><a href="#成本效益" class="headerlink" title="成本效益"></a>成本效益</h4><p>与传统的大型关系数据库相比，Hadoop 成本更低，因为它运行在廉价的硬件上。</p><h4 id="处理多种类型的数据"><a href="#处理多种类型的数据" class="headerlink" title="处理多种类型的数据"></a>处理多种类型的数据</h4><p>Hadoop 可以处理不同类型的数据，包括 结构化数据 半结构化数据 （如JSON）和 非结构化 数据（例如文本、图片、视频和音频等。）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据基础</title>
      <link href="/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B/"/>
      <url>/2024/06/15/%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="数据通用操作"><a href="#数据通用操作" class="headerlink" title="数据通用操作"></a>数据通用操作</h1><ul><li>采集</li><li>处理</li><li>存储</li><li>分析</li></ul><p>最后通过数据分析结果，进行预测、调优等等</p><h1 id="什么是大数据"><a href="#什么是大数据" class="headerlink" title="什么是大数据"></a>什么是大数据</h1><p>大数据（Big Data）是指在传统数据处理方法难以处理的情况下，需要新的处理模式来具有更强的决策力、洞察发现力和过程优化能力的海量、高增长率和多样化的信息资产。大数据的特征通常被概括为“4V”，即：</p><ul><li><strong>Volume（容量）</strong>：大数据的规模非常庞大，通常以 TB（太字节）、PB（拍字节）或 EB（艾字节）为单位，甚至更高。例如，2020 年全球互联网用户产生的数据量达到了 59ZB（泽字节），相当于每天产生 160 亿 GB 的数据。</li><li><strong>Velocity（速度）</strong>：大数据的产生和处理速度非常快，需要实时或近实时的响应。例如，社交媒体、电子商务、物联网等领域的数据流动非常快，需要快速分析和处理。</li><li><strong>Variety（多样性）</strong>：大数据的来源和类型非常多样，包括结构化的数据（如数据库表）、半结构化的数据（如 XML、JSON 等）和非结构化的数据（如文本、图像、音频、视频等）。例如，互联网上的用户行为数据、传感器数据、地理位置数据、社交网络数据等都属于大数据的范畴。</li><li><strong>Value（价值）</strong>：大数据的价值密度相对较低，需要通过有效的分析和挖掘才能发现其潜在的价值。例如，通过大数据分析，可以提高企业的竞争力、创新能力和效率，也可以为政府、社会和个人提供更好的服务和决策支持。</li></ul><h1 id="大数据主要技术"><a href="#大数据主要技术" class="headerlink" title="大数据主要技术"></a>大数据主要技术</h1><ul><li>数据收集</li><li>数据清洗 &#x2F; 预处理</li><li>数据存储</li><li>数据处理</li><li>数据分析</li><li>数据可视化</li></ul><p>其中最核心的当属</p><ul><li>分布式存储</li><li>分布式计算</li></ul><h1 id="大数据发展历程"><a href="#大数据发展历程" class="headerlink" title="大数据发展历程"></a>大数据发展历程</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/8742e6f91ce9d1dc878aa10ff7a2603b.png" alt="img"></p><p>大数据的概念并不是近年来才出现的，其发展历程可以追溯到上个世纪。根据不同的阶段，大数据的发展历程可以分为以下四个时期：</p><ul><li><h4 id="第一时期（1940-1970）：数据收集时期"><a href="#第一时期（1940-1970）：数据收集时期" class="headerlink" title="第一时期（1940-1970）：数据收集时期"></a>第一时期（1940-1970）：数据收集时期</h4><p>这一时期的主要特点是数据的产生和收集，以及数据的存储和管理。随着计算机技术的发展，数据的规模和类型也逐渐增加，出现了诸如</p><p>关系型数据库、层次型数据库、网络型数据库等不同的数据模型和系统。这一时期的代表性技术有： </p><ul><li><strong>磁带</strong>：磁带是一种早期的数据存储介质，利用磁性材料记录数据。磁带的优点是容量大、成本低，但缺点是读写速度慢、易损坏、不便于随机访问。</li><li><strong>磁盘</strong>：磁盘是一种改进的数据存储介质，利用磁性材料记录数据。磁盘的优点是读写速度快、可靠性高、便于随机访问，但缺点是容量小、成本高。</li><li><strong>关系型数据库</strong>：关系型数据库是一种基于关系模型的数据管理系统，利用二维表格存储和操作数据。关系型数据库的优点是结构清晰、逻辑简单、易于查询和维护，但缺点是不适合处理复杂和多样的数据类型。</li></ul></li><li><h4 id="第二时期（1970-1990）：数据分析时期"><a href="#第二时期（1970-1990）：数据分析时期" class="headerlink" title="第二时期（1970-1990）：数据分析时期"></a>第二时期（1970-1990）：数据分析时期</h4><p>这一时期的主要特点是数据的分析和挖掘，以及数据的应用和价值。随着数据的增长和多样化，出现了诸如数据仓库、数据挖掘、</p><p>数据可视化等不同的数据分析方法和技术。这一时期的代表性技术有： </p><ul><li><strong>数据仓库</strong>：数据仓库是一种用于支持决策的数据集成和分析系统，利用多维模型存储和操作数据。数据仓库的优点是能够提供历史和全面的数据视图，支持复杂和多维的数据分析，但缺点是构建和维护成本高，更新和实时性差。</li><li><strong>数据挖掘</strong>：数据挖掘是一种从大量数据中发现有用信息和知识的过程，利用统计、机器学习、人工智能等方法进行数据分析。数据挖掘的优点是能够揭示数据的规律和模式，提供预测和推荐的功能，但缺点是需要专业的知识和技能，存在一定的不确定性和误差。</li><li><strong>数据可视化</strong>：数据可视化是一种将数据转换为图形或图像的过程，利用视觉元素进行数据展示和交互。数据可视化的优点是能够提高数据的可理解性和吸引力，增强数据的沟通和表达，但缺点是需要考虑数据的完整性和准确性，避免产生误导和偏见。</li></ul></li><li><h4 id="第三时期（1990-2010）：大数据时代的到来"><a href="#第三时期（1990-2010）：大数据时代的到来" class="headerlink" title="第三时期（1990-2010）：大数据时代的到来"></a>第三时期（1990-2010）：大数据时代的到来</h4><p>这一时期的主要特点是数据的爆炸和挑战，以及大数据的概念和技术的诞生。随着互联网、物联网、移动通信等技术的发展，数据的产生速度和规模远远超过了传统数据处理方法的能力，数据的特征也变得更加复杂和多样，出现了大数据的概念和特征。为了应对大数据的挑战，Google 等公司提出了分布式文件系统 GFS、大数据分布式计算框架 MapReduce 和 NoSQL 数据库 BigTable 等技术，开创了大数据技术的先河。这一时期的代表性技术有： </p><ul><li><strong>云计算</strong>：云计算是一种基于互联网的数据处理模式，利用虚拟化技术提供可扩展的数据存储和计算服务。云计算的优点是能够降低数据处理的成本和复杂度，提高数据处理的效率和灵活性，但缺点是需要考虑数据的安全和隐私，以及网络的稳定和可靠。</li><li><strong>分布式系统</strong>：分布式系统是一种由多个独立的计算机组成的数据处理系统，利用网络通信协调和合作完成数据处理任务。分布式系统的优点是能够提高数据处理的性能和可靠性，支持大规模和分布式的数据处理，但缺点是需要解决数据的一致性和同步，以及系统的复杂性和开发难度。</li><li><strong>并行计算</strong>：并行计算是一种利用多个处理器同时执行数据处理任务的数据处理方法，利用并行算法和编程模型进行数据分解和合并。并行计算的优点是能够加速数据处理的速度和效果，支持复杂和高性能的数据处理，但缺点是需要考虑数据的划分和负载均衡，以及并行的可扩展性和可移植性。</li></ul></li><li><h4 id="第四时期（2010-至今）：大数据的发展与智能时期"><a href="#第四时期（2010-至今）：大数据的发展与智能时期" class="headerlink" title="第四时期（2010 至今）：大数据的发展与智能时期"></a>第四时期（2010 至今）：大数据的发展与智能时期</h4><p>这一时期的主要特点是数据的智能化和创新，以及数据的价值和影响。随着人工智能、机器学习、深度学习等技术的发展和应用，数据不仅可以被存储和分析，还可以被理解和利用，从而产生新的知识、服务和商业模式。这一时期的代表性技术和事件有：</p><ul><li><strong>分布式处理框架的发展</strong>：分布式处理框架是大数据处理的核心技术，用于将大规模的数据分解为小规模的任务，分配给多个节点并行执行，并将结果汇总返回。最早的分布式处理框架是 MapReduce，由 Google 提出，用于处理结构化和半结构化的数据。后来出现了更加灵活和高效的分布式处理框架，如 Spark、Flink、Storm 等，用于处理实时、流式、复杂的数据。</li><li><strong>非关系型数据库的兴起</strong>：非关系型数据库是一种不遵循关系模型的数据管理系统，用于存储和操作非结构化或半结构化的数据。非关系型数据库的优点是能够适应数据的多样性、动态性和分布性，提供高性能、高可用和高扩展的数据服务。非关系型数据库的类型有很多，如键值型、文档型、列族型、图形型等。一些著名的非关系型数据库有 MongoDB、Cassandra、Neo4j 等。</li><li><strong>云计算和大数据的融合</strong>：云计算为大数据提供了弹性、可扩展、低成本的数据存储和计算服务，大数据为云计算提供了海量、多样、高速的数据资源和分析需求。两者相互促进，形成了云计算和大数据的融合平台，如 Amazon Web Services、Microsoft Azure、Google Cloud Platform 等。</li><li><strong>机器学习和深度学习的应用</strong>：机器学习和深度学习是人工智能的重要分支，用于从数据中学习规律和模式，实现数据的分类、聚类、预测、推荐等功能。机器学习和深度学习的应用领域非常广泛，涉及搜索引擎、社交网络、电子商务、自然语言处理、计算机视觉、语音识别、自动驾驶等。一些著名的机器学习和深度学习的平台和框架有 TensorFlow、PyTorch、scikit-learn 等。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 管道</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E7%AE%A1%E9%81%93/</url>
      
        <content type="html"><![CDATA[<h3 id="匿名管道-IPC"><a href="#匿名管道-IPC" class="headerlink" title="匿名管道 IPC"></a>匿名管道 IPC</h3><h4 id="管道创建"><a href="#管道创建" class="headerlink" title="管道创建"></a>管道创建</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span> <span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br><span class="line"> <span class="comment">// 返回:成功返回0，出错返回-1</span></span><br></pre></td></tr></table></figure><p>fd 为 文件描述符数组，是函数的核心返回值， fd[0] 指向管道 读端 ， fd[1]指向管道写端，也即 fd[1] 是 fd[0] 的输入</p><h4 id="管道实现进程间通信"><a href="#管道实现进程间通信" class="headerlink" title="管道实现进程间通信"></a>管道实现进程间通信</h4><p>（1）父进程创建管道，得到两个⽂件描述符指向管道的两端</p><p>（2）父进程 fork 出子进程，⼦进程也有两个⽂件描述符指向同⼀管道。 </p><p>（3）父进程关闭fd[0],子进程关闭fd[1]，即⽗进程关闭管道读端,⼦进程关闭管道写端（因为管道只支持单向通信）。⽗进程可以往管道⾥写,⼦进程可以从管道⾥读,管道是⽤环形队列实现的,数据从写端流⼊从读端流出,这样就实现了进程间通信。</p><p>实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//子进程发送数据给父进程，父进程读取到数据输出</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//需要在 fork 之前创建管道 ， 这样子进程与父进程 对应相同的管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;pipe create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">// 父进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am parent process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        close(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//从管道的读取端读取数据</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//read会阻塞，进行读取数据</span></span><br><span class="line">            <span class="type">int</span> len = read(pipefd[<span class="number">0</span>],&amp;buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;parent recv : %s ,pid:%d \n&quot;</span>,buf,getpid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I am child process,pid:%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="comment">//子进程 关闭读端</span></span><br><span class="line">        close(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span>* str = <span class="string">&quot;Hello ,I am child &quot;</span>;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],str,<span class="built_in">strlen</span>(str));</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 共享内存</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="共享内存基本概念"><a href="#共享内存基本概念" class="headerlink" title="共享内存基本概念"></a>共享内存基本概念</h1><p>共享内存，顾名思义就是允许两个不相关的进程访问同一个逻辑内存，共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p><p>不同进程之间共享的内存通常为同一段物理内存。进程可以将同一段物理内存连接到他们自己的地址空间中，所有的进程都可以访问共享内存中的地址。如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。</p><p>共享内存并未提供锁机制，也就是说，在某一个进程对共享内存的进行读写的时候，不会阻止其它的进程对它的读写。如果要对共享内存的互斥访问，可以使用信号量。</p><h1 id="共享内存实现方式"><a href="#共享内存实现方式" class="headerlink" title="共享内存实现方式"></a>共享内存实现方式</h1><p>共享内存通常是各种 IPC 之中效率最高的方式。Linux 之中实现共享内存的方式通常有如下几类：</p><ul><li><strong>mmap</strong> 内存共享映射 （通常用于父子进程之间的内存共享，存在一定局限性，且用到更多的原因是其 零拷贝IO 的特性）</li><li>**System V **的共享内存</li><li><strong>POSIX</strong> 共享内存</li></ul><p>平时讨论主要的共享内存是后面两者，但是 System V 和 POSIX 的共享内存，底层都是基于内存文件系统 <strong>tmpfs</strong> 实现的，二者的主要区别是在接口设计上，</p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>将多个进程的地址空间映射到同一个物理内存，从而多个进程都能使用这块物理内存；从而可以用来实现不同进程间的数据共享，也即进程之间的通信</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/2b5437ee0d9c422ea100773c6cc5523f.png" alt="img"></p><h3 id="shm-共享内存接口函数"><a href="#shm-共享内存接口函数" class="headerlink" title="shm 共享内存接口函数"></a>shm 共享内存接口函数</h3><h4 id="相关头文件"><a href="#相关头文件" class="headerlink" title="相关头文件"></a>相关头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="shmget-—-创建共享内存"><a href="#shmget-—-创建共享内存" class="headerlink" title="shmget() — 创建共享内存"></a>shmget() — 创建共享内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong>： 由 ftok 生成的 key 标识，标识系统的唯一 IPC 资源。</p><p><strong>size</strong>： 需要申请共享内存的大小。在操作系统中，申请内存的最小单位为页，一页是4k字节，为了避免内存碎片，我们一般申请的内存大小为页的整数倍。</p><p><strong>shmflg</strong>： 如果要创建新的共享内存，需要使用IPC_CREAT，IPC_EXCL，如果是已经存在的，可以使用IPC_CREAT或直接传0。</p><p>**[返回值]**： 成功时返回一个新建或已经存在的的共享内存标识符，取决于 shmflg 的参数。失败返回 -1 并设置错误码。</p><h4 id="shmat-—-挂接共享内存"><a href="#shmat-—-挂接共享内存" class="headerlink" title="shmat() — 挂接共享内存"></a>shmat() — 挂接共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span> *shm_addr, <span class="type">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong> ： <code>shmget()</code>返回的共享内存标识。</p><p><strong>shm_addr</strong> ： 指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p><p><strong>shm_flg</strong> ： 一组标志位，通常为0。</p><p><strong>[返回值]</strong> ： 成功返回共享存储段的指针（虚拟地址），并且内核将使其与该共享存储段相关的 <code>shmid_ds</code> 结构中的 <code>shm_nattch</code> 计数器加1（类似于引用计数）；出错返回-1。</p><h4 id="shmdt-—-去关联共享内存"><a href="#shmdt-—-去关联共享内存" class="headerlink" title="shmdt() — 去关联共享内存"></a>shmdt() — 去关联共享内存</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shmaddr</strong>： <code>shmat()</code>返回的地址。</p><p>**[返回值]**： 调用成功时返回0，失败时返回-1.</p><h4 id="shmctl-—-控制共享内存（仅删除）"><a href="#shmctl-—-控制共享内存（仅删除）" class="headerlink" title="shmctl() — 控制共享内存（仅删除）"></a>shmctl() — 控制共享内存（仅删除）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>shm_id</strong>： <code>shmget()</code> 返回的共享内存标识符。</p><p><strong>command</strong>： 指定的执行操作，设置为<code>IPC_RMID</code>时表示可以删除共享内存。</p><p><strong>buf</strong>：  填 null 即可</p><p>**[返回值]**：成功返回0，失败返回-1。</p><h2 id="MMAP"><a href="#MMAP" class="headerlink" title="MMAP"></a>MMAP</h2><h3 id="MMAP-原理"><a href="#MMAP-原理" class="headerlink" title="MMAP 原理"></a>MMAP 原理</h3><ul><li><p>MMAP 本质是把 文件内容 映射到一段内存上 (准确说是虚拟内存上),  </p></li><li><p>因此通过对这段内存的读取和修改, 即可实现对文件的读取和修改,</p></li><li><p><code>mmap()</code> <strong>系统调用使得进程之间可以通过映射一个普通的文件实现共享内存</strong>。</p></li><li><p>文件映射到进程地址空间后，进程可以向访问内存的方式对文件进行访问，不需要其他系统调用 (read,write) 去操作。</p></li></ul><h4 id="MMAP-零拷贝原理："><a href="#MMAP-零拷贝原理：" class="headerlink" title="MMAP 零拷贝原理："></a>MMAP 零拷贝原理：</h4><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240512223136171.png" alt="image-20240512223136171" style="zoom:67%;" /><h4 id="MMAP-共享内存原理："><a href="#MMAP-共享内存原理：" class="headerlink" title="MMAP 共享内存原理："></a>MMAP 共享内存原理：</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1723697-e4822f4555069606.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPC --- 信号量</title>
      <link href="/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2024/05/12/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/IPC--%E4%BF%A1%E5%8F%B7%20%E4%B8%8E%20%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="信号量概述"><a href="#信号量概述" class="headerlink" title="信号量概述"></a>信号量概述</h1><h2 id="什么是信号量"><a href="#什么是信号量" class="headerlink" title="什么是信号量"></a>什么是信号量</h2><p>信号量（信号灯）本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</p><p>信号量是一个特殊的变量，只允许进程对它进行等待信号和发送信号操作。最简单的信号量是取值 0 和 1 的二元信号量，这是信号量最常见的形式。</p><p>通用信号量（可以取多个正整数值）和信号量集方面的知识比较复杂，应用场景也比较少，本文只介绍二元信号量。</p><h2 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h2><p>由于信号量只能进行两种操作等待和发送信号，即 <code>P(sv)</code>和<code>V(sv)</code>,他们的行为是这样的：</p><p>**P(sv)**：如果 sv 的值大于零，就给它减 1；如果它的值为零，就挂起该进程的执行</p><p>**V(sv)**：如果有其他进程因等待 sv 而被挂起，就让它恢复运行，如果没有进程因等待 sv 而挂起，就给它加 1.</p><p>举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。</p><h2 id="Linux的信号量机制"><a href="#Linux的信号量机制" class="headerlink" title="Linux的信号量机制"></a>Linux的信号量机制</h2><p>Linux提供了一组精心设计的信号量接口来对信号进行操作，它们不只是针对二进制信号量，下面将会对这些函数进行介绍，但请注意，这些函数都是用来对成组的信号量值进行操作的。它们声明在头文件<code>sys/sem.h</code>中。</p><h3 id="semget-—-信号量创建"><a href="#semget-—-信号量创建" class="headerlink" title="semget() — 信号量创建"></a>semget() — 信号量创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>key</strong>： 整数值（唯一非零），不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，程序先通过调用 <code>semget()</code> 函数并提供一个键，再由系统生成一个相应的信号标识符（semget()函数的返回值），只有 <code>semget()</code> 函数才直接使用信号量键，所有其他的信号量函数使用由 <code>semget()</code> 函数返回的信号量标识符。如果多个程序使用相同的 key 值，key 将负责协调工作。</p></li><li><p><strong>num_sems</strong>： 指定需要的信号量数目，它的值几乎总是1。</p></li><li><p><strong>sem_flags</strong>： 一组标志，当想要当信号量不存在时创建一个新的信号量，可以和值 IPC_CREAT 做按位或操作。设置了 IPC_CREAT 标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而  IPC_EXCL 则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。</p></li></ul><p><code>semget()</code> 函数成功返回一个相应信号标识符（非零），失败返回-1.</p><h3 id="semop-—-改变信号量的值"><a href="#semop-—-改变信号量的值" class="headerlink" title="semop() — 改变信号量的值"></a>semop() — 改变信号量的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf *sem_opa, <span class="type">size_t</span> num_sem_ops)</span>;</span><br></pre></td></tr></table></figure><p><code>sem_id</code> 是由 <code>semget()</code> 返回的信号量标识符，<code>sembuf</code> 结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="type">short</span> sem_num; <span class="comment">// 除非使用一组信号量，否则它为0</span></span><br><span class="line">    <span class="type">short</span> sem_op;  <span class="comment">// 信号量在一次操作中需要改变的数据，通常是两个数，一个是-1，即P（等待）操作，</span></span><br><span class="line">                   <span class="comment">// 一个是+1，即V（发送信号）操作。</span></span><br><span class="line">    <span class="type">short</span> sem_flg; <span class="comment">// 通常为SEM_UNDO,使操作系统跟踪信号，</span></span><br><span class="line">                   <span class="comment">// 并在进程没有释放该信号量而终止时，操作系统释放信号量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="semctl-—-修改信号量信息"><a href="#semctl-—-修改信号量信息" class="headerlink" title="semctl() — 修改信号量信息"></a>semctl() — 修改信号量信息</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li>sem_id: semget() 返回的 sem Id</li><li>sem_num: 指定需要的信号量数目，它的值几乎总是1</li><li>command: 通常是下面两个值中的其中一个:<ul><li>SETVAL：用来把信号量初始化为一个已知的值。p 这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。</li><li>IPC_RMID：用于删除一个已经无需继续使用的信号量标识符</li></ul></li></ul><p>如果有第四个参数，它通常是一个 <code>union semum</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *arry;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="用信号量实现多进程并发安全"><a href="#用信号量实现多进程并发安全" class="headerlink" title="用信号量实现多进程并发安全"></a>用信号量实现多进程并发安全</h1><h2 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h2><p><strong>进程互斥</strong>：不同进程之间的代码，A进程执行到部分代码字段 时，其他进程不能执行自身特定的代码字段，仅A进程将该字段执行完毕，其他程序才能继续执行</p><p>伪代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/* 信号量机制实现互斥 */</span><br><span class="line">semaphore mutex = 1; // 初始化信号量</span><br><span class="line"></span><br><span class="line">P1()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);   // 使用临界资源前需要加锁</span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   // 使用临界资源后需要解锁</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">  ...</span><br><span class="line">  P(mutex);  </span><br><span class="line">  临界区代码段.....</span><br><span class="line">  V(mutex);   </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h2 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h2><p><strong>进程同步</strong>： 散布在不同进程之间的若干程序片段，它们的运行必须严格按照一定的先后次序来运行，这种次序依赖于要完成的任务。比如数据的收发，必须发送方发送了接收方才能收</p><p>用例： 保证代码 4 必须在代码 1,2 之后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>; <span class="comment">// 初始化信号量</span></span><br><span class="line">P1()&#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    V(S);</span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P2()&#123;</span><br><span class="line">    P(S)</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程</title>
      <link href="/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/11183270-40bf3033d3e24a39.png" alt="img"></p><p>JVM 线程对主存中的共享变量进行修改时，必须先将共享变量读到自身工作内存中（实际就是CPU Cache），并在工作内存中进行修改，最后再刷回主存。</p><p>（CPU Cache： 缓解 内存 和 CPU 速度相差过大问题， 但 Cache 引入势必造成一致性问题）</p><h2 id="内存交互操作（保证原子性）"><a href="#内存交互操作（保证原子性）" class="headerlink" title="内存交互操作（保证原子性）"></a>内存交互操作（保证原子性）</h2><ul><li><strong>read</strong>： 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。</li><li><strong>load</strong>： 把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。</li><li><strong>use</strong>： 把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。</li><li><strong>assign</strong>： 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作</li><li><strong>store</strong>： 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。</li><li><strong>write</strong>： 作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li><li><strong>lock</strong>： 作用于主内存的变量，把一个变量标识为线程独占状态</li><li><strong>unlock</strong>：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li></ul><h3 id="相关规则"><a href="#相关规则" class="headerlink" title="相关规则"></a>相关规则</h3><ul><li>read &#x2F; load 和 store &#x2F; write  操作必须成对按序使用</li><li>变量 assign 之后必须存在 stire&#x2F;write 将其写回主存</li><li>加载完但未执行 assign 的变量 ，不允许重新写回主存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个线程 lock 了一个变量，后续该线程 且 仅有该线程能继续 lock 该变量； 直至调用相同 次数 unlock ，完成解锁</li><li>变量被 lock ，所有工作内存中的副本将被清除，因此执行引擎使用该变量前，必须重新 load 或 assign 以初始化变量的值</li><li>只能 unlock 被当前线程 lock 了的变量</li><li>对一个变量进行 unlock 操作之前，必须把此变量同步回主内存</li></ul><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>烂八股：</p><ul><li><strong>保证可见性</strong>： 线程对 volatile 变量修改后，强制将其刷回主存，并使其他 CPU 中的对应缓存行失效（MESI 和 内存屏障的作用）</li><li><strong>禁止指令重排：</strong> 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果 （阿里开发手册中关于 DCL 单例中的说明）</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>从汇编角度看，volatile 的作用基于 lock 前缀指令 —— 在线程对缓存行内变量执行写操作时，发出一个 lock 指令，锁住总线&#x2F;或缓存行，同时让 其他cpu中的缓存行失效，并将修改后的数据强制写回主存</p><h2 id="volatile-int-i-错误原因分析："><a href="#volatile-int-i-错误原因分析：" class="headerlink" title="volatile int i++ 错误原因分析："></a>volatile int i++ 错误原因分析：</h2><p>i++ 非原子性操作，</p><ul><li>读取 i</li><li>i 自增</li><li>回写 i</li></ul><p>volatile 可以保证第二 和 第三步 会合并成一个原子操作</p><p>但若两个 thread 读取操作发生在 peer 的改值操作之前，还是不能保证线程安全</p><p><strong>【参考】</strong></p><ul><li><a href="https://www.cnblogs.com/badboys/p/12695183.html">volatile与lock前缀指令 - 干饭人~ - 博客园 (cnblogs.com)</a></li></ul><h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Synchronized  是 java 中用来实现 线程同步&#x2F;互斥 编程的一个关键字，可以用来修饰</p><ul><li>实例方法 —— 锁住当前对象</li><li>静态方法 —— 锁住当前类对象</li><li>代码块 —— 静态代码块，锁住当前类对象； 普通代码块，锁住当前对象</li></ul><h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><p>无论是哪种使用方法，<code>synchronized</code> 底层都是通过 <code>monitorenter</code> 和 <code>monitorexit</code> 两个 jvm 指令实现的</p><p>而 <code>monitorenter</code> 和 <code>monitorexit</code> 则是基于 <code>markworkd 及 </code>objectmonitor&#96; 实现</p><h3 id="markword-对象头"><a href="#markword-对象头" class="headerlink" title="markword &#x2F; 对象头"></a>markword &#x2F; 对象头</h3><h4 id="对象组成"><a href="#对象组成" class="headerlink" title="对象组成"></a>对象组成</h4><ul><li>对象头</li><li>实例数据</li><li>对其填充字节</li></ul><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ul><li>Markword</li><li>类指针</li><li>数组长度（仅数组对象有）</li></ul><h4 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/aa.png" alt="aa"></p><h2 id="Synchronized-锁升级"><a href="#Synchronized-锁升级" class="headerlink" title="Synchronized 锁升级"></a>Synchronized 锁升级</h2><ol><li>当JVM启动后，一个共享资源对象直到有线程第一个访问时，这段时间内是处于无锁状态，对象头的Markword里偏向锁标识位是0，锁标识位是01。</li><li>当一个共享资源首次被某个线程访问时，锁就会从无锁状态升级到偏向锁状态，偏向锁会在 Markword 的偏向线程 ID 里存储当前线程的操作系统线程 ID，偏向锁标识位是1，锁标识位是01。<ul><li>从jdk1.6之后，JVM有两个默认参数是开启的，-XX:+UseBiasedLocking（表示启用偏向锁，想要关闭偏向锁，可添加JVM参数：-XX:-UseBiasedLocking），-XX:BiasedLockingStartupDelay&#x3D;4000（表示JVM启动4秒后打开偏向锁，也可以自定义这个延迟时间，如果设置成0，那么JVM启动就打开偏向锁）。</li><li>此后如果当前线程再次进入临界区域时，只比较这个偏向线程ID即可，这种情况是在只有一个线程访问的情况下，不再需要操作系统的重量级锁来切换上下文，提供程序的访问效率。</li><li>另外需要注意的是，由于硬件资源的不断升级，获取锁的成本随之下降，jdk15版本后默认关闭了偏向锁。<br>如果未开启偏向锁（或者在JVM偏向锁延迟时间之前）有线程访问共享资源则直接由无锁升级为轻量级锁，</li></ul></li><li>当第二个线程尝试获取偏向锁失败时，偏向锁会升级为轻量级锁，此时，JVM会使用CAS自旋操作来尝试获取锁，如果成功则进入临界区域，否则升级为重量级锁。<ul><li>轻量级锁是在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，尝试拷贝锁对象头的Markword到栈帧的Lock Record，若拷贝成功，JVM将使用CAS操作尝试将对象头的Markword更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象头的Markword。若拷贝失败,若当前只有一个等待线程，则可通过自旋继续尝试， 当自旋超过一定的次数，或者一个线程在持有锁，一个线程在自旋，又有第三个线程来访问时，轻量级锁就会膨胀为重量级锁。</li></ul></li><li>当轻量级锁获取锁失败时，说明有竞争存在，轻量级锁会升级为重量级锁，此时，JVM会将线程阻塞，直到获取到锁后才能进入临界区域，底层是通过操作系统的 mutex lock来实现的，每个对象指向一个monitor对象，这个monitor对象在堆中与锁是关联的，通过monitorenter 指令插入到同步代码块在编译后的开始位置，monitorexit 指令插入到同步代码块的结束处和异常处，这两个指令配对出现。JVM的线程和操作系统的线程是对应的，重量级锁的Markword里存储的指针是这个monitor对象的地址，操作系统来控制内核态中的线程的阻塞和恢复，从而达到JVM线程的阻塞和恢复，涉及内核态和用户态的切换，影响性能，所以叫重量级锁。</li></ol><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240528011826870.png" alt="image-20240528011826870"></p><h3 id="ObjectMonitor"><a href="#ObjectMonitor" class="headerlink" title="ObjectMonitor"></a>ObjectMonitor</h3><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个ObjectWaiter对象插入到cxq的队列尾部，然后暂停当前线程。当持有锁的线程释放锁前，会将cxq中的所有元素移动到EntryList中去，并唤醒EntryList的队首线程。</p><p>如果一个线程在同步块中调用了<code>Object#wait</code>方法，会将该线程对应的ObjectWaiter从EntryList移除并加入到WaitSet中，然后释放锁。当wait的线程被notify之后，会将对应的ObjectWaiter从WaitSet移动到EntryList中。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/932045510502514689.png" alt="932045510502514689"></p><p><strong>【参考】</strong></p><ul><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕Synchronized底层实现–概论 · Issue #12 · farmerjohngit&#x2F;myblog (github.com)</a></li></ul><h1 id="乐观锁-与-悲观锁"><a href="#乐观锁-与-悲观锁" class="headerlink" title="乐观锁 与 悲观锁"></a>乐观锁 与 悲观锁</h1><p>~ 是并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><p>悲观锁和乐观锁是实现并发安全的两种控制策略，并不是有两种锁，一个“乐观”一些，一个“悲观”一些； 因此个人感觉不应该叫做 乐观锁&#x2F;悲观锁</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><ul><li>悲观锁 的 线程安全控制策略 适用于 并发写操作较多的场景，</li><li>悲观锁 在加锁期间，其他线程无法访问被锁定的资源，从而保证了数据的完整性。</li><li>悲观锁 需要频繁地进行加锁和解锁操作，开销较大。</li></ul><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><ul><li>乐观锁适用于并发读操作较多的场景，因为读操作不涉及到数据的修改，不需要加锁。</li><li>乐观锁在更新数据时，只有在提交更新操作时才对数据进行版本检查，减少了加锁和解锁的开销。</li><li>乐观锁可能需要进行重试，以处理并发修改引起的冲突。</li></ul><p>乐观锁常用 <strong>CAS</strong> 或 **版本号 ** 机制 进行实现</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ， 即 仅比较通过才会进行设值， CAS 是乐观锁的主要实现方式之一</p><p>CAS 依赖于操作系统原语，更底层则依赖于 硬件指令集，即 CAS 最终由 硬件保证操作的原子性</p><h3 id="JAVA-CAS"><a href="#JAVA-CAS" class="headerlink" title="JAVA CAS"></a>JAVA CAS</h3><p>java cas 相关实现依赖于 Unsafe 类提供的一系列 JNI 接口</p><h3 id="CAS-相关问题"><a href="#CAS-相关问题" class="headerlink" title="CAS 相关问题"></a>CAS 相关问题</h3><h4 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h4><ul><li><p>CAS 操作成功，并不意味着值在 cas 所处指令序列的 值读取 与 CAS 设值 之间没有发生过 变更</p></li><li><p>解决：在变量前面追加上<strong>版本号或者时间戳</strong></p></li></ul><h4 id="自旋空转"><a href="#自旋空转" class="headerlink" title="自旋空转"></a>自旋空转</h4><p><strong>说明</strong>： CAS 经常会用自旋操作来进行重试，即不成功就一直循环直至成功为止。但若如果长时间不成功，会给 CPU 造成较大负担</p><p><strong>解决</strong>：参考 synchronized 引入适应性自旋，或限制自旋次数</p><h1 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>两个线程各自锁住一个资源，并无限期等待&#x2F;请求 对方锁住的资源，导致两个线程相互等待，导致程序无限期卡死</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601020943517.png" alt="image-20240601020943517"></p><h2 id="死锁发生的条件"><a href="#死锁发生的条件" class="headerlink" title="死锁发生的条件"></a>死锁发生的条件</h2><ul><li><p><strong>互斥使用</strong>，即当资源被一个线程占用时，别的线程不能使用</p></li><li><p><strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中抢夺资源，资源只能由占有者主动释放</p></li></ul><ul><li><strong>请求和保持</strong>，当资源请求者在请求其他资源的同时保持对原因资源的占有</li><li><strong>循环等待</strong>，多个线程存在环路的锁依赖关系而永远等待下去，例如T1占有T2的资源，T2占有T3的资源，T3占有T1的资源，这种情况可能会形成一个等待环路</li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><p>从死锁条件着手，破坏其中一个即可（互斥是基本需求，不能破坏）</p><p>实际常用的有：</p><ul><li>一次性申请所有资源</li><li>各方按相同顺序申请资源</li><li>给申请资源的等待时间设置限制</li><li>无法实现前面几种，还可以升级锁粒度，用一个大的锁控制全局互斥</li></ul><h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul><li>jstack 进程号<ul><li>指令运行结果会提示 相应 进程存在死锁问题</li><li>可先用 jps -l 查看所有java 进程</li></ul></li><li>使用图形化工具 jconsole.exe 或 jvisualvm.exe 会自动检测死锁</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 线程</title>
      <link href="/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux线程概念"><a href="#一、Linux线程概念" class="headerlink" title="一、Linux线程概念"></a>一、Linux线程概念</h1><h2 id="1、什么是线程"><a href="#1、什么是线程" class="headerlink" title="1、什么是线程"></a>1、什么是线程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509040108318.png" alt="image-20240509040108318"></p><p>首先从 <strong>进程</strong> 讲起，一个进程有自己对应的 PCB，虚拟地址空间，页表以及映射的物理内存，也即 <code>进程 = 内核数据结构 + 进程对应的代码和数据</code>。</p><p>对于<strong>虚存</strong>：虚拟内存决定了进程能够看到的”资源”。因为每一个进程都有对应的虚拟内存，所以进程具有独立性，从而进程需要通信的前提是看到同一份资源。</p><p>通过 fork 创建子进程的时候，会将父进程的PCB的内容，进程地址空间和页表都给子进程拷贝一份。</p><p><code>而如果创建多个 PCB，并将这些 PCB 使用同一个进程地址空间和页表，这样就可以看到同一份资源了，这就是线程。</code></p><p>因此可以将 线程 理解为 进程 内的一个执行流，线程在进程内运行，线程在进程的地址空间内运行，拥有该进程的一部分资源。</p><p>也即 线程是 CPU 调度的基本单位。进程 则是承担系统资源的基本实体，内部可以有一个或多个执行流。因为我们可以通过虚拟地址空间+页表的方式对进程的资源进行划分，单个”进程”(线程)执行粒度，一定要比之前的进程要细。</p><p>如果 OS 要专门设计线程的概念，就需要对线程进行管理，也就需要先描述，再组织，即一定要为线程设计专门的数据结构表示线程对象TCB。但是线程和进程一样都需要被执行，被调度(id,状态，优先级，上下文，栈…)，二者十分相似，所以单纯从线程调度角度，线程和进程有很多的地方是重叠的。所以Linux工程师不想给”线程”专门设计对应的数据结构，而是直接复用PCB，用 PCB 用来表示 Linux 内部的”线程”, 所以在Linux中，进程我们称为轻量级进程。而 windows 有单独的TCB结构</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>.Linux 内核中没有真正意义是线程，Linux是用进程的 PCB 来进行模拟，是一种完全属于自己的一套线程方案</p></li><li><p>站在 CPU视角，每一个PCB，都可以称之为轻量级进程</p></li><li><p>Linux 线程是 CPU 调度的基本单位，而进程是承担资源分配的基本单位</p></li><li><p>进程用来整体申请资源，线程用来伸手向进程要资源</p></li><li><p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”</p></li><li><p>一切进程至少都有一个执行线程</p></li><li><p>线程在进程内部运行，本质是在进程地址空间内运行</p></li><li><p>在 Linux 系统中，在 CPU 眼中，看到的 PCB 都要比传统的进程更加轻量化</p></li><li><p>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</p></li></ol><p>Linux内核中没有真正意义是线程，所以Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口，但是操作系统只认线程，用户(程序员)也只认线程，所以Linux在软件层提供了一个原生的线程库。</p><p>任何 Linux 操作系统，都必须默认携带这个原生线程库–用户级线程库</p><p>线程创建用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是新线程, 我正在运行! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> n = pthread_create(&amp;tid, nullptr, start_routine, (<span class="type">void</span> *)<span class="string">&quot;thread one&quot;</span>);</span><br><span class="line">    assert(<span class="number">0</span> == n);</span><br><span class="line">    (<span class="type">void</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是主线程, 我正在运行!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多<ul><li>进程：切换页表 &amp;&amp; 虚拟地址空间 &amp;&amp; 切换PCB &amp;&amp;上下文切换</li><li>线程：切换PCB &amp;&amp;上下文切换</li></ul></li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I&#x2F;O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I&#x2F;O密集型应用，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能损失</strong> —— 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><strong>健壮性降低</strong> —— 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><strong>缺乏访问控制</strong> —— 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><strong>编程难度提高</strong> —— 编写与调试一个多线程程序比单线程程序困难得多</li></ol><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃，<strong>因为信号在整体发给进程的</strong></p><p>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</p><h1 id="二、线程控制"><a href="#二、线程控制" class="headerlink" title="二、线程控制"></a>二、线程控制</h1><h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><h4 id="创建线程函数接口-–-pthread-create"><a href="#创建线程函数接口-–-pthread-create" class="headerlink" title="创建线程函数接口 – pthread_create"></a>创建线程函数接口 – pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建一个新的线程</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// thread_label: 线程标识符</span></span><br><span class="line"><span class="comment">// attr:设置线程的属性，attr为NULL表示使用默认属性</span></span><br><span class="line"><span class="comment">// start_routine:是个函数地址，线程启动后要执行的函数</span></span><br><span class="line"><span class="comment">// arg:传给线程启动函数的参数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread_label, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>thread_label 实际上是进程地址空间上的一个地址</li><li>用户线程、用户进程、内核线程 关系后续补充</li></ul><h2 id="2-线程终止"><a href="#2-线程终止" class="headerlink" title="2. 线程终止"></a>2. 线程终止</h2><p>如果需要只终止某个线程而不终止整个进程,可以有三种方法</p><ul><li>从线程函数 return。这种方法对主线程不适用，因为从 main 函数 return 相当于调用 exit。</li><li>线程调用 pthread_ exit 终止自己。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// value_ptr:value_ptr不要指向一个局部变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *value_ptr)</span>;</span><br></pre></td></tr></table></figure><ul><li>一个线程可以调用 pthread_ cancel 终止同一进程中的另一个线程。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread:线程ID</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><h2 id="3-线程等待"><a href="#3-线程等待" class="headerlink" title="3. 线程等待"></a>3. 线程等待</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS 详解</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>Java 自带的各种同步工具类的 基石</p><p>将临界资源抽象成一个 <code>volatile int stat</code>，并通过 cas 操作进行加减锁</p><p>此外，AQS 设计了一个 FIFO 的线程等待 （双向）队列，用以帮助并发竞争的线程间 进行 阻塞、唤醒等功能</p><p>而且，提供基础的 排它锁、共享锁设计基础， 实现类可在此基础上进一步补充 公平、非公平机制，实现常用锁功能和特性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractQueuedSynchronizer</span> <span class="keyword">extends</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> newState)</span> &#123;</span><br><span class="line">        state = newState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSetState</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractOwnableSynchronizer</span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span>/Setter</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁相关"><a href="#写锁相关" class="headerlink" title="写锁相关"></a>写锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>acquire 由 实现类的 lock() 调用，调用前 及 tryAcquire 具体实现中可自定义 公平&#x2F;非公平策略</li></ul><h2 id="共享锁相关"><a href="#共享锁相关" class="headerlink" title="共享锁相关"></a>共享锁相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">// 由子类实现</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();<span class="comment">// 找到前继节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);<span class="comment">// 由子类实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setHeadAndPropagate</span><span class="params">(Node node, <span class="type">int</span> propagate)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="literal">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平-与-非公平-写锁-–-以-ReentrantLock-为例"><a href="#公平-与-非公平-写锁-–-以-ReentrantLock-为例" class="headerlink" title="公平 与 非公平 写锁 – 以 ReentrantLock 为例"></a>公平 与 非公平 写锁 – 以 ReentrantLock 为例</h2><h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><ul><li><h4 id="fair-lock"><a href="#fair-lock" class="headerlink" title="fair lock"></a>fair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="unfair-lock"><a href="#unfair-lock" class="headerlink" title="unfair lock"></a>unfair lock</h4></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) </span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span> acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unlock"><a href="#unlock" class="headerlink" title="unlock"></a>unlock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal 总结</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/ThreadLocal%20%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="作用-使用场景"><a href="#作用-使用场景" class="headerlink" title="作用 &#x2F; 使用场景"></a>作用 &#x2F; 使用场景</h2><ul><li>线程隔离</li><li>同一 &#x2F; 父子 线程内跨方法传参</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>废话不多说，直接看代码</p><p>先是 ThreadLocal 类本身</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>ThreadLocal</code> 设值是找到当前线程的 <code>ThreadLocalMap</code> 对象，并以 <code>ThreadLocal</code> 对象自身为 key，以传入值为 value 添加 entry </p><p>所以再看 <code>Thread</code>  中的相关定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">inheritableThreadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code> 对象实际是 <code>ThreadLocal</code> 的 静态内部类，看一下类的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="built_in">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Entry[] table;</span><br><span class="line">    </span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">        table = <span class="keyword">new</span> <span class="title class_">Entry</span>[INITIAL_CAPACITY];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">        table[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(firstKey, firstValue);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        setThreshold(INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadLocal Map</code> 还包含几个核心方法——<code>getEntry</code>、<code>set()</code>、<code>remove()</code>， 其总体实现逻辑与 常规 Map 没什么太大差别，这里就不展开细讲了</p><p>这里主要讲一下 <code>ThreadLocalMap</code> 中这个 <code>WeakReference</code>， 这也是 ThreadLocal 常被诟病的内存泄漏的问题分析基石</p><h2 id="ThreadLocal-内存泄漏问题分析"><a href="#ThreadLocal-内存泄漏问题分析" class="headerlink" title="ThreadLocal 内存泄漏问题分析"></a>ThreadLocal 内存泄漏问题分析</h2><ul><li><code>Entry</code> 继承自 <code>ThreadLocal&lt;?&gt;</code> 的弱引用， 而 <code>Entry</code> 构造时，父类构造函数调用传入的是参数是 key 也即 <code>ThreadLocal</code> 对象，而 <code>super()</code> 调用过程也就是 弱引用的创建过程，因此，<code>ThreadLocal</code> 中的弱引用实际是 <code>Entry</code> -&gt; <code>ThreadLocal</code> (key) 的弱引用</li><li>而实际上存在 <code>thread</code> -&gt; <code>threadLocalMap</code> -&gt; <code>Entry[]</code> -&gt; <code>entry</code> -&gt; <code>value</code> 的强引用链</li></ul><p>所以在以下场景中，<code>threadlocal</code> 会有内存泄漏问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">        createThreadLocal();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">createThreadLocal</span><span class="params">()</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240601012342860.png" alt="image-20240601012342860"></p><h3 id="ThreadLocal-中-弱引用的作用"><a href="#ThreadLocal-中-弱引用的作用" class="headerlink" title="ThreadLocal 中 弱引用的作用"></a>ThreadLocal 中 弱引用的作用</h3><p>到这，弱引用的作用就比较清楚了</p><ul><li>可以保证 <code>threadLocal</code> 对象本身 可以在 GC 时被正常回收</li><li>但 <code>Value</code> 实际上还是强引用可达，因此并不能被 GC 自动回收，可能还是会造成内存泄漏</li></ul><h3 id="ThreadLocal-如何防止内存泄漏"><a href="#ThreadLocal-如何防止内存泄漏" class="headerlink" title="ThreadLocal 如何防止内存泄漏"></a>ThreadLocal 如何防止内存泄漏</h3><ul><li>使用完手动 <code>remove()</code></li></ul><h2 id="JAVA-引用类型"><a href="#JAVA-引用类型" class="headerlink" title="JAVA 引用类型"></a>JAVA 引用类型</h2><ul><li>强引用 —— 无论内存是否充足，均不回收</li><li>软引用 —— GC 时内存充足不回收，不充足时会回收<ul><li>意思是内存充足也会发生GC ?   手动触发 <code>System.gc()</code> ?</li></ul></li><li>弱引用 —— 无论内存是否充足，只要发生 GC ，都会将其回收</li><li>虚引用 —— 普通开发中几乎不会用到，一般在 GC 过程当中有使用<ul><li>参考： <a href="https://www.cnblogs.com/mfrank/p/9837070.html">你不可不知的Java引用类型之——虚引用 - 弗兰克的猫 - 博客园 (cnblogs.com)</a></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程基础</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul><li>进程可以理解为程序的一次执行过程，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>现代操作系统对于进程会分配独立的 内存地址空间和其他系统资源（IO）</li><li>对 Java 而言，<code>main()</code> 函数启动时其实就是启动了一个 JVM 的进程，而 <code>main()</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul><li>线程是依托于进程的一个指令执行序列</li><li>一个进程可以产生多个线程</li><li>linux中，线程又叫做轻量级进程（light-weight process LWP），也有PCB，创建线程使用的底层函数和进程底层一样，都是clone，但没有独立的地址空间；而进程有独立地址空间，拥有PCB。</li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>包含关系</strong>：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>资源开销</strong>：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li></ul><h2 id="进程间通信方式"><a href="#进程间通信方式" class="headerlink" title="进程间通信方式"></a>进程间通信方式</h2><ul><li><strong>管道 pipe</strong><ul><li><strong>管道概念</strong>：<ul><li>管道是一种半双工的通信方式，用以传输字节流</li><li>本质是内核中基于环形队列设计的一段缓冲区，对应着两个文件描述符，一个赋予读权限，一个赋予写权限</li><li>数据只能单向流动，一端写和一端读</li></ul></li><li><strong>分类</strong><ul><li><strong>匿名管道</strong>： 只能在父子或亲缘进程间使用</li><li><strong>命名管道</strong>：允许非情缘关系进程间进行通信</li></ul></li></ul></li></ul><ul><li><strong>消息队列</strong>：本质是 OS 内核中维护的一个 尾插头读 的链表，<ul><li>与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息</li></ul></li><li><strong>共享存储</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<ul><li><strong>优点</strong>：其他IPC一般涉及数据拷贝、传输，而共享内存不需要，因此 CPU、内存负载更低，同时提高了处理速度</li><li><strong>缺点</strong>：会引入并发安全问题，需引入信号量等机制，确保线程安全性</li><li><strong>实现方式</strong>：有 mmap 和 shmget 两种</li></ul></li><li><strong>信号量</strong>：信号量本质上是一个计数器，用于协调多个进程（包括但不限于父子进程）对共享数据对象的读&#x2F;写。它不以传送数据为目的，主要是用来保护共享资源（信号量、消息队列、socket连接等），保证共享资源在一个时刻只有一个进程独享。</li><li><strong>套接字</strong>：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</li><li><strong>信号</strong>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul><h2 id="进程互斥-与-同步"><a href="#进程互斥-与-同步" class="headerlink" title="进程互斥 与 同步"></a>进程互斥 与 同步</h2><h3 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h3><p>在操作系统中，进程是占有资源的最小单位。对于某些资源来说，可能有多个进程需要占用，但是为了保障操作系统和指令的正常执行，有些资源在同一时间只能被其中一个进程所占用。这些一次只能被一个进程所占用的资源就是所谓的临界资源。</p><p>典型的临界资源比如物理上的打印机，或是存在硬盘或内存中被多个进程所共享的一些变量和数据等(如果这类资源不被看成临界资源加以保护，那么很有可能造成丢数据的问题)。</p><p> 对于临界资源的访问，必须是互斥进行。也就是当临界资源被占用时，另一个申请临界资源的进程会被阻塞，直到其所申请的临界资源被释放。而进程内访问临界资源的代码被成为临界区。</p><p>  对于临界区的访问过程分为四个部分：</p><ol><li><strong>进入区</strong>:  查看临界区是否可访问，如果可以访问，则转到步骤二，否则进程会被阻塞</li><li><strong>临界区</strong>:  在临界区做操作</li><li><strong>退出区</strong>:  清除临界区被占用的标志</li><li><strong>剩余区</strong>：进程与临界区不相关部分的代码</li></ol><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>多进程完成某个任务时，进程之间 部分指令 或 代码块 的执行需按照指定先后关系按序执行</p><h3 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h3><p>并行的多个进程 访问临界资源，在其中一个进程A进入临界区后，其他线程在进入临界区前必须阻塞等待进程 A 退出临界区</p><h1 id="CPU-Cache-一致性"><a href="#CPU-Cache-一致性" class="headerlink" title="CPU Cache 一致性"></a>CPU Cache 一致性</h1><p>在单核 CPU 中，只需要考虑 Cache 与 内存 的一致性。但是在多核 CPU 中，由于每个核心都有一份独占的 Cache，就会存在一个核心修改数据后，两个核心 Cache 数据不一致的问题。因此， CPU 缓存一致性问题应该从 2 个维度理解：</p><ul><li><strong>纵向：Cache 与 内存 的一致性问题：</strong> 在修改 Cache 数据后，如何同步回内存？</li><li><strong>横向：多核心 Cache 的一致性问题：</strong> 在一个核心修改 Cache 数据后，如何同步给其他核心 Cache？</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511022424797.png" alt="image-20240511022424797" style="zoom:50%;" /><h2 id="单核场景-cache-与-内存数据一致性"><a href="#单核场景-cache-与-内存数据一致性" class="headerlink" title="单核场景 cache 与 内存数据一致性"></a>单核场景 cache 与 内存数据一致性</h2><ul><li><strong>写直达</strong>：CPU每次访问修改数据时，无论数据在不在缓存中，都将修改后的数据同步到内存中，缓存数据与内存数据保持<strong>强一致性</strong>，这种做法影响写操作的性能。</li><li><strong>写回</strong>：数据在被写入到 CPU 缓存时不会立即同步到内存，而是暂时保存在缓存中。只有在缓存行被替换出缓存（缓存算法对其进行淘汰）时，才会将该缓存行的数据写回到内存中。</li></ul><h2 id="多核场景-cache-一致性"><a href="#多核场景-cache-一致性" class="headerlink" title="多核场景 cache 一致性"></a>多核场景 cache 一致性</h2><h3 id="多核-cache-一致性保证条件"><a href="#多核-cache-一致性保证条件" class="headerlink" title="多核 cache 一致性保证条件"></a>多核 cache 一致性保证条件</h3><ul><li><strong>写传播</strong> —— 某个core 修改某个变量后，其他 core 需要及时感知</li><li>**串行化 ** —— 某个 core 的连续操作，对其他 core 而言，观察到的顺序一致</li></ul><h3 id="cache-一致性协议基石"><a href="#cache-一致性协议基石" class="headerlink" title="cache 一致性协议基石"></a>cache 一致性协议基石</h3><ul><li><strong>写传播 - 总线嗅探：</strong> 总线除了能在一个主模块和一个从模块之间传输数据，还支持一个主模块对多个从模块写入数据，这种操作就是广播。要实现写传播，其实就是将所有的读写操作广播到所有 CPU 核心，而其它 CPU 核心时刻监听总线上的广播，再修改本地的数据；</li><li><strong>事务串行化 - 总线仲裁：</strong> 总线的独占性要求同一时刻最多只有一个主模块占用总线，天然地会将所有核心对内存的读写操作串行化。如果多个核心同时发起总线事务，此时总线仲裁单元会对竞争做出仲裁，未获胜的事务只能等待获胜的事务处理完成后才能执行。</li></ul><h2 id="MESI-协议-（默认生效）"><a href="#MESI-协议-（默认生效）" class="headerlink" title="MESI 协议 （默认生效）"></a><strong>MESI 协议</strong> （默认生效）</h2><p>MESI 对应 CPU Cache 中的四种状态</p><ul><li><strong>M</strong>: modified</li><li><strong>E</strong>: Exclusive</li><li><strong>S</strong>: Share</li><li><strong>I</strong>: invalid</li></ul><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015059650.png" alt="image-20240511015059650" style="zoom:60%;" /><p>由于 修改等操作 需其他 CPU 进行ACK ，影响速率，因此引入 Store Buffer 和 Invalid Queue</p><p>CPU A 修改某个值时，直接将值写入 Store Buffer，并向其他 CPU 失效队列投递 invalid 通知，Invalid 通知成功（兑入对应invalid queue） 再将 store buffer 值 写入 cache</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240511015623898.png" alt="image-20240511015623898" style="zoom:50%;" /><p>store buffer 和 invalid queue 加快了程序运行速度，但 也带来了问题 —— CPU 间 数据强一致性为了最终一致 &#x2F; 弱一致</p><h2 id="内存屏障解决-有序性问题"><a href="#内存屏障解决-有序性问题" class="headerlink" title="内存屏障解决 有序性问题"></a>内存屏障解决 有序性问题</h2><h3 id="编译器内存屏障"><a href="#编译器内存屏障" class="headerlink" title="编译器内存屏障"></a>编译器内存屏障</h3><p>Linux 内核提供函数 <code>barrier()</code> 用于让编译器保证其之前的内存访问先于其之后的完成——内存屏障调用前后指令不乱序执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> barrier() __asm__ __volatile__(<span class="string">&quot;&quot;</span> ::: <span class="string">&quot;memory&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="CPU-内存屏障"><a href="#CPU-内存屏障" class="headerlink" title="CPU 内存屏障"></a>CPU 内存屏障</h3><h4 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h4><p>先看例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;   </span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若某一时刻， CPU0 cache 占有 变量 b&#x3D;0，准备执行 func0()， CPU1 cache 占有变量 a&#x3D;0， 准备执行 func1()； 且后续执行流程如下：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>CPU 0 继续执行赋值语句 b&#x3D;1，由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line。</li><li>CPU 1执行 while (b &#x3D;&#x3D; 0) 循环，由于 b 不在CPU 1 的 cache 中，因此，CPU发送一个 read message 到总线上，尝试从其他 cpu 的 localcache 或者 memory 中读取数据。</li><li>CPU 0 收到 read message，将最新的 b 值 1 回送给 CPU1，同时将 b cacheline的状态设定为 S。</li><li>CPU 1 收到了来自 CPU 0 的 read response，将 b 变量最新值 1 值写入自己的 cacheline，状态修改为shared。</li><li>由于 b 值等于 1 ，CPU 1跳出while (b &#x3D;&#x3D; 0)的循环，继续执行。</li><li>CPU 1 执行 assert(a &#x3D;&#x3D; 1)，这时候 CPU1 中的local cache中还是旧的a值，因此assert(a &#x3D;&#x3D; 1)失败。<strong>程序异常</strong></li></ol><p>为避免缓存不一致问题引起的 异常结果， 可在 a&#x3D;1 的赋值操作之后加上写内存屏障，此时 ：</p><ol><li>CPU 0 执行赋值语句 a&#x3D;1，由于 a 不在 local cache 中，CPU 0 将 a 值放到 store buffer 中之后，并向总线发送 read invalidate 命令</li><li>cpu0 完成 a&#x3D;1 复制操作之后，遇到写内存屏障，执行 flush store buffer</li><li>cpu0 阻塞等待 store buffer 中所有记录 得到 ACK</li><li>cpu1 cache line 收到 a 变量 invalid 消息，并自动 ACK</li><li><strong>cpu1 完成 invalid  queue 处理，修改 local cache 中 cacheline a&#x3D;1 状态为 I</strong></li><li>cpu0 阻塞结束，继续执行 b&#x3D;1 赋值， 由于 b 就在自身 local cache （cacheline 处于 M 状态或者 E 状态），CPU0 直接操作将新的值 1 写入cache line</li><li>若不考虑 cpu1 的 invalid queue 主动 ack，则cpu1 判断 a&#x3D;&#x3D;1 时，将发现cache line 中的 缓存已失效，需重新从总线获取，此时 assert t通过</li></ol><h4 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h4><p>仍以上例说明，由于 cpu1 存在 invalid queue ，会自动回复 ACK，所以：</p><ul><li>若 cpu1 未及时完成 invalid queue 处理， 则 CPU1 后续执行 a&#x3D;&#x3D;1 判断时，会判断 cache 中 有cacheline 命中，因此仍有可能失败</li></ul><p>因此，为确保 invalid queue 数据及时处理</p><ul><li>进一步在 assert(a&#x3D;&#x3D;1) 之前加上 读内存屏障</li></ul><p>读内存屏障作用为——cpu 下一次读取操作前，必须 flush invalid queue</p><p>因此，以上例子在无锁添加下，可通过以下改造确保程序运行正确</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span> , b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun0</span><span class="params">()</span> &#123;   </span><br><span class="line">  a = <span class="number">1</span>;</span><br><span class="line">  smp_mb();  <span class="comment">// 写内存屏障</span></span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun1</span><span class="params">()</span> &#123;   </span><br><span class="line">  <span class="keyword">while</span> (b == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  smp_rmb();<span class="comment">// 读内存屏障</span></span><br><span class="line">  assert(a == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并发安全性基础"><a href="#并发安全性基础" class="headerlink" title="并发安全性基础"></a>并发安全性基础</h1><ul><li><strong>原子性</strong> —— 一个线程的一组操作要么未执行，要么全部执行，即使中间因线程调度而中断，其总体执行结果与一次性执行完毕的结果无异，本质就是 多线程&#x2F;进程 对临界资源的互斥访问</li><li><strong>可见性</strong> —— 多个线程修改同一个共享变量时，一个线程修改后，其他线程能马上获得修改后的值</li><li><strong>有序性</strong> —— 即程序执行的顺序按照代码的先后顺序执行</li></ul><h1 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h1><h2 id="什么是指令重排"><a href="#什么是指令重排" class="headerlink" title="什么是指令重排"></a>什么是指令重排</h2><p>指令重排是计算机编译器或处理器为了提高性能而对指令执行顺序进行的一种优化手段。</p><p>在多核和多线程的计算机系统中，指令重排的目标是通过优化执行顺序来提高指令级别的并行度，充分发挥计算资源，加速程序的执行</p><h2 id="指令重排序分类"><a href="#指令重排序分类" class="headerlink" title="指令重排序分类"></a>指令重排序分类</h2><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><h3 id="编译器优化重排序"><a href="#编译器优化重排序" class="headerlink" title="编译器优化重排序"></a>编译器优化重排序</h3><p>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</p><h3 id="指令级并行的重排序"><a href="#指令级并行的重排序" class="headerlink" title="指令级并行的重排序"></a>指令级并行的重排序</h3><p>现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><h3 id="内存系统的重排"><a href="#内存系统的重排" class="headerlink" title="内存系统的重排"></a>内存系统的重排</h3><p>由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p>也即源代码从编译到最终运行之间可能涉及的重排序流程如下：</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240526135057956.png" alt="image-20240526135057956"></p><h2 id="指令重排的准则-（以-java-为例）"><a href="#指令重排的准则-（以-java-为例）" class="headerlink" title="指令重排的准则 （以 java 为例）"></a>指令重排的准则 （以 java 为例）</h2><h3 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h3><h4 id="语义"><a href="#语义" class="headerlink" title="语义:"></a><strong>语义:</strong></h4><p><strong>不管怎么重排序</strong> ，程序在单线程情况下的运行结果不能改变。</p><p>编译器、runtime和处理器都必须遵守as-if-serial语 义。</p><p>为了遵守 as-if-serial ，编译器和处理器不会对存在数据依赖关系的操作做重排序， 因为这种重排序会改变执行结果。</p><p>但是，如果操作之间不存在数据依赖关系，这些操作就可 能被编译器和处理器重排序。但这种重排序可能在多线程情况下引入问题</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><h4 id="程序顺序原则"><a href="#程序顺序原则" class="headerlink" title="程序顺序原则"></a>程序顺序原则</h4><p>　　即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。</p><h4 id="锁规则"><a href="#锁规则" class="headerlink" title="锁规则"></a>锁规则</h4><p>　　解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是 说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个 锁)。</p><h4 id="volatile规则"><a href="#volatile规则" class="headerlink" title="volatile规则"></a>volatile规则</h4><p>　　volatile变量的写，先发生于读，这保证了volatile变量的可见性，简 单的理解就是，volatile变量在每次被线程访问时，<strong>都强迫从主内存中读该变量的 值</strong>，而<strong>当该变量发生变化时，又会强迫将最新的值刷新到主内存</strong>，任何时刻，不同的 线程总是能够看到该变量的最新值。</p><h4 id="线程启动规则"><a href="#线程启动规则" class="headerlink" title="线程启动规则"></a>线程启动规则</h4><p>　　线程的start()方法先于它的每一个动作，即如果线程A在执行线程B 的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享 变量的修改对线程B可见</p><h4 id="传递性"><a href="#传递性" class="headerlink" title="传递性"></a>传递性</h4><p>　　A先于B ，B先于C 那么A必然先于C</p><h4 id="线程终止规则"><a href="#线程终止规则" class="headerlink" title="线程终止规则"></a>线程终止规则</h4><p>　　线程的所有操作先于线程的终结，Thread.join()方法的作用是等待 当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的 join方法成功返回后，线程B对共享变量的修改将对线程A可见。</p><h4 id="线程中断规则"><a href="#线程中断规则" class="headerlink" title="线程中断规则"></a>线程中断规则</h4><p>　　对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到 中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。</p><h4 id="对象终结规则"><a href="#对象终结规则" class="headerlink" title="对象终结规则"></a>对象终结规则</h4><p>　　对象的构造函数执行，结束先于finalize()方法 </p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h1><h2 id="线程创建方式"><a href="#线程创建方式" class="headerlink" title="线程创建方式"></a>线程创建方式</h2><ul><li>继承Thread 类</li><li>实现 Runable 接口</li><li>实现 callable 接口</li><li>使用线程池</li></ul><p>不过，这些方式其实并没有真正创建出线程。准确点来说，这些都属于是在 Java 代码中使用多线程的方法。</p><p>此外，严格来说，Java 其实只有一种方式可以创建线程，那就是通过<code>new Thread().start()</code>创建。不管是哪种方式，最终还是依赖于<code>new Thread().start()</code>。</p><h2 id="线程相关方法"><a href="#线程相关方法" class="headerlink" title="线程相关方法"></a>线程相关方法</h2><ul><li><p><strong>wait()</strong></p><ul><li>调用该方法的线程进入WAITING 状态，只有等待另外线程的通知或被中断才会返回，</li><li>会释放对象的锁</li></ul></li><li><p><strong>sleep()</strong></p><ul><li>sleep 导致当前线程休眠，sleep(long)会导致线程进入TIMED-WATING 状态</li><li>不会释放锁</li></ul></li><li><p><strong>yield()</strong></p><ul><li>yield 会使当前线程让出 CPU 执行时间片，与其他线程一起重新竞争CPU 时间片。</li><li>不释放锁</li></ul></li><li><p><strong>join()</strong></p><ul><li>中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位，这个线程本身并不会因此而改变状态(如阻塞，终止等)。</li></ul></li><li><p><strong>interrupt()</strong></p><ul><li>将一个阻塞状态线程的中断标志位置位，并使其中断&#x2F;抛出异常，抛出异常后 清楚中断标记位</li><li></li></ul></li></ul><h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1383841-20190624155001636-644135935.jpg" alt="img"></p><h2 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h2><p>Java线程可以具有不同的优先级，用于告诉操作系统在竞争CPU时间片时应该优先考虑哪个线程。线程的优先级范围从1到10，默认优先级是5。您可以使用setPriority()方法设置线程的优先级，范围从1（最低优先级）到10（最高优先级）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line">thread.setPriority(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="Java-线程池"><a href="#Java-线程池" class="headerlink" title="Java 线程池"></a>Java 线程池</h1><h2 id="线程池作用"><a href="#线程池作用" class="headerlink" title="线程池作用"></a>线程池作用</h2><p><strong>池化思想</strong>： 频繁创建销毁的东西，尽量设计成一个可以预分配、使用后归还、且可重复使用的模式，并交由一个管理器进行统一管理，以负责可复用对象的初始化、申请和归还处理；</p><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><p><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</p><p><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><h2 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h2><h3 id="使用-Executors-工具"><a href="#使用-Executors-工具" class="headerlink" title="使用 Executors 工具"></a>使用 Executors 工具</h3><p>Executors.newFixedThreadPool</p><p>Executors.newSingleThreadExecutor</p><p>Executors.newCachedThreadPool</p><p>Executors.newScheduledThreadPool</p><p>Executors.newSingleThreadScheduledExecutor</p><h3 id="手动创建线程池"><a href="#手动创建线程池" class="headerlink" title="手动创建线程池"></a>手动创建线程池</h3><h4 id="通用线程池-——-ThreadPoolExecutor"><a href="#通用线程池-——-ThreadPoolExecutor" class="headerlink" title="通用线程池 —— ThreadPoolExecutor"></a>通用线程池 —— ThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                              TimeUnit unit,</span></span><br><span class="line"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                              ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                              RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a><strong>参数列表</strong></h5><ul><li>corePoolSize: 核心线程数</li><li>maximumPoolSize： 最大线程数</li><li>keepAliveTime： 超出核心线程数的线程闲置后，最大存活时间</li><li>unit： 最大存活时间对应时间单位</li><li>workQueue： 任务队列</li><li>threadFactory： 线程工厂（可以配置线程命名、优先级等）</li><li>handler： 拒绝策略（可以集成 prometheus 实现埋点上报）<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240607015733333.png" alt="image-20240607015733333"><ul><li>AbortPolicy —— 不执行，并抛出异常</li><li>CallerRunPolicy —— 调用者执行</li><li>DiscardPolicy —— 不执行，也不抛出异常</li><li>DiscardOldestPolicy —— 不抛出异常，换掉最旧的任务</li></ul></li></ul><h4 id="延时任务线程池-——-ScheduledThreadPoolExecutor"><a href="#延时任务线程池-——-ScheduledThreadPoolExecutor" class="headerlink" title="延时任务线程池 —— ScheduledThreadPoolExecutor"></a>延时任务线程池 —— ScheduledThreadPoolExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                                   ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                                   RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS, <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>阻塞队列为无界队列</li></ul><h2 id="线程池参数设置"><a href="#线程池参数设置" class="headerlink" title="线程池参数设置"></a>线程池参数设置</h2><h3 id="核心线程数大小"><a href="#核心线程数大小" class="headerlink" title="核心线程数大小"></a>核心线程数大小</h3><ul><li>corePoolSize：<ul><li>CPU 密集型： CPU 核数 + 1</li><li>IO 密集型:  CPU 核数 * 2</li></ul></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li><p>无界队列</p><ul><li>LinkedBlockingQueue</li></ul></li><li><p>有界队列</p><ul><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，<code>Collection</code> 接口派生三个子接口 <code>List</code> <code>Set</code> <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240506003529811.png" alt="image-20240506003529811"></p><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>: 底层 Object 数组</li><li><code>Vector</code>: 底层 Object 数组</li><li><code>LinkedList</code>: 底层双向链表</li></ul></li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code> : 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆</li><li><code>DelayQueue</code>:&#96;PriorityQueue&#96;&#96;</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值<ul><li><code>HashMap</code>：数组 + 链表 + 红黑树</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-Array（数组）的区别"><a href="#ArrayList-和-Array（数组）的区别" class="headerlink" title="ArrayList 和 Array（数组）的区别"></a>ArrayList 和 Array（数组）的区别</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h2 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h2><h3 id="插入——add-："><a href="#插入——add-：" class="headerlink" title="插入——add()："></a>插入——add()：</h3><ul><li>头插：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾插：<ul><li>当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul></li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul><li><strong>头部删除</strong>：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li><strong>尾部删除</strong>：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li><strong>指定位置删除</strong>：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)</li></ul><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;</h2><p>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><p>ArrayList 的扩容是创建一个<strong>1.5 倍</strong>的新数组，然后把原数组的值拷贝过去。</p><h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>不推荐使用</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>写时复制技术，可以保障读写并发安全性</li></ul><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><ul><li>代理对象，额外创建mutex ，执行相关操作时，对mutex 加锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><h4 id="Queue-相关API"><a href="#Queue-相关API" class="headerlink" title="Queue 相关API"></a>Queue 相关API</h4><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><h4 id="Deque-相关API"><a href="#Deque-相关API" class="headerlink" title="Deque 相关API"></a>Deque 相关API</h4><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>此外，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-对比"><a href="#ArrayDeque-与-LinkedList-对比" class="headerlink" title="ArrayDeque 与 LinkedList 对比"></a>ArrayDeque 与 LinkedList 对比</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个<code>queue</code>的子接口。<code>BlockingQueue</code> 定义了阻塞式等待的插入和拿取操作（也可指定超时时间）</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制</li><li>读写&#x2F;生产消费 使用一把锁</li><li>提前分配内存，可能存在内存浪费，但是会快些</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>基于链表实现的阻塞队列</li><li>读写锁分离</li><li>无内存浪费，但是需要动态申请堆内存，会慢些</li></ul><h4 id="其他阻塞队列"><a href="#其他阻塞队列" class="headerlink" title="其他阻塞队列"></a>其他阻塞队列</h4><ul><li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p></li><li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p></li><li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的hash表，已不建议使用</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ul><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="&#x3D;&#x3D;HashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>&#x3D;&#x3D;<strong>数组 + 链表 + 红黑树</strong>&#x3D;&#x3D; （1.8 以后）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509021422847.png" alt="image-20240509021422847"></p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>默认长度： 16</li><li>最大长度： 2^30</li><li>负载因子： 0.75</li><li>链表树化阈值： 8</li><li>红黑树退化阈值： 6</li><li>链表树化时数组长度阈值： 64</li><li>node 数组扩容倍数： 2</li></ul><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509022413104.png" alt="image-20240509022413104"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><h4 id="常用的hash冲突解决办法"><a href="#常用的hash冲突解决办法" class="headerlink" title="常用的hash冲突解决办法"></a>常用的hash冲突解决办法</h4><ul><li>再哈希，直至找到空槽</li><li>开放地址法，寻找下一个空槽<ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数</li></ul></li><li>拉链法——也即JDK 1.8 HashMap 所采用方法</li></ul></li><li><h4 id="为什么-node-数组长度要是-2的幂次方"><a href="#为什么-node-数组长度要是-2的幂次方" class="headerlink" title="为什么 node 数组长度要是 2的幂次方"></a>为什么 node 数组长度要是 2的幂次方</h4><ul><li><strong>两点原因： 插入时定下标快，扩容时重新确定下标块</strong><ul><li>hash 过多，内存放不下，进而</li><li>一般通过 hash（或再映射）对数组长区域确定下标</li><li>而用 2的整数次幂为长度，余运算可以转为位运算，计算更快</li><li>此外，初始数组在没有把握的情况下，不宜设得过大，因此存在数组的后续扩容操作</li><li>以2的整数次幂为长度，且以 2 做扩容倍数时，可以方便的确定原数组链表内所有节点在扩容后的位置</li></ul></li></ul></li><li><h4 id="为什么选-0-75-为扩容因子"><a href="#为什么选-0-75-为扩容因子" class="headerlink" title="为什么选 0.75 为扩容因子"></a>为什么选 0.75 为扩容因子</h4></li><li><p>由加载因子的定义，其取值范围是 (0, 1]。</p></li><li><p>还有一个因素是为了提升扩容效率。因为<code>HashMap</code>的容量（<code>size</code>属性，构造函数中的<code>initialCapacity</code>变量）有一个要求：它一定是 2 的幂 （4,8,16，……）。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。</p></li><li><p>经验</p><ul><li>如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。</li><li>如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。</li></ul></li><li><h4 id="死循环问题"><a href="#死循环问题" class="headerlink" title="死循环问题"></a>死循环问题</h4><ul><li>1.8 之后改为尾插法不存在此问题， 1.7 及之前，头插法可能导致此问题</li></ul></li><li><h4 id="Hash-扰动"><a href="#Hash-扰动" class="headerlink" title="Hash 扰动"></a>Hash 扰动</h4><ul><li><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>一般数组长度可能不会太长，扰动后可使高16位也能参与下标计算，可在一定程度上缓解 hash 碰撞，使 key 分布更均衡</li><li>同时位运算消耗较低</li></ul></li><li><h4 id="为什么采用-红黑树-而不是-AVL-树"><a href="#为什么采用-红黑树-而不是-AVL-树" class="headerlink" title="为什么采用 红黑树 而不是 AVL 树"></a>为什么采用 红黑树 而不是 AVL 树</h4><ul><li><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p></li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>JDK1.7 的 采用 <strong>分段的数组+链表</strong> 实现， 每一个分段类似于一个子 Map ，一般也称 segment</li><li>JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，</li></ul><h3 id="实现线程安全的方式"><a href="#实现线程安全的方式" class="headerlink" title="&#x3D;&#x3D;实现线程安全的方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>实现线程安全的方式</strong>&#x3D;&#x3D;</h3><ul><li>JDK1.7 时，针对 segment 加锁</li><li>JDK 1.8 时数据结构跟 <code>HashMap</code> 1.8 的结构一样。并采用 <code>Node + CAS + synchronized</code> 来保证并发安全，同时降低了锁粒度，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</li><li>并发度层面 JDK 1.7 时最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap-中-key-和-value-不能为-null"><a href="#ConcurrentHashMap-中-key-和-value-不能为-null" class="headerlink" title="ConcurrentHashMap 中 key 和 value 不能为 null"></a>ConcurrentHashMap 中 key 和 value 不能为 null</h3><p><strong>原因</strong>： 主要是为了避免二义性。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-语言特点"><a href="#1-Java-语言特点" class="headerlink" title="1.    Java 语言特点"></a>1.    Java 语言特点</h2><ul><li><strong>面向对象</strong></li><li><strong>平台无关</strong></li><li><strong>支持多线程</strong><br>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li><li><strong>编译与解释并存</strong></li></ul><h2 id="2-JDK、JRE、JVM-关系"><a href="#2-JDK、JRE、JVM-关系" class="headerlink" title="2.    JDK、JRE、JVM 关系"></a>2.    JDK、JRE、JVM 关系</h2><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。</p><p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p><p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><h2 id="3-什么是字节码"><a href="#3-什么是字节码" class="headerlink" title="3.    什么是字节码"></a>3.    什么是字节码</h2><p>字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p>Java 跨平台特性其实就是为不同平台提供不同的 JVM，JVM 基于平台特性调整字节码解释实现，从而使得字节码在不同平台均可运行</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505211415926.png" alt="image-20240505211415926" style="zoom:67%;" /><h2 id="4-什么是面向对象"><a href="#4-什么是面向对象" class="headerlink" title="4.    什么是面向对象"></a>4.    什么是面向对象</h2><p><strong>面向对象是一种 相对面向过程 而言的编程范式</strong></p><p><strong>面向过程</strong>程序设计是具体化的，流程化的；面向过程的代码设计通过着手于事物的实现流程，根据已有条件如何一步一步生成结果。</p><p>因此，基于面向过程思路所涉及的代码通常不便于扩展和代码复用，此外，面向过程的思路在处理复杂问题时，编程难度将显著增加。</p><p>而<strong>面向对象</strong>程序设计是模型化的，把对象作为基本单位，将问题抽象建模为一系列对象之间的交互，使得程序易于理解、维护。具有相同行为和属性的对象泛化为类的实例。此外，面向对象具有三大特性——封装、继承与多态</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1    封装"></a>4.1    封装</h4><p><strong>概念</strong>：将一些属性和相关方法封装在一个对象中，对外隐藏内部实现细节。内部具体实现，外界不需要关心，而只需要根据”内部提供的接口“去使用就可以。</p><p><strong>好处</strong>：</p><ul><li><p>使用起来更加方便</p></li><li><p>保证数据的安全，针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改）</p></li><li><p>利于代码维护：如果后期功能实现逻辑需要调整，则保持接口名不变，修改实现代码即可，外界不需要做任何代码修改。</p></li></ul><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2    继承"></a>4.2    继承</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。</p><p>可提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p><h4 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3    多态"></a>4.3    多态</h4><p>同一个方法，在不同的对象上有不同的表现形式</p><p><strong>多态的要点：</strong></p><ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol><h2 id="5-访问权限"><a href="#5-访问权限" class="headerlink" title="5.    访问权限"></a>5.    访问权限</h2><ul><li><strong><code>default</code></strong> （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong><code>private</code></strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong><code>public</code></strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong><code>protected</code></strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="6-final-关键字"><a href="#6-final-关键字" class="headerlink" title="6.    final 关键字"></a>6.    final 关键字</h2><ul><li>当 <code>final</code> 修饰一个类时，表明这个类不能被继承。比如，<code>String</code> 类、<code>Integer</code> 类和其他包装类都是用 <code>final</code> 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（<code>@Override</code>）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 <code>final</code> 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。<ul><li>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；</li><li>如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。</li></ul></li></ul><h2 id="7-引用数据类型-、基本数据类型-与-包装类"><a href="#7-引用数据类型-、基本数据类型-与-包装类" class="headerlink" title="7.    引用数据类型 、基本数据类型 与 包装类"></a>7.    引用数据类型 、基本数据类型 与 包装类</h2><h4 id="7-1-引用数据类型"><a href="#7-1-引用数据类型" class="headerlink" title="7.1    引用数据类型"></a>7.1    引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="7-2-基本数据类型"><a href="#7-2-基本数据类型" class="headerlink" title="7.2    基本数据类型"></a>7.2    基本数据类型</h4><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1 比特</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h4 id="7-3-包装类"><a href="#7-3-包装类" class="headerlink" title="7.3    包装类"></a>7.3    包装类</h4><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，而几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h5 id="7-3-1-包装类常量池-缓存"><a href="#7-3-1-包装类常量池-缓存" class="headerlink" title="7.3.1    包装类常量池(缓存)"></a>7.3.1    包装类常量池(缓存)</h5><p>byte、int、long 类型 均缓存有 -128~127 的值在常量池中</p><p>char 缓存所有char</p><h2 id="8-Java-拷贝机制"><a href="#8-Java-拷贝机制" class="headerlink" title="8.    Java 拷贝机制"></a>8.    Java 拷贝机制</h2><ul><li><strong>浅拷贝</strong>：值类型拷贝，引用类型指向同一对象</li><li><strong>深拷贝</strong>：值类型拷贝，引用类型则拷贝了一个新对象，且引用类型内部按此规则递归</li></ul><h4 id="8-1-cloneable-接口与-clone"><a href="#8-1-cloneable-接口与-clone" class="headerlink" title="8.1    cloneable 接口与 clone()"></a>8.1    cloneable 接口与 clone()</h4><p><code>clone()</code> 默认浅拷贝， 且相应对象若未实现 <code>cloneable</code> 接口，会抛出异常</p><h4 id="8-2-如何实现-深拷贝"><a href="#8-2-如何实现-深拷贝" class="headerlink" title="8.2    如何实现 深拷贝"></a>8.2    如何实现 深拷贝</h4><ul><li>自定义拷贝构造函数（递归）</li><li>递归实现 <code>cloneable</code> 接口并重写 <code>clone()</code> 方法</li><li>序列化</li></ul><h2 id="9-String-相关"><a href="#9-String-相关" class="headerlink" title="9.    String 相关"></a>9.    String 相关</h2><h4 id="9-1-String、StringBuffer、StringBuilder"><a href="#9-1-String、StringBuffer、StringBuilder" class="headerlink" title="9.1    String、StringBuffer、StringBuilder"></a>9.1    String、StringBuffer、StringBuilder</h4><p><code>String</code> 是不可变的（自然线程安全）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，且 <code>StringBuffer</code> 对字符串的操作方法都添加了同步锁，因此性能安全，但同时影响了性能</p><h4 id="9-2-String-为什么不可变"><a href="#9-2-String-为什么不可变" class="headerlink" title="9.2    String 为什么不可变"></a>9.2    String 为什么不可变</h4><ul><li>String 类中 核心数组 被final修饰，此外，String 类中未提供修改 数组内元素的方法</li><li>String 类自身也是 final 的，可以避免子类提供数组修改方法</li></ul><h4 id="9-3-String-为什么要设计成不可变的"><a href="#9-3-String-为什么要设计成不可变的" class="headerlink" title="9.3    String 为什么要设计成不可变的"></a>9.3    String 为什么要设计成不可变的</h4><ul><li><strong>安全</strong> —— String 类型经常用来做参数，比如 url、pwd 之类的</li><li><strong>允许缓存 HashCode</strong> —— Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存</li><li><strong>字符串常量池需要</strong></li></ul><h2 id="10-Object"><a href="#10-Object" class="headerlink" title="10.    Object"></a>10.    Object</h2><h4 id="10-1-常用方法"><a href="#10-1-常用方法" class="headerlink" title="10.1    常用方法"></a>10.1    常用方法</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505224438372.png" alt="image-20240505224438372"></p><h4 id="10-2-和-equals"><a href="#10-2-和-equals" class="headerlink" title="10.2    &#x3D;&#x3D; 和 equals"></a>10.2    &#x3D;&#x3D; 和 equals</h4><ul><li>&#x3D;&#x3D; 判断值类型是否相等，引用类型是否指向同一对象</li><li><code>equals</code> 默认情况下与 &#x3D;&#x3D; 等价，重写后可能不等价</li></ul><h4 id="10-3-为什么重写-equals-时必须重写-hashCode-方法"><a href="#10-3-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="10.3    为什么重写 equals() 时必须重写 hashCode() 方法"></a>10.3    为什么重写 equals() 时必须重写 hashCode() 方法</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>导致 HashMap 可能存入两个逻辑相等的对象</p><h2 id="11-序列化、反序列化"><a href="#11-序列化、反序列化" class="headerlink" title="11.    序列化、反序列化"></a>11.    序列化、反序列化</h2><h4 id="11-1-什么是序列化、反序列化"><a href="#11-1-什么是序列化、反序列化" class="headerlink" title="11.1    什么是序列化、反序列化"></a>11.1    什么是序列化、反序列化</h4><ul><li>序列化：把 Java 对象转换为字节序列的过程</li><li>反序列：把字节序列恢复为 Java 对象的过程</li></ul><h4 id="11-2-注意点"><a href="#11-2-注意点" class="headerlink" title="11.2    注意点"></a>11.2    注意点</h4><ul><li>static 静态变量和 transient 修饰的字段是不会被序列化的</li><li>serialVersionUID问题</li><li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li><li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li></ul><h4 id="11-3-不推荐使用-JDK-自带的序列化"><a href="#11-3-不推荐使用-JDK-自带的序列化" class="headerlink" title="11.3    不推荐使用 JDK 自带的序列化"></a>11.3    不推荐使用 JDK 自带的序列化</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.    异常"></a>12.    异常</h2><h4 id="12-1-异常层级"><a href="#12-1-异常层级" class="headerlink" title="12.1    异常层级"></a>12.1    异常层级</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505230455539.png" alt="image-20240505230455539"></p><ul><li>**<code>Throwable</code>**：是 java 中所有异常和错误的超类,其两个子类为 <strong><code>Error</code></strong>(错误) 和 <strong><code>Exception</code></strong>(异常)<ul><li><strong>Error</strong>： 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</li><li>**<code>Exception</code>**： 是程序本身可以捕获并且可以处理的异常。其中可分为运行时异常（RuntimeException）和非运行时异常，也叫做受检异常<ul><li>**运行时异常(不受检异常)**： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li><li>**非运行时异常(受检异常)**： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</li></ul></li></ul></li></ul><h4 id="12-1-try-with-finally"><a href="#12-1-try-with-finally" class="headerlink" title="12.1    try - with - finally"></a>12.1    try - with - finally</h4><ul><li><p>无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p></li><li><p>不要在 finally 语句块中使用 return， 因为当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略</p></li><li><p>finally 语句在 线程被杀死、JVM 关闭等情况时也不一定会执行</p></li><li><p>对必须关闭的资源，推荐使用 <code>try with resources</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注解"><a href="#13-注解" class="headerlink" title="13.    注解"></a>13.    注解</h2><h4 id="13-1-注解作用"><a href="#13-1-注解作用" class="headerlink" title="13.1    注解作用"></a>13.1    注解作用</h4><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，并可添加根据注解内容而执行的特定逻辑。</p><h4 id="13-2-注解类型"><a href="#13-2-注解类型" class="headerlink" title="13.2    注解类型"></a>13.2    注解类型</h4><ul><li><p>元注解</p><ul><li>@Retention</li><li>@Documented</li><li>@Target</li><li>@Inherited</li><li>@Repeatable</li></ul></li><li><p>内置普通注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SupressWarnings</li><li>@SafeVarargs</li></ul></li><li><p>自定义注解</p></li></ul><h4 id="13-3-其他"><a href="#13-3-其他" class="headerlink" title="13.3    其他"></a>13.3    其他</h4><ul><li>注解也是一个类，可以添加属性，并设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Coder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GRQ&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">language</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">company</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;China_Company&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型设计模式</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><p>创建型设计模式的主要关注点是“怎么创建对象”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建有相关的工厂来完成。就像我们去商城购买商品时，不需要知道商品是怎么深处出来的一样，因为它们由专业的厂商生产。</p><p>创建型模式分为以下几种：</p><ul><li>简单工厂模式：</li><li>单例（Singleton）模式：某个类只能生成一个实例，该实例提供一个全局访问店供外部获取该对象，其扩展时有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类型的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，有子类决定生产什么产品。</li><li>抽象工厂（Abstract Factory）模式：提供一个创建产品族的接口，其每个子类可以生产一些列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建从复杂对象。</li></ul><p>以上 5 种创建型模式，处理工厂方法模式属于（类）创建型模式，其他的全部属于（对象）创建模式。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例（Singleton）模式的定义：指一个类只有一个实例，其该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示的内容不一致等错误。</p><p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>1）单例类只有一个对象；</p><p>2）该单例对象必须由单例类自行创建；</p><p>3）单例类对外提供一个访问该单例的全局访问店。</p><h3 id="结构与实现"><a href="#结构与实现" class="headerlink" title="结构与实现"></a>结构与实现</h3><p>单例模式是设计模式中最简单的模式之一。通常，普通类的 结构函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。但是，如果将类的构造函数设为私有的，外部类就无法通过调用该类的构造函数，也就无法生成多个实例。这是该类自身必须定义一个静态私有实例，并向外提供一个讲台的公有函数用于创建或获取静态私有实例。</p><p>下面分析单例模式的实现。</p><p>单例模式有懒汉式和饿汉式两种实现形式。</p><h4 id="第一种：懒汉式"><a href="#第一种：懒汉式" class="headerlink" title="第一种：懒汉式"></a>第一种：懒汉式</h4><p>该模式的特点是类加载时没有生成单例，只有当第一次调用 getInstance 方法才去创建单例。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">LazySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">//保证 instance 在所有线程中同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;    <span class="comment">//private 避免类在外部被实例化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// getInstance 方法前加同步</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第二种：饿汉式单例"><a href="#第二种：饿汉式单例" class="headerlink" title="第二种：饿汉式单例"></a>第二种：饿汉式单例</h4><p>该模式的特点是类一旦加载就创建一个单例，保证在调用 getInstance 方法之前单例已经存在了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例在类 创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，以后线程安全的，可以直接用于多线程而不会出现问题。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在应用场景中，某类只要求生成一个对象的时候，如一个班中的板子、每个人的身份证号等。</li><li>当对象需要被共享的场合。由于单例模式志云与创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li><li>当某类需要频繁实例化，而创建的对象有频繁被销毁的时候，如多线程的线程池、网络连接池等。</li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><h3 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h3><p>原型模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。这种方式创建对象非常高效，根本无需指定对象创建的细节。例如，Windows 操作系统的安装通常比较耗时，如果复制就快了很多。</p><h3 id="结构和实现"><a href="#结构和实现" class="headerlink" title="结构和实现"></a>结构和实现</h3><p>由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>原型模式包含以下主要角色：</p><p>① 抽象原型类：规定了具体原型对象必须实现的接口。</p><p>② 具体实现类：实现抽象原型类的 clone() 方法，它使可被复制的对象。</p><p>③ 访问类：使用具体原型类中的 clone() 方法来复制新对象。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>原型模式的克隆分为浅克隆和深克隆，Java 中的 Object 类提供了浅克隆的 clone() 方法，具体原型类只要实现 Cloneable 接口就可实现对象的浅克隆，这里的 Cloneable 接口就是抽象原型类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    Realizetype() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候，</li><li><strong>对象的创建过程比较麻烦</strong>，但复制比较简单的时候。</li></ul><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="定义与特点-1"><a href="#定义与特点-1" class="headerlink" title="定义与特点"></a>定义与特点</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者。它使将一个复杂的对象分解为多个简单的对象，然后一步步构建而成。它将变与不变相分离，即产品的组成部分是不变得，但每一部分是可以灵活选择的。</p><h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><ol><li>各个具体建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于口直细节风险。</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>产品的组成部分必须相同，这限制了其使用的范围。</li><li>如果产品的内部变化负责，该模式会增加很多的建造者类。</li></ol><p>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零 部件的创建过程，但两者可以结合使用。</p><h3 id="结构与实现-1"><a href="#结构与实现-1" class="headerlink" title="结构与实现"></a>结构与实现</h3><p>建造者模式由产品、抽象建造者、具体建造者、指挥者等4个要素构成，现在我们来分析其基本结构和实现方法。</p><h4 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h4><p>建造者模式的主要角色如下。</p><ol><li>产品角色：它是包含多个组成部件的复杂对象，有具体建造者来创建其各个部件。</li><li>抽象建造者：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六大设计原则</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>单一职责原则是面向对象设计中的一项基本准则，它有助于构建出更加健壮、可维护和可扩展的软件系统</p><p>单一职责原则强调的是软件实体（如类、模块、函数等）应当具有单一的职责，即一个类应该只负责一个功能领域中的相应职责。</p><h3 id="单一职责原则的定义"><a href="#单一职责原则的定义" class="headerlink" title="单一职责原则的定义"></a>单一职责原则的定义</h3><p>单一职责原则可以表述为：“一个类应该只有一个引起它变化的原因。”换句话说，如果一个类承担了多个职责，那么当其中一个职责发生变化时，可能会影响到其他职责的实现，从而导致类的修改变得复杂和频繁。</p><h3 id="单一职责原则的意义"><a href="#单一职责原则的意义" class="headerlink" title="单一职责原则的意义"></a>单一职责原则的意义</h3><ul><li><strong>提高可维护性</strong>：当一个类只负责单一的职责时，它的功能更明确，也更容易理解和维护。如果需要修改某一部分功能，可以定位到具体的类，而不会影响到其他无关的职责。</li><li><strong>降低耦合度</strong>：单一职责原则有助于降低类之间的耦合度，因为每个类只关注于自己的职责，减少了对其他类的依赖。</li><li><strong>提高可复用性</strong>：职责单一的类更容易被复用，因为它们的功能更纯粹，更不容易受到其他功能变化的影响。</li><li><strong>促进模块化设计</strong>：遵循单一职责原则可以促使开发者将系统划分为更小、更独立的模块，每个模块负责一个特定的职责，这有利于系统的扩展和重构。</li></ul><h3 id="如何判断职责是否单一"><a href="#如何判断职责是否单一" class="headerlink" title="如何判断职责是否单一"></a>如何判断职责是否单一</h3><p>判断一个类的职责是否单一，可以从以下几个角度考虑：</p><ul><li>变化的独立性：如果一个类的多个功能会因为不同的原因而变化，那么这些功能可能就不应该放在同一个类中。</li><li>功能的独立性：如果一个类的多个功能可以独立地被测试和复用，那么它们可能更适合被分离到不同的类中。</li><li>代码的可读性和可理解性：如果一个类的代码量过大，或者代码的逻辑复杂，以至于难以理解和维护，那么可能表明类的职责不够单一。</li></ul><h3 id="实践单一职责原则"><a href="#实践单一职责原则" class="headerlink" title="实践单一职责原则"></a>实践单一职责原则</h3><p>在实践中，遵循单一职责原则可能需要对现有的类进行重构，将职责分解到多个类中。例如，一个原本负责数据处理和界面显示的类，可以被拆分为一个专门的数据处理器类和一个专门的视图控制器类。这样，每个类只负责自己的核心职责，提高了整体系统的质量和可维护性。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>开闭原则主张软件实体（如类、模块、函数等）应该对扩展开放（Open for extension），对修改关闭（Closed for modification）。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>开闭原则可以这样表述：“软件实体应当在不修改的情况下就可以被扩展。”这意味着，当系统需要增加新的功能时，应该通过添加新的代码来实现，而不是修改已有的代码。这样做的目的是为了保持现有代码的稳定性和可维护性。</p><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>可维护性</strong>：遵循开闭原则的系统更容易维护，因为新的需求可以通过扩展现有功能来实现，而不需要修改原有代码，减少了引入新bug的风险。</li><li><strong>可扩展性</strong>：系统设计遵循开闭原则，意味着可以通过添加新的类或组件来轻松地扩展功能，而无需触及原有的代码。</li><li><strong>稳定性</strong>：开闭原则有助于保持系统的稳定性，因为已验证的代码不会因为新的需求而被修改，降低了系统崩溃的风险。</li><li><strong>灵活性</strong>：开闭原则鼓励使用抽象和多态，这使得系统设计更加灵活，能够更好地应对未来的变化。</li></ul><h3 id="实现开闭原则的方法"><a href="#实现开闭原则的方法" class="headerlink" title="实现开闭原则的方法"></a>实现开闭原则的方法</h3><p>要实现开闭原则，通常采用以下几种方法：</p><ul><li>使用抽象：通过定义抽象类或接口，为系统提供一个稳定的接口，具体的实现可以通过继承或实现接口的类来提供。</li><li>依赖注入：通过依赖注入，系统可以在运行时动态地提供具体实现，而无需修改代码。</li><li>策略模式：策略模式允许算法在运行时被替换，这样可以根据不同的情况使用不同的算法实现，而无需修改调用算法的代码。</li><li>工厂模式：工厂模式可以创建对象而不需要指定具体的类，这使得系统可以在不修改现有代码的情况下添加新的对象类型。</li></ul><h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>尽管开闭原则提供了诸多优点，但在实际应用中也会遇到一些挑战。例如，过度抽象可能导致设计过于复杂，增加了理解和维护的成本。此外，设计时需要充分预见未来可能的变化，否则可能需要重新设计系统结构才能适应新的需求。<br>开闭原则是面向对象设计的重要基石，它鼓励设计者从一开始就考虑系统的可扩展性和可维护性，通过合理的设计来减少未来的修改成本，从而构建出更加健壮和灵活的软件系统。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>里氏替换原则是关于继承和多态的正确使用，确保在使用继承时，子类可以替换其父类，并且程序的行为不会因此而改变。</p><p>里氏替换原则是面向对象设计中确保继承和多态正确使用的基石，它有助于构建出更加健壮、可复用和可扩展的软件系统。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>里氏替换原则可以这样表述：“如果S是T的子类型，则可以将对象s的任何地方替换成T类型的对象t，而程序的行为不会受到影响。”换句话说，任何期望接收T类型的地方，都能接受S类型的对象，而不会破坏程序的正确性。</p><h3 id="意义-1"><a href="#意义-1" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>保证继承的正确性</strong>：LSP确保了继承关系的正确使用，避免了因不当的继承而导致的程序行为改变。</li><li><strong>增强代码的可复用性</strong>：遵循LSP的子类可以安全地替换基类，从而提高了代码的可复用性。</li><li><strong>提高代码的健壮性</strong>：LSP有助于构建更加健壮的系统，因为子类不会破坏基类的契约，减少了错误的发生。</li><li><strong>促进多态的正确使用</strong>：LSP鼓励使用多态来实现代码的灵活性，而不是滥用继承来达到代码复用的目的。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>要遵循LSP，需要在设计和实现继承关系时注意以下几点：</p><ul><li>避免改变基类的预设行为：子类应该保留基类的公共接口行为，除非有明确的理由并且在文档中明确指出。</li><li>避免过度覆盖或重写：子类重写基类的方法时，应确保不会改变或破坏基类方法的语义。</li><li>设计良好的接口：基类或接口应该设计得足够通用，以适应多种可能的实现，同时避免过于宽泛导致的约束不足。</li><li>使用接口隔离原则（ISP）：确保子类不需要依赖于基类中不会使用的接口部分，这有助于更好地满足LSP。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一个基类Shape，它有一个area()方法计算形状的面积。根据LSP，任何使用Shape的地方，应该能够接受任何Shape的子类，如Circle或Rectangle，而不会改变程序的行为。</p><h3 id="挑战-1"><a href="#挑战-1" class="headerlink" title="挑战"></a>挑战</h3><p>在实际应用中，LSP有时会与代码的灵活性和复用性产生冲突。例如，严格遵循LSP可能限制了子类的自由度，使得某些特定的优化或定制变得困难。因此，在设计时需要权衡LSP与实际需求之间的关系，找到合适的平衡点。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则（Law of Demeter，简称LoD），也称为最少知识原则（Least Knowledge Principle，简称LKP）。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p><strong>一个对象应当对其他对象有尽可能少的了解。</strong></p><p>具体而言，一个对象应该只与它的直接朋友通信，这里的“朋友”指的是：</p><ul><li>该对象自身；</li><li>该对象的参数；</li><li>该对象的成员对象；</li><li>该对象创建的对象；</li></ul><h3 id="意义-2"><a href="#意义-2" class="headerlink" title="意义"></a>意义</h3><ul><li>降低耦合度：通过限制对象之间的交互，迪米特法则有助于降低对象之间的耦合度，使得一个对象的修改不会轻易影响到其他对象。</li><li>提高可维护性：较少的依赖关系意味着代码更容易理解和维护，因为每个对象的职责和行为更加明确。</li><li>提高可测试性：对象之间较少的交互使得单元测试变得更加简单，因为不需要模拟太多的外部依赖。</li><li>促进模块化设计：迪米特法则鼓励模块化设计，每个模块只关注其直接相关的部分，这有助于构建出更加灵活和可扩展的系统。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>要遵循迪米特法则，可以采取以下一些做法：</p><ul><li>减少对象间的直接通信：避免一个对象直接访问另一个对象的内部状态，而是通过调用方法来进行通信。</li><li>使用中介者模式：当多个对象之间存在复杂的交互时，可以引入一个中介者对象来协调这些对象之间的通信。</li><li>利用依赖注入：通过依赖注入框架，可以减少对象之间的直接依赖，使得对象之间的关系更加松散。</li><li>避免深度的对象图遍历：一个对象不应该访问另一个对象的属性，再通过这个属性访问第三个对象的属性，以此类推，形成深度的对象图遍历。</li></ul><h3 id="挑战-2"><a href="#挑战-2" class="headerlink" title="挑战"></a>挑战</h3><p>虽然迪米特法则有助于降低耦合度，但在实际应用中也可能带来一些挑战。例如，过度的解耦可能导致代码结构过于复杂，或者增加代码的间接性，这有时会降低代码的直观性和性能。因此，在应用迪米特法则时，也需要权衡其带来的好处与可能的负面影响。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则（Interface Segregation Principle，简称ISP），ISP 主张客户端不应该被强迫依赖于它不使用的方法，也就是说，不应该有“胖接口”（fat interfaces）的存在。</p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>使用多个专门的接口比使用单一的总接口要好。</p><p>也即意味着，一个类应该依赖于细粒度的接口，而不是依赖于一个包含了多个不相关功能的大接口。</p><h3 id="意义-3"><a href="#意义-3" class="headerlink" title="意义"></a>意义</h3><p>降低耦合度：ISP有助于降低类之间的耦合度，因为每个类只依赖于它真正需要的接口，而不是一个包含了多余方法的大接口。<br>提高灵活性：细粒度的接口使得系统更加灵活，因为可以更容易地添加、修改或删除接口而不影响到其他部分。<br>提高可维护性：当接口细化后，每个接口的职责更加明确，这有助于代码的可读性和可维护性。<br>避免强制依赖：ISP避免了类由于依赖于大接口而被迫实现它并不需要的所有方法，这减少了代码的冗余和复杂性。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>要遵循ISP，可以采取以下一些做法：<br>细化接口：将大型接口分解为多个小的、特定的接口，每个接口只包含一组相关的方法。<br>按需实现：类应该只实现它真正需要的接口，避免实现那些它永远不会使用的方法。<br>定制接口：为特定的类或子系统定制接口，这样可以确保接口中的方法都是必要的。<br>避免过度继承：在设计接口层次结构时，避免不必要的接口继承，因为这可能导致接口的膨胀。</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>假设有一个“动物”接口，它包含了“吃”、“走”、“飞”和“游泳”等方法。但是，并非所有动物都会飞或游泳。按照ISP，可以将这个大接口分解为多个小接口，比如“飞行动物”接口、“水生动物”接口等，这样，鸟类可以实现“飞行动物”接口，鱼类可以实现“水生动物”接口，而哺乳动物则可以实现“陆生动物”接口。</p><h3 id="挑战-3"><a href="#挑战-3" class="headerlink" title="挑战"></a>挑战</h3><p>虽然ISP有助于提高系统的灵活性和可维护性，但过度的接口细分也可能导致接口数量的激增，从而增加系统的复杂性。因此，在应用ISP时，需要找到一个平衡点，既要避免“胖接口”，也要避免不必要的接口细分。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则（Dependency Inversion Principle，简称DIP）， DIP 强调了高层次模块与低层次模块之间的依赖关系，以及依赖于抽象而非具体实现的重要性。</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><h3 id="意义-4"><a href="#意义-4" class="headerlink" title="意义"></a>意义</h3><ul><li><strong>降低耦合度</strong>：通过依赖于抽象，模块之间的耦合度降低，因为模块不再直接依赖于其他模块的具体实现。</li><li><strong>提高可维护性</strong>：当依赖于抽象时，修改或替换具体实现变得更加容易，而不会影响到依赖于这些实现的高层模块。</li><li><strong>增强灵活性</strong>：依赖倒置原则使得系统更加灵活，因为可以通过更改配置或依赖注入等方式轻松地切换不同的实现。</li><li><strong>促进模块化设计</strong>：依赖于抽象促进了模块化设计，每个模块专注于实现特定的抽象，而不需要关心其他模块的实现细节。</li></ul><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>要遵循依赖倒置原则，可以采取以下一些做法：</p><ul><li><strong>使用抽象层</strong>：通过定义接口或抽象类作为高层模块与低层模块之间的桥梁，使得高层模块依赖于抽象，而低层模块提供具体的实现。</li><li><strong>依赖注入</strong>：通过构造函数、setter方法或静态工厂方法等方式，将具体实现传递给依赖于抽象的模块，而不是在模块内部创建这些实现。</li><li><strong>避免紧耦合</strong>：避免高层模块直接依赖于低层模块的具体实现，而是通过抽象接口或服务定位器等机制来获取所需的服务。</li><li>模块间通信：模块之间的通信应该通过抽象接口进行，而不是直接引用具体类，这样可以降低模块之间的耦合度。</li></ul><h3 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h3><p>假设有一个日志记录模块，它可以记录各种信息。按照依赖倒置原则，日志记录模块不应该直接依赖于文件系统、数据库或其他具体存储方式，而是应该依赖于一个抽象的日志存储接口。这样，无论是将日志信息写入文件、数据库还是发送到远程服务器，只需要提供符合日志存储接口的具体实现即可，而不需要修改日志记录模块的代码。</p><h3 id="挑战-4"><a href="#挑战-4" class="headerlink" title="挑战"></a>挑战</h3><p>虽然依赖倒置原则有助于提高系统的灵活性和可维护性，但过度的抽象和依赖注入也可能导致代码结构变得复杂，增加理解和维护的难度。因此，在应用依赖倒置原则时，需要找到一个平衡点，既不过度抽象，也不过分依赖于具体实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式概述</title>
      <link href="/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
      <url>/2024/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式概述-——-代码设计"><a href="#设计模式概述-——-代码设计" class="headerlink" title="设计模式概述 —— 代码设计"></a>设计模式概述 —— 代码设计</h1><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>上来就讲破大天，不如先明确<strong>代码设计的核心诉求</strong>：</p><ul><li>安全性</li><li>正确性</li><li>高效性</li><li>可维护</li><li>易拓展</li></ul><p>围绕以上目标，历代开发者总结出的历史经验：</p><ul><li>设计原则 —— 心法</li><li>设计模式 —— 剑谱</li></ul><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><h3 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h3><ul><li><strong>Single Responsibility Principle：单一职责原则</strong></li><li><strong>Open Closed Principle：开闭原则</strong></li><li><strong>Liskov Substitution Principle：里氏替换原则</strong></li><li><strong>Law of Demeter：迪米特法则</strong></li><li><strong>Interface Segregation Principle：接口隔离原则</strong></li><li><strong>Dependence Inversion Principle：依赖倒置原则</strong></li></ul><p>把这六个原则的首字母联合起来（两个 L 算做一个）就是 SOLID （solid，稳定的），其代表的含义就是这六个原则结合使用的好处：建立稳定、灵活、健壮的设计。下面我们来分别看一下这六大设计原则。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240709223429759.png" alt="image-20240709223429759"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据目的"><a href="#根据目的" class="headerlink" title="根据目的"></a>根据目的</h4><ul><li>创建型</li><li>行为型</li><li>结构型</li></ul><h4 id="根据作用对象"><a href="#根据作用对象" class="headerlink" title="根据作用对象"></a>根据作用对象</h4><ul><li>类模式</li><li>对象模式</li></ul><table><thead><tr><th><strong>范围&#x2F;目的</strong></th><th><strong>创建型模式</strong></th><th><strong>结构型模式</strong></th><th><strong>行为型模式</strong></th></tr></thead><tbody><tr><td><strong>类模式</strong></td><td>工厂方法</td><td>（类）适配器</td><td>模板方法 <br />解释器</td></tr><tr><td><strong>对象模式</strong></td><td>单例<br /> 原型 <br />抽象工厂 <br />建造者</td><td>代理 <br />（对象）适配器 <br />桥接 <br />装饰 <br />外观 <br />享元 <br />组合</td><td>策略 <br />命令 <br />职责链 <br />状态 <br />观察者 <br />中介者 <br />迭代器 <br />访问者 <br />备忘录</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>除以上的经验外，还有其他一些经验，也值得在代码设计或开发过程中进行使用</p><ul><li>模块拆分与设计</li><li>持续重构</li><li>文档注释</li><li>单元测试</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
