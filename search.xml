<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux 线程</title>
      <link href="/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2024/05/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%20%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux线程概念"><a href="#一、Linux线程概念" class="headerlink" title="一、Linux线程概念"></a>一、Linux线程概念</h1><h2 id="1、什么是线程"><a href="#1、什么是线程" class="headerlink" title="1、什么是线程"></a>1、什么是线程</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509040108318.png" alt="image-20240509040108318"></p><p>首先从 <strong>进程</strong> 讲起，一个进程有自己对应的 PCB，虚拟地址空间，页表以及映射的物理内存，也即 <code>进程** = 内核数据结构 + 进程对应的代码和数据</code>。</p><p>对于<strong>虚存</strong>：虚拟内存决定了进程能够看到的”资源”。因为每一个进程都有对应的虚拟内存，所以进程具有独立性，从而进程需要通信的前提是看到同一份资源。</p><p>通过 fork 创建子进程的时候，会将父进程的PCB的内容，进程地址空间和页表都给子进程拷贝一份。</p><p><code>而如果创建多个 PCB，并将这些 PCB 使用同一个进程地址空间和页表，这样就可以看到同一份资源了，这就是线程。</code></p><p>因此可以将 线程 理解为 进程 内的一个执行流，线程在进程内运行，线程在进程的地址空间内运行，拥有该进程的一部分资源。</p><p>也即 线程是 CPU 调度的基本单位。进程 则是承担系统资源的基本实体，内部可以有一个或多个执行流。因为我们可以通过虚拟地址空间+页表的方式对进程的资源进行划分，单个”进程”(线程)执行粒度，一定要比之前的进程要细。</p><p>如果 OS 要专门设计线程的概念，就需要对线程进行管理，也就需要先描述，再组织，即一定要为线程设计专门的数据结构表示线程对象TCB。但是线程和进程一样都需要被执行，被调度(id,状态，优先级，上下文，栈…)，二者十分相似，所以单纯从线程调度角度，线程和进程有很多的地方是重叠的。所以Linux工程师不想给”线程”专门设计对应的数据结构，而是直接复用PCB，用 PCB 用来表示 Linux 内部的”线程”, 所以在Linux中，进程我们称为轻量级进程。而 windows 有单独的TCB结构</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ol><li><p>.Linux 内核中没有真正意义是线程，Linux是用进程的 PCB 来进行模拟，是一种完全属于自己的一套线程方案</p></li><li><p>站在 CPU视角，每一个PCB，都可以称之为轻量级进程</p></li><li><p>Linux 线程是 CPU 调度的基本单位，而进程是承担资源分配的基本单位</p></li><li><p>进程用来整体申请资源，线程用来伸手向进程要资源</p></li><li><p>在一个程序里的一个执行路线就叫做线程（thread）。更准确的定义是：线程是“一个进程内部的控制序列”</p></li><li><p>一切进程至少都有一个执行线程</p></li><li><p>线程在进程内部运行，本质是在进程地址空间内运行</p></li><li><p>在 Linux 系统中，在 CPU 眼中，看到的 PCB 都要比传统的进程更加轻量化</p></li><li><p>透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程执行流</p></li></ol><p>Linux内核中没有真正意义是线程，所以Linux便无法直接提供创建线程的系统调用接口，而只能给我们提供创建轻量级进程的接口，但是操作系统只认线程，用户(程序员)也只认线程，所以Linux在软件层提供了一个原生的线程库。</p><p>任何 Linux 操作系统，都必须默认携带这个原生线程库–用户级线程库</p><p>线程创建用例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">start_routine</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是新线程, 我正在运行! &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">int</span> n = pthread_create(&amp;tid, nullptr, start_routine, (<span class="type">void</span> *)<span class="string">&quot;thread one&quot;</span>);</span><br><span class="line">    assert(<span class="number">0</span> == n);</span><br><span class="line">    (<span class="type">void</span>)n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;我是主线程, 我正在运行!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线程优缺点"><a href="#线程优缺点" class="headerlink" title="线程优缺点"></a>线程优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建一个新线程的代价要比创建一个新进程小得多</li><li>与进程之间的切换相比，线程之间的切换需要操作系统做的工作要少很多<ul><li>进程：切换页表 &amp;&amp; 虚拟地址空间 &amp;&amp; 切换PCB &amp;&amp;上下文切换</li><li>线程：切换PCB &amp;&amp;上下文切换</li></ul></li><li>线程占用的资源要比进程少很多</li><li>能充分利用多处理器的可并行数量</li><li>在等待慢速I&#x2F;O操作结束的同时，程序可执行其他的计算任务</li><li>计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现</li><li>I&#x2F;O密集型应用，为了提高性能，将I&#x2F;O操作重叠。线程可以同时等待不同的I&#x2F;O操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li><strong>性能损失</strong> —— 一个很少被外部事件阻塞的计算密集型线程往往无法与共它线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不变。</li><li><strong>健壮性降低</strong> —— 编写多线程需要更全面更深入的考虑，在一个多线程程序里，因时间分配上的细微偏差或者因共享了不该共享的变量而造成不良影响的可能性是很大的，换句话说线程之间是缺乏保护的。</li><li><strong>缺乏访问控制</strong> —— 进程是访问控制的基本粒度，在一个线程中调用某些OS函数会对整个进程造成影响。</li><li><strong>编程难度提高</strong> —— 编写与调试一个多线程程序比单线程程序困难得多</li></ol><h2 id="线程异常"><a href="#线程异常" class="headerlink" title="线程异常"></a>线程异常</h2><p>单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃，<strong>因为信号在整体发给进程的</strong></p><p>线程是进程的执行分支，线程出异常，就类似进程出异常，进而触发信号机制，终止进程，进程终止，该进程内的所有线程也就随即退出</p><h1 id="二、线程控制"><a href="#二、线程控制" class="headerlink" title="二、线程控制"></a>二、线程控制</h1><h2 id="1-线程创建"><a href="#1-线程创建" class="headerlink" title="1. 线程创建"></a>1. 线程创建</h2><h3 id="POSIX线程库"><a href="#POSIX线程库" class="headerlink" title="POSIX线程库"></a>POSIX线程库</h3><h4 id="创建线程函数接口-–-pthread-create"><a href="#创建线程函数接口-–-pthread-create" class="headerlink" title="创建线程函数接口 – pthread_create"></a>创建线程函数接口 – pthread_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 功能：创建一个新的线程</span></span><br><span class="line"><span class="comment">// 参数</span></span><br><span class="line"><span class="comment">// thread:返回线程ID</span></span><br><span class="line"><span class="comment">// attr:设置线程的属性，attr为NULL表示使用默认属性</span></span><br><span class="line"><span class="comment">// start_routine:是个函数地址，线程启动后要执行的函数</span></span><br><span class="line"><span class="comment">// arg:传给线程启动函数的参数</span></span><br><span class="line"><span class="comment">// 返回值：成功返回0；失败返回错误码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span>*), <span class="type">void</span> *arg)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于 Linux 中的线程使用的是原生线程库，因此在原生线程库中就可能会存在多个线程，</p><p>此时就需要对线程进行管理，管理的方法是<strong>先描述再组织</strong>。</p><p>在Linux中，用户级线程，用户关系的线程属性在库中，内核中提供执行流的调度。Linux用户级线程:内核轻量级进程 &#x3D; 1 : 1。</p><p>用户级线程的 tid 是库中描述线程结构体的起始地址。所以pthread_t 到底是什么类型呢？取决于实现。对于Linux目前实现的NPTL实现而言，pthread_t类型的线程ID，本质就是一个进程地址空间上的一个地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并发 </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程</title>
      <link href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><ul><li>进程可以理解为程序的一次执行过程，系统运行一个程序即是一个进程从创建，运行到消亡的过程。</li><li>现代操作系统对于进程会分配独立的 内存地址空间和其他系统资源（IO）</li><li>对 Java 而言，<code>main()</code> 函数启动时其实就是启动了一个 JVM 的进程，而 <code>main()</code> 函数所在的线程就是这个进程中的一个线程，也称主线程。</li></ul><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><ul><li>线程是依托于进程的一个指令执行序列</li><li>一个进程可以产生多个线程</li><li>linux中，线程又叫做轻量级进程（light-weight process LWP），也有PCB，创建线程使用的底层函数和进程底层一样，都是clone，但没有独立的地址空间；而进程有独立地址空间，拥有PCB。</li></ul><h2 id="进程与线程对比"><a href="#进程与线程对比" class="headerlink" title="进程与线程对比"></a>进程与线程对比</h2><ul><li><strong>本质区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。</li><li><strong>包含关系</strong>：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</li><li><strong>资源开销</strong>：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</li><li><strong>影响关系</strong>：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合</title>
      <link href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/"/>
      <url>/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h1><p>Java 集合，也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素，<code>Collection</code> 接口派生三个子接口 <code>List</code> <code>Set</code> <code>Queue</code>；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240506003529811.png" alt="image-20240506003529811"></p><ul><li><code>List</code> (对付顺序的好帮手): 存储的元素是有序的、可重复的。<ul><li><code>ArrayList</code>: 底层 Object 数组</li><li><code>Vector</code>: 底层 Object 数组</li><li><code>LinkedList</code>: 底层双向链表</li></ul></li><li><code>Set</code> (注重独一无二的性质): 存储的元素不可重复的。<ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素。</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul></li><li><code>Queue</code> : 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。<ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现小顶堆</li><li><code>DelayQueue</code>:&#96;PriorityQueue&#96;&#96;</li><li><code>ArrayDeque</code>: 可扩容动态双向数组。</li></ul></li><li><code>Map</code> (用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值<ul><li><code>HashMap</code>：数组 + 链表 + 红黑树</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>：数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的。</li><li><code>TreeMap</code>：红黑树（自平衡的排序二叉树）。</li></ul></li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList-和-Array（数组）的区别"><a href="#ArrayList-和-Array（数组）的区别" class="headerlink" title="ArrayList 和 Array（数组）的区别"></a>ArrayList 和 Array（数组）的区别</h2><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li><li><code>ArrayList</code>创建时不需要指定大小，而<code>Array</code>创建时必须指定大小。</li></ul><h2 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h2><h3 id="插入——add-："><a href="#插入——add-：" class="headerlink" title="插入——add()："></a>插入——add()：</h3><ul><li>头插：由于需要将所有元素都依次向后移动一个位置，因此时间复杂度是 O(n)。</li><li>尾插：<ul><li>当 <code>ArrayList</code> 的容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>当容量已达到极限并且需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。</li></ul></li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n&#x2F;2 个元素，因此时间复杂度为 O(n)。</li></ul><h3 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h3><ul><li><strong>头部删除</strong>：由于需要将所有元素依次向前移动一个位置，因此时间复杂度是 O(n)。</li><li><strong>尾部删除</strong>：当删除的元素位于列表末尾时，时间复杂度为 O(1)。</li><li><strong>指定位置删除</strong>：需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n&#x2F;2 个元素，时间复杂度为 O(n)</li></ul><h2 id="ArrayList-扩容机制"><a href="#ArrayList-扩容机制" class="headerlink" title="&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;"></a>&#x3D;&#x3D;ArrayList 扩容机制&#x3D;&#x3D;</h2><p>ArrayList 是基于数组的集合，数组的容量是在定义的时候确定的，如果数组满了，再插入，就会数组溢出。所以在插入时候，会先检查是否需要扩容，如果当前容量+1 超过数组长度，就会进行扩容。</p><p>ArrayList 的扩容是创建一个<strong>1.5 倍</strong>的新数组，然后把原数组的值拷贝过去。</p><h2 id="线程安全的List"><a href="#线程安全的List" class="headerlink" title="线程安全的List"></a>线程安全的List</h2><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><ul><li>不推荐使用</li></ul><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><ul><li>写时复制技术，可以保障读写并发安全性</li></ul><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><ul><li>代理对象，额外创建mutex ，执行相关操作时，对mutex 加锁</li></ul><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><h2 id="HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><h2 id="Queue-与-Deque-的区别"><a href="#Queue-与-Deque-的区别" class="headerlink" title="Queue 与 Deque 的区别"></a>Queue 与 Deque 的区别</h2><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><h4 id="Queue-相关API"><a href="#Queue-相关API" class="headerlink" title="Queue 相关API"></a>Queue 相关API</h4><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><h4 id="Deque-相关API"><a href="#Deque-相关API" class="headerlink" title="Deque 相关API"></a>Deque 相关API</h4><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>此外，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈</p><h2 id="ArrayDeque-与-LinkedList-对比"><a href="#ArrayDeque-与-LinkedList-对比" class="headerlink" title="ArrayDeque 与 LinkedList 对比"></a>ArrayDeque 与 LinkedList 对比</h2><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈</p><h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p><code>BlockingQueue</code> （阻塞队列）是一个<code>queue</code>的子接口。<code>BlockingQueue</code> 定义了阻塞式等待的插入和拿取操作（也可指定超时时间）</p><h3 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><ul><li>使用数组实现的有界阻塞队列。在创建时需要指定容量大小，并支持公平和非公平两种方式的锁访问机制</li><li>读写&#x2F;生产消费 使用一把锁</li><li>提前分配内存，可能存在内存浪费，但是会快些</li></ul><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><ul><li>基于链表实现的阻塞队列</li><li>读写锁分离</li><li>无内存浪费，但是需要动态申请堆内存，会慢些</li></ul><h4 id="其他阻塞队列"><a href="#其他阻塞队列" class="headerlink" title="其他阻塞队列"></a>其他阻塞队列</h4><ul><li><p><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</p></li><li><p><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。每个插入操作都必须等待对应的删除操作，反之删除操作也必须等待插入操作。因此，<code>SynchronousQueue</code>通常用于线程之间的直接传递数据。</p></li><li><p><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队</p></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>线程安全的hash表，已不建议使用</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><p>相比于HashMap来说， TreeMap 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</p><ul><li><strong>定向搜索</strong>: <code>ceilingEntry()</code>, <code>floorEntry()</code>, <code>higherEntry()</code>和 <code>lowerEntry()</code> 等方法可以用于定位大于、小于、大于等于、小于等于给定键的最接近的键值对。</li><li><strong>子集操作</strong>: <code>subMap()</code>, <code>headMap()</code>和 <code>tailMap()</code> 方法可以高效地创建原集合的子集视图，而无需复制整个集合。</li><li><strong>逆序视图</strong>:<code>descendingMap()</code> 方法返回一个逆序的 <code>NavigableMap</code> 视图，使得可以反向迭代整个 <code>TreeMap</code>。</li><li><strong>边界操作</strong>: <code>firstEntry()</code>, <code>lastEntry()</code>, <code>pollFirstEntry()</code>和 <code>pollLastEntry()</code> 等方法可以方便地访问和移除元素。</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="&#x3D;&#x3D;HashMap&#x3D;&#x3D;"></a>&#x3D;&#x3D;HashMap&#x3D;&#x3D;</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>&#x3D;&#x3D;<strong>数组 + 链表 + 红黑树</strong>&#x3D;&#x3D; （1.8 以后）</li></ul><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509021422847.png" alt="image-20240509021422847"></p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>默认长度： 16</li><li>最大长度： 2^30</li><li>负载因子： 0.75</li><li>链表树化阈值： 8</li><li>红黑树退化阈值： 6</li><li>链表树化时数组长度阈值： 64</li><li>node 数组扩容倍数： 2</li></ul><h3 id="put-流程"><a href="#put-流程" class="headerlink" title="put()流程"></a>put()流程</h3><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240509022413104.png" alt="image-20240509022413104"></p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><h4 id="常用的hash冲突解决办法"><a href="#常用的hash冲突解决办法" class="headerlink" title="常用的hash冲突解决办法"></a>常用的hash冲突解决办法</h4><ul><li>再哈希，直至找到空槽</li><li>开放地址法，寻找下一个空槽<ul><li>线性探测：从冲突的位置开始，依次往后找，直到找到空槽。</li><li>二次探测：从冲突的位置 x 开始，第一次增加 12 个位置，第二次增加 22，直到找到空槽。</li><li>双重哈希：和再哈希法类似，准备多个哈希函数，发生冲突的时候，使用另外一个哈希函数</li></ul></li><li>拉链法——也即JDK 1.8 HashMap 所采用方法</li></ul></li><li><h4 id="为什么-node-数组长度要是-2的幂次方"><a href="#为什么-node-数组长度要是-2的幂次方" class="headerlink" title="为什么 node 数组长度要是 2的幂次方"></a>为什么 node 数组长度要是 2的幂次方</h4><ul><li><strong>两点原因： 插入时定下标快，扩容时重新确定下标块</strong><ul><li>hash 过多，内存放不下，进而</li><li>一般通过 hash（或再映射）对数组长区域确定下标</li><li>而用 2的整数次幂为长度，余运算可以转为位运算，计算更快</li><li>此外，初始数组在没有把握的情况下，不宜设得过大，因此存在数组的后续扩容操作</li><li>以2的整数次幂为长度，且以 2 做扩容倍数时，可以方便的确定原数组链表内所有节点在扩容后的位置</li></ul></li></ul></li><li><h4 id="为什么选-0-75-为扩容因子"><a href="#为什么选-0-75-为扩容因子" class="headerlink" title="为什么选 0.75 为扩容因子"></a>为什么选 0.75 为扩容因子</h4></li><li><p>由加载因子的定义，其取值范围是 (0, 1]。</p></li><li><p>还有一个因素是为了提升扩容效率。因为<code>HashMap</code>的容量（<code>size</code>属性，构造函数中的<code>initialCapacity</code>变量）有一个要求：它一定是 2 的幂 （4,8,16，……）。所以加载因子选择了0.75就可以保证它与容量的乘积为整数。</p></li><li><p>经验</p><ul><li>如果加载因子过小，那么扩容门槛低，扩容频繁，这虽然能使元素存储得更稀疏，有效避免了哈希冲突发生，同时操作性能较高，但是会占用更多的空间。</li><li>如果加载因子过大，那么扩容门槛高，扩容不频繁，虽然占用的空间降低了，但是这会导致元素存储密集，发生哈希冲突的概率大大提高，从而导致存储元素的数据结构更加复杂（用于解决哈希冲突），最终导致操作性能降低。</li></ul></li><li><h4 id="死循环问题"><a href="#死循环问题" class="headerlink" title="死循环问题"></a>死循环问题</h4><ul><li>1.8 之后改为尾插法不存在此问题， 1.7 及之前，头插法可能导致此问题</li></ul></li><li><h4 id="Hash-扰动"><a href="#Hash-扰动" class="headerlink" title="Hash 扰动"></a>Hash 扰动</h4><ul><li><code>return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></li><li>一般数组长度可能不会太长，扰动后可使高16位也能参与下标计算，可在一定程度上缓解 hash 碰撞，使 key 分布更均衡</li><li>同时位运算消耗较低</li></ul></li><li><h4 id="为什么采用-红黑树-而不是-AVL-树"><a href="#为什么采用-红黑树-而不是-AVL-树" class="headerlink" title="为什么采用 红黑树 而不是 AVL 树"></a>为什么采用 红黑树 而不是 AVL 树</h4><ul><li><p>平衡二叉树比红黑树的要求更高，每个节点的左右子树的高度最多相差1，这种高度的平衡保证了极佳的查找效率，但在进行插入和删除操作时，可能需要频繁地进行旋转来维持树的平衡，这在某些情况下可能导致更高的维护成本。</p><p>红黑树是一种折中的方案，它在保证了树平衡的同时，插入和删除操作的性能也得到了保证，查询效率是 O(logn)。</p></li></ul></li></ul><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>JDK1.7 的 采用 <strong>分段的数组+链表</strong> 实现， 每一个分段类似于一个子 Map ，一般也称 segment</li><li>JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，</li></ul><h3 id="实现线程安全的方式"><a href="#实现线程安全的方式" class="headerlink" title="&#x3D;&#x3D;实现线程安全的方式&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>实现线程安全的方式</strong>&#x3D;&#x3D;</h3><ul><li>JDK1.7 时，针对 segment 加锁</li><li>JDK 1.8 时数据结构跟 <code>HashMap</code> 1.8 的结构一样。并采用 <code>Node + CAS + synchronized</code> 来保证并发安全，同时降低了锁粒度，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升</li><li>并发度层面 JDK 1.7 时最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</li></ul><h3 id="ConcurrentHashMap-中-key-和-value-不能为-null"><a href="#ConcurrentHashMap-中-key-和-value-不能为-null" class="headerlink" title="ConcurrentHashMap 中 key 和 value 不能为 null"></a>ConcurrentHashMap 中 key 和 value 不能为 null</h3><p><strong>原因</strong>： 主要是为了避免二义性。</p><p>拿 get 方法取值来说，返回的结果为 null 存在两种情况：</p><ul><li>值没有在集合中 ；</li><li>值本身就是 null。</li></ul><p>如果你确实需要在 ConcurrentHashMap 中使用 null 的话，可以使用一个特殊的静态空对象来代替 null。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基础</title>
      <link href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Java-语言特点"><a href="#1-Java-语言特点" class="headerlink" title="1.    Java 语言特点"></a>1.    Java 语言特点</h2><ul><li><strong>面向对象</strong></li><li><strong>平台无关</strong></li><li><strong>支持多线程</strong><br>C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持</li><li><strong>编译与解释并存</strong></li></ul><h2 id="2-JDK、JRE、JVM-关系"><a href="#2-JDK、JRE、JVM-关系" class="headerlink" title="2.    JDK、JRE、JVM 关系"></a>2.    JDK、JRE、JVM 关系</h2><p><strong>JVM</strong>：Java Virtual Machine，也就是 Java 虚拟机，是 Java 实现跨平台的关键所在，针对不同的操作系统，有不同的 JVM 实现。JVM 负责将 Java 字节码转换为特定平台的机器码，并执行。</p><p><strong>JRE</strong>：Java Runtime Environment，也就是 Java 运行时环境，包含了运行 Java 程序所必需的库，以及 Java 虚拟机（JVM）。</p><p><strong>JDK</strong>：Java Development Kit，是一套完整的 Java SDK（软件开发工具包），包括了 JRE 以及译器（javac）、Java 文档生成工具（Javadoc）、Java 调试器等开发工具。</p><p>简单来说，JDK 包含 JRE，JRE 包含 JVM。</p><h2 id="3-什么是字节码"><a href="#3-什么是字节码" class="headerlink" title="3.    什么是字节码"></a>3.    什么是字节码</h2><p>字节码，就是 Java 程序经过编译之类产生的.class 文件，字节码能够被虚拟机识别，从而实现 Java 程序的跨平台性。</p><p><strong>Java</strong> 程序从源代码到运行主要有三步：</p><ul><li><strong>编译</strong>：将我们的代码（.java）编译成虚拟机可以识别理解的字节码(.class)</li><li><strong>解释</strong>：虚拟机执行 Java 字节码，将字节码翻译成机器能识别的机器码</li><li><strong>执行</strong>：对应的机器执行二进制机器码</li></ul><p>Java 跨平台特性其实就是为不同平台提供不同的 JVM，JVM 基于平台特性调整字节码解释实现，从而使得字节码在不同平台均可运行</p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505211415926.png" alt="image-20240505211415926" style="zoom:67%;" /><h2 id="4-什么是面向对象"><a href="#4-什么是面向对象" class="headerlink" title="4.    什么是面向对象"></a>4.    什么是面向对象</h2><p><strong>面向对象是一种 相对面向过程 而言的编程范式</strong></p><p><strong>面向过程</strong>程序设计是具体化的，流程化的；面向过程的代码设计通过着手于事物的实现流程，根据已有条件如何一步一步生成结果。</p><p>因此，基于面向过程思路所涉及的代码通常不便于扩展和代码复用，此外，面向过程的思路在处理复杂问题时，编程难度将显著增加。</p><p>而<strong>面向对象</strong>程序设计是模型化的，把对象作为基本单位，将问题抽象建模为一系列对象之间的交互，使得程序易于理解、维护。具有相同行为和属性的对象泛化为类的实例。此外，面向对象具有三大特性——封装、继承与多态</p><h4 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1    封装"></a>4.1    封装</h4><p><strong>概念</strong>：将一些属性和相关方法封装在一个对象中，对外隐藏内部实现细节。内部具体实现，外界不需要关心，而只需要根据”内部提供的接口“去使用就可以。</p><p><strong>好处</strong>：</p><ul><li><p>使用起来更加方便</p></li><li><p>保证数据的安全，针对于安全级别高的数据，可以设置成”私有“，可以控制数据为只读（外界无法修改）</p></li><li><p>利于代码维护：如果后期功能实现逻辑需要调整，则保持接口名不变，修改实现代码即可，外界不需要做任何代码修改。</p></li></ul><h4 id="4-2-继承"><a href="#4-2-继承" class="headerlink" title="4.2    继承"></a>4.2    继承</h4><p>继承允许一个类（子类）继承现有类（父类或者基类）的属性和方法。</p><p>可提高代码的复用性，建立类之间的层次关系。</p><p>同时，子类还可以重写或者扩展从父类继承来的属性和方法，从而实现多态。</p><h4 id="4-3-多态"><a href="#4-3-多态" class="headerlink" title="4.3    多态"></a>4.3    多态</h4><p>同一个方法，在不同的对象上有不同的表现形式</p><p><strong>多态的要点：</strong></p><ol><li>多态是方法的多态，不是属性的多态（多态与属性无关）。</li><li>多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。</li><li>父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。</li></ol><h2 id="5-访问权限"><a href="#5-访问权限" class="headerlink" title="5.    访问权限"></a>5.    访问权限</h2><ul><li><strong><code>default</code></strong> （即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。可以修饰在类、接口、变量、方法。</li><li><strong><code>private</code></strong> : 在同一类内可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong></li><li><strong><code>public</code></strong> : 对所有类可见。可以修饰类、接口、变量、方法</li><li><strong><code>protected</code></strong> : 对同一包内的类和所有子类可见。可以修饰变量、方法。<strong>注意：不能修饰类（外部类）</strong>。</li></ul><h2 id="6-final-关键字"><a href="#6-final-关键字" class="headerlink" title="6.    final 关键字"></a>6.    final 关键字</h2><ul><li>当 <code>final</code> 修饰一个类时，表明这个类不能被继承。比如，<code>String</code> 类、<code>Integer</code> 类和其他包装类都是用 <code>final</code> 修饰的。</li><li>当 <code>final</code> 修饰一个方法时，表明这个方法不能被重写（<code>@Override</code>）。也就是说，如果一个类继承了某个类，并且想要改变父类中被 <code>final</code> 修饰的方法的行为，是不被允许的。</li><li>当 <code>final</code> 修饰一个变量时，表明这个变量的值一旦被初始化就不能被修改。<ul><li>如果是基本数据类型的变量，其数值一旦在初始化之后就不能更改；</li><li>如果是引用类型的变量，在对其初始化之后就不能再让其指向另一个对象。</li></ul></li></ul><h2 id="7-引用数据类型-、基本数据类型-与-包装类"><a href="#7-引用数据类型-、基本数据类型-与-包装类" class="headerlink" title="7.    引用数据类型 、基本数据类型 与 包装类"></a>7.    引用数据类型 、基本数据类型 与 包装类</h2><h4 id="7-1-引用数据类型"><a href="#7-1-引用数据类型" class="headerlink" title="7.1    引用数据类型"></a>7.1    引用数据类型</h4><ul><li>类</li><li>接口</li><li>数组</li></ul><h4 id="7-2-基本数据类型"><a href="#7-2-基本数据类型" class="headerlink" title="7.2    基本数据类型"></a>7.2    基本数据类型</h4><table><thead><tr><th>数据类型</th><th>默认值</th><th>大小</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1 比特</td></tr><tr><td>char</td><td>‘\u0000’</td><td>2 字节</td></tr><tr><td>byte</td><td>0</td><td>1 字节</td></tr><tr><td>short</td><td>0</td><td>2 字节</td></tr><tr><td>int</td><td>0</td><td>4 字节</td></tr><tr><td>long</td><td>0L</td><td>8 字节</td></tr><tr><td>float</td><td>0.0f</td><td>4 字节</td></tr><tr><td>double</td><td>0.0</td><td>8 字节</td></tr></tbody></table><h4 id="7-3-包装类"><a href="#7-3-包装类" class="headerlink" title="7.3    包装类"></a>7.3    包装类</h4><p><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。</p><p><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，而几乎所有对象实例都存在于堆中。</p><p><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</p><p><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</p><p><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</p><h5 id="7-3-1-包装类常量池-缓存"><a href="#7-3-1-包装类常量池-缓存" class="headerlink" title="7.3.1    包装类常量池(缓存)"></a>7.3.1    包装类常量池(缓存)</h5><p>byte、int、long 类型 均缓存有 -128~127 的值在常量池中</p><p>char 缓存所有char</p><h2 id="8-Java-拷贝机制"><a href="#8-Java-拷贝机制" class="headerlink" title="8.    Java 拷贝机制"></a>8.    Java 拷贝机制</h2><ul><li><strong>浅拷贝</strong>：值类型拷贝，引用类型指向同一对象</li><li><strong>深拷贝</strong>：值类型拷贝，引用类型则拷贝了一个新对象，且引用类型内部按此规则递归</li></ul><h4 id="8-1-cloneable-接口与-clone"><a href="#8-1-cloneable-接口与-clone" class="headerlink" title="8.1    cloneable 接口与 clone()"></a>8.1    cloneable 接口与 clone()</h4><p><code>clone()</code> 默认浅拷贝， 且相应对象若未实现 <code>cloneable</code> 接口，会抛出异常</p><h4 id="8-2-如何实现-深拷贝"><a href="#8-2-如何实现-深拷贝" class="headerlink" title="8.2    如何实现 深拷贝"></a>8.2    如何实现 深拷贝</h4><ul><li>自定义拷贝构造函数（递归）</li><li>递归实现 <code>cloneable</code> 接口并重写 <code>clone()</code> 方法</li><li>序列化</li></ul><h2 id="9-String-相关"><a href="#9-String-相关" class="headerlink" title="9.    String 相关"></a>9.    String 相关</h2><h4 id="9-1-String、StringBuffer、StringBuilder"><a href="#9-1-String、StringBuffer、StringBuilder" class="headerlink" title="9.1    String、StringBuffer、StringBuilder"></a>9.1    String、StringBuffer、StringBuilder</h4><p><code>String</code> 是不可变的（自然线程安全）</p><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 是可变的，且 <code>StringBuffer</code> 对字符串的操作方法都添加了同步锁，因此性能安全，但同时影响了性能</p><h4 id="9-2-String-为什么不可变"><a href="#9-2-String-为什么不可变" class="headerlink" title="9.2    String 为什么不可变"></a>9.2    String 为什么不可变</h4><ul><li>String 类中 核心数组 被final修饰，此外，String 类中未提供修改 数组内元素的方法</li><li>String 类自身也是 final 的，可以避免子类提供数组修改方法</li></ul><h4 id="9-3-String-为什么要设计成不可变的"><a href="#9-3-String-为什么要设计成不可变的" class="headerlink" title="9.3    String 为什么要设计成不可变的"></a>9.3    String 为什么要设计成不可变的</h4><ul><li><strong>安全</strong> —— String 类型经常用来做参数，比如 url、pwd 之类的</li><li><strong>允许缓存 HashCode</strong> —— Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。字符串不变性保证了hash码的唯一性，因此可以放心地进行缓存</li><li><strong>字符串常量池需要</strong></li></ul><h2 id="10-Object"><a href="#10-Object" class="headerlink" title="10.    Object"></a>10.    Object</h2><h4 id="10-1-常用方法"><a href="#10-1-常用方法" class="headerlink" title="10.1    常用方法"></a>10.1    常用方法</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505224438372.png" alt="image-20240505224438372"></p><h4 id="10-2-和-equals"><a href="#10-2-和-equals" class="headerlink" title="10.2    &#x3D;&#x3D; 和 equals"></a>10.2    &#x3D;&#x3D; 和 equals</h4><ul><li>&#x3D;&#x3D; 判断值类型是否相等，引用类型是否指向同一对象</li><li><code>equals</code> 默认情况下与 &#x3D;&#x3D; 等价，重写后可能不等价</li></ul><h4 id="10-3-为什么重写-equals-时必须重写-hashCode-方法"><a href="#10-3-为什么重写-equals-时必须重写-hashCode-方法" class="headerlink" title="10.3    为什么重写 equals() 时必须重写 hashCode() 方法"></a>10.3    为什么重写 equals() 时必须重写 hashCode() 方法</h4><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>导致 HashMap 可能存入两个逻辑相等的对象</p><h2 id="11-序列化、反序列化"><a href="#11-序列化、反序列化" class="headerlink" title="11.    序列化、反序列化"></a>11.    序列化、反序列化</h2><h4 id="11-1-什么是序列化、反序列化"><a href="#11-1-什么是序列化、反序列化" class="headerlink" title="11.1    什么是序列化、反序列化"></a>11.1    什么是序列化、反序列化</h4><ul><li>序列化：把 Java 对象转换为字节序列的过程</li><li>反序列：把字节序列恢复为 Java 对象的过程</li></ul><h4 id="11-2-注意点"><a href="#11-2-注意点" class="headerlink" title="11.2    注意点"></a>11.2    注意点</h4><ul><li>static 静态变量和 transient 修饰的字段是不会被序列化的</li><li>serialVersionUID问题</li><li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li><li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li></ul><h4 id="11-3-不推荐使用-JDK-自带的序列化"><a href="#11-3-不推荐使用-JDK-自带的序列化" class="headerlink" title="11.3    不推荐使用 JDK 自带的序列化"></a>11.3    不推荐使用 JDK 自带的序列化</h4><p>我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p><ul><li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li><li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码</li></ul><h2 id="12-异常"><a href="#12-异常" class="headerlink" title="12.    异常"></a>12.    异常</h2><h4 id="12-1-异常层级"><a href="#12-1-异常层级" class="headerlink" title="12.1    异常层级"></a>12.1    异常层级</h4><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20240505230455539.png" alt="image-20240505230455539"></p><ul><li>**<code>Throwable</code>**：是 java 中所有异常和错误的超类,其两个子类为 <strong><code>Error</code></strong>(错误) 和 <strong><code>Exception</code></strong>(异常)<ul><li><strong>Error</strong>： 是程序中无法处理的错误，表示运行应用程序中出现了严重的错误。此类错误一般表示代码运行时JVM出现问题。通常有Virtual MachineError（虚拟机运行错误）、NoClassDefFoundError（类定义错误）等。比如说当jvm耗完可用内存时，将出现OutOfMemoryError。此类错误发生时，JVM将终止线程。非代码性错误。因此，当此类错误发生时，应用不应该去处理此类错误。</li><li>**<code>Exception</code>**： 是程序本身可以捕获并且可以处理的异常。其中可分为运行时异常（RuntimeException）和非运行时异常，也叫做受检异常<ul><li>**运行时异常(不受检异常)**： RuntimeException类极其子类表示JVM在运行期间可能出现的错误。编译器不会检查此类异常，并且不要求处理异常，比如用空值对象的引用（NullPointerException）、数组下标越界（ArrayIndexOutBoundException）。此类异常属于不可查异常，一般是由程序逻辑错误引起的，在程序中可以选择捕获处理，也可以不处理。</li><li>**非运行时异常(受检异常)**： Exception中除RuntimeException极其子类之外的异常。编译器会检查此类异常，如果程序中出现此类异常，比如说IOException，必须对该异常进行处理，要么使用try-catch捕获，要么使用throws语句抛出，否则编译不通过。</li></ul></li></ul></li></ul><h4 id="12-1-try-with-finally"><a href="#12-1-try-with-finally" class="headerlink" title="12.1    try - with - finally"></a>12.1    try - with - finally</h4><ul><li><p>无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</p></li><li><p>不要在 finally 语句块中使用 return， 因为当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略</p></li><li><p>finally 语句在 线程被杀死、JVM 关闭等情况时也不一定会执行</p></li><li><p>对必须关闭的资源，推荐使用 <code>try with resources</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.txt&quot;</span>))) &#123;</span><br><span class="line">    <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">        System.out.println(scanner.nextLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">    fnfe.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-注解"><a href="#13-注解" class="headerlink" title="13.    注解"></a>13.    注解</h2><h4 id="13-1-注解作用"><a href="#13-1-注解作用" class="headerlink" title="13.1    注解作用"></a>13.1    注解作用</h4><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 ，并可添加根据注解内容而执行的特定逻辑。</p><h4 id="13-2-注解类型"><a href="#13-2-注解类型" class="headerlink" title="13.2    注解类型"></a>13.2    注解类型</h4><ul><li><p>元注解</p><ul><li>@Retention</li><li>@Documented</li><li>@Target</li><li>@Inherited</li><li>@Repeatable</li></ul></li><li><p>内置普通注解</p><ul><li>@Override</li><li>@Deprecated</li><li>@SupressWarnings</li><li>@SafeVarargs</li></ul></li><li><p>自定义注解</p></li></ul><h4 id="13-3-其他"><a href="#13-3-其他" class="headerlink" title="13.3    其他"></a>13.3    其他</h4><ul><li>注解也是一个类，可以添加属性，并设置默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Coder &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">id</span><span class="params">()</span> <span class="keyword">default</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;GRQ&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">language</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">company</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;China_Company&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
