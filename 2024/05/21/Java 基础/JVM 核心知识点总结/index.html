<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JVM 核心知识点总结 | ZengCP's BLOGS</title><meta name="author" content="ZengCP"><meta name="copyright" content="ZengCP"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="#一、基本概念 1.1 OpenJDK自 1996 年 JDK 1.0 发布以来，Sun 公司在大版本上发行了 JDK 1.1、JDK 1.2、JDK 1.3、JDK 1.4、JDK 5，JDK 6 ，这些版本的 JDK 都可以统称为 SunJDK 。 之后，在 2006 年的 JavaOne 大会上，Sun 公司宣布将 Java 开源，在随后的一年多里，它陆续将 JDK 的各个部分在 GPL v">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 核心知识点总结">
<meta property="og:url" content="http://example.com/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="ZengCP&#39;s BLOGS">
<meta property="og:description" content="#一、基本概念 1.1 OpenJDK自 1996 年 JDK 1.0 发布以来，Sun 公司在大版本上发行了 JDK 1.1、JDK 1.2、JDK 1.3、JDK 1.4、JDK 5，JDK 6 ，这些版本的 JDK 都可以统称为 SunJDK 。 之后，在 2006 年的 JavaOne 大会上，Sun 公司宣布将 Java 开源，在随后的一年多里，它陆续将 JDK 的各个部分在 GPL v">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png">
<meta property="article:published_time" content="2024-05-21T11:46:19.000Z">
<meta property="article:modified_time" content="2025-02-15T12:53:24.059Z">
<meta property="article:author" content="ZengCP">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png"><link rel="shortcut icon" href="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/longmao.png"><link rel="canonical" href="http://example.com/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 核心知识点总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-15 20:53:24'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ZengCP's BLOGS"><span class="site-name">ZengCP's BLOGS</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM 核心知识点总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-21T11:46:19.000Z" title="发表于 2024-05-21 19:46:19">2024-05-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-15T12:53:24.059Z" title="更新于 2025-02-15 20:53:24">2025-02-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM 核心知识点总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>#一、基本概念</p>
<h2 id="1-1-OpenJDK"><a href="#1-1-OpenJDK" class="headerlink" title="1.1 OpenJDK"></a>1.1 OpenJDK</h2><p>自 1996 年 <code>JDK 1.0</code> 发布以来，Sun 公司在大版本上发行了 <code>JDK 1.1</code>、<code>JDK 1.2</code>、<code>JDK 1.3</code>、<code>JDK 1.4</code>、<code>JDK 5</code>，<code>JDK 6</code> ，这些版本的 JDK 都可以统称为 SunJDK 。</p>
<p>之后，在 2006 年的 JavaOne 大会上，Sun 公司宣布将 Java 开源，在随后的一年多里，它陆续将 JDK 的各个部分在 GPL v2（GNU General Public License，version 2）协议下开源，并建立了 OpenJDK 组织来对这些代码进行独立的管理，这就是 OpenJDK 的来源，此时的 OpenJDK 拥有当时 sunJDK 7 的几乎全部代码。</p>
<h2 id="1-2-OracleJDK"><a href="#1-2-OracleJDK" class="headerlink" title="1.2 OracleJDK"></a>1.2 OracleJDK</h2><p>JDK 7 的开发期间，Sun 公司市值一路下跌，无力推进 JDK 7 的开发， JDK 7 的发布也一直被推迟。</p>
<p>之后，在 2009 年 Sun 被 Oracle 收购，为解决 JDK 7 长期跳票的问题，Oracle 将 JDK 7 中大部分未能完成的项目推迟到 JDK 8 ，并于 2011 年发布了JDK 7，在这之后由 Oracle 公司正常发行的 JDK 版本就由 SunJDK 改称为 Oracle JDK。</p>
<p>在 2017 年 JDK 9 发布后，Oracle 公司宣布：以后 JDK 将会在每年的 3 月和 9 月各发布一个大版本，即半年发行一个大版本，目的是为了避免众多功能被捆绑到一个 JDK 版本上而引发的无法交付的风险。</p>
<p>在 JDK 11 发布后，Oracle 同步调整了 JDK 的商业授权，宣布从 JDK 11 起，将以前的商业特性全部开源给 OpenJDK ，这样 OpenJDK 11 和 OracleJDK 11 的代码和功能，在本质上就完全相同了。</p>
<p>同时还宣布以后会发行两个版本的 JDK ：</p>
<ul>
<li>一个是在 GPLv2 + CE 协议下由 Oracle 开源的 OpenJDK；</li>
<li>一个是在 OTN 协议下正常发行的 OracleJDK。</li>
</ul>
<p>两者共享大部分源码，在功能上几乎一致。唯一的区别是 Oracle OpenJDK 可以在开发、测试或者生产环境中使用，但只有半年的更新支持；而 OracleJDK 对个人免费，但在生产环境中商用收费，可以有三年时间的更新支持。</p>
<h2 id="1-3-HotSpot-VM"><a href="#1-3-HotSpot-VM" class="headerlink" title="1.3 HotSpot VM"></a>1.3 HotSpot VM</h2><p>HotSpot VM 是 Sun&#x2F;Oracle JDK 和 OpenJDK 中默认的虚拟机，也是目前使用最广泛的虚拟机。</p>
<p>最初由 Longview Technologies 公司设计发明，该公司在 1997 年被 Sun 公司收购，而 Sun 公司在 06 年开源 SunJDK 时也将 HotSpot 虚拟机一并开了源。</p>
<p>Oracle 收购 Sun 以后，建立了 HotRockit 项目，并将其收购的另外一家公司（BEA）的 JRockit 虚拟机中的优秀特性集成到 HotSpot 中</p>
<p>HotSpot 在这个过程里移除掉永久代，并吸收了 JRockit 的 Java Mission Control 监控工具等功能。</p>
<p>到 JDK 8 发行时，采用的就是集两者之长的 HotSpot VM。</p>
<hr>
<h1 id="二、JVM-组成"><a href="#二、JVM-组成" class="headerlink" title="二、JVM 组成"></a>二、JVM 组成</h1><h2 id="2-1-JVM的总体架构"><a href="#2-1-JVM的总体架构" class="headerlink" title="2.1 JVM的总体架构"></a>2.1 JVM的总体架构</h2><p>如下图所示， JVM的总体架构可以分为以下几个主要部分：</p>
<ol>
<li><strong>类加载器（Class Loader）</strong></li>
<li><strong>运行时数据区（Runtime Data Area）</strong></li>
<li><strong>执行引擎（Execution Engine）</strong></li>
<li><strong>本地接口（Native Interface）</strong></li>
</ol>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250214004159875.png" alt="image-20250214004159875"></p>
<h2 id="2-2-类加载子系统"><a href="#2-2-类加载子系统" class="headerlink" title="2.2 类加载子系统"></a>2.2 类加载子系统</h2><p>类加载子系统主要包含一系列的类加载器 —— 负责加载<code>.class</code>文件到 JVM 的内存中，并将其转换为<code>java.lang.Class</code>的实例。</p>
<hr>
<h2 id="2-3-执行引擎（Execution-Engine）"><a href="#2-3-执行引擎（Execution-Engine）" class="headerlink" title="2.3 执行引擎（Execution Engine）"></a>2.3 执行引擎（Execution Engine）</h2><p>执行引擎负责执行字节码指令。它包括以下几个部分：</p>
<ul>
<li><strong>解释器（Interpreter）</strong>：<ul>
<li>逐条解释执行字节码指令。</li>
<li>适合执行不频繁的代码。</li>
</ul>
</li>
<li><strong>即时编译器（Just-In-Time Compiler，JIT）</strong>：<ul>
<li>将热点代码（频繁执行的代码）编译为本地机器码，提高执行效率。</li>
<li>常见的JIT编译器包括C1（Client Compiler）和C2（Server Compiler）。</li>
</ul>
</li>
<li><strong>垃圾回收器（Garbage Collector）</strong>：<ul>
<li>负责自动管理堆内存，回收不再使用的对象。</li>
<li>常见的垃圾回收器包括Serial GC、Parallel GC、CMS GC、G1 GC等。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-4-本地接口（Native-Interface）"><a href="#2-4-本地接口（Native-Interface）" class="headerlink" title="2.4 本地接口（Native Interface）"></a>2.4 本地接口（Native Interface）</h3><p>本地接口允许Java代码调用本地方法（如C&#x2F;C++编写的代码）。它包括：</p>
<ul>
<li><strong>JNI（Java Native Interface）</strong>：<ul>
<li>提供了一种机制，允许Java代码调用本地方法。</li>
<li>本地方法可以访问操作系统资源或执行性能敏感的操作。</li>
</ul>
</li>
<li><strong>JNA（Java Native Access）</strong>：<ul>
<li>提供了一种更简单的方式来访问本地库，无需编写JNI代码。</li>
</ul>
</li>
</ul>
<h2 id="2-5-运行时数据区"><a href="#2-5-运行时数据区" class="headerlink" title="2.5 运行时数据区"></a>2.5 运行时数据区</h2><p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250213215907962.png" alt="image-20250213215907962"></p>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><ul>
<li><p>线程私有</p>
</li>
<li><p>一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。</p>
</li>
<li><p>字节码解释器通过改变程序计数器的值来选取下一条需要执行的字节码指令，</p>
<ul>
<li>分支、循环、跳转、异常处理、线程恢复等基础功能都需要该计数器来完成。</li>
</ul>
</li>
</ul>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><ul>
<li><p>虚拟机栈（Java Virtual Machine Stack）也是线程私有，</p>
</li>
<li><p>描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个栈帧，用于存储以下信息</p>
<ul>
<li>局部变量表、</li>
<li>操作数栈、</li>
<li>动态连接、</li>
<li>方法出口</li>
</ul>
</li>
<li><p>方法从调用到结束就对应着一个栈帧从入栈到出栈的过程。在《Java 虚拟机规范》中，对该内存区域规定了两类异常：</p>
<ul>
<li><p>如果线程请求的栈深度大于虚拟机所允许的栈深度，将抛出 <code>StackOverflowError</code> 异常；</p>
</li>
<li><p>如果 Java 虚拟机栈的容量允许动态扩展，当栈扩展时如果无法申请到足够的内存会抛出 <code>OutOfMemoryError</code> 异常。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈类似，其区别在于：Java 虚拟机栈是为虚拟机执行 Java 方法（也就是字节码）服务的，而本地方法栈则是为 JVM 使用到的<strong>本地（Native）方法</strong>服务。</p>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><ul>
<li><p>堆（Java Heap）是虚拟机所管理的最大一块内存空间，<strong>用于存放对象实例</strong>。</p>
</li>
<li><p>堆被<strong>所有线程所共享</strong></p>
</li>
<li><p>Java 堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为是连续的。</p>
</li>
<li><p>Java 堆可以被实现成固定大小的，也可以是可扩展的。</p>
<ul>
<li><p>当前大多数主流的虚拟机都是按照可扩展来实现的，即可以通过最大值参数 <code>-Xmx</code> 和最小值参数 <code>-Xms</code> 进行设定。</p>
</li>
<li><p>如果 Java 堆中没有足够的内存来完成对象实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><p>方法区也被称为 “非堆”，目的是与 Java 堆进行区分。《Java 虚拟机规范》规定，如果方法区无法满足新的内存分配需求时，将会抛出 <code>OutOfMemoryError</code> 异常。</p>
<ul>
<li><p><strong>各个线程共享</strong> 的内存区域，</p>
</li>
<li><p>用于存储以下内容</p>
<ul>
<li>已被虚拟机加载的类信息、</li>
<li>常量、</li>
<li>静态变量、</li>
<li>JIT 编译后的代码缓存等数据。</li>
</ul>
</li>
<li><p>JDK 8 以后的方法区实现 由 <strong>永久代（Permanent Generation）</strong> 转为 <strong>元空间（Metaspace）</strong>。</p>
<ul>
<li><p>运行时常量池（Runtime Constant Pool）用于存放常量池表（Constant Pool Table），池表中存放了编译期生成的各种符号字面量和符号引用。</p>
</li>
<li><p>JDK 8 以后的运行时常量池在元空间中。</p>
</li>
</ul>
</li>
</ul>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><p>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。</p>
<p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 <code>OutOfMemoryError</code> 错误出现。</p>
<p>直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<p>类似的概念还有 <strong>堆外内存</strong> 。在一些文章中将直接内存等价于堆外内存，个人觉得不是特别准确。</p>
<p>堆外内存就是把内存对象分配在堆外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响</p>
<hr>
<h1 id="三、对象"><a href="#三、对象" class="headerlink" title="三、对象"></a>三、对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1、-对象创建方式"><a href="#1、-对象创建方式" class="headerlink" title="1、 对象创建方式"></a>1、 对象创建方式</h3><h4 id="1-1-使用new关键字"><a href="#1-1-使用new关键字" class="headerlink" title="1.1 使用new关键字"></a><strong>1.1 使用<code>new</code>关键字</strong></h4><p>这是最常见的对象创建方式。通过<code>new</code>关键字调用类的构造器来创建对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：<ul>
<li><code>new</code>关键字会触发JVM进行对象的内存分配，并调用构造器进行初始化。</li>
<li>如果类的构造器是无参构造器，JVM会自动调用父类的无参构造器（如果存在）。</li>
</ul>
</li>
</ul>
<h4 id="1-2-使用反射"><a href="#1-2-使用反射" class="headerlink" title="1.2 使用反射"></a><strong>1.2 使用反射</strong></h4><p>反射可以动态地创建对象，通过<code>Class</code>类的<code>newInstance()</code>方法或<code>Constructor</code>类的<code>newInstance()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = MyClass.class;</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) clazz.newInstance(); <span class="comment">// 调用无参构造器</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;MyClass&gt; constructor = MyClass.class.getConstructor();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> constructor.newInstance();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：<ul>
<li><code>newInstance()</code>方法会调用类的无参构造器。</li>
<li><code>Constructor.newInstance()</code>方法可以指定构造器的参数。</li>
</ul>
</li>
</ul>
<h4 id="1-3-使用克隆（Clone）"><a href="#1-3-使用克隆（Clone）" class="headerlink" title="1.3 使用克隆（Clone）"></a><strong>1.3 使用克隆（Clone）</strong></h4><p>通过实现<code>Cloneable</code>接口并重写<code>clone()</code>方法，可以创建对象的副本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyClass</span> <span class="variable">original</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">copy</span> <span class="operator">=</span> (MyClass) original.clone();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：<ul>
<li><code>clone()</code>方法会创建对象的浅拷贝。</li>
<li>如果需要深拷贝，需要手动实现深拷贝逻辑。</li>
</ul>
</li>
</ul>
<h4 id="1-4-使用反序列化"><a href="#1-4-使用反序列化" class="headerlink" title="1.4 使用反序列化"></a><strong>1.4 使用反序列化</strong></h4><p>通过序列化和反序列化，可以创建对象的副本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;file.ser&quot;</span>));</span><br><span class="line">oos.writeObject(myObject);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;file.ser&quot;</span>));</span><br><span class="line"><span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> (MyClass) ois.readObject();</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>原理</strong>：<ul>
<li>序列化将对象状态写入字节流。</li>
<li>反序列化从字节流中读取对象状态，创建对象的副本。</li>
</ul>
</li>
</ul>
<h3 id="2、-Java对象的创建过程"><a href="#2、-Java对象的创建过程" class="headerlink" title="2、 Java对象的创建过程"></a><strong>2、 Java对象的创建过程</strong></h3><p>对象的创建过程涉及类加载、内存分配、对象初始化等多个步骤。以下是详细的创建过程：</p>
<h4 id="2-1-类加载"><a href="#2-1-类加载" class="headerlink" title="2.1 类加载"></a><strong>2.1 类加载</strong></h4><p>在创建对象之前，JVM需要加载类到内存中：</p>
<ol>
<li><strong>加载</strong>：<ul>
<li>JVM通过类加载器（如启动类加载器、扩展类加载器、应用类加载器）加载<code>.class</code>文件到内存。</li>
</ul>
</li>
<li><strong>链接</strong>：<ul>
<li><strong>验证</strong>：检查字节码的正确性。</li>
<li><strong>准备</strong>：为类的静态变量分配内存。</li>
<li><strong>解析</strong>：将符号引用转换为直接引用。</li>
</ul>
</li>
<li><strong>初始化</strong>：<ul>
<li>执行类的静态代码块和静态变量初始化。</li>
</ul>
</li>
</ol>
<h4 id="2-2-内存分配"><a href="#2-2-内存分配" class="headerlink" title="2.2 内存分配"></a><strong>2.2 内存分配</strong></h4><p>在堆内存中为对象分配内存：</p>
<ol>
<li><strong>分配内存</strong>：<ul>
<li>JVM在堆内存中分配一块足够大的内存空间。</li>
<li>如果内存不足，会触发垃圾回收器回收内存。</li>
<li>如果回收后仍不足，会抛出<code>OutOfMemoryError</code>。</li>
</ul>
</li>
<li><strong>内存布局</strong>：<ul>
<li>对象内存布局包括对象头（存储对象的元数据和锁信息）、实例数据（存储对象的字段值）和对齐填充（确保对象内存对齐）。</li>
</ul>
</li>
</ol>
<h4 id="2-3-初始化对象"><a href="#2-3-初始化对象" class="headerlink" title="2.3 初始化对象"></a><strong>2.3 初始化对象</strong></h4><p>对象的初始化过程：</p>
<ol>
<li><strong>零初始化</strong>：<ul>
<li>JVM将对象的实例字段初始化为默认值（如数字类型初始化为0，引用类型初始化为<code>null</code>）。</li>
</ul>
</li>
<li><strong>字段初始化</strong>：<ul>
<li>执行字段的显式初始化（如<code>private int x = 10;</code>）。</li>
</ul>
</li>
<li><strong>构造器初始化</strong>：<ul>
<li>调用构造器进行对象的初始化。</li>
<li>如果类有父类，会先调用父类的构造器。</li>
</ul>
</li>
</ol>
<h2 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h2><p>在 HotSpot 中，对象在堆内存中的存储布局可以划分为以下三个部分：</p>
<h4 id="1-对象头-Header"><a href="#1-对象头-Header" class="headerlink" title="1. 对象头 (Header)"></a>1. 对象头 (Header)</h4><p>对象头包括两部分信息：</p>
<ul>
<li><strong>Mark Word</strong>：对象自身的运行时数据，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，</li>
<li><strong>类型指针</strong>：对象指向它类型元数据的指针，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。需要说明的是，并非所有的虚拟机都必须要在对象数据上保留类型指针，这取决于对象的访问定位方式。</li>
</ul>
<h4 id="2-实例数据-Instance-Data"><a href="#2-实例数据-Instance-Data" class="headerlink" title="2. 实例数据 (Instance Data)"></a>2. 实例数据 (Instance Data)</h4><p>即我们在代码中定义的各种类型的字段，无论是从父类继承而来，还是子类中定义的都需要记录。</p>
<h4 id="3-对齐填充-Padding"><a href="#3-对齐填充-Padding" class="headerlink" title="3. 对齐填充 (Padding)"></a>3. 对齐填充 (Padding)</h4><p>主要起占位符的作用。HotSpot 要求对象起始地址必须是 8 字节的整倍数，即间接要求了任何对象的大小都必须是 8 字节的整倍数。对象头部分在设计上就是 8 字节的整倍数，如果对象的实例数据不是 8 字节的整倍数，则由对齐填充进行补全。</p>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>对象创建后，Java 程序就可以通过栈上的 <code>reference</code>（也就是引用）来操作堆上的具体对象。</p>
<p>《Java 虚拟机规范》规定 <code>reference</code> 是一个指向对象的引用，但并未规定其具体实现方式。主流的方式方式有以下两种：</p>
<ul>
<li><strong>句柄访问</strong>：Java 堆将划分出一块内存来作为句柄池， <code>reference</code> 中存储的是对象的句柄地址，而句柄则包含了对象实例数据和类型数据的地址信息。</li>
<li><strong>指针访问</strong>：<code>reference</code> 中存储的直接就是对象地址，而对象的类型数据则由上文介绍的对象头中的类型指针来指定。</li>
</ul>
<p>通过句柄访问对象：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f6b5eb22-a5af-40c0-8c80-00fdd6d16b1d.png" alt="img"></p>
<p>通过直接指针访问对象：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f696f4a8-af51-4e28-9d72-c2f6b1e5b3db.png" alt="img"></p>
<p><strong>句柄访问的优点在于对象移动时（垃圾收集时移动对象是非常普遍的行为）只需要改变句柄中实例数据的指针，而 <code>reference</code> 本身并不需要修改；</strong></p>
<p>指针访问则反之，由于其 <code>reference</code> 中存储的直接就是对象地址，所以当对象移动时， <code>reference</code> 需要被修改。但针对只需要访问对象本身的场景，指针访问则可以减少一次定位开销。由于对象访问是一项非常频繁的操作，所以这类减少的效果会非常显著，基于这个原因，<strong>HotSpot 主要使用的是指针访问的方式</strong>。</p>
<hr>
<h1 id="四、垃圾收集机制"><a href="#四、垃圾收集机制" class="headerlink" title="四、垃圾收集机制"></a>四、垃圾收集机制</h1><p>在 JVM 内存模型中，程序计数器、虚拟机栈、本地方法栈这 3 个区域都是线程私有的，会随着线程的结束而销毁，因此在这 3 个区域当中，无需过多考虑垃圾回收问题。垃圾回收问题主要发生在 Java 堆上。</p>
<p>在 Java 堆上，垃圾回收的主要内容是死亡的对象（不可能再被任何途径使用的对象）。</p>
<p>判断对象是否死亡有以下两种方法：</p>
<p>##4.1  引用计数法</p>
<ul>
<li>无法处理循环引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objA.instance = objB</span><br><span class="line">objB.instance = objA    </span><br><span class="line">objA = null;</span><br><span class="line">objB = null;</span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure>

<p>如上所示，此时两个对象已经不能再被访问，但其互相持有对对方的引用，如果采用引用计数法，则两个对象都无法被回收。</p>
<h2 id="4-2-可达性分析"><a href="#4-2-可达性分析" class="headerlink" title="4.2 可达性分析"></a>4.2 可达性分析</h2><p>可达性分析是通过一系列被称为 <code>GC Roots</code> 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径被称为引用链（Reference Chain），如果某个对象到 <code>GC Roots</code> 间没有任何引用链相连，这代表 <code>GC Roots</code> 到该对象不可达， 此时证明该对象不可能再被使用。</p>
<p>在 Java 语言中，固定可作为 <code>GC Roots</code> 的对象包括以下几种：</p>
<ul>
<li>在<strong>虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等；</li>
<li>在方法区（元空间）中<strong>类静态变量引用的对象</strong>，譬如 Java 类中引用类型的静态变量；</li>
<li>在方法区（元空间）中<strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用；</li>
<li>在本地方法栈中的 JNI（Native 方法）引用的对象；</li>
<li>Java 虚拟机内部的引用，如基本数据类型对应的 Class 对象，一些常驻的异常对象（如 NullPointException，OutOfMemoryError 等）及系统类加载器；</li>
<li>所有被同步锁（synchronized 关键字）持有的对象；</li>
</ul>
<p>除了这些固定的 <code>GC Roots</code> 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域的不同，还可能会有其他对象 “临时性” 地加入，共同构成完整的 <code>GC Roots</code> 集合。</p>
<h2 id="4-3-对象引用"><a href="#4-3-对象引用" class="headerlink" title="4.3 对象引用"></a>4.3 对象引用</h2><p>可达性分析是基于引用链进行判断的，在 JDK 1.2 之后，Java 将引用关系分为以下四类：</p>
<h3 id="1、强引用-Strongly-Reference"><a href="#1、强引用-Strongly-Reference" class="headerlink" title="1、强引用 (Strongly Reference)"></a>1、强引用 (Strongly Reference)</h3><p>最传统的引用，如 <code>Object obj = new Object()</code> 。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>
<h3 id="2、软引用-Soft-Reference"><a href="#2、软引用-Soft-Reference" class="headerlink" title="2、软引用 (Soft Reference)"></a>2、软引用 (Soft Reference)</h3><p>用于描述一些还有用，但非必须的对象。</p>
<p>只被软引用关联着的对象，在系统将要发生内存溢出之前，会被列入回收范围内进行第二次回收，如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
<h3 id="3、弱引用-Weak-Reference"><a href="#3、弱引用-Weak-Reference" class="headerlink" title="3、弱引用 (Weak Reference)"></a>3、弱引用 (Weak Reference)</h3><p>弱引用关联的对象只能生存到下一次垃圾收集发生时，无论当前内存是否足够，弱引用对象都会被回收。</p>
<h3 id="4、虚引用-Phantom-Reference"><a href="#4、虚引用-Phantom-Reference" class="headerlink" title="4、虚引用 (Phantom Reference)"></a>4、虚引用 (Phantom Reference)</h3><h4 id="虚引用的特点"><a href="#虚引用的特点" class="headerlink" title="虚引用的特点"></a><strong>虚引用的特点</strong></h4><ol>
<li><strong>无法获取对象实例</strong>：虚引用的 <code>get()</code> 方法总是返回 <code>null</code>，无法通过虚引用来直接访问对象。</li>
<li><strong>配合引用队列使用</strong>：虚引用必须与 <code>ReferenceQueue</code> 结合使用。当虚引用指向的对象被垃圾回收时，虚引用会被加入到关联的引用队列中。</li>
<li><strong>不影响对象生命周期</strong>：虚引用的存在不会阻止垃圾回收器回收对象。</li>
</ol>
<h4 id="虚引用的典型使用场景"><a href="#虚引用的典型使用场景" class="headerlink" title="虚引用的典型使用场景"></a><strong>虚引用的典型使用场景</strong></h4><ol>
<li><strong>资源清理</strong>：<ul>
<li>虚引用常用于在对象被回收时执行清理操作，例如释放文件句柄、关闭网络连接或释放其他系统资源。</li>
<li>例如，在 <code>DirectByteBuffer</code> 中，虚引用用于在对象被回收时释放直接内存。</li>
</ul>
</li>
<li><strong>对象生命周期监控</strong>：<ul>
<li>虚引用可以用于监控对象的生命周期。当对象被垃圾回收时，通过监听引用队列可以触发相应的通知或日志记录。</li>
</ul>
</li>
<li><strong>内存管理与缓存清理</strong>：<ul>
<li>在缓存系统中，虚引用可以用于监控缓存对象的生命周期。当缓存对象被回收时，可以触发清理操作，避免内存泄漏。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhantomReferenceExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建一个对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建引用队列</span></span><br><span class="line">        ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建虚引用，并关联引用队列</span></span><br><span class="line">        PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, queue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟资源清理操作</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">cleanupThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    PhantomReference&lt;?&gt; reference = (PhantomReference&lt;?&gt;) queue.remove();</span><br><span class="line">                    System.out.println(<span class="string">&quot;对象被回收，执行清理操作: &quot;</span> + reference);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        cleanupThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">        cleanupThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消强引用，使对象可被回收</span></span><br><span class="line">        obj = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 手动触发垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待一段时间，确保垃圾回收完成</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-对象真正死亡"><a href="#4-4-对象真正死亡" class="headerlink" title="4.4 对象真正死亡"></a>4.4 对象真正死亡</h2><p>要真正宣告一个对象死亡，需要经过至少两次标记过程：</p>
<p>①、如果对象在进行可达性分析后发现 <code>GC Roots</code> 不可达，将会进行第一次标记；</p>
<p>②、随后进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalized()</code> 方法。</p>
<p>如果对象没有覆盖 <code>finalized()</code> 方法，或者 <code>finalized()</code> 已经被虚拟机调用过，这两种情况都会视为没有必要执行。</p>
<p>如果判定结果是有必要执行，此时对象会被放入名为 <code>F-Queue</code> 的队列，等待 Finalizer 线程执行其 <code>finalized()</code> 方法。</p>
<p>在这个过程中，收集器会进行第二次小规模的标记，如果对象在 <code>finalized()</code> 方法中重新将自己与引用链上的任何一个对象进行了关联，如将自己（<code>this</code> 关键字）赋值给某个类变量或者对象的成员变量，此时它就实现了自我拯救，则第二次标记会将其移除 “即将回收” 的集合，否则该对象就将被真正回收，走向死亡。</p>
<h2 id="4-5-垃圾收集算法"><a href="#4-5-垃圾收集算法" class="headerlink" title="4.5 垃圾收集算法"></a>4.5 垃圾收集算法</h2><h3 id="1、分代收集理论"><a href="#1、分代收集理论" class="headerlink" title="1、分代收集理论"></a>1、分代收集理论</h3><p>当前大多数虚拟机都遵循 “分代收集” 的理论进行设计，它建立在强弱两个分代假说下：</p>
<ul>
<li><strong>弱分代假说 (Weak Generational Hypothesis)</strong> ：绝大多数对象都是朝生夕灭的。</li>
<li><strong>强分代假说 (Strong Generational Hypothesis)</strong> ：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
<li><strong>跨带引用假说 (Intergenerational Reference Hypothesis)</strong> ：基于上面两条假说还可以得出的一条隐含推论：存在相互引用关系的两个对象，应该倾向于同时生存或者同时消亡。</li>
</ul>
<p>强弱分代假说奠定了垃圾收集器的设计原则：<strong>收集器应该将 Java 堆划分出不同的区域</strong>，然后将回收对象依据其年龄（年龄就是对象经历垃圾收集的次数）分配到不同的区域中进行存储。</p>
<p>之后如果一个区域中的对象都是朝生夕灭的，那么收集器只需要关注少量对象的存活而不是去标记那些大量将要被回收的对象，此时就能以较小的代价获取较大的空间。</p>
<p>最后再将难以消亡的对象集中到一块，根据强分代假说，它们是很难消亡的，因此虚拟机可以使用较低的频率进行回收，这就兼顾了时间和内存空间的开销。</p>
<p>###2、回收类型</p>
<p>根据分代收集理论，收集范围可以分为以下几种类型：</p>
<p>①、<strong>部分收集 (Partial GC)</strong> ：具体分为：</p>
<ul>
<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
<li><strong>整堆收集 (Full GC)</strong> ：收集整个 Java 堆和方法区。</li>
</ul>
<h3 id="3、标记-清除算法"><a href="#3、标记-清除算法" class="headerlink" title="3、标记-清除算法"></a>3、标记-清除算法</h3><p>它是最基础的垃圾收集算法，收集过程分为两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；也可以反过来，标记存活对象，统一回收所有未被标记的对象。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-7d489254-f1e0-4feb-bd4a-af129767a787.png" alt="img"></p>
<p>它主要有以下两个缺点：</p>
<ul>
<li>执行效率不稳定：如果 Java 堆上包含大量需要回收的对象，则需要进行大量标记和清除动作；</li>
<li>内存空间碎片化：标记清除后会产生大量不连续的空间，从而导致无法为大对象分配足够的连续内存。</li>
</ul>
<h3 id="4、标记-复制算法"><a href="#4、标记-复制算法" class="headerlink" title="4、标记-复制算法"></a>4、标记-复制算法</h3><p>标记-复制算法基于 ”半区复制“ 算法：它将可用内存按容量划分为大小相等的两块，每次只使用其中一块，当这一块的内存使用完了，就将还存活着的对象复制到另外一块，然后再把已经使用过的那块内存空间一次性清理掉。其优点在于避免了内存空间碎片化的问题，其缺点如下：</p>
<ul>
<li>如果内存中多数对象都是存活的，这种算法将产生大量的复制开销；</li>
<li>浪费内存空间，内存空间变为了原有的一半。</li>
</ul>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-f4572b93-f7f3-41cc-9901-93816e79c789.png" alt="img"></p>
<p>基于新生代 “朝生夕灭” 的特点，大多数虚拟机都不会按照 1:1 的比例来进行内存划分，例如 HotSpot 会将内存空间划分为一块较大的 <code>Eden</code> 和两块较小的 <code>Survivor</code> 空间，它们之间的比例是 8:1:1 。</p>
<p>每次分配时只会使用 <code>Eden</code> 和其中的一块 <code>Survivor</code> ，发生垃圾回收时，只需要将存活的对象一次性复制到另外一块 <code>Survivor</code> 上，这样只有 10% 的内存空间会被浪费掉。</p>
<p>当 <code>Survivor</code> 空间不足以容纳一次 <code>Minor GC</code> 时，此时由其他内存区域（通常是老年代）来进行分配担保。</p>
<h3 id="5、标记-整理算法"><a href="#5、标记-整理算法" class="headerlink" title="5、标记-整理算法"></a>5、标记-整理算法</h3><p>标记-整理算法是在标记完成后，让所有存活对象都向内存的一端移动，然后直接清理掉边界以外的内存。</p>
<p>其优点在于可以避免内存空间碎片化的问题，也可以充分利用内存空间；其缺点在于根据所使用的收集器的不同，在移动存活对象时可能要全程暂停用户程序：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-e674c49f-c55b-4eba-95ea-34be62d55a78.png" alt="img"></p>
<h1 id="五、垃圾收集器"><a href="#五、垃圾收集器" class="headerlink" title="五、垃圾收集器"></a>五、垃圾收集器</h1><p>HotSpot 中一共存在七款经典的垃圾收集器：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-1fa20f99-d203-42d6-982c-f1bd66a0c929.png" alt="img"></p>
<h2 id="5-1-Serial-收集器"><a href="#5-1-Serial-收集器" class="headerlink" title="5.1 Serial 收集器"></a>5.1 Serial 收集器</h2><p>Serial 收集器是最基础、历史最悠久的收集器，它是一个单线程收集器，在进行垃圾回收时，必须暂停其他所有的工作线程，直到收集结束，这是其主要缺点。</p>
<p>它的优点在于单线程避免了多线程复杂的上下文切换，因此在单线程环境下收集效率非常高，由于这个优点，迄今为止，其仍然是 HotSpot 虚拟机在客户端模式下默认的新生代收集器：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/serial-garbage-collector.png" alt="Serial 收集器"></p>
<h2 id="5-2-ParNew-收集器"><a href="#5-2-ParNew-收集器" class="headerlink" title="5.2 ParNew 收集器"></a>5.2 ParNew 收集器</h2><p>它是 Serial 收集器的多线程版本，可以使用多条线程进行垃圾回收：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250213235426748.png" alt="image-20250213235426748"></p>
<h2 id="5-3-Parallel-Scavenge-收集器"><a href="#5-3-Parallel-Scavenge-收集器" class="headerlink" title="5.3 Parallel Scavenge 收集器"></a>5.3 Parallel Scavenge 收集器</h2><p>Parallel Scavenge 也是新生代收集器，基于 标记-复制 算法进行实现，它的目标是达到一个可控的吞吐量。这里的吞吐量指的是处理器运行用户代码的时间与处理器总消耗时间的比值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量 = 运行用户代码时间 \ (运行用户代码时间 + 运行垃圾收集时间)</span><br></pre></td></tr></table></figure>

<p>Parallel Scavenge 收集器提供两个参数用于精确控制吞吐量：</p>
<p>①、<code>-XX:MaxGCPauseMillis</code>：控制最大垃圾收集时间，假设需要回收的垃圾总量不变，那么降低垃圾收集的时间就会导致收集频率变高，所以需要将其设置为合适的值，不能一味减小。</p>
<p>②、<code>-XX:MaxGCTimeRatio</code>：直接用于设置吞吐量大小，它是一个大于 0 小于 100 的整数。假设把它设置为 19，表示此时允许的最大垃圾收集时间占总时间的 5%（即 1&#x2F;(1+19) ）；默认值为 99 ，即允许最大 1%（ 1&#x2F;(1+99) ）的垃圾收集时间。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/image-20250214000748151.png" alt="image-20250214000748151"></p>
<h2 id="5-4-Serial-Old-收集器"><a href="#5-4-Serial-Old-收集器" class="headerlink" title="5.4 Serial Old 收集器"></a>5.4 Serial Old 收集器</h2><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：</p>
<ul>
<li>一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用</li>
<li>另一种用途是<strong>作为 CMS 收集器的后备方案</strong>。</li>
</ul>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/serial-garbage-collector.png" alt="Serial 收集器"></p>
<h2 id="5-5-Paralled-Old-收集器"><a href="#5-5-Paralled-Old-收集器" class="headerlink" title="5.5 Paralled Old 收集器"></a>5.5 Paralled Old 收集器</h2><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/parallel-scavenge-garbage-collector.png" alt="Parallel Old收集器运行示意图"></p>
<h2 id="5-6-CMS-（Concurrent-Mark-Sweep）收集器"><a href="#5-6-CMS-（Concurrent-Mark-Sweep）收集器" class="headerlink" title="5.6 CMS （Concurrent Mark Sweep）收集器"></a>5.6 CMS （Concurrent Mark Sweep）收集器</h2><ul>
<li><p><strong>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p>
</li>
<li><p><strong>CMS收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p>
</li>
<li><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p>
<ul>
<li><p><strong>初始标记：</strong> 短暂停顿，标记直接与 root 相连的对象（根对象）；</p>
</li>
<li><p><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</p>
</li>
<li><p><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</p>
</li>
<li><p><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/cms-garbage-collector.png" alt="CMS 收集器"></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li><strong>对 CPU 资源敏感；</strong></li>
<li><strong>无法处理浮动垃圾；</strong></li>
<li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li>
</ul>
<p><strong>CMS 垃圾回收器在 Java 9 中已经被标记为过时(deprecated)，并在 Java 14 中被移除。</strong></p>
<h2 id="5-7-Garbage-First-收集器"><a href="#5-7-Garbage-First-收集器" class="headerlink" title="5.7 Garbage First 收集器"></a>5.7 Garbage First 收集器</h2><ul>
<li><p>G1 是一款面向服务器的垃圾收集器，主要<strong>针对配备多颗处理器及大容量内存的机器</strong>。以<strong>极高概率满足 GC 停顿时间要求</strong>的同时， 还<strong>具备高吞吐量</strong>性能特征。</p>
</li>
<li><p>G1 被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备以下特点：</p>
<ul>
<li><p><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</p>
</li>
<li><p><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</p>
</li>
<li><p><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</p>
</li>
<li><p><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒</p>
</li>
</ul>
</li>
<li><p>使用 G1  时的内存管理：</p>
<ul>
<li>G1 虽然也遵循分代收集理论，但不再以固定大小和固定数量来划分分代区域，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region）。<ul>
<li>每一个 Region 都可以根据不同的需求来扮演新生代的 <code>Eden</code> 空间、<code>Survivor</code> 空间或者老年代空间，收集器会根据其扮演角色的不同而采用不同的收集策略。</li>
<li>此外，如下图所示 ，有一些 Region 使用 H 进行标注，它代表 Humongous，表示这些 Region 用于存储大对象（humongous object，H-obj），即大小大于等于 region 一半的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-e0f5da26-6e46-4f9d-bfcc-0842cc7079e7.png" alt="img"></p>
<ul>
<li><p>G1 收集器的运作大致分为以下几个步骤：</p>
<ul>
<li><p><strong>初始标记</strong>： 短暂停顿（Stop-The-World，STW），标记从 GC Roots 可直接引用的对象，即标记所有直接可达的活跃对象</p>
</li>
<li><p><strong>并发标记</strong>：与应用并发运行，标记所有可达对象。 这一阶段可能持续较长时间，取决于堆的大小和对象的数量。</p>
</li>
<li><p><strong>最终标记</strong>： 短暂停顿（STW），处理并发标记阶段结束后残留的少量未处理的引用变更。</p>
</li>
<li><p><strong>筛选回收</strong>：根据标记结果，选择回收价值高的区域，复制存活对象到新区域，回收旧区域内存。这一阶段包含一个或多个停顿（STW），具体取决于回收的复杂度<br><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/g1-garbage-collector.png" alt="G1 收集器"></p>
</li>
</ul>
</li>
<li><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>
</li>
<li><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p>
</li>
</ul>
<h2 id="5-8-内存分配原则"><a href="#5-8-内存分配原则" class="headerlink" title="5.8 内存分配原则"></a>5.8 内存分配原则</h2><h4 id="1-对象优先在-Eden-分配"><a href="#1-对象优先在-Eden-分配" class="headerlink" title="1. 对象优先在 Eden 分配"></a>1. 对象优先在 Eden 分配</h4><p>大多数情况下，对象在新生代的 <code>Eden</code> 区中进行分配，当 <code>Eden</code> 区没有足够空间时，虚拟机将进行一次 Minor GC。</p>
<h4 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h4><p>大对象就是指需要大量连续内存空间的 Java 对象，最典型的就是超长的字符串或者元素数量很多的数组，它们将直接进入老年代。</p>
<p>主要是因为如果在新生代分配，因为其需要大量连续的内存空间，可能会导致提前触发垃圾回收；并且由于新生代的垃圾回收本身就很频繁，此时复制大对象也需要额外的性能开销。</p>
<h4 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h4><p>虚拟机会给每个对象在其对象头中定义一个年龄计数器。对象通常在 <code>Eden</code> 区中诞生，如果经历第一次 Minor GC 后仍然存活，并且能够被 Survivor 容纳的话，该对象就会被移动到 Survivor 中，并将其年龄加 1。</p>
<p>对象在 Survivor 中每经过一次 Minor GC，年龄就加 1，当年龄达到一定程度后（由 <code>-XX:MaxTenuringThreshold</code> 设置，默认值为 15）就会进入老年代中。</p>
<h4 id="4-动态年龄判断"><a href="#4-动态年龄判断" class="headerlink" title="4. 动态年龄判断"></a>4. 动态年龄判断</h4><p>如果在 Survivor 空间中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代，而无需等待年龄到达 <code>-XX:MaxTenuringThreshold</code> 设置的值。</p>
<h4 id="5-空间担保分配"><a href="#5-空间担保分配" class="headerlink" title="5. 空间担保分配"></a>5. 空间担保分配</h4><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果条件成立，那么这一次的 Minor GC 可以确认是安全的。</p>
<p>如果不成立，虚拟机会查看 <code>-XX:HandlePromotionFailure</code> 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于或者 <code>-XX:HandlePromotionFailure</code> 的值设置不允许冒险，那么就要改为进行一次 Full GC 。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/whereis-the-object-8.png" alt="img"></p>
<h2 id="5-9-垃圾收集器选择与开启"><a href="#5-9-垃圾收集器选择与开启" class="headerlink" title="5.9 垃圾收集器选择与开启"></a>5.9 垃圾收集器选择与开启</h2><h3 id="1-Serial收集器"><a href="#1-Serial收集器" class="headerlink" title="1. Serial收集器"></a><strong>1. Serial收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseSerialGC</code></li>
<li><strong>新生代</strong>：Serial（复制算法）</li>
<li><strong>老年代</strong>：Serial Old（标记-整理算法）</li>
<li><strong>特点</strong>：单线程收集器，适合单核CPU或小内存应用。</li>
</ul>
<h3 id="2-Parallel-Scavenge收集器"><a href="#2-Parallel-Scavenge收集器" class="headerlink" title="2. Parallel Scavenge收集器"></a><strong>2. Parallel Scavenge收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseParallelGC</code></li>
<li><strong>新生代</strong>：Parallel Scavenge（复制算法）</li>
<li><strong>老年代</strong>：默认为Serial Old，但通常会自动启用Parallel Old。</li>
<li><strong>特点</strong>：多线程收集器，适合多核CPU，关注吞吐量。</li>
</ul>
<h3 id="3-Parallel-Old收集器"><a href="#3-Parallel-Old收集器" class="headerlink" title="3. Parallel Old收集器"></a><strong>3. Parallel Old收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseParallelOldGC</code></li>
<li><strong>新生代</strong>：Parallel Scavenge（复制算法）</li>
<li><strong>老年代</strong>：Parallel Old（标记-整理算法）</li>
<li><strong>特点</strong>：与Parallel Scavenge配合使用，适合多核CPU。</li>
</ul>
<h3 id="4-ParNew收集器"><a href="#4-ParNew收集器" class="headerlink" title="4. ParNew收集器"></a><strong>4. ParNew收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseParNewGC</code></li>
<li><strong>新生代</strong>：ParNew（复制算法）</li>
<li><strong>老年代</strong>：默认为Serial Old，但通常会自动启用CMS。</li>
<li><strong>特点</strong>：多线程收集器，适合多核CPU，适合与CMS配合使用。</li>
</ul>
<h3 id="5-CMS收集器"><a href="#5-CMS收集器" class="headerlink" title="5. CMS收集器"></a><strong>5. CMS收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseConcMarkSweepGC</code></li>
<li><strong>新生代</strong>：ParNew（复制算法）</li>
<li><strong>老年代</strong>：CMS（并发标记-清除算法）</li>
<li><strong>特点</strong>：并发收集器，适合低延迟需求，但可能产生内存碎片。</li>
</ul>
<h3 id="6-G1收集器"><a href="#6-G1收集器" class="headerlink" title="6. G1收集器"></a><strong>6. G1收集器</strong></h3><ul>
<li><strong>指令</strong>：<code>-XX:+UseG1GC</code></li>
<li><strong>新生代和老年代</strong>：G1（复制算法和标记-整理算法）</li>
<li><strong>特点</strong>：分区收集器，适合大堆内存，兼顾吞吐量和低延迟。</li>
</ul>
<h3 id="7-Serial-Old收集器"><a href="#7-Serial-Old收集器" class="headerlink" title="7. Serial Old收集器"></a><strong>7. Serial Old收集器</strong></h3><ul>
<li><strong>指令</strong>：无单独启用指令，通常作为其他收集器的后备方案。</li>
<li><strong>新生代</strong>：与Serial或Parallel Scavenge配合使用。</li>
<li><strong>老年代</strong>：Serial Old（标记-整理算法）</li>
<li><strong>特点</strong>：单线程收集器，适合单核CPU或小内存应用。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>Serial</strong>：适合单核CPU或小内存应用。</li>
<li><strong>Parallel Scavenge + Parallel Old</strong>：适合多核CPU，关注吞吐量。</li>
<li><strong>ParNew + CMS</strong>：适合多核CPU，低延迟需求。</li>
<li><strong>G1</strong>：适合大堆内存，兼顾吞吐量和低延迟。</li>
<li><strong>Serial Old</strong>：通常作为后备方案，适合单核CPU或小内存应用。</li>
</ul>
<p>这些垃圾收集器各有特点，选择合适的收集器需要根据应用的具体需求和运行环境来决定。</p>
<hr>
<h1 id="六、类加载机制"><a href="#六、类加载机制" class="headerlink" title="六、类加载机制"></a>六、类加载机制</h1><p>Java 虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程被称为虚拟机的类加载机制。</p>
<h2 id="6-1-类加载时机"><a href="#6-1-类加载时机" class="headerlink" title="6.1 类加载时机"></a>6.1 类加载时机</h2><p>一个类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、卸载、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析三个部分统称为连接：</p>
<img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/class-load-20231031202641.png" alt="img" style="zoom:67%;" />

<h2 id="6-2-类加载过程"><a href="#6-2-类加载过程" class="headerlink" title="6.2 类加载过程"></a>6.2 类加载过程</h2><h3 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h3><p>在加载阶段，虚拟机需要完成以下三件事：</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流 ；</li>
<li>将这个字节流所代表的静态存储结构转换为运行时数据结构；</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为这个类的各种数据的访问入口。</li>
</ul>
<p>《Java 虚拟机规范》并没有限制从何处获取二进制流，因此可以从 JAR 包、WAR 包获取，也可以从 JSP 生成的 Class 文件等处获取。</p>
<h3 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h3><p>这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的约束要求，从而保证虚拟机自身的安全。</p>
<p>验证阶段大致会完成下面四项验证：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/class-loading-process-verification.png" alt="验证阶段示意图"></p>
<h3 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h3><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>这时候进行内存分配的仅包括类变量（ 也即静态变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li>
<li>从概念上讲，类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。不过有一点需要注意的是：JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。 而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</li>
<li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如 0、0L、null、false 等），<ul>
<li><strong>特殊情况</strong>：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111</li>
</ul>
</li>
</ul>
<h3 id="4-解析"><a href="#4-解析" class="headerlink" title="4. 解析"></a>4. 解析</h3><p>解析是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程：</p>
<ul>
<li><strong>符号引用</strong>：符号引用用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li><strong>直接引用</strong>：直接引用是指可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。</li>
</ul>
<p>整个解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行解析。</p>
<p>《深入理解 Java 虚拟机》7.3.4 节第三版对符号引用和直接引用的解释如下：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/symbol-reference-and-direct-reference.png" alt="符号引用和直接引用"></p>
<h3 id="5-初始化"><a href="#5-初始化" class="headerlink" title="5. 初始化"></a>5. 初始化</h3><p>初始化阶段就是执行类构造器的 <code>&lt;clinit&gt;()</code> 方法的过程，该方法具有以下特点：</p>
<ul>
<li><code>&lt;clinit&gt;()</code> 方法由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生，编译器收集顺序由语句在源文件中出现的顺序决定。</li>
<li><code>&lt;clinit&gt;()</code> 方法与类的构造方法（即在虚拟机视角中的实例构造器 <code>&lt;init&gt;()</code>方法）不同，它不需要显示的调用父类的构造器，Java 虚拟机会保证在子类的 <code>&lt;clinit&gt;()</code> 方法执行前，父类的 <code>&lt;clinit&gt;()</code> 方法已经执行完毕。</li>
<li>由于父类的 <code>&lt;clinit&gt;()</code> 方法先执行，也就意味着父类中定义的静态语句块要优先于子类变量的赋值操作。</li>
<li><code>&lt;clinit&gt;()</code> 方法对于类或者接口不是必须的，如果一个类中没有静态语句块，也没有对变量进行赋值操作，那么编译器可以不为这个类生成 <code>&lt;clinit&gt;()</code> 方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成 <code>&lt;clinit&gt;()</code> 方法。</li>
<li>Java 虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确的加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 <code>&lt;clinit&gt;()</code> 方法，其他线程都需要阻塞等待。</li>
</ul>
<h2 id="6-3-类加载器"><a href="#6-3-类加载器" class="headerlink" title="6.3 类加载器"></a>6.3 类加载器</h2><p>能够通过一个类的全限定名来获取描述该类的二进制字节流的工具称为类加载器。</p>
<p>每一个类加载器都拥有一个独立的类名空间，因此对于任意一个类，都必须由加载它的类加载器和这个类本身来共同确立其在 Java 虚拟机中的唯一性。</p>
<p>这意味着要想比较两个类是否相等，必须在同一类加载器加载的前提下；如果两个类的类加载器不同，则它们一定不相等。</p>
<h2 id="6-4-双亲委派模型"><a href="#6-4-双亲委派模型" class="headerlink" title="6.4 双亲委派模型"></a>6.4 双亲委派模型</h2><p>从 Java 虚拟机角度而言，类加载器可以分为以下两类：</p>
<ul>
<li><strong>启动类加载器</strong> ：启动类加载器（Bootstrap ClassLoader）由 C++ 语言实现（以 HotSpot 为例），它是虚拟机自身的一部分；</li>
<li><strong>其他所有类的类加载器</strong> ：由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自 <code>java.lang.ClassLoader</code> 。</li>
</ul>
<p>从开发人员角度而言，类加载器可以分为以下三类：</p>
<ul>
<li><strong>启动类加载器 (Boostrap Class Loader)</strong> ：负责把存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中，或被 <code>-Xbootclasspath</code> 参数所指定的路径中存放的能被 Java 虚拟机识别的类库加载到虚拟机的内存中；</li>
<li><strong>扩展类加载器 (Extension Class Loader)</strong> ：负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中，或被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库。</li>
<li><strong>应用程序类加载器 (Application Class Loader)</strong> ：负责加载用户类路径（ClassPath）上的所有的类库。</li>
</ul>
<p>JDK 9 之前的 Java 应用都是由这三种类加载器相互配合来完成加载：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/zongjie-c1fcdc37-4e5a-4ed3-94b1-ad4afa2dba7c.png" alt="img"></p>
<p>上图所示的各种类加载器之间的层次关系被称为类加载器的 “双亲委派模型”，“双亲委派模型” 要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，需要注意的是这里的加载器之间的父子关系一般不是以继承关系来实现的，而是使用组合关系来复用父类加载器的代码。</p>
<p>双亲委派模型的工作过程如下：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p>
<p>基于双亲委派模型可以保证程序中的类在各种类加载器环境中都是同一个类，否则就有可能出现一个程序中存在两个不同的 <code>java.lang.Object</code> 的情况。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ZengCP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">http://example.com/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ZengCP's BLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/" title="JVM 调优总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JVM 调优总结</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/18/Java%20%E5%9F%BA%E7%A1%80/Java%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="Java 代理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java 代理模式</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/21/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E8%B0%83%E4%BC%98%E6%80%BB%E7%BB%93/" title="JVM 调优总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-21</div><div class="title">JVM 调优总结</div></div></a></div><div><a href="/2024/05/22/Java%20%E5%9F%BA%E7%A1%80/JVM%20%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JVM 核心知识点总结"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-22</div><div class="title">JVM 核心知识点总结</div></div></a></div><div><a href="/2024/05/08/Java%20%E5%9F%BA%E7%A1%80/AQS%20%E8%AF%A6%E8%A7%A3/" title="AQS 详解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-08</div><div class="title">AQS 详解</div></div></a></div><div><a href="/2024/05/18/Java%20%E5%9F%BA%E7%A1%80/Java%20%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" title="Java 代理模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-18</div><div class="title">Java 代理模式</div></div></a></div><div><a href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/" title="Java 基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-04</div><div class="title">Java 基础</div></div></a></div><div><a href="/2024/05/11/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java 并发编程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-11</div><div class="title">Java 并发编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZengCP</div><div class="author-info__description">记录心得，见证成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">82</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-OpenJDK"><span class="toc-number">1.</span> <span class="toc-text">1.1 OpenJDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-OracleJDK"><span class="toc-number">2.</span> <span class="toc-text">1.2 OracleJDK</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-HotSpot-VM"><span class="toc-number">3.</span> <span class="toc-text">1.3 HotSpot VM</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JVM-%E7%BB%84%E6%88%90"><span class="toc-number"></span> <span class="toc-text">二、JVM 组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-JVM%E7%9A%84%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">2.1 JVM的总体架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">2.2 类加载子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%88Execution-Engine%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">2.3 执行引擎（Execution Engine）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%9C%AC%E5%9C%B0%E6%8E%A5%E5%8F%A3%EF%BC%88Native-Interface%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">2.4 本地接口（Native Interface）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">4.</span> <span class="toc-text">2.5 运行时数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">1. 程序计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="toc-number">4.2.</span> <span class="toc-text">2. 虚拟机栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">4.3.</span> <span class="toc-text">3. 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86"><span class="toc-number">4.4.</span> <span class="toc-text">4. 堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">4.5.</span> <span class="toc-text">5. 方法区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">4.6.</span> <span class="toc-text">6. 直接内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%AF%B9%E8%B1%A1"><span class="toc-number"></span> <span class="toc-text">三、对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">1.</span> <span class="toc-text">对象的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81-%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">1、 对象创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BD%BF%E7%94%A8new%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 使用new关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 使用反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E5%85%8B%E9%9A%86%EF%BC%88Clone%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 使用克隆（Clone）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 使用反序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81-Java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2、 Java对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 类加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 内存分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 初始化对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.</span> <span class="toc-text">3.2 对象的内存布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%A4%B4-Header"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 对象头 (Header)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE-Instance-Data"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 实例数据 (Instance Data)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85-Padding"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 对齐填充 (Padding)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.1.</span> <span class="toc-text">3.3 对象的访问定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">四、垃圾收集机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">4.2 可达性分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">4.3 对象引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8-Strongly-Reference"><span class="toc-number">2.1.</span> <span class="toc-text">1、强引用 (Strongly Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-Reference"><span class="toc-number">2.2.</span> <span class="toc-text">2、软引用 (Soft Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Reference"><span class="toc-number">2.3.</span> <span class="toc-text">3、弱引用 (Weak Reference)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-Reference"><span class="toc-number">2.4.</span> <span class="toc-text">4、虚引用 (Phantom Reference)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">2.4.1.</span> <span class="toc-text">虚引用的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.2.</span> <span class="toc-text">虚引用的典型使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%AF%B9%E8%B1%A1%E7%9C%9F%E6%AD%A3%E6%AD%BB%E4%BA%A1"><span class="toc-number">3.</span> <span class="toc-text">4.4 对象真正死亡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4.5 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-number">4.1.</span> <span class="toc-text">1、分代收集理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">3、标记-清除算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">4、标记-复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">5、标记-整理算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">五、垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text">5.1 Serial 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">5.2 ParNew 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">5.3 Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">5.4 Serial Old 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-Paralled-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">5.5 Paralled Old 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-CMS-%EF%BC%88Concurrent-Mark-Sweep%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">6.</span> <span class="toc-text">5.6 CMS （Concurrent Mark Sweep）收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-7-Garbage-First-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">5.7 Garbage First 收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-8-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">8.</span> <span class="toc-text">5.8 内存分配原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-Eden-%E5%88%86%E9%85%8D"><span class="toc-number">8.0.1.</span> <span class="toc-text">1. 对象优先在 Eden 分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">8.0.2.</span> <span class="toc-text">2. 大对象直接进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">8.0.3.</span> <span class="toc-text">3. 长期存活的对象将进入老年代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E5%B9%B4%E9%BE%84%E5%88%A4%E6%96%AD"><span class="toc-number">8.0.4.</span> <span class="toc-text">4. 动态年龄判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%A9%BA%E9%97%B4%E6%8B%85%E4%BF%9D%E5%88%86%E9%85%8D"><span class="toc-number">8.0.5.</span> <span class="toc-text">5. 空间担保分配</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-9-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E9%80%89%E6%8B%A9%E4%B8%8E%E5%BC%80%E5%90%AF"><span class="toc-number">9.</span> <span class="toc-text">5.9 垃圾收集器选择与开启</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.1.</span> <span class="toc-text">1. Serial收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.2.</span> <span class="toc-text">2. Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.3.</span> <span class="toc-text">3. Parallel Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.4.</span> <span class="toc-text">4. ParNew收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.5.</span> <span class="toc-text">5. CMS收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.6.</span> <span class="toc-text">6. G1收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">9.7.</span> <span class="toc-text">7. Serial Old收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number"></span> <span class="toc-text">六、类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-number">1.</span> <span class="toc-text">6.1 类加载时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">6.2 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.1.</span> <span class="toc-text">1. 加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81"><span class="toc-number">2.2.</span> <span class="toc-text">2. 验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%87%86%E5%A4%87"><span class="toc-number">2.3.</span> <span class="toc-text">3. 准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A7%A3%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">4. 解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">5. 初始化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">6.3 类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">6.4 双亲委派模型</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/27/%E6%8C%81%E4%B9%85%E5%B1%82/MySQL/ShardingSphere%20%E5%88%86%E6%9E%90/" title="无题">无题</a><time datetime="2025-02-26T16:24:07.723Z" title="发表于 2025-02-27 00:24:07">2025-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/" title="RocketMQ 核心架构原理">RocketMQ 核心架构原理</a><time datetime="2024-12-08T09:02:36.000Z" title="发表于 2024-12-08 17:02:36">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/08/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ/RocketMQ%20%E6%A6%82%E8%BF%B0/" title="RocketMQ 概述">RocketMQ 概述</a><time datetime="2024-12-08T07:16:48.000Z" title="发表于 2024-12-08 15:16:48">2024-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Kafka 经典面试题">Kafka 经典面试题</a><time datetime="2024-12-07T12:45:18.000Z" title="发表于 2024-12-07 20:45:18">2024-12-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/12/07/%E4%B8%AD%E9%97%B4%E4%BB%B6/Kafka/Kafka%20%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/" title="Kafka 进阶">Kafka 进阶</a><time datetime="2024-12-07T08:09:53.000Z" title="发表于 2024-12-07 16:09:53">2024-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ZengCP</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>