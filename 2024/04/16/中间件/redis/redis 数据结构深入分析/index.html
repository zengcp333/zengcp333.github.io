<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 数据结构深入分析 | ZengCP's BLOGS</title><meta name="author" content="ZengCP"><meta name="copyright" content="ZengCP"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 数据结构深入分析本文主要介绍 Redis 的数据结构，包括总体的结构模型，常用的基础数据结构 以及 对应的 底层数据结构，其中基本数据结构与底层数据结构之间的映射表如下，可见每种数据结构都有多种的内部编码实现，且 Redis 实际会在合适的场景选择合适的内部编码。  一、结构模型基础我们在上面了解到了关于键的基本数据结构。而我们Redis中的所有value都是以object的形式存在的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 数据结构深入分析">
<meta property="og:url" content="http://example.com/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="ZengCP&#39;s BLOGS">
<meta property="og:description" content="Redis 数据结构深入分析本文主要介绍 Redis 的数据结构，包括总体的结构模型，常用的基础数据结构 以及 对应的 底层数据结构，其中基本数据结构与底层数据结构之间的映射表如下，可见每种数据结构都有多种的内部编码实现，且 Redis 实际会在合适的场景选择合适的内部编码。  一、结构模型基础我们在上面了解到了关于键的基本数据结构。而我们Redis中的所有value都是以object的形式存在的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png">
<meta property="article:published_time" content="2024-04-16T12:41:59.000Z">
<meta property="article:modified_time" content="2025-02-15T16:12:47.830Z">
<meta property="article:author" content="ZengCP">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png"><link rel="shortcut icon" href="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/longmao.png"><link rel="canonical" href="http://example.com/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 数据结构深入分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-02-16 00:12:47'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ZengCP's BLOGS"><span class="site-name">ZengCP's BLOGS</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis 数据结构深入分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-16T12:41:59.000Z" title="发表于 2024-04-16 20:41:59">2024-04-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-15T16:12:47.830Z" title="更新于 2025-02-16 00:12:47">2025-02-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/redis/">redis</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis 数据结构深入分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis-数据结构深入分析"><a href="#Redis-数据结构深入分析" class="headerlink" title="Redis 数据结构深入分析"></a>Redis 数据结构深入分析</h1><p>本文主要介绍 Redis 的数据结构，包括总体的结构模型，常用的基础数据结构 以及 对应的 底层数据结构，其中基本数据结构与底层数据结构之间的映射表如下，可见每种数据结构都有多种的内部编码实现，且 Redis 实际会在合适的场景选择合适的内部编码。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922093317769-1818232862.png" alt="img"></p>
<h2 id="一、结构模型基础"><a href="#一、结构模型基础" class="headerlink" title="一、结构模型基础"></a>一、结构模型基础</h2><p>我们在上面了解到了关于键的基本数据结构。而我们Redis中的所有value都是以object的形式存在的。其通用结构结构源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisObject</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> [type] <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> [encoding] <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> [lru] REDIS_LRU_BITS;</span><br><span class="line">    <span class="type">int</span> refcount;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p>（1）type指的就是我们的基本数据结构，如string，list等其他类型；</p>
<p>（2）encoding指的是这些结构内部类型的具体实现方式，如string可以用int来实现也可以用char[]来实现；list可以用ziplist或者链表来实现；</p>
<p>（3）lru表示本对象的空转时长，用于有限内存下长时间不访问的对象清理；</p>
<p>（4）refcount对象引用计数，用于GC；</p>
<p>（5）ptr指向以encoding方式实现这个对象实际实现者的地址，如String对象对应的SDS（<em>Simple Dynamic String</em> 结构）地址。</p>
<p>示意图如下：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922095552955-1765467256.png" alt="img"></p>
<h2 id="二、-String类型"><a href="#二、-String类型" class="headerlink" title="二、 String类型"></a>二、 String类型</h2><p>关于string内部结构，上面也介绍了主要是以三种编码形式来组成的，分别是int，raw，embstr。这里int主要是用来存放整形值的字符串，embstr用来存放字符串的短字符串（大小不超过44个字节），raw存放字符的长字符串（大小不超过44个字节）。</p>
<h3 id="SDS结构"><a href="#SDS结构" class="headerlink" title="SDS结构"></a>SDS结构</h3><p>我们在上面介绍了关于键的基本结构redisObject，但其实在我们的String中还用着另外一种结构，也就是我们的SDS结构（<em>Simple Dynamic String</em> 结构）。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20200922153617467-1478669101.png" alt="img"></p>
<p>从源码的文件里面可以看见，同样一组结构Redis使用泛型定义了好多次。那么为什么不直接用int类型呢？这里呢主要是因为当字符串比较短的时候，len和alloc可以使用byte和short来表示，Redis为了对内存做极致的优化，不同长度的字符串使用不同的结构体来表示。</p>
<p><strong>为什么不直接使用C字符串呢？</strong></p>
<p>我们为什么要重新在定义一个SDS的动态字符串的结构？其实呢这主要是为了从Redis对字符串安全性和效率以及功能方面的要求。C 语言使用了一个长度为 N+1 的字符数组来表示长度为 N 的字符串，并且字符数组最后一个元素总是 <code>&#39;\0&#39;</code>。而在Redis中<code>\0</code>可能会被判定为提前结束而识别不了字符串。通过分析可以发现，总共有以下一些缺点：</p>
<p>（1）获取字符串长度为O(n)，因为C字符串需要去遍历。</p>
<p>（2）不能很好的杜绝缓冲区溢出&#x2F;内存泄漏的问题，因为原因同上，进行字符串拼接等其他操作获取长度的时候易出现问题。</p>
<p>（3）C字符串只能保存文本数据，因为必须符合某种编码（如ASCLL）。像一些<code>\0</code>就不易处理。</p>
<p>表格区别汇总如下。</p>
<table>
<thead>
<tr>
<th align="left">C字符串</th>
<th align="left">SDS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">获取字符串长度的复杂度为O(N)</td>
<td align="left">获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td align="left">API是不安全的，可能会造成缓冲区溢出</td>
<td align="left">API是安全的，不会造成缓冲区溢出</td>
</tr>
<tr>
<td align="left">修改字符串长度N次必然需要执行N次内存重分配</td>
<td align="left">修改字符串长度N次最多需要执行N次内存重分配</td>
</tr>
<tr>
<td align="left">只能保存文本数据</td>
<td align="left">可以保存文本或者二进制数据</td>
</tr>
<tr>
<td align="left">可以使用所有&lt;string.h&gt;库中的函数</td>
<td align="left">可以使用一部分&lt;string.h&gt;库中的函数</td>
</tr>
</tbody></table>
<h3 id="raw与embstr的区别"><a href="#raw与embstr的区别" class="headerlink" title="raw与embstr的区别"></a>raw与embstr的区别</h3><p>（1）redis并未提供任何修改embstr的方式，即embstr是只读的形式。对embstr的修改实际上是先转换为raw再进行修改。</p>
<p>（2）采用内存分配方式不同，虽然raw和embstr编码方式都是使用redisObject结构和sdshdr结构。但是raw编码方式采用两次分配内存的方式，分别创建redisObject和sdshdr，而embstr编码方式则是采用一次分配，分配一个连续的空间给redisObject和sdshdr。（embstr一次性分配内存的方式：1，使得分配空间的次数减少。2、释放内存也只需要一次。3、在连续的内存块中，利用了缓存的优点。）</p>
<h3 id="String的应用场景"><a href="#String的应用场景" class="headerlink" title="String的应用场景"></a>String的应用场景</h3><p><strong>（1）缓存功能</strong></p>
<p>字符串最经典的使用场景，redis最为缓存层，Mysql作为储存层，绝大部分请求数据都是 redis中获取，由于redis具有支撑高并发特性，所以缓存通常能起到加速读写和降低后端压力的作用。</p>
<p><strong>（2）计数器</strong></p>
<p>许多应用都会使用redis作为计数的基础工具，因为redis的<code>INCR</code>命令具有原子性的自增操作，在并发下也可以保证一个线程安全的问题。如果我们常见的论坛，网站的点赞数或者视频播放数就是使用redis作为计数的基础组件。</p>
<p><strong>（3）共享session</strong></p>
<p>出于负载均衡的考虑，分布式服务会将用户信息的访问均衡到不同服务器上，这样可能我们用户在第一次访问和第二次访问的时候不是同一台服务器的话，session不同步，就会导致重新登录。为避免这个问题可以使用redis将用户session集中管理。（示意图如下）</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001092356031-822974235.png" alt="img"></p>
<p>当客户端第一次发送请求后，nginx将这个请求分发给服务器实例M ，然后将服务器实例M 产生的Session 放入Redis中，此时客户端、服务器实例M 和Redis中都会有一个相同的Session，当客户端发送第二次请求的时候，nginx将请求分发给服务器实例N （已知服务器实例N 中无Session），因为客户端自己携带了一个Session，那么服务器实例N就可以拿着客户端带来的Session中的ID去Redis中找到Session，找到这个Session后，就能正常执行之后的操作。</p>
<p><strong>（5）限流</strong></p>
<p>我们的redis处于安全考虑或者在高并发访问，都会进行一个限流或者限速。比如防止某个接口被频繁调用而崩溃或者像手机验证码验证，防止短信接口不被频繁访问。</p>
<p>我们常见的限流算法有很多，如令牌桶，漏桶，计数器，滑动窗口等。而用String的话，就可以使用计数器，我们如果要设置一个一分钟最多只能访问100次的限流接口，只要设置键的一分钟过期时间就行，然后在一分钟之内通过计数器来进行计数。关于具体的限流算法，我后面会继续更新补充一下这一块的知识点。(点击跳转，待补充)</p>
<h2 id="三、List类型"><a href="#三、List类型" class="headerlink" title="三、List类型"></a>三、List类型</h2><p>我们在最开始的图上面也介绍了，list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist。然后针对这两种的弊端又设计出了一个快速列表。关于双向链表，老数据结构不介绍了，这里重点介绍一下压缩列表和快速列表。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p><strong>ziplist</strong>是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储。但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，对象结构中ptr所指向的就是一个ziplist。整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。</p>
<p>ziplist的结构表如下：</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001100507850-847200896.png" alt="img"></p>
<p>　　　　1、zlbytes:用于记录整个压缩列表占用的内存字节数</p>
<p>　　　　2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节</p>
<p>　　　　3、zllen：记录了压缩列表包含的节点数量。</p>
<p>　　　　4、entryX：要说列表包含的各个节点</p>
<p>　　　　5、zlend：用于标记压缩列表的末端</p>
<p><strong>为什么数据量大不使用ziplist？</strong></p>
<p>我们在上面也说到了，因为它的插入的时间复杂度是O(n)，而且插入一个新的元素就要调用realloc进行扩展内存。取决于内存分配器算法和当前的ziplist内存大小，realloc可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能直接原地扩展。而如果我们的数据量大的话，那么重新分配内存和拷贝内存就会有很大的消耗。所以ziplist不适合大型字符串，存储的元素也不宜过多。</p>
<h3 id="快速列表"><a href="#快速列表" class="headerlink" title="快速列表"></a>快速列表</h3><p>其实这里如果看网上早期的博客很容易漏掉一个数据结构。我们的Redis早期版本list内部编码是ziplist或者linkedlist，但是这两者都有着自己的缺点。ziplist的数据量大不适合用，在上面也重点介绍了，而linkedlist的附加空间相对太高，prev和next指针就要占去16个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p>
<p>所以针对这两种编码数据结构，后续版本进行了改造了，诞生了quicklist。</p>
<p>quicklist是ziplist和linkedlist的混合体，它将linkedlist按段切分，每一段使用ziplist来紧凑存储，多个ziplist之间使用双指针串接起来。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001103326988-2044742495.png" alt="img"></p>
<p><strong>ziplist的长度</strong></p>
<p>quicklist内部默认单个ziplist长度为8k字节，超出了这个字节数，就会新起一个ziplist。关于长度可以使用<code>list-max-ziplist-size</code>来决定。</p>
<p><strong>压缩深度</strong></p>
<p>我们上面说到了quicklist下是用多个ziplist组成的，同时为了进一步节约空间，Redis还会对ziplist进行压缩存储，使用LZF算法压缩，可以选择压缩深度。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001111702607-948543746.png" alt="img"></p>
<p>quicklist默认的压缩深度是0，也就是不压缩。压缩的实际深度由配置参数<code>list-compress-depth</code>决定。为了支持快速的 <code>push/pop</code> 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>
<p>关于压缩具体介绍可以参考这里👉<a target="_blank" rel="noopener" href="https://www.cnblogs.com/exceptioneye/p/7044341.html?utm_source=itdadao&utm_medium=referral">点击跳转</a></p>
<h3 id="List的应用场景"><a href="#List的应用场景" class="headerlink" title="List的应用场景"></a>List的应用场景</h3><p><strong>（1）消息队列</strong></p>
<p>redis的<code>lpush+brpop</code>命令组合即可实现阻塞队列，生产者客户端是用<code>lupsh</code>从列表左侧插入元素，多个消费者客户端使用<code>brpop</code>命令阻塞时的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201001112341182-215857925.png" alt="img"></p>
<p><strong>（2）最新列表</strong></p>
<p>list类型的<code>lpush</code>命令和<code>lrange</code>命令能实现最新列表的功能，每次通过<code>lpush</code>命令往列表里插入新的元素，然后通过<code>lrange</code>命令读取最新的元素列表，如朋友圈的点赞列表、评论列表。</p>
<p><strong>（3）排行榜</strong></p>
<p>适用于定时计算的排行榜。 list类型的<code>lrange</code>命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在list类型中，如京东每日的手机销量排行、学校每次月考学生的成绩排名、斗鱼年终盛典主播排名等排行榜。</p>
<h2 id="四、Hash类型"><a href="#四、Hash类型" class="headerlink" title="四、Hash类型"></a>四、Hash类型</h2><p>哈希类型的底层编码可以是ziplist也可以是我们的hashtable。ziplist在上面我们已经介绍了，这里我们着重介绍一下hashtable。</p>
<h3 id="HashTable结构"><a href="#HashTable结构" class="headerlink" title="HashTable结构"></a>HashTable结构</h3><p>我们的hashtable主要是通过dict来实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>可以看到我们每个dict结构里面都有两个hashtable。（ht[0]和ht[1]）</p>
<p>虽然dict结构有两个hashtable，但是通常情况下只有一个hashtable是有值的。但是在dict扩容缩容的时候，需要分配新的hashtable，然后进行渐近式搬迁，这时候两个hashtable存储的旧的hashtable和新的hashtable。搬迁结束后，旧hashtable删除，新的取而代之。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002105644237-1980970838.png" alt="img"></p>
<p>hashtable的结构和Java的HashMap几乎是一样的，都是通过分桶的方式来解决hash冲突的。第一维是数组，第二维是链表。而数组中存储的是第二维链表的第一个元素的指针。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002105929003-1083710349.png" alt="img"></p>
<h3 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h3><p>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕。</p>
<p>这里我们将说说扩容条件和缩容条件，然后再介绍一下rehash的过程。</p>
<p><strong>扩容条件</strong></p>
<p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p>
<p>这里不扩容主要是为了尽可能减少内存页过多分离，系统后需要更多的开销去回收内存。</p>
<p><strong>缩容条件</strong></p>
<p>当我们的hash表元素逐渐删除的越来越少的时候，第一维数组长度太长也不是太好。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p>
<p>这里不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p>
<p><strong>rehash步骤</strong></p>
<p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p>
<p>2、在几点钟（定时）维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p>
<p>3、在rehash 进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p>
<p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p>
<p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash是只能对ht[0]进行使得h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p>
<p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。有安全迭代器可用, 安全迭代器保证, 在迭代起始时, 字典中的所有结点, 都会被迭代到, 即使在迭代过程中对字典有插入操作。</p>
<h3 id="相关知识补充"><a href="#相关知识补充" class="headerlink" title="相关知识补充"></a>相关知识补充</h3><p><strong>hash函数</strong></p>
<p>hashtable的性能取决于hash函数的质量，如果hash把key打散的比较均匀，就是一个好函数。redis默认的函数是siphash，不仅打散均匀而且性能还特别快。</p>
<p><strong>hash攻击</strong></p>
<p>hash攻击指的是如果我们的hash函数的打散不均匀的话，存在偏向性。那么黑客就有可能利用这种偏向性对服务器进行攻击，存在偏向性的hash函数在特定模式下的输入会导致hash第二维链表长度即为不均匀，导致查找速率急剧下降，从O(1)到O(n)。有限的服务器计算能力就会被hashtable的查找效率彻底拖垮。</p>
<h3 id="Hash的应用场景"><a href="#Hash的应用场景" class="headerlink" title="Hash的应用场景"></a>Hash的应用场景</h3><p>哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于<strong>用户信息</strong>，<strong>购物车</strong>等管理，但是哈希类型和关系型数据库有所不同，哈希类型是稀疏的，而关系型数据库是完全结构化的，关系型数据库可以做复杂的关系查询，而redis去模拟关系型复杂查询开发困难，维护成本高。</p>
<p>这里举一个实例，以用户id为key，商品id为field，商品数量为value，恰好构成了购物车的3个要素</p>
<h2 id="五、Set类型"><a href="#五、Set类型" class="headerlink" title="五、Set类型"></a>五、Set类型</h2><p>Redis 的集合相当于 Java 语言中的 <strong>HashSet</strong>，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合Set类型底层编码包括hashtable和inset。hashtable在上面介绍过了，我们就只介绍inset。</p>
<h3 id="inset的结构"><a href="#inset的结构" class="headerlink" title="inset的结构"></a>inset的结构</h3><p>intset底层本质是一个有序的、不重复的、整型的数组、支持不同类型整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;</span><br><span class="line">    <span class="type">uint32_t</span> length;</span><br><span class="line">    <span class="type">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>（1）encoding 的值可以是以下三个常量的其中一个 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<p>（2）length就是数组的实际长度。</p>
<p>（3）contents 数组是实际保存元素的地方，数组中的元素有以下两个特性：</p>
<ul>
<li>没有重复元素；</li>
<li>元素在数组中从小到大排列；</li>
</ul>
<p><strong>inset的查询</strong></p>
<p>intset是一个有序集合，查找元素的复杂度为O(logN)<strong>（采用二分法）</strong>，但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。是intset不支持降级操作。</p>
<p><strong>补充</strong></p>
<p>这里需要注意的是，这里的说inset是有序不要和我们zset搞混，zset是设置一个score来进行排序，而inset这里只是单纯的对整数进行升序而已。</p>
<h3 id="Set的应用场景"><a href="#Set的应用场景" class="headerlink" title="Set的应用场景"></a>Set的应用场景</h3><p>（1）交集，并集，差集。这里如交集可以用来如一个用户对娱乐 、体育比较感兴趣，另一个可能对新闻比较感兴趣，他们就有共同的标签，可以做互相推荐的功能，喜欢体育的人还喜欢娱乐。类似其他的功能都可以抽象一点去想象用法。</p>
<p>（2）随机数。这里可以使用<code>spop/srandmember</code>命令来获取随机数，可以做一个抽奖功能等。</p>
<p>（3）社交需求。类似<code>sadd/sinter</code>命令可以添加你有多少个朋友的共同好友等操作，类似可能认识的人。</p>
<h2 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h2><p>Zset有序集合和set集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数，作为排序的依据。 （有序集合中的元素不可以重复，但是csore可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。</p>
<p>简单来说，它类似于 Java 中 <strong>SortedSet</strong> 和 <strong>HashMap</strong> 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以为每个 value 赋予一个 score 值，用来代表排序的权重。</p>
<p>zet的底层编码有两种数据结构，一个ziplist，一个是skiplist。这里因为ziplis也做了排序，所以也要简单再介绍一下。</p>
<h3 id="ziplist排序"><a href="#ziplist排序" class="headerlink" title="ziplist排序"></a>ziplist排序</h3><p>我们之前也介绍过了ziplist，底层就是压缩列表。这里我们为了实现排序，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p>
<p>压缩列表内的集合元素按分值从小到大进行排序，分值较小的元素被放置在靠近表头的方向，而分值较大的元素则被放在靠近表尾的方向。可以参考示意图如下。</p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002160252776-1435470436.png" alt="img"></p>
<h3 id="skiplist跳表"><a href="#skiplist跳表" class="headerlink" title="skiplist跳表"></a>skiplist跳表</h3><p>关于skiplist比较复杂，这里我只简单介绍一下，具体可以参考  <a target="_blank" rel="noopener" href="https://github.com/linmuhan/JavaGuide/blob/master/docs/database/Redis/redis-collection/Redis(2)%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E8%A1%A8.md">这篇文章</a>  ，可以全面了解这个数据结构。</p>
<p>skiplist是与dict结合使用的，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>head和tail分别指向头节点和尾节点，然后每个skiplistNode里面的结构又是分层的(即level数组)。每一列都代表一个节点，保存了member和score，按score从小到大排序。每个节点有不同的层数，这个层数是在生成节点的时候随机生成的数值。每一层都是一个指向后面某个节点的指针。这种结构使得跳跃表可以跨越很多节点来快速访问。<strong>（前进可以跳跃式的跳过几个节点，而后退只能后退一个节点，可以看看下面示意图可比较容易理解）。</strong></p>
<p><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/1993240-20201002173146736-216480070.png" alt="img"></p>
<p><strong>为什么不使用平衡树，而使用跳跃表？</strong></p>
<p>这里redis的设计者antirez也给出了原因，主要是从内存占用、对范围查找、实现难易程度来考虑的。</p>
<p>（1）在做范围查找的时候，平衡树比skiplist操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。</p>
<p>（2）平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。</p>
<p>（3）从内存占用上来说，skiplist比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1&#x2F;(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p&#x3D;1&#x2F;4，那么平均每个节点包含1.33个指针，比平衡树更有优势。</p>
<p><strong>为什么要使用skiplist与dict结合使用呢？</strong></p>
<p>这里需要我们去思考一下，为什么我们要两个混合着使用呢？</p>
<p>其实呢，我们可以分析一下就知道了。首先是我们的跳跃表，可以跨过多个节点进行查询，时间复杂度是O(lgn)左右，但是可以保持有序性。我们的dict是用hashtable实现，因为是哈希，所以查询是O(1)的大小，但是是无序性。</p>
<p>而我们使用两者混合，在进行分数索引的时候查询使用跳跃表，进行数据索引查找的时候，可以使用哈希的O(1)查找。设想如果没有字典, 如果想按数据查分数, 就必须进行遍历O(logn)。两套底层数据结构均只作为索引使用, 即不直接持有数据本身.。数据被封装在SDS中, 由跳跃表与字典共同持有，而数据的分数则由跳跃表结点直接持有(double类型数据), 由字典间接持有。</p>
<h3 id="Zset的应用场景"><a href="#Zset的应用场景" class="headerlink" title="Zset的应用场景"></a>Zset的应用场景</h3><p>Zset的使用场景和set很是类似，而且还可以我们上面String做不了的实时排行榜。</p>
<p><strong>（1）实时排行榜</strong></p>
<p>比如我们要做一个一小时热搜，我们可以把当前的时间戳作为zset的key，把帖子ID作为member，点击数评论数作为score，当score发生变化时更新score。然后可以利用<code>zrevrange</code>或<code>zrange</code>来来查到对应数量的在时间内的记录。</p>
<p><strong>（2）延时队列</strong></p>
<p>zset会按照score进行排序，如果score代表想要执行时间的时间戳。在某个时间将它插入zset集合中，它便会按照时间戳大小进行排序，也就是对执行时间前后进行排序。</p>
<p><strong>（3）限流</strong></p>
<p>滑动窗口是限流常见的一种策略。如果我们把一个用户的 ID 作为 key 来定义一个 zset ，member 或者 score 都为访问时的时间戳。我们只需统计某个 key 下在指定时间戳区间内的个数，就能得到这个用户滑动窗口内访问频次，与最大通过次数比较，来决定是否允许通过。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于Redis的数据结构，这里介绍的其实也不是特别全。因为redis的一直在更新，而且很多知识点也不是一篇博客可以讲完，比如在redis5.0之后更新了紧凑列表listpack来替代了ziplist，但是因为ziplist应用在数据结构里面范围太大了，不太好更新，所以现在还没有取代，但是它却是比ziplist要好的存在，解决了ziplist存在问题。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">ZengCP</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/">http://example.com/2024/04/16/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ZengCP's BLOGS</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/04/Java%20%E5%9F%BA%E7%A1%80/Java%20%E5%9F%BA%E7%A1%80/" title="Java 基础"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java 基础</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Q+A%EF%BC%89/" title="Redis 面试题 （Q&amp;A）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Redis 面试题 （Q&amp;A）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/05/Java%20%E5%9F%BA%E7%A1%80/Java%20%E9%9B%86%E5%90%88/" title="Java 集合"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-05</div><div class="title">Java 集合</div></div></a></div><div><a href="/2024/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Q+A%EF%BC%89/" title="Redis 面试题 （Q&amp;A）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-14</div><div class="title">Redis 面试题 （Q&amp;A）</div></div></a></div><div><a href="/2024/04/14/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88Q%EF%BC%89/" title="Redis 面试题 （Q only）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-14</div><div class="title">Redis 面试题 （Q only）</div></div></a></div><div><a href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E9%9B%86%E7%BE%A4/" title="redis 三大集群模式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-13</div><div class="title">redis 三大集群模式</div></div></a></div><div><a href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redisson%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%8E%9F%E7%90%86/" title="Redisson 分布式锁原理"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-13</div><div class="title">Redisson 分布式锁原理</div></div></a></div><div><a href="/2024/04/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/redis/redis%20%E7%BC%93%E5%AD%98%20%E4%B8%8E%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E8%87%B4%E6%80%A7/" title="redis 缓存与数据库一致性分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-13</div><div class="title">redis 缓存与数据库一致性分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://my-blog-images-1314066800.cos.ap-guangzhou.myqcloud.com/images/dog.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZengCP</div><div class="author-info__description">记录心得，见证成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">25</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Redis 数据结构深入分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">一、结构模型基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81-String%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">二、 String类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SDS%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">SDS结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raw%E4%B8%8Eembstr%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">raw与embstr的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">String的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81List%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">三、List类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">压缩列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">快速列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.3.</span> <span class="toc-text">List的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Hash%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">四、Hash类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashTable%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">HashTable结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="toc-number">1.4.2.</span> <span class="toc-text">渐进式rehash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">相关知识补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.4.</span> <span class="toc-text">Hash的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Set%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">五、Set类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inset%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">inset的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">Set的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">Zset类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ziplist%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">ziplist排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#skiplist%E8%B7%B3%E8%A1%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">skiplist跳表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.6.3.</span> <span class="toc-text">Zset的应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/27/%E6%9E%B6%E6%9E%84/DDD%20%E6%A6%82%E8%BF%B0/" title="DDD 简介">DDD 简介</a><time datetime="2024-10-27T12:11:58.000Z" title="发表于 2024-10-27 20:11:58">2024-10-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/24/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/" title="架构演进">架构演进</a><time datetime="2024-10-24T15:26:41.000Z" title="发表于 2024-10-24 23:26:41">2024-10-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E7%86%94%E6%96%AD%E3%80%81%E9%99%90%E6%B5%81%20%E4%B8%8E%20%E9%99%8D%E7%BA%A7/" title="服务治理概述">服务治理概述</a><time datetime="2024-09-08T13:47:59.000Z" title="发表于 2024-09-08 21:47:59">2024-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/" title="服务治理注册与发现">服务治理注册与发现</a><time datetime="2024-09-08T08:37:19.000Z" title="发表于 2024-09-08 16:37:19">2024-09-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/08/%E5%88%86%E5%B8%83%E5%BC%8F%20%E4%B8%8E%20%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E7%AE%80%E4%BB%8B/" title="服务治理概述">服务治理概述</a><time datetime="2024-09-08T06:53:38.000Z" title="发表于 2024-09-08 14:53:38">2024-09-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By ZengCP</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>